[
  {
    "id": "1-logo.html",
    "t": "Logo",
    "b": "┌────────┐ ┌┐ ┌┐ ┌┐ ┌┐ (tm)\n └───┐┌───┘ ││ ││ ││ ││\n ││ ││ ││ ││ ││\n ││ ││ ││ ││ ││\n ││ ┌────┐ ┌────┐ ┌┐ ┌┐ │└───┘│ ┌────┐ ││ ┌────┐ ││\n ││ │┌───┘ │┌───┘ ││ ││ │┌───┐│ │┌───┘ ││ │┌──┐│ ││\n ││ │└──┐ ││ │└──┘│ ││ ││ │└──┐ ││ ││ ││ ││\n ││ │┌──┘ ││ │┌──┐│ ││ ││ │┌──┘ ││ ││ ││ └┘\n ││ │└───┐ │└───┐ ││ ││ ││ ││ │└───┐ ││ │└──┘│ ┌┐\n └┘ └────┘ └────┘ └┘ └┘ └┘ └┘ └────┘ └┘ │┌───┘ └┘\n ││\n The Electronic ││\n Technical Reference Manual ││\n ││\n Written by Dan Rollins └┘\n\n ┌──────────────────────────────────────────────────────┐\n │ Tech Help! database version 6.0 │\n │ Copyright (c) 1985,1994 by Flambeaux Software, Inc. │\n └──────────────────────────────────────────────────────┘\n\nTECH Help! 6 to HTML conversion and .CHM compilation done by\n(c) SysTools 2018\nhttp://systools.losthost.org/\n\nTECH Help! database file version:\n\nFile: TECH.HLP\nSize: 932,522\nCRC32: 77AADA49\nmd5: c5f25df667a1e24492b80d7d4432f526\nYear: 1994\n\nPlease contact if you have newer version (latest would be from 1997).\n\nChangelog:\n\nBuild 2018.06.27\n\nAll changes compared with online version at http://www.techhelpmanual.com/\nIf someone have site owner contacts please report him about this TECH Help!\nSo he can update his site with this version as it very accurate. Thanks!\n- reversed TECH.HLP file format\n- convert all non-ASCII characters to its UTF-8 equivalents\n- escaped special HTML characters\n- and added necessary HTML tags for W3C validation\n- fixed misplaced and add missing links and color tags\n- added JavaScript code for back links instead of \"missing.html\" page\n- compiled all pages to the single TechHelp.chm help file\n- fixed 0013h..0024h links topics in \"INT 33H: Mouse Support\" (832)\n- \"Exit from Help!\" replaced with this text Logo page (1) with changelog\n- topics 1034, 1035, 1036 still don't have back links since it's error pages\n\n Back to Main Menu"
  },
  {
    "id": "2-main_menu.html",
    "t": "Main Menu",
    "b": "TECH Topics \n\n API Index \n\n DOS & BIOS Data Structures\n\n DOS & BIOS Service Index \n\n General Index \n\n How to use TECH Help! \n\n HTML Help! Logo"
  },
  {
    "id": "3-tech_topics.html",
    "t": "TECH Topics",
    "b": "┌ Quick Reference ─────────────────────────────── Characters & Codes ──────┐\n│ DOS Functions QuickRef INTs & BIOS Services ASCII■Dec■Hex■Binary xRef│\n│ DOS Interrupts BIOS Data Area Box & Special Characters │\n│ DOS Error Codes IRQs: Hardware INTs ASCII Control Codes │\n│ Service Groups I/O Port Map Character Set Matrix │\n│ │\n│ 80x86/87 Opcodes Cables & Pin Outs ANSI Escape Sequences │\n└───────────────────────────────────────────────┐ │\n┌ Indexes ───────────────── DOS Fns ────────┐ │ Extended ASCII Keystrokes│\n│ API Index by Category │ │ Keyboard Scan Codes │\n│ Combined API Services by Number │ │ Keyboard Shift Flags │\n│ CONFIG.SYS Commands by Version │ │ │\n│ Data Structures Superseded Fns │ │ Screen Attributes │\n│ General Index Obsolete Fns │ │ Color Table │\n└───────────────────────────────────────────┘ └──────────────────────────┘\n Overviews and Articles\n──────────────────────────────────────────────────────────────█▌DOS kernel▐█\n About DOS Functions File Attributes\n Absolute Disk I/O File Handles\n Accessing Upper Memory InDOS Flag\n Clean Boot Interactive Boot\n CONFIG.SYS Media Descriptor\n Critical Error Handler MultiConfig Menus\n Device Drivers Predefined Environment Variables\n DOS Environment Program Startup & Exit\n DOS Versions Standard I/O and I/O Redirection\n ErrorMode Flag System Startup Sequence\n EXE File Header Layout TECH Help! Data Structures\n File Allocation Table TSR/Popup Topics\n─────────────────────────────────────────────────────────────█▌DoubleSpace▐█\n DoubleSpace Overview\n DoubleSpace Compressed Volume File Layout\n DBLSPACE.INI\n Mapping DOS FAT to MDFAT\n Microsoft Real-Time Compression Interface (MRCI)\n Using a Compressed RAM Disk\n───────────────────────────────────────────────────────█▌System Extensions▐█\n APM: Power Management Windows Clipboard\n DPMI: Using DPMI Services Windows Enh386 Services & Notifications\n EMS: Expanded Memory VDD: Windows Virtual Display Device\n Mouse Support VxDs: Some Published VxD IDs\n Multiplex Interrupt\n Switcher API Overview\n XMS: Extended Memory\n────────────────────────────────────────────────────────────█▌Video Topics▐█\n Video Memory Layouts CGA: Color Graphics Adapter\n Video Font Definition EGA: Enhanced Graphics Adapter\n Video Services MDA: Monochrome Display Adapter\n Video Attributes VGA: Video Graphics Array\n Color Table SVGA: SuperVGA Display Adapters\n─────────────────────────────────────────────────────────────█▌BIOS Topics▐█\n AT Keyboard Keyboard Flags\n BIOS Data Area ROM-Scan\n Cables and Pin Outs Speaker Control\n CMOS Storage Layout Switch Settings\n Disk Partitions / MBR System Compatibility\n I/O Port Map System Startup Sequence\n IRQs: Hardware Interrupts\n -♦-"
  },
  {
    "id": "4-general_index.html",
    "t": "General Index",
    "b": "┌──────────────────────────────────────────────────────────────────────┐\n │ Press letter keys A-Z to zoom to a desired part of this index. │\n ├──────────────────────────────────────────────────────────────────────┤\n │ You may access any topic listed here by typing: XVIEW topic ◄─┘ at │\n │ the DOS prompt.┌─────────────────────────────────────────────────────┘\n └────────────────┘ See Also: API Index Service Groups TECH Topics\n 80x86 Opcodes\n 80x87 Floating-Point Opcodes\n 8253-5 Timer/Counter chip\n 8255A Programmable Peripheral Interface (PPI)\n 8259 Interrupt Controller\n───────────────────────────────────────────────────────────────────────█▌A▐█\n A20 line control\n absolute disk I/O\n alarm functions (INT 1aH)\n alarm handler interrupt (INT 4aH)\n allocate memory, conventional\n allocate memory, EMS\n allocate memory, protected-mode (DPMI)\n allocate memory, upper\n allocate memory, XMS\n allocate switcher ID\n allocation strategy\n Alt key, status\n Alt-shifted keys\n ANSI Console Escape Sequences\n ANSI.SYS services\n API Index\n APM, About\n APM: Advanced Power Management Services\n APPEND.EXE services\n Articles and Overviews\n ASCII (SubMenu)\n ASCII box & line characters\n ASCII character set matrix\n ASCII control codes\n ASCII extended ASCII Keystrokes\n ASCII/Hex/Decimal/Binary Xref\n ASCIIZ string▲\n assign-list entry\n ASSIGN.COM services\n Asynchronous Communications (INT 14H)\n Async Com Adapter Ports\n Async Com Input (DOS Fn 03H)\n Async Com IRQs\n Async Com Output (DOS Fn 04H)\n AT-class computers\n AT Extended Services (INT 15H)\n AT Keyboard Functions\n AT Switch Settings\n AT, CMOS storage in\n AT, hard disk ports in\n AT, hard disk types in\n attribute, device driver\n attribute, EMS handle\n attribute, file\n attribute, video\n attribute, video: Color Table\n available memory, DOS/conventional\n available memory, EMS\n available memory, upper\n available memory, XMS\n───────────────────────────────────────────────────────────────────────█▌B▐█\n background color\n beep, producing\n bidirectional parallel port I/O\n BIOS Interrupts and Services\n BIOS Data Area\n BIOS Data Structures\n BIOS Power-On Self-Test\n BIOS ROM-Scan\n BitFAT (CVF Region)\n blink, character foreground\n block device drivers\n block device IOCTL\n boot drive, get\n boot, clean\n boot, interactive\n Boot Sector Layout\n BootSect (CVF Region)\n bootstrap loader\n bootstrap operation\n border color\n bounds exception\n BPB (BIOS Parameter Block)\n BPB, build\n BPB, convert to DPB\n break handler (INT 23H)\n break, BIOS keyboard\n break, DOS control over\n BREAK= (CONFIG.SYS Command)\n breakpoint interrupt\n BUFFERS= (CONFIG.SYS Command)\n busy, CPU is (APM)\n busy, BIOS device is\n busy, DOS device is\n busy, DOS is\n busy, file is\n busy, printer is\n busy, output until\n buttons, mouse\n───────────────────────────────────────────────────────────────────────█▌C▐█\n cables\n cables, InterLink\n CD-ROM Services\n CDS: Current Directory Structure (undocumented data structure)\n CGA: Color Graphics Adaptor (SubMenu)\n CGA: Video Snow and CLS Flash\n change-line\n character devices\n character generator functions\n Character I/O Functions\n character redefinition\n characters, ASCII\n CHDIR\n clear screen via BIOS\n clear screen via DOS\n Clipboard Services, Windows\n clock functions, BIOS See Also: Timer\n clock functions, DOS\n CLOCK$ I/O structure\n close EMM handle\n close file\n close XMS handle\n CMOS Storage Layout (non-volatile memory)\n code page\n code page font files\n codes, ASCII\n codes, control\n codes, error\n color attributes\n color table\n colors, DOS startup menu\n colors, TECH Help!\n commit file\n command-line hook (INT 2fH aexxH)\n COMn: See Asynchronous Communications\n compressed RAM disk, using\n compressed volume file, DoubleSpace\n compression, real-time\n CON device\n CONFIG.SYS Commands\n CONFIG.SYS Options, Enhanced\n configuring TECH Help!\n connection, network\n connectors\n control codes, ASCII\n conventional memory: See Memory\n coprocessor not present interrupt\n coprocessor opcodes, math\n coprocessor, is installed\n coprocessor, status of\n copying TECH Help! text\n country ID Codes\n country-dependent information\n See Also: National Language Support\n COUNTRY= (CONFIG.SYS Command)\n CPI File Layout (Code Page Font Files)\n CPU compatibility\n CPU opcodes\n create directory\n create file\n Critical Error Handler (INT 24H)\n critical section\n Ctrl key, status\n Ctrl+Break: See Break\n Ctrl-shifted keys\n cursor position and size, query, set\n cursor emulation (scaling)\n cursor position, set\n cursor size, set\n cursor, turning off\n CVF fragmentation\n CVF layout\n───────────────────────────────────────────────────────────────────────█▌D▐█\n DAC color registers\n data area, BIOS\n data structures\n data, compress\n data, decompress\n date functions\n DBLSPACE.INI Commands\n DCC (Display Combination Code)\n Debug Commands\n default disk\n delete directory\n delete file\n device attribute\n device driver basics\n device driver errors\n device header\n device I/O control\n device request header\n device requests\n device redirection, network\n device status word\n Device Drivers (SubMenu)\n device ID, APM\n DEVICE= (CONFIG.SYS Command)\n DEVICEHIGH= (CONFIG.SYS Command)\n directory entry layout\n disk controller ports\n disk data structures\n disk device drivers\n disk directory services\n disk extended partition table\n disk file I/O services\n disk I/O; sector-level via BIOS\n disk I/O; sector-level via DOS\n disk I/O; track-level via DOS\n disk media descriptor\n disk parameter table, diskette\n disk parameter table, hard disk\n disk services, BIOS\n disk services, DOS\n disk types\n disk, boot sector of\n disk, compressed\n disk, DOS current default\n disk, partition table of\n disk, query boot\n disk, query free space on\n disk, query remote\n diskette interrupt (INT 0eH)\n display memory\n display services, BIOS\n display services, DOS\n display adapter, CGA\n display adapter, EGA\n display adapter, SVGA\n display adapter, VGA\n See Also: Video\n division overflow interrupt (INT 00H)\n DMA Ports\n DOS busy flag\n DOS Data Structures (SubMenu)\n DOS Environment\n DOS Error Codes\n DOS Functions, About\n DOS Functions, by DOS Version Number\n DOS Functions, by Functional Groups\n DOS Functions, Complete List\n DOS Functions, Quick Reference\n DOS Idle (INT 28H)\n DOS Interrupts (SubMenu)\n DOS Partition\n DOS Program Startup & Exit\n DOS Protected Mode Interface (DPMI)\n DOS Variables, undocumented\n DOS Versions\n DOSKEY.COM services\n double-byte character set (DBCS)\n DoubleSpace (SubMenu)\n DoubleSpace API Services\n DoubleSpace CVF Layout\n DoubleSpace MDFAT-to-FAT Mapping\n DoubleSpace, see if drive is\n DPB: Drive Parameter Block\n DPMI API\n DPMI services, using\n Drive Parameter Block (DPB)\n DRIVPARM= (CONFIG.SYS Command)\n DTA: Disk Transfer Address\n dynamic character redefinition\n───────────────────────────────────────────────────────────────────────█▌E▐█\n EGA: Enhanced Graphics Adapter (SubMenu)\n EGA I/O Ports\n EGA BIOS Services\n EGA Data Areas\n EGA Pin Outs\n EGA Switch Settings\n EMS API Services\n EMS: Expanded Memory Specification (SubMenu)\n emulation, cursor\n emulation, light pen\n enh386 windows services and notifications\n entry address, DPMI\n entry address, MRCI\n entry address, Switcher\n entry address, VxDs\n entry address, XMM\n environment\n environment variables, predefined\n Epson/IBM Printer Codes\n equipment installed\n error codes (SubMenu)\n error codes at power-on\n error handler, critical\n error info, get\n error info, set\n escape sequence, ANSI.SYS\n event wait\n execute a program\n exit address\n exit code, get\n exit program (terminate)\n Expanded Memory Specification (EMS) (SubMenu)\n extended ASCII Keystrokes\n extended country information\n extended error information, get\n extended error information, set\n extended keyboard\n Extended Memory Specification (XMS) (SubMenu)\n extended open/create file\n───────────────────────────────────────────────────────────────────────█▌F▐█\n Fast PUTCHAR\n FAT (File Allocation Table)\n FAT (CVF Region)\n FAT, Mapping to MDFAT\n FaxBIOS\n FCB: File Control Block\n FCBS= (CONFIG.SYS Command)\n File Allocation Table (FAT)\n File and Directory Services\n file attribute\n File Control Block (FCB)\n file handles\n file I/O Services, FCB-Oriented\n file I/O services, handle-Oriented\n File Sharing Functions\n file time/date format\n file, commit\n file, CONFIG.SYS\n file, find\n file, Standard I/O\n FILES= (CONFIG.SYS Command)\n find file\n floating-point opcodes\n flush and invalidate DoubleSpace cache\n flush disk buffers\n flush DoubleSpace cache\n font definition, video\n font services, video\n foreground blink\n foreground color\n formatting disks via BIOS\n formatting disks via DOS\n formats, clipboard data\n fragmentation of CVF\n fragmentation, file\n free disk space, query\n free disk space, query DoubleSpace\n free memory block, conventional or UMB\n free memory block, EMS\n free memory block, XMS\n functions, API Index\n functions, BIOS Interrupts\n functions, combined API services\n functions, DOS\n functions, DOS Quickref\n───────────────────────────────────────────────────────────────────────█▌G▐█\n Game I/O Adapter Port\n Generic IOCTL\n General Memory Map\n General Protection Fault\n Graphics Memory Layouts\n Graphics Modes, Standard\n Graphics Modes, SVGA\n Graphics Pointer, Mouse\n Gray-Scale, convert to\n Gray-Scale Summing\n GRAFTABL.COM Services\n───────────────────────────────────────────────────────────────────────█▌H▐█\n handle, device or file\n handle, EMS\n handle, XMS\n Handle-Oriented File I/O\n hard disk ports, AT\n hard disk ports, XT\n hard disk types\n Hardware Interrupts / IRQs\n HELP: TECH Help! Viewer Help\n Hercules display adapter (See MDA)\n hide mouse pointer\n high memory area (HMA)▲\n high memory area, installed state\n high memory area, is DOS in the\n HIMEM.SYS Services (XMS Entry Address)\n hooking DOS commands (INT 2fH aexxH)\n HMA▲\n HMA Suballocations\n───────────────────────────────────────────────────────────────────────█▌I▐█\n I/O functions, BIOS Disk\n I/O functions, BIOS Keyboard\n I/O functions, BIOS Printer\n I/O functions, BIOS Serial Port\n I/O functions, BIOS Timer\n I/O functions, character\n I/O functions, file via FCB\n I/O functions, file\n I/O Port Map\n I/O Redirection\n I/O, Standard\n ID, APM device\n ID, code page\n ID, country\n ID, switcher\n ID, media (media descriptor)\n ID, virtual machine\n ID, volume\n ID, VxDs\n implied 9th bit\n INCLUDE= (CONFIG.SYS Command)\n incremental decompression\n Index, API\n Index, Combined Services\n Index, DOS Function QuickRef\n Index, DOS Functions by Category\n Index, DOS Functions by Version\n Index, DOS Functions\n InDOS Flag\n Information Functions, System\n initialize device driver\n INSTALL= (CONFIG.SYS Command)\n installed state, ANSI.SYS\n installed state, APM\n installed state, APPEND.EXE\n installed state, ASSIGN.COM\n installed state, disk drive\n installed state, DOSKEY.COM\n installed state, DoubleSpace\n installed state, GRAFTABL.COM\n installed state, HIMEM.SYS (XMS support)\n installed state, joystick\n installed state, KEYB.COM\n installed state, mouse support\n installed state, MRCI compression support\n installed state, MSCDEX\n installed state, network support\n installed state, Network support\n installed state, NLSFUNC.EXE\n installed state, PRINT.EXE\n installed state, SHARE.EXE\n installed state, Switcher\n installed state, Windows Clipboard\n installed state, Windows Enh386 Support\n installed state, XMS support\n INSTALLHIGH= (CONFIG.SYS Command)\n instance data, switcher\n Instruction Set (CPU Opcodes)\n INT nn (Interrupts and BIOS Services)\n INT nn (opcode)\n ──────────── (Example: use XVIEW \"INT 10\"◄┘ for quick look-up) ───────────\n INT 00H INT 01H INT 02H INT 03H INT 04H INT 05H INT 06H INT 07H\n INT 08H INT 09H INT 0aH INT 0bH INT 0cH INT 0dH INT 0eH INT 0fH\n INT 10H INT 11H INT 12H INT 13H INT 14H INT 15H INT 16H INT 17H\n INT 18H INT 19H INT 1aH INT 1bH INT 1cH INT 1dH INT 1eH INT 1fH\n INT 20H INT 21H INT 22H INT 23H INT 24H INT 25H INT 26H INT 27H\n INT 28H INT 29H INT 2aH INT 2eH INT 2fH INT 31H INT 33H INT 40H\n INT 41H INT 43H INT 4aH INT 67H INT 70H\n ──────────────────────────────────────────────────────────────────────────\n Interrupt Controller\n Interrupt, Get Vector\n Interrupt, Multiplex (INT 2fH)\n Interrupt, Non-Maskable\n Interrupt, Set Vector\n Interrupts and BIOS Services\n Interrupts, DOS\n Invalid Opcode Interrupt (INT 06H)\n Invalid Task State Interrupt (INT 0aH)\n invalidate DoubleSpace cache\n IOCTL Functions\n IOCTL data packets, generic\n IOCTL, block devices\n IOCTL, character devices\n IOCTL, device driver input\n IOCTL, device driver output\n IOCTL, device driver generic\n IOCTL, support query, device driver\n IOCTL, support indicated in device attribute\n IRQs: Hardware Interrupts (SubMenu)\n───────────────────────────────────────────────────────────────────────█▌J▐█\n jobs, print spooler\n joystick BIOS support (INT 15H)\n joystick I/O port\n joystick installed state\n───────────────────────────────────────────────────────────────────────█▌K▐█\n key codes, ASCII\n key codes, extended ASCII\n key, Alt, Ctrl & Shift status\n key, Break (avoiding DOS exit)\n key, Break (BIOS)\n key, Break (setting DOS Break level)\n key, PrintScreen\n key, SysReq\n KEYB.COM Services\n keyboard connector - AT\n keyboard connector - PC/XT\n keyboard connector - PS/2\n keyboard ports & hardware\n keyboard intercept (INT 15H)\n keyboard interrupt (INT 09H)\n keyboard scan codes\n keyboard services, BIOS (INT 16H)\n keyboard services, DOS\n keyboard services, DOSKEY\n keyboard shift status flags\n keyboard status LEDs\n keyboard typematic rate\n───────────────────────────────────────────────────────────────────────█▌L▐█\n language support, national\n LASTDRIVE= (CONFIG.SYS Command)\n layout, CMOS Storage\n layout, CVF\n layout, video memory\n LDT descriptors\n level, break-check\n light pen emulation (mouse fn 0dH)\n light pen support (BIOS)\n line-drawing characters\n linear memory\n lines, screen, setting in text mode\n link state, upper memory\n List of Lists (undocumented DOS variables)\n load and execute program or overlay\n loading of video font characters, dynamic\n loading video fonts\n lock file access\n lock XMS memory block\n LPTn services\n───────────────────────────────────────────────────────────────────────█▌M▐█\n machine ID, virtual\n math coprocessor installed\n math coprocessor not present (INT 07H)\n MDBPB (CVF Region)\n MDFAT (CVF Region)\n media descriptor (media ID byte)\n media type\n media, removable\n memory allocation strategy\n Memory Control Block (MCB)\n memory control block, base\n Memory Management Functions\n Memory Map, BIOS Variables\n Memory Map, General\n memory size, < 1MB\n memory size, > 1MB\n memory size, DOS Free\n memory, accessing upper\n memory, at program startup\n memory, CMOS (configuration data layout)\n memory, conventional▲\n memory, DPMI services\n memory, expanded (EMS)\n memory, extended (XMS)\n memory, HMA▲\n memory, HMA Suballocations\n memory, ROM-Scan\n memory, upper▲\n memory, video\n memory-resident software support services\n MENUCOLOR= (CONFIG.SYS Command)\n MENUDEFAULT= (CONFIG.SYS Command)\n MENUITEM= (CONFIG.SYS Command)\n Microprocessor, Instruction Set\n Microprocessor, System Compatibility\n Microsoft Real-Time Compression Interface\n MKDIR\n mode, protected\n modes, SVGA\n modes, video\n mount DoubleSpace drive\n Mouse Support Services\n move or rename a file or directory\n MRCI API\n MSCDEX Support\n MultiConfig Menus\n music, producing\n───────────────────────────────────────────────────────────────────────█▌N▐█\n named handle, EMS\n National Language Support Functions\n Network and File-Sharing Functions\n NLSFUNC Services\n Non-Maskable Interrupt\n notifications, switcher\n notifications, Windows\n NUMLOCK= (CONFIG.SYS Command)\n───────────────────────────────────────────────────────────────────────█▌O▐█\n Obsolete DOS Functions\n opcode summary\n opcode, invalid (INT 06H)\n opcodes, 80x86\n opcodes, alphabetical list\n opcodes, 80x87 floating point\n open device (BIOS Hook)\n open EMM handle\n open file via FCB\n open file, with extended options\n open file\n Open Mode / Access Mode\n options, TECH Help! configuration\n output functions, character\n output functions, device driver\n output functions, file\n output functions, IOCTL\n output functions, printer\n overflow (division by 0)\n overflow handler for INTO opcode\n overflow stack (protected mode)\n overlay file, load\n overscan / border color\n Overviews and Articles\n───────────────────────────────────────────────────────────────────────█▌P▐█\n Page Fault Interrupt (Protected Mode)\n page frame (EMS)\n Page, Video\n page, video\n paging, virtual memory\n palette functions, CGA\n palette functions, EGA/VGA\n parallel ports\n partition table\n partition, extended DOS\n Path, Append\n PATH, predefined e-var\n Pin Outs and Cables\n pointer, mouse\n Popup Programs (TSRs)\n ports, asynchronous communications (COMn)\n ports, CGA and MDA\n ports, diskette controller\n ports, DMA\n ports, EGA\n ports, hard disk (AT)\n ports, hard disk (XT)\n ports, I/O Port Map\n ports, interrupt Controller\n ports, joystick (game adaptor)\n ports, keyboard\n ports, PPI\n ports, printer\n ports, serial (COMn)\n ports, timer\n ports, VGA\n POST: Power-On Self-Test\n POST Error Codes\n Power Management Services\n power management, about\n PPI (Programmable Peripheral Interface) Ports\n predefined environment variables\n prepare code page\n print spooler API\n PRINT.EXE Services\n printer codes, Epson/IBM\n printer connector\n Printer I/O Ports\n printer IRQs\n Printer Services and Topics\n printer, ASCII Control Codes\n printer, BIOS services (INT 17H)\n printer, LPTn base addresses\n printer, network\n printer, standard I/O handle of\n printing TECH Help! topics\n PrintScreen handler, select alternate\n PrintScreen key interrupt handler\n Program Control Functions\n program exit code\n program idle\n program overlay, load\n Program Segment Prefix (PSP)\n Program Startup & Exit\n program, execute\n program, terminate\n Programmable Peripheral Interface (PPI)\n protected mode\n PS/2\n PSP: Program Segment Prefix\n PUTCHAR, fast (INT 29H)\n───────────────────────────────────────────────────────────────────────█▌Q▐█\n Quick-Reference Subset of DOS Functions\n query system settings\n───────────────────────────────────────────────────────────────────────█▌R▐█\n RAM (See Also: Memory)\n RAM disk, using a compressed\n read disk file or device\n read disk sector (BIOS)\n read disk sector (DOS)\n read disk track (DOS)\n read IOCTL data from file or device\n real-time clock alarm handler (INT 4aH)\n real-time clock hardware (CMOS)\n real-time clock interrupt (INT 70H)\n real-time clock services\n real-time compression\n redefinition, dynamic character\n redirect network device\n redirect standard I/O handle\n reentrancy status (InDOS Flag)\n REM (CONFIG.SYS Command)\n remote drive\n rename or move a file or directory\n request header, device driver\n requests, device driver\n resident software (TSR)\n retry count, network sharing\n RMDIR\n ROM character sets\n ROM-BIOS (See Also: BIOS)\n ROM-BIOS Data Area\n ROM-Scan\n RootDir (CVF Region)\n───────────────────────────────────────────────────────────────────────█▌S▐█\n Scan Code, Keyboard\n Sector Heap (CVF Region)\n sector-level I/O, BIOS\n sector-level I/O, DOS\n segment not present handler (INT 0bH)\n Self-Test\n Serial I/O (See Also: Asynchronous I/O)\n serial ports\n services, BIOS\n services, by category\n services, combined API list\n services, DOS All\n services, DOS QuickRef\n SET (CONFIG.SYS Command)\n SHELL= (CONFIG.SYS Command)\n shift-hey status flags\n single-step interrupt\n sounds, producing\n speaker control\n special characters\n spooler services\n stack overflow handler (INT 0cH)\n STACKS= (CONFIG.SYS Command)\n startup & exit, program\n static functionality table (VGA)\n string, get input of\n string, output via BIOS\n string, output via DOS\n string, upshift for national language\n structures, conventions used in TECH Help!\n structures, DOS & BIOS\n SUBMENU= (CONFIG.SYS Command)\n superseded DOS functions\n SuperVGA (SubMenu)\n SVGA (SubMenu)\n swap DoubleSpace drive IDs\n Switch Settings (SubMenu)\n switchar\n SWITCHAR= (CONFIG.SYS Command)\n switcher / DOS Shell services\n Switcher API Overview\n SWITCHES= (CONFIG.SYS Command)\n SysReq Key\n System Compatibility\n System Services, by Category\n System Startup Sequence\n───────────────────────────────────────────────────────────────────────█▌T▐█\n Task Switcher / DOS Shell API\n\n TECH Help! configuration file (XVIEW.INI)\n TECH Help! menus\n TECH Help! keyboard usage\n TECH Help!, data structures in\n TECH Help!, using\n\n Terminate Address (INT 22H)\n Terminate and Stay Resident Services\n terminate program (fn 4cH)\n terminate program (INT 20H)\n terminating, Switcher is\n terminating, Windows is\n time, BIOS Services (INT 1aH)\n time, DOS CLOCK$ I/O\n time, DOS query current\n time, DOS set current\n time, DOS set/query for file\n timer event handler (INT 4aH)\n timer event, set (INT 15H)\n timer interrupt (INT 08H)\n timer interrupt, RTC (INT 70H)\n timer interrupt, User (INT 1cH)\n timer ports\n timer wait (INT 15H)\n timer, CMOS Real-Time Clock\n timeslice, release\n timeslice, using DOS Idle time\n track, format via BIOS\n track, format via DOS\n track, read/write via DOS\n transfer address, disk (DTA)\n TrueName\n TSR Services\n TTY, write character as\n typematic rate, keyboard\n───────────────────────────────────────────────────────────────────────█▌U▐█\n UMB▲\n UMB, access via DEVICEHIGH= command\n UMB, accessing\n UMB, in DOS= command\n UMB, loading xView into\n unique temporary file, create\n unlock file access\n unlock XMS memory block\n unmount DoubleSpace drive\n upper memory▲\n upper memory, accessing\n upshift text (NLS Support)\n User Alarm Handler (4aH)\n User Timer Interrupt (1cH)\n user-defined video fonts\n Using TECH Help!\n───────────────────────────────────────────────────────────────────────█▌V▐█\n variables, environment\n variables, predefined environment\n variables, undocumented DOS\n vector, get interrupt\n vector, set interrupt\n viewer, using the TECH Help!\n verify disk I/0\n verify sectors (BIOS)\n verify track (DOS)\n VERIFY= (CONFIG.SYS Command)\n version, DOS\n version, DOS fns listed by\n version, get DOS (fn 30H)\n version, get DOS actual (fn 3306H)\n version, get DoubleSpace\n version, get EMS\n version, get mouse\n version, get Switcher\n version, get XMS\n VESA/SVGA Services\n VGA: Video Graphics Adaptor (SubMenu)\n VGA cables\n VGA data areas\n VGA I/O ports\n video adapter cables and connectors\n video attributes\n video color table\n video font definition\n video memory layouts\n video modes\n video modes, SVGA\n video page\n Video Services (INT 10H)\n video snow\n virtual display driver fns\n volume label (in boot record)\n volume label (in root directory)\n VxDs: Some Published IDs\n───────────────────────────────────────────────────────────────────────█▌W▐█\n wait for keystroke (BIOS)\n wait for keystroke (DOS)\n wait for specified interval\n Windows Clipboard API\n Windows Enh386 Services\n Windows VDD Services\n write to disk file or device\n write disk sector (BIOS)\n write disk sector (DOS)\n write disk track (DOS)\n write IOCTL data to file or device\n─────────────────────────────────────────────────────────────────────█▌X-Z▐█\n XMS Services\n XMS: Extended Memory Specification\n XMS, check installed state\n XMS, get entry address\n XT\n XT Hard disk Ports\n XT Switch Settings\n XVIEW Syntax\n XVIEW.INI, modifying (TECH Help! configuration)\n───────────────────────────────────────────────────────────────█▌DOS Fn #s▐█\n (Example: use XVIEW 3c◄┘ at DOS prompt for quick look-up)\n 00H 01H 02H 03H 04H 05H 06H 07H 08H 09H 0aH 0bH 0cH\n 0dH 0eH 0fH 10H 11H 12H 13H 14H 15H 16H 17H 19H 1aH\n 1bH 1cH 1fH 21H 22H 23H 24H 25H 26H 27H 28H 29H 2aH\n 2bH 2cH 2dH 2eH 2fH 30H 31H 32H 33H 34H 35H 36H 37H\n 38H 39H 3aH 3bH 3cH 3dH 3eH 3fH 40H 41H 42H 43H 44H\n 4400H 4401H 4402H 4403H 4404H 4405H 4406H 4407H 4408H 4409H 440aH 440bH\n 440cH 440dH 440eH 440fH 4410H 4411H 45H 46H 47H 48H 49H 4aH 4bH\n 4cH 4dH 4eH 4fH 50H 51H 52H 53H 54H 56H 57H 58H 59H\n 5aH 5bH 5cH 5d0aH 5eH 5fH 60H 62H 65H 66H 67H 68H 6cH\n -♦-"
  },
  {
    "id": "5-dos_function_index___quick_reference_subset.html",
    "t": "DOS Function Index - Quick Reference Subset",
    "b": "All DOS Fns 25H Set INT Vector 3cH Create File 4eH Find File/GetInfo\n Service Groups 2aH Get Sys Date 3dH Open File 4fH Find Next File\n DOS Interrupts 2bH Set Sys Date 3eH Close File 50H Set Cur PSP\n 2cH Get Sys Time 3fH Read File 51H Get Cur PSP\n 00H Terminate 2dH Set Sys Time 40H Write File 52H List Of Lists\n 01H Kybd Input 2eH Set Verify 41H Delete File 54H Get Verify\n 02H Display Char 2fH Get DTA 42H Move File Ptr 56H Rename/Move File\n 05H Prn Output 30H Get Version 43H File Attrib 57H Time/Date File\n 06H Console I/O 31H TSR 44H IOCTL 58H MemAlloc Strategy\n 07H NoEcho RawInp 32H Get DPB 45H Dup Handle 59H Get Err Info\n 08H NoEcho Inp 3300H Get BreakLvl 46H Redir Handle 5aH Create Uniq File\n 09H Display Text 3301H Set BreakLvl 47H Get Dflt Dir 5bH Create New File\n 0aH Bufrd Input 3305H Get Boot Drv 48H Mem Alloc 5cH Lock File\n 0bH Get InpStatus 34H Get InDOS 49H Mem Free 5eH Network Misc\n 0cH Clear & Input 35H Get INT Vector 4aH Mem Resize 5fH Network Redirect\n 0dH Reset Disk 36H Disk Size/Free 4bH Exec 65H National Lang Fns\n 0eH Set Dflt Disk 39H MkDir 4cH Terminate 67H Set Handle Cnt\n 19H Get Dflt Disk 3aH RmDir 4dH Get Exit Code 68H Commit File Data\n 1aH Set DTA 3bH ChDir 6cH Open/Create File\n -♦-"
  },
  {
    "id": "6-system_service_groups.html",
    "t": "System Service Groups",
    "b": "Character I/O\n Device Drivers\n Directory and File\n Display\n Disk Drives\n File I/O\n File I/O via FCB\n Memory Management\n Miscellaneous\n National Language Support\n Network and File-Sharing\n Printer\n Process Control\n System Information\n TSR/Popup Functions\nDOS Function Lists ───────────────────────────────────────────────────────────\n Quick Reference Subset\n Complete list, by Fn Number\n 2.0+ Fns, by Version\n Superseded DOS Functions\n DOS Interrupts"
  },
  {
    "id": "7-character_i_o_functions.html",
    "t": "Character I/O Functions",
    "b": "┌───────────────────────┐\n 01H and 3fH (BX=0) keyboard input │ Keystroke Codes │\n 08H keyboard input (no output echo) │ ASCII Table │\n 07H raw keyboard input (no echo, no Break check) │ Box & Line Characters │\n 06H console input and output (no-wait input) │ ANSI Escape Sequences │\n 0bH get input status (and process pending Break) │ I/O Redirection │\n 0cH clear keyboard buffer and wait for input └───────────────────────┘\n 0aH and 3fH (BX=0) buffered keyboard input (input string)\n\n 02H and 40H (BX=1 or 2) display one character\n 09H and 40H (BX=1 or 2) display a string of characters\n\n 03H and 3fH (BX=3) AUX (serial port) input\n 04H and 40H (BX=3) AUX (serial port) output\n 05H and 40H (BX=4) PRN (printer) output\n 33H set Ctrl-Break check level 44H IOCTL (talk to device drivers)\n\n INT 10H BIOS Video Services INT 33H Mouse support\n INT 16H BIOS Keyboard Services INT 2fH MUX fns (print spooler, et al.)\n──────────────────────────────────────────────────────────────────────────────\n Service Groups Printer Functions National Language Support API Index"
  },
  {
    "id": "8-directory_and_file_functions.html",
    "t": "Directory and File Functions",
    "b": "39H MkDir: create a new directory 3cH create file\n 3aH RmDir: remove a directory 41H delete file\n\n 3bH ChDir: select default directory 0eH select current default disk\n 47H query current default directory 19H query current default disk\n 56H rename a directory\n\n 5700H query file time/date 5701H change file time/date\n 4eH or 42H query file size 42H change file size (pre-allocate)\n 4300H query file attribute 4301H change file attribute\n 56H change a file's name/move it\n\n 5cH lock/unlock file access Network and File-Sharing Functions\n 68H commit (flush buffers to disk)\n 0dH reset disk (flush buffers) IOCTL Functions (file/device info)\n\n 4eH 4fH search for files via ASCIIZ filename (get file info)\n 11H 12H search current directory via FCB (get DirEntryRec)\n──────────────────────────────────────────────────────────────────────────────\n Service Groups Data Structures File Handles DOS Functions"
  },
  {
    "id": "9-disk_drive_functions.html",
    "t": "Disk Drive Functions",
    "b": "19H query DOS default disk 0eH select DOS default disk\n 47H query current default directory 3bH set default directory\n 2fH query DTA (Disk Transfer Addr) 1aH set DTA\n 54H query disk verify status 2eH set disk verify status\n\n 36H get total and free disk space\n 32H get DPB disk info 1bH 1cH get disk info ◄superseded►\n\n 3305H query ID of boot drive\n\n 0dH reset disk (flush buffers) DS IOCTL 'F' flush DoubleSpace cache\n DS IOCTL 'I' invalidate Dblspace cache\n INT 13H BIOS Disk services\n INT 24H critical error handler address\n INT 25H/26H DOS direct disk read/write\n\n DoubleSpace API (see if disk is compressed, swap IDs, real free space,etc.)\n\n────────────────────────────────────────────█▌Block device IOCTL functions▐█\n 440dH 60H get device parameters 440dH 40H set device parameters\n 440dH 61H read track 440dH 41H write track\n 440dH 62H verify track 440dH 42H format and verify track\n 440dH 66H query media ID 440dH 46H set media ID\n 440dH 68H sense media type\n\n 4408H removable media query\n 440eH get logical drive 440fH set logical drive\n 4411H query IOCTL device\n──────────────────────────────────────────────────────────────────────────────\n INT 13H BIOS disk I/O Service Groups DOS Functions"
  },
  {
    "id": "10-display_functions.html",
    "t": "Display Functions",
    "b": "INT 10H BIOS video services ─────────────────────────────█▌BIOS/Hardware▐█\n CGA MDA EGA VGA SVGA video system submenus\n\n Video Modes Video Snow Screen Attributes\n Video Memory Layouts Color Table\n Video Font Definition (and dynamic character redefinition)\n─────────────────────────────────────────────────────────────────────█▌DOS▐█\n 06H console input and output (no-wait input)\n 02H and 40H (BX=1 or 2) display one character\n 09H and 40H (BX=1 or 2) display a string of characters\n\n 440cH 5fH set display mode (e.g., 50-line mode on VGA)\n 440cH 7fH query display information\n\n INT 2fH 1a00H see if ANSI.SYS is installed\n ANSI Escape Sequences move cursor; cls; set screen colors, etc.\n National Language Support font downloading\n MENUCOLOR= set screen color in MultiConfig Menus\n INT 2fH 40xxH Enh386-mode Windows Virtual Display services\n──────────────────────────────────────────────────────────────────────────────\n Character I/O Functions Service Groups"
  },
  {
    "id": "11-fcb_file_i_o_functions.html",
    "t": "FCB File I/O Functions",
    "b": "These ◄superseded► functions operate on the DOS default directory only.\n In most cases, it is wise to use the Handle-Oriented File I/O functions.\n\n 16H create file 29H parse text into FCB-type filename\n 0fH open file 11H 12H search current directory via FCB\n 10H close file (may be used in CVF▲ spelunking)\n 13H delete file\n\n 14H read sequential file\n 15H write sequential file\n\n 21H read record from random access file\n 27H read multiple records from random access file\n\n 24H set random record block field size\n 22H write record to random access file\n 28H write multiple-records to random access file (also change file size)\n\n──────────────────────────────────────────────────────────────────────────────\n FCB: File Control Block Handle-Oriented File I/O Function Groups"
  },
  {
    "id": "12-handle_oriented_file_i_o.html",
    "t": "Handle-Oriented File I/O",
    "b": "These functions are preferred over the superseded FCB File I/O functions\n unless you must maintain compatibility with DOS 1.0.\n\n 3cH create file 5bH create new file (must not exist)\n 3dH open file 5aH create unique/temporary file\n 3eH close file 6cH extended create and open\n 41H delete file\n\n 42H move read/write pointer (also use to get file size)\n 3fH read from file or device\n 40H write to file or device\n 68H commit file data (flush buffers to disk)\n\n 4406H check for EOF (input status) 4400H see if handle is device or file\n 4407H check for busy (output status) 440aH see if file is on network drv\n\n 45H duplicate file handle 67H set (increase) maximum handles\n 46H redirect file handle I/O\n──────────────────────────────────────────────────────────────────────────────\n Service Groups FCB File I/O File Handles DOS Functions API Index"
  },
  {
    "id": "13-memory_management_functions.html",
    "t": "Memory Management Functions",
    "b": "48H (BX=ffffH) determine largest available block\n 48H allocate a block of memory\n 49H free an allocated block of memory\n 4aH resize (shrink/expand) a memory block\n\n 5800H query allocation strategy 5801H set allocation strategy\n 5802H query upper-memory link 5803H set upper-memory link\n 3306H See if DOS is in the HMA▲ INT 2fH 4axxH Suballocate in the HMA\n\n XMS Services XMS memory/HMA control EMM Services LIM-EMS memory\n DPMI Services DOS Protected Mode Interface services\n\n Accessing Upper Memory how to allocate a UMB▲\n Program Startup & Exit memory considerations when a program starts\n CONFIG.SYS Commands (DOS=, DEVICEHIGH=, etc. affect memory)\n\n MCB Memory Control Block layout PSP fields wNextSeg, et al. are relevant\n INT 12H total conventional memory INT 15H 88H total extended memory\n──────────────────────────────────────────────────────────────────────────────\n TSR/Popup Functions Service Groups DOS Functions"
  },
  {
    "id": "14-miscellaneous_dos_functions.html",
    "t": "Miscellaneous DOS Functions",
    "b": "2bH set system date 2eH set/query disk verify level\n 2dH set system time 3300H query Break-checking level\n 57H query time/date of a file 3301H set Break-checking level\n\n 25H set interrupt vector\n 35H query interrupt vector\n\n 30H query DOS Version (as set via SetVer)\n 3306H query actual DOS Version\n\n 50H set current process ID\n 51H query current process ID\n 34H get InDOS and ErrorMode addresses\n\n 2fH query Disk Transfer Address (DTA)\n 1aH set Disk Transfer Address (DTA)\n\n 37H set the DOS command line switch character ◄obsolete►\n──────────────────────────────────────────────────────────────────────────────\n TSR/Popup Functions Service Groups DOS Functions"
  },
  {
    "id": "15-national_language_support_functions.html",
    "t": "National Language Support Functions",
    "b": "38H set or query country info Country ID Codes (dates, money, etc.)\n 6501H query extended country info\n COUNTRY= (in CONFIG.SYS)\n\n 6504H get uppercase table\n 6505H get filename uppercase table\n 6506H get collating sequence table\n 6507H get double-byte character set info\n\n 6520H upshift character\n 6521H upshift text\n 6522H upshift ASCIIZ string\n\n 6601H query active code page Code Page overview and ID list\n 6602H activate code page Code Page Font Files .CPI file layout\n Video Font Definition\n DEVICE= install DISPLAY.SYS or PRINTER.SYS code page support\n INT 2fH adxxH Keyb services\n INT 2fH b000H is Graftabl installed?\n────────────────────────────────────────█▌Character device IOCTL functions▐█\n 440cH 4aH select a prepared code page\n\n 440cH 4cH begin preparing a code page\n 4403H send control data to char device\n 440cH 4dH done preparing a code page\n\n 440cH 6aH query active code page\n 440cH 6bH get prepared code page list\n\n 440cH 5fH set display info\n 440cH 7fH query display info\n──────────────────────────────────────────────────────────────────────────────\n Service Groups DOS Functions"
  },
  {
    "id": "16-network_and_file_sharing_functions.html",
    "t": "Network and File-Sharing Functions",
    "b": "INT 2fH 1000H see if file-sharing support is installed\n\n 440bH set sharing retry count\n 5c00H lock part or all of a file\n 5c01H unlock part or all of a file\n\n INT 2fH 1000H see if network support is installed\n\n 4409H see if drive is local or remote\n 440aH see if file or device is local or remote\n\n 5e00H get machine name (network node name)\n 5e02H set network printer setup\n 5e03H query network printer setup\n\n 5f02H get assign-list entry (get index number needed for other fns)\n 5f03H make network connection (associate drive ID with remote drive)\n 5f04H delete network connection\n──────────────────────────────────────────────────────────────────────────────\n Access Mode / Open Mode Service Groups DOS Functions"
  },
  {
    "id": "17-printer_functions.html",
    "t": "Printer Functions",
    "b": "┌─────────────────────────┐\n 05H and 40H (BX=4) write data to PRN │ ASCII Control Codes │\n │ ASCII Table │\n 3301H notice Ctrl+Break during PRN output │ Epson/IBM Printer Codes │\n │ I/O Redirection │\n 4407H get output status (check for busy) └─────────────────────────┘\n 440aH see if PRN is on a remote server\n 440cH 45H set retry iteration count\n\n 5e02H set network printer setup\n 5e03H query network printer setup\n\n INT 24H Critical Error (get control on printer error)\n INT 2fH 01xxH Print.Exe spooler services\n\n INT 17H BIOS printer services\n\n INT 05H Print screen\n INT 0dH and INT 0fH LPTn IRQ handlers\n──────────────────────────────────────────────────────────────────────────────\n File Handles National Language Support (font downloading) Service Groups"
  },
  {
    "id": "18-process_control_functions.html",
    "t": "Process Control Functions",
    "b": "4b00H load and execute program 26H Build PSP ◄superseded►\n 4b01H load program\n 4b03H load overlay\n 4b05H set execution state (SetVer version info)\n\n 4cH terminate 00H and INT 20H ◄superseded►\n 4dH get exit code of child process\n\n 31H terminate and keep memory (TSR) INT 27H ◄superseded►\n 51H get PSP of current process See also: TSR/Popup Functions\n 50H set current PSP Program Segment Prefix\n 34H get InDOS and ErrorMode addresses\n\n INT 23H Ctrl+Break handler vector (default handler terminates program)\n INT 24H Critical Error handler vector (default handler may terminate you)\n INT 2fH aexxH Control execution of DOS commands\n\n Program Startup & Exit conditions when a program starts\n DPMI Services EXE File Header DOS Environment CONFIG.SYS\n──────────────────────────────────────────────────────────────────────────────\n TSR/Popup Functions Memory Functions Service Groups DOS Functions"
  },
  {
    "id": "19-system_information_functions.html",
    "t": "System Information Functions",
    "b": "30H DOS version number 3305H ID of boot drive\n 3306H actual DOS version CONFIG start up menu choice\n 59H recent error information COMSPEC COMMAND.COM load path\n\n 2aH current date INT 1cH detect timer tick\n 2cH current time INT 28H detect DOS Idle state\n\n 19H current default disk INT 11H BIOS equipment list\n 47H current default directory INT 15H c0H BIOS configuration info\n\n 2fH current DTA address INT 15H 5300H APM installed state\n 34H InDOS addr (reentrancy state)\n 35H current value of an INT vector INT 2fH 1700H Windows Enh386 active\n 51H current PSP (active program) INT 2fH 1700H Windows/Clipboard state\n 52H List Of Lists (misc DOS vars) INT 2fH 1687H DPMI installed state\n INT 2fH 4b02H Dosshell installed state\n 54H disk verify mode\n 3300H Ctrl-Break checking state INT 33H 0000H mouse installed state\n──────────────────────────────────────────────────────────────────────────────\n Service Groups DOS Functions BIOS Data Area Data Structures API Index"
  },
  {
    "id": "20-terminate_and_stay_resident__tsr_.html",
    "t": "Terminate and Stay Resident (TSR)",
    "b": "TECH Help! topics cover many facets of writing TSR programs:\n\n DOS fn 31H Make your program resident in memory. Also INT 27H.\n DOS fn 4aH Shrink your memory block to only the size you need.\n DOS fn 4bH EXEC a child process (you're resident while it executes).\n\n DOS fn 34H Get InDOS Flag and ErrorMode addresses before installing (VERY\n important in writing crash-free TSRs).\n DOS fn 01H-0cH take special precautions with these fns.\n\n DOS fn 52H Trace MCBs to see what TSRs are resident. ◄undocumented►\n\n DOS fn 35H/25H Save/restore an interrupt vector (install an INT handler).\n DOS fn 51H/50H Save/restore the PSP of interrupted program.\n DOS fn 2fH/1aH Save/restore DTA of interrupted program.\n XMS fn 07H/03H Save/restore the state of A20 (if you mess around with it).\n\n INT 33H 0017H / 0018H Save/restore mouse status\n INT 67H 4700H / 4800H Save/restore Expanded Memory Manager page mapping\n\n XMS 01H a TSR may want to own the HMA▲.\n\n INSTALL= and INSTALLHIGH= CONFIG.SYS commands make a TSR resident.\n\n Switcher API Maintain separate data areas per each DOS session.\n MRCI API TSRs using MRCI compression must be careful.\n Accessing Upper Memory Have your TSR load itself into a UMB▲.\n DOS Environment Use 49H to free your environment at PSP:002eH.\n Program Startup & Exit Some general background info applies to TSRs, too.\n xView Syntax How to use TECH Help! as a RAM-resident popup.\n\n────────────────────────────────────█▌Interrupts often intercepted by TSRs▐█\n INT 08H Get control 18 times per second.\n INT 09H Watch keyboard for the scan code of your hot key.\n Use the Keyboard Flags to check the current state of shift keys.\n INT 16H Watch keyboard for your Extended ASCII keystroke hot key.\n INT 23H Get control when user presses Ctrl-Break in your program.\n INT 24H Get control on Critical Error (e.g., drive door open).\n INT 28H Get control on DOS Idle (at a time when it is safe to popup).\n INT 2fH Communicate with previously-installed copy of yourself.\n──────────────────────────────────────────────────────────────────────────────\n DOS Functions BIOS Data Area API Index Service Groups"
  },
  {
    "id": "21-superseded_dos_functions.html",
    "t": "Superseded DOS Functions",
    "b": "This index lists DOS version 1.0 services which have been superseded by\n services available with DOS 2.0+. The newer services are typically much\n easier to use.\n\n Old Function New Function\n ───────────────────────────── ──────────────────────────────────────\n 00H Terminate Program 4cH End Program\n 01H Read Keyboard with Echo 3fH Read File or Device (BX=0)\n 02H Display Character 40H Write File or Device (BX=1 or 2)\n 03H Auxiliary Input 3fH Read File or Device (BX=3)\n 04H Auxiliary Output 40H Write File or Device (BX=3)\n 05H Print Character 40H Write File or Device (BX=4)\n 09H Display String 40H Write File or Device (BX=1 or 2)\n 0aH Buffered Keyboard Input 3fH Read File or Device (BX=0)\n 0fH Open File with FCB 3dH Open File with Handle\n 10H Close File with FCB 3eH Close File with Handle\n 11H Find First File with FCB 4eH Find First File\n 12H Find Next File with FCB 4fH Find Next File\n 13H Delete File with FCB 41H Delete File\n 14H Sequential Read 3fH Read File or Device\n 15H Sequential Write 40H Write File or Device\n 16H Create File with FCB 3cH Create File with Handle\n 17H Rename File with FCB 56H Rename File\n 1bH Get Default Drive Data 36H Get Disk Free Space\n 1cH Get Drive Data 36H Get Disk Free Space\n 21H Random Read 3fH Read File or Device\n 22H Random Write 40H Write File or Device\n 23H Get File Size 42H Move File Pointer\n 24H Set Random Record Number 42H Move File Pointer\n 26H Create New PSP 4b00H Load and Execute Program\n 27H Random Block Read 3fH Read File + 42H Move File Pointer\n 28H Random Block Write 40H Write File + 42H Move File Pointer\n\n INT 20H Terminate Program 4cH End Program\n INT 27H Terminate & Stay Res 31H Terminate & Stay Resident\n ───────────────────────────── ──────────────────────────────────────\n Notes: ■ Fns 01H-0cH continue to be needed by TSRs when InDOS is set.\n ■ Fn 11H is still useful when you need to access a CVF▲ directly\n (it returns a starting cluster; see Mapping DOS FAT to MDFAT).\n\nSee Also: Obsolete DOS Functions\n DOS Function Index - by DOS Version\n DOS Versions (summary of differences from version to version)\n DOS Functions"
  },
  {
    "id": "22-obsolete_dos_functions.html",
    "t": "Obsolete DOS Functions",
    "b": "The following INT 21H services are listed in Microsoft literature as not\n being supported by DOS 5.0+:\n\n 18H (undocumented, original purpose unknown)\n 1dH (undocumented, original purpose unknown)\n 1eH (undocumented, original purpose unknown)\n 20H (undocumented, original purpose unknown)\n 3700H (undocumented; originally queried command-line switch character)\n 3701H (undocumented; originally set command-line switch character)\n 61H (undocumented, original purpose unknown)\n 63H (undocumented, original purpose unknown)\n\n Notes: In general, the repeated warnings about using undocumented DOS\n services have been moot. On all but the most obscure functions,\n Microsoft has maintained upward compatibility since the start.\n\n With DOS 5.0, Microsoft documented many \"new\" services and\n labeled them as \"available with DOS 2.0 and all later versions.\"\n Such functions are flagged with ◄wasUndoc► in TECH Help!\n\nSee Also: Superseded DOS Functions\n DOS Function Index - by DOS Version\n DOS Versions (summary of differences from version to version)\n DOS Functions"
  },
  {
    "id": "23-dos_function_index___by_number.html",
    "t": "DOS Function Index - by Number",
    "b": "This index lists all INT 21H functions, organized by function number,\n and identifying the DOS versions under which they are available.\n\n See DOS Function Index - by DOS Version to see functions in the\n chronological order in which they were added to DOS.\n See DOS Function Index - Quick Reference Subset for a one-screen summary.\n\nVersions DOS Function\n ┌────┐ ───────────────────────────────────────────────────────────────────\n │1.0+│ 00H Terminate a Program\n │1.0+│ 01H Keyboard Input\n │1.0+│ 02H Display Output\n │1.0+│ 03H Auxiliary Input\n │1.0+│ 04H Auxiliary Output\n │1.0+│ 05H Printer Output\n │1.0+│ 06H Console I/O\n │1.0+│ 07H No Echo Unfiltered Console Input\n │1.0+│ 08H No Echo Console Input\n │1.0+│ 09H Display String\n │1.0+│ 0aH Buffered String Input\n │1.0+│ 0bH Check Input Status\n │1.0+│ 0cH Clear & Input\n │1.0+│ 0dH Reset Disk\n │1.0+│ 0eH Select DOS Default Disk\n │1.0+│ 0fH Open File via FCB\n │1.0+│ 10H Close File via FCB\n │1.0+│ 11H Find 1st Matching File via FCB\n │1.0+│ 12H Find Next Matching File via FCB\n │1.0+│ 13H Delete File via FCB\n │1.0+│ 14H Read Sequential File via FCB\n │1.0+│ 15H Write Sequential File via FCB\n │1.0+│ 16H Create File via FCB\n │1.0+│ 17H Rename File via FCB\n │?.? │ 18H (unknown) ◄obsolete►\n │1.0+│ 19H Query DOS Default Disk\n │1.0+│ 1aH Set Disk Transfer Address (DTA)\n │1.0+│ 1bH Get Drive Info (current disk)\n │2.0+│ 1cH Get Drive Info (any disk)\n │?.? │ 1dH (unknown) ◄obsolete►\n │?.? │ 1eH (unknown) ◄obsolete►\n │2.0+│ 1fH Get Drive Parameter Block (current disk) ◄wasUndoc►\n │?.? │ 20H (unknown) ◄obsolete►\n │1.0+│ 21H Read Random File Record\n │1.0+│ 22H Write Random File Record\n │1.0+│ 23H Query File Size via FCB\n │1.0+│ 24H Set Random File Block Address\n │1.0+│ 25H Set Interrupt Vector\n │1.0+│ 26H Create Program Segment Prefix\n │1.0+│ 27H Read Random File Block\n │1.0+│ 28H Write Random File Block\n │1.0+│ 29H Parse Filename\n │1.0+│ 2aH Query DOS Date\n │1.0+│ 2bH Set DOS Date\n │1.0+│ 2cH Query DOS Time\n │1.0+│ 2dH Set DOS Time\n │1.0+│ 2eH Set/Reset Verify Switch\n │2.0+│ 2fH Query Disk Transfer Address (DTA)\n │2.0+│ 30H Get DOS Version Number\n │2.0+│ 31H Terminate & Stay Resident\n │2.0+│ 32H Get DPB (Drive Parameter Block) ◄wasUndoc►\n │2.0+│ 3300H Query Break-Check Flag\n │2.0+│ 3301H Set Break-check level\n │2.0+│ 3305H Get Boot Drive ◄wasUndoc►\n │5.0+│ 3306H Get DOS Version Info (and HMA use)\n │2.0+│ 34H Get InDOS Address (DOS Reentrancy Status) ◄wasUndoc►\n │2.0+│ 35H Get Interrupt Vector\n │2.0+│ 36H Get Disk Free Space\n │?.? │ 3700H Query Switchar ◄obsolete►\n │?.? │ 3701H Set Switchar ◄obsolete►\n │2.0+│ 38H Get/Set Country-dependent Info\n │2.0+│ 39H Create a New Directory -- MKDIR\n │2.0+│ 3aH Delete a Directory -- RMDIR\n │2.0+│ 3bH Set DOS Default Directory -- CHDIR\n │2.0+│ 3cH Create a File via Handle\n │2.0+│ 3dH Open a File via Handle\n │2.0+│ 3eH Close a File Handle\n │2.0+│ 3fH Read from File via Handle\n │2.0+│ 40H Write to File via Handle\n │2.0+│ 41H Delete File\n │2.0+│ 42H Set File Pointer\n │2.0+│ 4300H Query File Attribute\n │2.0+│ 4301H Set File Attribute\n │2.0+│ 4400H IOCTL Query Device/File Flags\n │2.0+│ 4401H IOCTL Set Device/File Flags\n │2.0+│ 4402H IOCTL Receive Control Data from Char Device\n │2.0+│ 4403H IOCTL Send Control Data to Character Device\n │2.0+│ 4404H IOCTL Receive Control Data from Block Device\n │2.0+│ 4405H IOCTL Send Control Data to Block Device\n │2.0+│ 4406H IOCTL Query Handle Input Status\n │2.0+│ 4407H IOCTL Query Handle Output Status\n │3.0+│ 4408H IOCTL Does Drive Use Removable Media\n │3.1+│ 4409H IOCTL Is Drive Remote\n │3.1+│ 440aH IOCTL Is File/Device Remote\n │3.1+│ 440bH IOCTL Set Sharing Retry Count\n │3.3+│ 440cH 45H IOCTL Set Retry Iteration Count\n │3.3+│ 440cH 4AH IOCTL Select Code Page\n │3.3+│ 440cH 4CH IOCTL Start Code Page Prepare\n │3.3+│ 440cH 4DH IOCTL End Code Page Prepare\n │4.0+│ 440cH 5Fh IOCTL Set Display Mode\n │3.3+│ 440cH 65H IOCTL Query Retry Iteration Count\n │3.3+│ 440cH 6AH IOCTL Query Current Code Page\n │3.3+│ 440cH 6BH IOCTL Query Code Page List\n │4.0+│ 440cH 7Fh IOCTL Query Display Mode\n │3.2+│ 440dH 40H IOCTL Set Device Parameters\n │3.2+│ 440dH 41H IOCTL Write Track on Logical Drive\n │3.2+│ 440dH 42H IOCTL Format Track on Logical Drive\n │4.0+│ 440dH 46H IOCTL Set Media ID\n │3.2+│ 440dH 47H IOCTL Set Access Flag\n │3.2+│ 440dH 60H IOCTL Query Device Parameters\n │3.2+│ 440dH 61H IOCTL Read Track on Logical Drive\n │3.2+│ 440dH 62H IOCTL Verify Track on Logical Drive\n │5.0+│ 440dH 66H IOCTL Query Media ID\n │4.0 │ 440dH 67H IOCTL Query Access Flag\n │3.2+│ 440dH 68H IOCTL Sense Media Type\n │3.2+│ 440eH IOCTL Query Logical Drive Map\n │3.2+│ 440fH IOCTL Set Logical Drive Map\n │5.0+│ 4410H IOCTL Query IOCTL Support for Handle\n │5.0+│ 4411H IOCTL Query IOCTL Support for Device\n │2.0+│ 45H Duplicate a File Handle\n │2.0+│ 46H Redirect a Handle\n │2.0+│ 47H Query Default Directory\n │2.0+│ 48H Allocate Memory / Query Free Memory\n │2.0+│ 49H Free Allocated Memory Block\n │2.0+│ 4aH Shrink or Expand a Memory Block\n │2.0+│ 4b00H Execute a Program -- EXEC\n │2.0+│ 4b01H Load Program ◄wasUndoc►\n │2.0+│ 4b03H Load Overlay\n │5.0+│ 4b05H Set Execution State\n │2.0+│ 4cH Terminate Program\n │2.0+│ 4dH Get Program Exit Code\n │2.0+│ 4eH Find 1st Matching File\n │2.0+│ 4fH Find Next Matching File\n │2.0+│ 50H Set PSP ◄wasUndoc►\n │2.0+│ 51H Query Current PSP ◄wasUndoc►\n │????│ 52H Get DOS Variables ◄undoc►\n │????│ 53H Convert BPB to DPB ◄undoc►\n │2.0+│ 54H Get DOS Verify State\n │2.0+│ 56H Rename/Move a File\n │2.0+│ 5700H Query File Time/Date\n │2.0+│ 5701H Set File Time/Date\n │3.0+│ 5800H Query Memory Allocation Strategy\n │3.0+│ 5801H Set Memory Allocation Strategy\n │5.0+│ 5802H Query Upper-Memory Link State\n │5.0+│ 5803H Set Upper-Memory Link State\n │3.0+│ 59H Get Extended Error Info\n │3.0+│ 5aH Create Unique Temporary File\n │3.0+│ 5bH Create New File\n │3.1+│ 5c00H Lock File Access\n │3.1+│ 5c01H Unlock File Access\n │4.0+│ 5d0aH Set Extended Error\n │3.1+│ 5e00H Query Network Node Name\n │3.1+│ 5e02H Set Network Printer Setup\n │3.1+│ 5e03H Query Network Printer Setup\n │3.1+│ 5f02H Network Query Assign-List Entry\n │3.1+│ 5f03H Make Network Connection\n │3.1+│ 5f04H Delete Network Connection\n │????│ 60H Query TrueName ◄undoc►\n │2.0+│ 62H Query Current PSP ◄wasUndoc►\n │3.3+│ 6501H Get Extended Country Information\n │3.3+│ 6504H Get Uppercase Table\n │3.3+│ 6505H Get Filename Character Table\n │3.3+│ 6506H Get Collating Sequence Table\n │3.3+│ 6507H Get Double-Byte Character Set\n │3.3+│ 6520H Upshift Character\n │3.3+│ 6521H Upshift String\n │3.3+│ 6522H Upshift ASCIIZ String\n │3.3+│ 6601H Query Active Code Page\n │3.3+│ 6602H Activate Code Page\n │3.3+│ 67H Set File Handle Count\n │3.3+│ 68H Commit File\n │4.0+│ 6cH Extended Open/Create\n └────┘\nSee Also: Superseded DOS Functions\n Obsolete DOS Functions\n DOS Versions (summary of differences from version to version)\n -♦-"
  },
  {
    "id": "24-dos_function_index___by_dos_version.html",
    "t": "DOS Function Index - by DOS Version",
    "b": "This index lists INT 21H functions, organized by the DOS versions in which\n they first appeared. Fns that have been supported since DOS 1.x and 2.x\n are not listed, except for a few which were first documented with DOS 5.0.\n\n See DOS Function Index - by Number for a complete list.\n\nVersions DOS Function\n ┌────┐ ───────────────────────────────────────────────────────────────────\n │?.? │ 52H Get DOS Variables ◄undoc►\n │?.? │ 53H Convert BPB to DPB ◄undoc►\n │?.? │ 60H Query TrueName ◄undoc►\n │ │\n │2.0+│ 1fH Get Drive Parameter Block (current disk) ◄wasUndoc►\n │2.0+│ 32H Get DPB (Drive Parameter Block) ◄wasUndoc►\n │2.0+│ 3305H Get Boot Drive ◄wasUndoc►\n │2.0+│ 34H Get InDOS Address (DOS Reentrancy Status) ◄wasUndoc►\n │2.0+│ 4b01H Load Program ◄wasUndoc►\n │2.0+│ 50H Set PSP ◄wasUndoc►\n │2.0+│ 51H Query Current PSP ◄wasUndoc►\n │2.0+│ 62H Query Current PSP ◄wasUndoc►\n │ │\n │3.0+│ 4408H IOCTL Does Drive Use Removable Media\n │3.0+│ 5800H Query Memory Allocation Strategy\n │3.0+│ 5801H Set Memory Allocation Strategy\n │3.0+│ 59H Get Extended Error Info\n │3.0+│ 5aH Create Unique Temporary File\n │3.0+│ 5bH Create New File\n │ │\n │3.1+│ 4409H IOCTL Is Drive Remote\n │3.1+│ 440aH IOCTL Is File/Device Remote\n │3.1+│ 440bH IOCTL Set Sharing Retry Count\n │3.1+│ 5c00H Lock File Access\n │3.1+│ 5c01H Unlock File Access\n │3.1+│ 5e00H Query Network Node Name\n │3.1+│ 5e02H Set Network Printer Setup\n │3.1+│ 5e03H Query Network Printer Setup\n │3.1+│ 5f02H Network Query Assign-List Entry\n │3.1+│ 5f03H Make Network Connection\n │3.1+│ 5f04H Delete Network Connection\n │ │\n │3.2+│ 440dH 40H IOCTL Set Device Parameters\n │3.2+│ 440dH 41H IOCTL Write Track on Logical Drive\n │3.2+│ 440dH 42H IOCTL Format Track on Logical Drive\n │3.2+│ 440dH 47H IOCTL Set Access Flag\n │3.2+│ 440dH 60H IOCTL Query Device Parameters\n │3.2+│ 440dH 61H IOCTL Read Track on Logical Drive\n │3.2+│ 440dH 62H IOCTL Verify Track on Logical Drive\n │3.2+│ 440dH 68H IOCTL Sense Media Type\n │3.2+│ 440eH IOCTL Query Logical Drive Map\n │3.2+│ 440fH IOCTL Set Logical Drive Map\n │ │\n │3.3+│ 440cH 45H IOCTL Set Retry Iteration Count\n │3.3+│ 440cH 4AH IOCTL Select Code Page\n │3.3+│ 440cH 4CH IOCTL Start Code Page Prepare\n │3.3+│ 440cH 4DH IOCTL End Code Page Prepare\n │3.3+│ 440cH 65H IOCTL Query Retry Iteration Count\n │3.3+│ 440cH 6AH IOCTL Query Current Code Page\n │3.3+│ 440cH 6BH IOCTL Query Code Page List\n │3.3+│ 6501H Get Extended Country Information\n │3.3+│ 6504H Get Uppercase Table\n │3.3+│ 6505H Get Filename Character Table\n │3.3+│ 6506H Get Collating Sequence Table\n │3.3+│ 6507H Get Double-Byte Character Set\n │3.3+│ 6520H Upshift Character\n │3.3+│ 6521H Upshift String\n │3.3+│ 6522H Upshift ASCIIZ String\n │3.3+│ 6601H Query Active Code Page\n │3.3+│ 6602H Activate Code Page\n │3.3+│ 67H Set File Handle Count\n │3.3+│ 68H Commit File\n │ │\n │4.0 │ 440dH 67H IOCTL Query Access Flag\n │4.0+│ 440cH 5Fh IOCTL Set Display Mode\n │4.0+│ 440cH 7Fh IOCTL Query Display Mode\n │4.0+│ 440dH 46H IOCTL Set Media ID\n │4.0+│ 5d0aH Set Extended Error\n │4.0+│ 6cH Extended Open/Create\n │ │\n │5.0+│ 3306H Get DOS Version Info\n │5.0+│ 440dH 66H IOCTL Query Media ID\n │5.0+│ 4410H IOCTL Query IOCTL Support for Handle\n │5.0+│ 4411H IOCTL Query IOCTL Support for Device\n │5.0+│ 4b05H Set Execution State\n │5.0+│ 5802H Query Upper-Memory Link State\n │5.0+│ 5803H Set Upper-Memory Link State\n └────┘\nSee Also: DOS Function Index - by Number\n Superseded DOS Functions\n Obsolete DOS Functions\n DOS Versions (summary of differences from version to version)\n -♦-"
  },
  {
    "id": "25-api_index.html",
    "t": "API Index",
    "b": "TECH Help! covers the following programming \"toolboxes\", often called\n Application Programming Interfaces or APIs:\n\n BIOS Functions all system interrupts\n DOS Functions DOS file system, memory, devices, etc.\n\n APM API power management services\n Append Services when DOS Append command is resident\n AT Keyboard Functions command codes for the keyboard controller\n Device Driver Requests installable device drivers\n Doskey Services when DOSKEY.COM is resident\n DoubleSpace API control drive IDs, unmount, CVF layout\n DPMI Services DOS Protected Mode Interface services\n EMM Services expanded Memory Manager services\n FaxBIOS discussed in overview only\n HMA Sub-Allocations allocate memory in the HMA when DOS=HIGH\n IOCTL Functions DOS fn 44H control of devices\n Keyb Services when KEYB.COM is resident\n Mouse Support when mouse support has been installed\n MRCI API Microsoft Real-Time Compression services\n Mscdex Services CD-ROM services\n Multiplex Interrupt INT 2fH portal to various APIs\n Print Spooler Services when PRINT.EXE is resident\n Task Switcher API DOS Shell services and notifications\n VESA/SVGA Services SuperVGA services with compliant BIOS\n Video Services all INT 10H services\n Windows 386Enh Services used when in a DOS session under Windows\n Windows Clipboard Access used when in a DOS session under Windows\n Windows VM-aware VDD fns screen save/restore under 386Enh mode\n XMS Services extended Memory services (HIMEM.SYS)\n────────────────────────────────────────────────────────────────────────────\n Service Groups TECH Topics"
  },
  {
    "id": "26-qtopic.html",
    "t": "Topic",
    "b": "For instance,\n\n XVIEW ASCII ◄─┘\n\nbrings up a menu of ASCII topics. If this\nindexed-lookup technique sends you to an\nundesired topic with a similar title, press\nEsc to backtrack to this index.\n\nUse quotes for multiple-word entries; e.g.,\n\n XVIEW \"INT 10H\" ◄─┘"
  },
  {
    "id": "27-dos__bios___extensions_service_index.html",
    "t": "DOS, BIOS & Extensions Service Index",
    "b": "This is the complete, combined list of DOS functions and BIOS interrupts\n and common DOS extension services covered by TECH Help! These are listed\n by interrupt number, then sub-function number. For more manageable chunks,\n see:\n API Index ........ Individual APIs listed separately\n Service Groups ... Indexes with functions grouped by category\n TECH Topics ...... Often used topics, plus API overviews and articles\n General Index .... Lots of ways to find stuff\n DOS Fns QuickRef by Number by DOS Version Obsolete Fns\n DOS Interrupts\n────────────────────────────────────────────── Interrupts and BIOS Services\n INT 00H: Division Overflow\n INT 01H: Single-Step Interrupt\n INT 02H: Non-Maskable Interrupt\n INT 03H: Breakpoint Interrupt\n INT 04H: Overflow Interrupt\n INT 05H: Print Screen / Bounds Exception\n INT 06H: Invalid Opcode\n INT 07H: Math Coprocessor Not Present\n INT 08H: Timer Interrupt\n INT 09H: Keyboard Interrupt\n INT 0aH: IRQ 2 Cascade / Invalid Task State\n INT 0bH: IRQ 3 COM2/4 / Segment Not Present\n INT 0cH: IRQ 4 COM1/3 / Stack Overflow\n INT 0dH: IRQ 5 LPT2 / General Protection Fault\n INT 0eH: Diskette Interrupt / Page Fault\n INT 0fH: IRQ 7 LPT1\n─────────────────────────────────────────────────── INT 10H: Video Services\n INT 10H 00H: Set Video Mode\n INT 10H 01H: Set Cursor Shape & Size\n INT 10H 02H: Set Cursor Position\n INT 10H 03H: Query Cursor Position and Size\n INT 10H 04H: Query Light Pen\n INT 10H 05H: Select Video Page\n INT 10H 06H: Scroll Up / Clear Screen Rectangle\n INT 10H 07H: Scroll Down / Clear Screen Rectangle\n INT 10H 08H: Read Character/Attribute at Cursor Location\n INT 10H 09H: Write Character/Attribute to Cursor Location\n INT 10H 0aH: Write Character to Cursor Location\n INT 10H 0bH: Select Graphics Palette or Text Border Color\n INT 10H 0cH: Write Graphics Pixel\n INT 10H 0dH: Read Graphics Pixel\n INT 10H 0eH: Write Character as TTY\n INT 10H 0fH: Query Current Video Info\n INT 10H 13H: AT/EGA/VGA String Display Functions\n INT 10H 1300H: Display String\n INT 10H 1301H: Display String and Update Cursor\n INT 10H 1302H: Display Character/Attribute Cells\n INT 10H 1303H: Display Char/Attr Cells & Update Cursor\n INT 10H 10H: EGA/VGA Palette Functions\n INT 10H 1000H: Set One Palette Register\n INT 10H 1001H: Set Overscan/Border Color Register\n INT 10H 1002H: Set All Palette Registers and Overscan\n INT 10H 1003H: Select Foreground Blink or Bold Background\n INT 10H 1007H: Read One Palette Register\n INT 10H 1008H: Read Overscan Register\n INT 10H 1009H: Read All Palette Registers\n INT 10H 1010H: Set One DAC Color Register\n INT 10H 1012H: Set a Block of DAC Color Register\n INT 10H 1013H: DAC Color Paging Functions\n INT 10H 1015H: Read One DAC Color Register\n INT 10H 1017H: Read a Block of DAC Color Registers\n INT 10H 101aH: Query DAC Color Paging State\n INT 10H 101bH: Convert DAC Colors to Gray-Scale Values\n INT 10H 11H: EGA/VGA Character Generator Functions\n INT 10H 1100H: Load User-Defined Font\n INT 10H 1101H: Load ROM 8x14 Character Set\n INT 10H 1102H: Load ROM 8x8 Character Set\n INT 10H 1103H: Activate Font Block\n INT 10H 1104H: Load ROM 8x16 Character Set\n INT 10H 1110H: Load and Activate User-Defined Font\n INT 10H 1111H: Load and Activate ROM 8x14 Character Set\n INT 10H 1112H: Load and Activate ROM 8x8 Character Set\n INT 10H 1114H: Load and activate ROM 8x16 Character Set\n INT 10H 1120H: Setup INT 1fH Vector\n INT 10H 1121H: Setup User-Defined Font for Graphics Mode\n INT 10H 1122H: Setup ROM 8x14 Font for Graphics Mode\n INT 10H 1123H: Setup ROM 8x8 Font for Graphics Mode\n INT 10H 1124H: Setup ROM 8x16 Font for Graphics Mode\n INT 10H 1130H: Get Current Character Generator Info\n INT 10H 12H: EGA/VGA Special Functions/Alternate Select\n INT 10H 12H BL=10H: Get EGA information\n INT 10H 12H BL=20H: Select Alternate Print Screen Handler\n INT 10H 12H BL=30H: Select Scan Lines for Text Modes\n INT 10H 12H BL=31H: Palette Loading on Mode Set\n INT 10H 12H BL=32H: Enable/Disable Video RAM & I/O Ports\n INT 10H 12H BL=33H: Enable/Disable Gray-Scale Summing\n INT 10H 12H BL=34H: Cursor Emulation (Scaling)\n INT 10H 12H BL=35H: Switch PS/2 Displays\n INT 10H 12H BL=36H: Enable/Disable Screen Refresh\n INT 10H 1aH: Set or Query Display Combination Code\n INT 10H 1bH: Get VGA Functionality and State Info\n INT 10H 1cH: VGA State Save/Restore Functions\n INT 10H 1c00H: VGA Query Size of State-Save Buffer\n INT 10H 1c01H: VGA Save Video State\n INT 10H 1c02H: VGA Restore Video State\n────────────────────────────────────────────────── VESA/SVGA BIOS Functions\n INT 10H 4f00H - Query SuperVGA Support\n INT 10H 4f01H - Query SuperVGA Mode Information\n INT 10H 4f02H - Set SuperVGA Video Mode\n INT 10H 4f03H - Query Current SuperVGA Video Mode\n INT 10H 4f04H - Save/Restore SuperVGA State\n INT 10H 4f05H - Query/Set SuperVGA Video Memory Window\n\n INT 11H: Equipment Check\n INT 12H: Conventional Memory Size\n──────────────────────────────────────────────────── INT 13H: BIOS Disk I/O\n INT 13H 00H: Reset Drive\n INT 13H 01H: Query Disk Error Status\n INT 13H 02H: Read Sectors\n INT 13H 03H: Write Sectors\n INT 13H 04H: Verify Sectors\n INT 13H 05H: Format Track\n INT 13H 08H: Get Drive Parameters\n INT 13H 09H: Initialize Drive Parameter Table\n INT 13H 0aH: Read Sector Plus ECC\n INT 13H 0bH: Write Sector Plus ECC\n INT 13H 0cH: Seek Cylinder\n INT 13H 0dH: Alternate Reset Drive\n INT 13H 10H: Test Drive Ready\n INT 13H 11H: Recalibrate Drive\n INT 13H 14H: Controller Self-Test\n INT 13H 15H: Get Diskette Type or Check Hard Drive Installed\n INT 13H 16H: Detect Media Change\n INT 13H 17H: Set Media Transfer Rate\n INT 13H 18H: Set Media Type for Format\n────────────────────────────────────────────────── INT 14H: Serial Port I/O\n INT 14H 00H: Initialize Asynchronous Communication Port\n INT 14H 01H: Send a Character\n INT 14H 02H: Receive a Character\n INT 14H 03H: Query Serial Port Status\n─────────────────────────────────────── INT 15H: AT Extended Services / APM\n INT 15H 4fH: Keyboard Intercept\n INT 15H 80H: Device Open\n INT 15H 81H: Device Close\n INT 15H 82H: Program Termination\n INT 15H 8300H: Set Event Wait Interval\n INT 15H 8301H: Cancel Event Wait Interval\n INT 15H 84H: Joystick Support\n INT 15H 85H: SysReq Key\n INT 15H 86H: Wait\n INT 15H 87H: Move Memory Block\n INT 15H 88H: Get Extended Memory Size\n INT 15H 89H: Switch to Protected mode\n INT 15H 90H: Device Busy\n INT 15H 91H: Interrupt Finished\n INT 15H c0H: Get System Parameters\n────────────────────────────────────────────────────── Power Management API\n INT 15H 5300H: Installation Check\n INT 15H 5301H: Interface Connect\n INT 15H 5302H: Interface Connect (Prot. Mode/16-bit)\n INT 15H 5303H: Interface Connect (Prot. Mode/32-bit)\n INT 15H 5304H: Interface Disconnect\n INT 15H 5305H: CPU Idle\n INT 15H 5306H: CPU Busy\n INT 15H 5307H: Set Power State\n INT 15H 5308H: Enable/Disable Power Management\n INT 15H 5309H: Restore System-BIOS Power-On Defaults\n INT 15H 530aH: Query Power Status\n INT 15H 530bH: Get Power Management Event\n──────────────────────────────────────────────── INT 16H: Keyboard Services\n INT 16H 00H: Read (Wait for) Next Keystroke\n INT 16H 01H: Query Keyboard Status / Preview Key\n INT 16H 02H: Query Keyboard Shift Status\n INT 16H 03H: Set Keyboard Typematic Rate and Delay\n INT 16H 05H: Store Keystroke Data\n INT 16H 10H: Read Extended Keyboard Input\n INT 16H 11H: Query Extended Keyboard Status / Preview Key\n INT 16H 12H: Query Extended Keyboard Shift Status\n────────────────────────────────────────────────── INT 17H: Printer Support\n INT 17H 00H: Print One Character\n INT 17H 01H: Initialize Printer Port\n INT 17H 02H: Query Printer Status\n\n INT 18H: ROM-BASIC\n INT 19H: Bootstrap Loader\n─────────────────────────────────── INT 1aH: Timer I/O (and MRCI POST Hook)\n INT 1aH 00H: Read System Clock (Ticks)\n INT 1aH 01H: Set System Clock (Ticks)\n INT 1aH 02H: Read Time from Real-Time Clock\n INT 1aH 03H: Set Time on Real-Time Clock\n INT 1aH 04H: Read Date from Real-Time Clock\n INT 1aH 05H: Set Date on Real-Time Clock\n INT 1aH 06H: Set Real-Time Clock Alarm\n INT 1aH 07H: Cancel Real-Time Clock Alarm\n\n INT 1aH b001H: Query ROM/Hardware-Based MRCI Support\n\n INT 1bH: Keyboard Break\n INT 1cH: User Timer Interrupt\n INT 1dH: Video Initialization Table Pointer\n INT 1eH: Diskette Parameter Pointer\n INT 1fH: CGA Graphics Character Font Pointer\n\n INT 20H: Program Terminate\n──────────────────────────────────────────────────── INT 21H: DOS Functions\n DOS Fn 00H: Terminate a Program\n DOS Fns 01H-0cH: Low-level I/O\n DOS Fn 01H: Keyboard Input\n DOS Fn 02H: Display Output\n DOS Fn 03H: Auxiliary Input\n DOS Fn 04H: Auxiliary Output\n DOS Fn 05H: Printer Output\n DOS Fn 06H: Console I/O\n DOS Fn 07H: No Echo Unfiltered Console Input\n DOS Fn 08H: No Echo Console Input\n DOS Fn 09H: Display String\n DOS Fn 0aH: Buffered String Input\n DOS Fn 0bH: Check Input Status\n DOS Fn 0cH: Clear & Input\n DOS Fn 0dH: Reset Disk\n DOS Fn 0eH: Select DOS Default Disk\n DOS Fn 0fH: Open File via FCB\n DOS Fn 10H: Close File via FCB\n DOS Fn 11H: Find 1st Matching File via FCB\n DOS Fn 12H: Find Next Matching File via FCB\n DOS Fn 13H: Delete File via FCB\n DOS Fn 14H: Read Sequential File via FCB\n DOS Fn 15H: Write Sequential File via FCB\n DOS Fn 16H: Create File via FCB\n DOS Fn 17H: Rename File via FCB\n DOS Fn 19H: Query DOS Default Disk\n DOS Fn 1aH: Set Disk Transfer Address (DTA)\n DOS Fn 1bH: Get Drive Info (current disk)\n DOS Fn 1cH: Get Drive Info (any disk)\n DOS Fn 1fH: Get Drive Parameter Block (current disk)\n DOS Fn 21H: Read Random File Record\n DOS Fn 22H: Write Random File Record\n DOS Fn 23H: Query File Size via FCB\n DOS Fn 24H: Set Random File Block Address\n DOS Fn 25H: Set Interrupt Vector\n DOS Fn 26H: Create Program Segment Prefix\n DOS Fn 27H: Read Random File Block\n DOS Fn 28H: Write Random File Block\n DOS Fn 29H: Parse Filename\n DOS Fn 2aH: Query DOS Date\n DOS Fn 2bH: Set DOS Date\n DOS Fn 2cH: Query DOS Time\n DOS Fn 2dH: Set DOS Time\n DOS Fn 2eH: Set/Reset Verify Switch\n DOS Fn 2fH: Query Disk Transfer Address (DTA)\n DOS Fn 30H: Get DOS Version Number\n DOS Fn 31H: Terminate & Stay Resident\n DOS Fn 32H: Get DPB (Drive Parameter Block)\n DOS Fn 33H: Set/Query Break-check; Query DOS Info\n DOS Fn 3300H: Query Break-Check Flag\n DOS Fn 3301H: Set Break-check level\n DOS Fn 3305H: Get Boot Drive\n DOS Fn 3306H: Get DOS Version Info\n DOS Fn 34H: Get InDOS Address (DOS Reentrancy Status)\n DOS Fn 35H: Get Interrupt Vector\n DOS Fn 36H: Get Disk Free Space\n DOS Fn 37H: Set or Query Switch Character\n DOS Fn 3700H: Query Switchar\n DOS Fn 3701H: Set Switchar\n DOS Fn 38H: Get/Set Country-dependent Info\n DOS Fn 39H: Create a New Directory -- MKDIR\n DOS Fn 3aH: Delete a Directory -- RMDIR\n DOS Fn 3bH: Set DOS Default Directory -- CHDIR\n DOS Fn 3cH: Create a File via Handle\n DOS Fn 3dH: Open a File via Handle\n DOS Fn 3eH: Close a File Handle\n DOS Fn 3fH: Read from File via Handle\n DOS Fn 40H: Write to File via Handle\n DOS Fn 41H: Delete File\n DOS Fn 42H: Set File Pointer\n DOS Fn 43H: Set or Query File attributes\n DOS Fn 4300H: Query File Attribute\n DOS Fn 4301H: Set File Attribute\n DOS Fn 44H: Device I/O Control -- IOCTL\n DOS Fn 4400H: IOCTL Query Device/File Flags\n DOS Fn 4401H: IOCTL Set Device/File Flags\n DOS Fn 4402H: IOCTL Receive Control Data from Char Device\n DOS Fn 4403H: IOCTL Send Control Data to Character Device\n DOS Fn 4404H: IOCTL Receive Control Data from Block Device\n DoubleSpace IOCTL fn 'F': Flush DoubleSpace Cache\n DoubleSpace IOCTL fn 'I': Flush and Invalidate Cache\n DoubleSpace IOCTL fn 'S': Get DriveSpace Pointers\n DOS Fn 4405H: IOCTL Send Control Data to Block Device\n DOS Fn 4406H: IOCTL Query Handle Input Status\n DOS Fn 4407H: IOCTL Query Handle Output Status\n DOS Fn 4408H: IOCTL Does Drive Use Removable Media\n DOS Fn 4409H: IOCTL Is Drive Remote or SUBST\n DOS Fn 440aH: IOCTL Is File/Device Remote\n DOS Fn 440bH: IOCTL Set Sharing Retry Count\n DOS Fn 440cH: Generic I/O Control -- Character Devices\n DOS Fn 440cH CL=45H: IOCTL Set Retry Iteration Count\n DOS Fn 440cH CL=4AH: IOCTL Select Code Page\n DOS Fn 440cH CL=4CH: IOCTL Start Code Page Prepare\n DOS Fn 440cH CL=4DH: IOCTL End Code Page Prepare\n DOS Fn 440cH CL=5Fh: IOCTL Set Display Mode\n DOS Fn 440cH CL=65H: IOCTL Query Retry Iteration Count\n DOS Fn 440cH CL=6AH: IOCTL Query Current Code Page\n DOS Fn 440cH CL=6BH: IOCTL Query Code Page List\n DOS Fn 440cH CL=7Fh: IOCTL Query Display Mode\n DOS Fn 440dH: Generic I/O Control -- Block Devices\n DOS Fn 440dH CL=40H: IOCTL Set Device Parameters\n DOS Fn 440dH CL=41H: IOCTL Write Track on Logical Drive\n DOS Fn 440dH CL=42H: IOCTL Format Track on Logical Drive\n DOS Fn 440dH CL=46H: IOCTL Set Media ID\n DOS Fn 440dH CL=47H: IOCTL Set Access Flag\n DOS Fn 440dH CL=60H: IOCTL Query Device Parameters\n DOS Fn 440dH CL=61H: IOCTL Read Track on Logical Drive\n DOS Fn 440dH CL=62H: IOCTL Verify Track on Logical Drive\n DOS Fn 440dH CL=66H: IOCTL Query Media ID\n DOS Fn 440dH CL=67H: IOCTL Query Access Flag\n DOS Fn 440dH CL=68H: IOCTL Sense Media Type\n DOS Fn 440eH: IOCTL Query Logical Drive Map\n DOS Fn 440fH: IOCTL Set Logical Drive Map\n DOS Fn 4410H: IOCTL Query IOCTL Support for Handle\n DOS Fn 4411H: IOCTL Query IOCTL Support for Device\n DOS Fn 45H: Duplicate a File Handle\n DOS Fn 46H: Redirect a Handle\n DOS Fn 47H: Query Default Directory\n DOS Fn 48H: Allocate Memory / Query Free Memory\n DOS Fn 49H: Free Allocated Memory Block\n DOS Fn 4aH: Shrink or Expand a Memory Block\n DOS Fn 4bH: Load or Execute a program\n DOS Fn 4b00H: Execute a Program\n DOS Fn 4b01H: Load Program\n DOS Fn 4b03H: Load Overlay\n DOS Fn 4b05H: Set Execution State\n DOS Fn 4cH: Terminate Program\n DOS Fn 4dH: Get Program Exit Code\n DOS Fn 4eH: Find 1st Matching File\n DOS Fn 4fH: Find Next Matching File\n DOS Fn 50H: Set PSP\n DOS Fn 51H: Query Current PSP\n DOS Fn 52H: Get DOS Variables\n DOS Fn 53H: Convert BPB to DPB\n DOS Fn 54H: Get DOS Verify State\n DOS Fn 56H: Rename/Move a File\n DOS Fn 57H: Set or Query File Time/Date\n DOS Fn 5700H: Query File Time/Date\n DOS Fn 5701H: Set File Time/Date\n DOS Fn 58H: Set or Query Memory Allocation Options\n DOS Fn 5800H: Query Memory Allocation Strategy\n DOS Fn 5801H: Set Memory Allocation Strategy\n DOS Fn 5802H: Query Upper-Memory Link State\n DOS Fn 5803H: Set Upper-Memory Link State\n DOS Fn 59H: Get Extended Error Info\n DOS Fn 5aH: Create Unique Temporary File\n DOS Fn 5bH: Create New File\n DOS Fn 5cH: Lock/Unlock File Access\n DOS Fn 5c00H: Lock File Access\n DOS Fn 5c01H: Unlock File Access\n DOS Fn 5d0aH: Set Extended Error\n DOS Fn 5eH: Network Miscellaneous\n DOS Fn 5e00H: Query Network Node Name\n DOS Fn 5e02H: Set Network Printer Setup\n DOS Fn 5e03H: Query Network Printer Setup\n DOS Fn 5fH: Network Device Redirection\n DOS Fn 5f02H: Network Query Assign-List Entry\n DOS Fn 5f03H: Make Network Connection\n DOS Fn 5f04H: Delete Network Connection\n DOS Fn 60H: Query TrueName\n DOS Fn 62H: Query Current PSP\n DOS Fn 65H: Extended Country Information Functions\n DOS Fn 6501H: Get Extended Country Information\n DOS Fn 6504H: Get Uppercase Table\n DOS Fn 6505H: Get Filename Character Table\n DOS Fn 6506H: Get Collating Sequence Table\n DOS Fn 6507H: Get Double-Byte Character Set\n DOS Fn 6520H: Upshift Character\n DOS Fn 6521H: Upshift String\n DOS Fn 6522H: Upshift ASCIIZ String\n DOS Fn 66H: Set or Query Active Code Page\n DOS Fn 6601H: Query Active Code Page\n DOS Fn 6602H: Activate Code Page\n DOS Fn 67H: Set File Handle Count\n DOS Fn 68H: Commit File\n DOS Fn 6cH: Extended Open/Create\n──────────────────────────────────────────────────── Device Driver Requests\n Device Request 00H: Initialize device\n Device Request 01H: Media Check\n Device Request 02H: Build BPB\n Device Request 03H: IOCTL Input\n Device Request 04H: Input (Read Data from Device)\n Device Request 05H: Non-destructive Input\n Device Request 06H: Input Status\n Device Request 07H: Input Flush\n Device Request 08H: Output (Write Data to Device)\n Device Request 09H: Output (Write/Verify Data to Device)\n Device Request 0aH: Output Status\n Device Request 0bH: Output Flush\n Device Request 0cH: IOCTL Output\n Device Request 0dH: Device Open\n Device Request 0eH: Device Close\n Device Request 0fH: Removable Media\n Device Request 10H: Output Until Busy\n Device Request 13H: Generic IOCTL Request\n Device Request 17H: Get Logical Device\n Device Request 18H: Set Logical Device\n Device Request 19H: IOCTL Support Query\n\n INT 22H: Terminate Address\n INT 23H: Ctrl-Break Exit Address\n INT 24H: Critical Error Handler\n INT 25H/26H: Absolute Disk Read/Write\n INT 27H: Terminate but Stay Resident\n INT 28H: DOS Idle\n INT 29H: Fast PUTCHAR\n INT 2aH: Microsoft Network Services\n INT 2eH: Perform DOS Command\n────────────────────────────────────────────── INT 2fH: Multiplex Interrupt\n INT 2fH 01xxH: DOS Print Spooler Functions\n INT 2fH 0100H: Is Print.Exe Installed?\n INT 2fH 0101H: Submit File to Spooler\n INT 2fH 0102H: Remove File from Print Queue\n INT 2fH 0103H: Cancel All Files\n INT 2fH 0104H: Hold All Jobs and Get Status\n INT 2fH 0105H: Resume Printing\n INT 2fH 0106H: Get Printer Device Driver Header\n\n INT 2fH 0600H: Is Assign.Com Installed?\n\n INT 2fH 1000H: Is Share.Exe Installed?\n\n INT 2fH 1100H: Is Network Support Installed?\n\n INT 2fH 1400H: Is Nlsfunc.Exe Installed?\n\n INT 2fH 15xxH: Mscdex CD-ROM Functions\n INT 2fH 1500H: Is MSCDEX Installed?/Count Drive Letters\n INT 2fH 150dH: Query CD-ROM Drive Letters\n\n──────────────────── INT 2fH 16xxH: Enh386 Windows Services & Notifications\n INT 2fH 1600H: Is Enh386 Windows Installed?\n INT 2fH 1602H: Get Enh386 Windows Entry-Point Address\n INT 2fH 1605H: Windows Is About to Startup\n INT 2fH 1606H: Windows Is About to Terminate\n INT 2fH 1607H: Device Call Out\n INT 2fH 1608H: Windows Initialization is Complete\n INT 2fH 1609H: Windows is Terminating\n INT 2fH 1680H: Program Idle (Release Timeslice)\n INT 2fH 1681H: Begin Critical Section\n INT 2fH 1682H: End Critical Section\n INT 2fH 1683H: Get Current Virtual Machine ID\n INT 2fH 1684H: Get Device Entry-Point Address (for VxDs)\n INT 2fH 1685H: Switch VMs and CallBack\n INT 2fH 1686H: Detect INT 31h DPMI Services (see also: INT 31H, below)\n\n INT 2fH 1687H: Get Real-to-Protected Mode Switch Address (see INT 31H)\n INT 2fH 168AH: Get Vendor-Specific DPMI API Entry Address (see INT 31H)\n\n──────────────────────────────── INT 2fH 17xxH: Windows Clipboard Functions\n INT 2fH 1700H: Is Clipboard Available?\n INT 2fH 1701H: Get Access to Clipboard\n INT 2fH 1702H: Discard Clipboard Contents\n INT 2fH 1703H: Put Data into the Clipboard\n INT 2fH 1704H: Query Size of Clipboard Data\n INT 2fH 1705H: Copy Clipboard Data to Buffer\n INT 2fH 1708H: Release Control of the Clipboard\n INT 2fH 1709H: See if Data Will Fit in Clipboard\n INT 2fH 170aH: Obtain Device Capabilities\n\n INT 2fH 1a00H: Is ANSI.SYS Installed?\n\n─────────────────────────── INT 2fH 40xxH: Virtual Display Driver Functions\n INT 2fH 4000H: Enable VM-Assisted Video Save/Restore\n INT 2fH 4001H: Notify Background Switch\n INT 2fH 4002H: Notify Foreground Switch\n INT 2fH 4003H: Enter Critical Section\n INT 2fH 4004H: Exit Critical Section\n INT 2fH 4005H: Save Video Register State\n INT 2fH 4006H: Restore Video Register State\n INT 2fH 4007H: Disable VM-Assisted Video Save/Restore\n───────────────────────────────────────────────────────────── XMS Functions\n INT 2fH 4300H: Is HIMEM.SYS (XMS Support) Installed?\n INT 2fH 4310H: Get HIMEM.SYS (XMM) Entry Address\n XMS 00H: Get XMS Version Number\n XMS 01H: Request High Memory Area\n XMS 02H: Release High Memory Area\n XMS 03H: Global Enable A20\n XMS 04H: Global Disable A20\n XMS 05H: Local Enable A20\n XMS 06H: Local Disable A20\n XMS 07H: Query A20 State\n XMS 08H: Query Free Extended Memory\n XMS 09H: Allocate Extended Memory Block\n XMS 0aH: Free Extended Memory Block\n XMS 0bH: Move Extended Memory Block\n XMS 0cH: Lock Extended Memory Block\n XMS 0dH: Unlock Extended Memory Block\n XMS 0eH: Get Handle Information\n XMS 0fH: Resize Extended Memory Block\n XMS 10H: Request Upper Memory Block\n XMS 11H: Release Upper Memory Block\n\n─────────────────────────────────────── INT 2fH 48xxH: DOSKEY.COM Functions\n INT 2fH 4800H: Is DOSKEY.COM Installed?\n INT 2fH 4810H: Get Keyboard Input with Doskey Editing\n\n─────────────────────────────────────── INT 2fH 4axxH: HMA Suballocations\n INT 2fH 4a01H: Query HMA Free Space and Address\n INT 2fH 4a02H: Suballocate HMA Memory\n\n────────────────────────── Microsoft Real-time Compression Interface (MRCI)\n INT 2fH 4a12H: Get MRCI Installed State and Entry Address\n MRCI Fn 0001H: Compress Data\n MRCI Fn 0002H: Decompress Data\n MRCI Fn 0020H: Incrementally Decompress Data\n MRCI Fn ffffH: Deinstall Server\n\n─────────────────────────────────── INT 2fH 4a11H: DoubleSpace API Services\n INT 2fH 4a11H BX=0000H: Get Dblspace Version & Drives\n INT 2fH 4a11H BX=0001H: Get Dblspace Drive Mapping\n INT 2fH 4a11H BX=0002H: Dblspace Swap Drive\n INT 2fH 4a11H BX=0005H: Mount Dblspace Drive\n INT 2fH 4a11H BX=0006H: Unmount Dblspace Drive\n INT 2fH 4a11H BX=0007H: Get Dblspace Disk Size / Free Space\n INT 2fH 4a11H BX=0008H: Get CVF Fragmentation Info\n INT 2fH 4a11H BX=0009H: Get Count of DISK_UNIT Structures\n INT 2fH 4a11H BX=000aH: Set Automount Drives\n INT 2fH 4a11H BX=000bH: Query Automount Drives\n\n────────────────────────────────────────────────────────────── Switcher API\n INT 2fH 4BxxH: Task Switcher Functions\n INT 2fH 4B01H: Build Notification Chain\n INT 2fH 4B02H: Is Switcher Installed? / Get Service Addr\n INT 2fH 4B03H: Allocate Switcher ID\n INT 2fH 4B04H: Free Switcher ID\n INT 2fH 4B05H: Identify Instance Data\n SwNtfy Fn 0000H: A Switcher Is Being Initialized\n SwNtfy Fn 0001H: Can Switcher Suspend Your Session?\n SwNtfy Fn 0002H: Switcher Is Suspending Your Session\n SwNtfy Fn 0003H: Switcher Is Activating Your Session\n SwNtfy Fn 0004H: Session Is Now Active\n SwNtfy Fn 0005H: Switcher Is Creating a Session\n SwNtfy Fn 0006H: Switcher Is Destroying a Session\n SwNtfy Fn 0007H: Switcher Is Exiting\n SwSrvc Fn 0000H: Get Switcher Version\n SwSrvc Fn 0001H: Test Memory Region\n SwSrvc Fn 0002H: Suspend Switcher\n SwSrvc Fn 0003H: Resume Switcher\n SwSrvc Fn 0004H: Hook Notification Chain\n SwSrvc Fn 0005H: Unhook Notification Chain\n SwSrvc Fn 0006H: Query API Support\n\n───────────────────────────────────────── INT 2fH adxxH: KEYB.COM Functions\n INT 2fH ad80H: Is KEYB.COM Installed? / Get Version\n INT 2fH ad81H: Set KEYB.COM Active Code Page\n INT 2fH ad82H: Set KEYB.COM Country Flag\n INT 2fH ad83H: Query KEYB.COM Country Flag\n\n──────────────────────── INT 2fH aexxH: Command Processor Command-Line Hook\n INT 2fH ae00H: Notify Pending Command\n INT 2fH ae01H: Process Hooked Command\n\n INT 2fH b000H: Is GRAFTABL.COM Installed?\n\n─────────────────────────────────────── INT 2fH b7xxH: APPEND.EXE Functions\n INT 2fH b700H: Is APPEND.EXE Installed?\n INT 2fH b702H: Get APPEND.EXE Version\n INT 2fH b704H: Get APPEND.EXE Path String\n INT 2fH b706H: Query APPEND.EXE Option Settings\n INT 2fH b707H: Set APPEND.EXE Options / Disable APPEND\n INT 2fH b711H: Set APPEND.EXE Truename Flag\n\n INT 2fH xxfbH: FaxBIOS Functions\n───────────────────────────────────────────────────────────── DPMI Services\n INT 2fH 1687H: Get Real-to-Protected Mode Switch Address\n INT 2fH 168AH: Get Vendor-Specific DPMI API Entry Address\n\n INT 31H 0000H: Allocate LDT Descriptors\n INT 31H 0001H: Free LDT Descriptor\n INT 31H 0002H: Segment to Descriptor\n INT 31H 0003H: Query Selector Increment Value\n INT 31H 0006H: Query Segment Base Address\n INT 31H 0007H: Set Segment Base Address\n INT 31H 0008H: Set Segment Limit\n INT 31H 0009H: Set Descriptor Access Rights\n INT 31H 000aH: Create Alias Descriptor\n INT 31H 000bH: Query Descriptor\n INT 31H 000cH: Set Descriptor\n INT 31H 000dH: Allocate Specific Descriptor\n INT 31H 000eH: Query Multiple Descriptors\n INT 31H 000fH: Set Multiple Descriptors\n INT 31H 0100H: Allocate DOS Memory Block\n INT 31H 0101H: Free DOS Memory Block\n INT 31H 0102H: Resize DOS Memory Block\n INT 31H 0200H: Query Real-mode Interrupt Vector\n INT 31H 0201H: Set Real-mode Interrupt Vector\n INT 31H 0202H: Query Processor Exception Handler Vector\n INT 31H 0203H: Set Processor Exception Handler Vector\n INT 31H 0204H: Query Protected-Mode Interrupt Vector\n INT 31H 0205H: Set Protected-mode Interrupt Vector\n INT 31H 0210H: Query Exception Handler Vector (Prot. Mode)\n INT 31H 0211H: Query Exception Handler Vector (Real Mode)\n INT 31H 0212H: Set Exception Handler Vector (Prot. Mode)\n INT 31H 0213H: Set Exception Handler Vector (Real Mode)\n INT 31H 0300H: Simulate Real Mode Interrupt\n INT 31H 0301H: Simulate Real Mode FAR CALL\n INT 31H 0302H: Simulate Real Mode CALL for IRET\n INT 31H 0303H: Allocate Real-mode Callback Address\n INT 31H 0304H: Free Real-mode Callback Address\n INT 31H 0305H: Query State Save/Restore Addresses\n INT 31H 0306H: Query Raw Mode-Switch Address\n INT 31H 0400H: Query DPMI Version\n INT 31H 0401H: Query DPMI Capabilities\n INT 31H 0500H: Query Free Memory Information\n INT 31H 0501H: Allocate Memory Block\n INT 31H 0502H: Free Memory Block\n INT 31H 0503H: Resize Memory Block\n INT 31H 0504H: Allocate Linear Memory Block\n INT 31H 0505H: Resize Linear Memory Block\n INT 31H 0506H: Query Page Attributes\n INT 31H 0507H: Set Page Attributes\n INT 31H 0508H: Map Device in Memory Block\n INT 31H 0509H: Map Conventional Memory in Memory Block\n INT 31H 050aH: Query Memory Block Size and Base\n INT 31H 050bH: Query Memory Information\n INT 31H 0600H: Lock Linear Region\n INT 31H 0601H: Unlock Linear Region\n INT 31H 0602H: Mark Real-Mode Region as Pageable\n INT 31H 0603H: Relock Real-Mode Region\n INT 31H 0604H: Query Page Size\n INT 31H 0700H: Mark Page as Demand-Paging Candidate\n INT 31H 0701H: Discard Page Contents\n INT 31H 0800H: Physical Address Mapping\n INT 31H 0801H: Free Physical Address Mapping\n INT 31H 0900H: Query and Disable Virtual Interrupt State\n INT 31H 0901H: Query and Disable Virtual Interrupt State\n INT 31H 0902H: Query Virtual Interrupt State\n INT 31H 0a00H: Get Vendor-Specific API Entry Address\n INT 31H 0b00H: Set Debug Watchpoint\n INT 31H 0b01H: Clear Debug Watchpoint\n INT 31H 0b02H: Query State of Debug Watchpoint\n INT 31H 0b03H: Reset Debug Watchpoint\n INT 31H 0c00H: Setup DPMI TSR Callback\n INT 31H 0c01H: Protected-Mode Terminate and Stay Resident\n INT 31H 0d00H: Allocate Shared Memory\n INT 31H 0d01H: Free Shared Memory\n INT 31H 0d02H: Serialize on Shared Memory\n INT 31H 0d03H: Free Serialization on Shared Memory\n INT 31H 0e00H: Query Coprocessor Status\n INT 31H 0e01H: Set Coprocessor Emulation\n─────────────────────────────────────────────────────INT 33H: Mouse Support\n INT 33H 0000H: Reset/Query Installed State\n INT 33H 0001H: Show Mouse Pointer\n INT 33H 0002H: Hide Mouse Pointer\n INT 33H 0003H: Query Position / Button Status\n INT 33H 0004H: Set Mouse Pointer Position\n INT 33H 0005H: Query Button-Pressed Counter\n INT 33H 0006H: Query Button-Released Counter\n INT 33H 0007H: Set Horizontal Range\n INT 33H 0008H: Set Vertical Range\n INT 33H 0009H: Set Graphics Pointer Shape\n INT 33H 000aH: Set Text Pointer Mask\n INT 33H 000bH: Query Motion Distance\n INT 33H 000cH: Set Mouse Event Handler\n INT 33H 000dH: Enable Lightpen Emulation\n INT 33H 000eH: Disable Lightpen Emulation\n INT 33H 000fH: Set Pointer Speed\n INT 33H 0010H: Set Exclusion Area\n INT 33H 0013H: Set Speed-Doubling Threshold\n INT 33H 0014H: Exchange Mouse Event Handler\n INT 33H 0015H: Query Size of Mouse Status Buffer\n INT 33H 0016H: Save Mouse Status\n INT 33H 0017H: Restore Mouse Status\n INT 33H 0018H: Set Alternate Event Handler\n INT 33H 0019H: Query User Alternate Event Handler\n INT 33H 001aH: Set Mouse Sensitivity\n INT 33H 001bH: Query Mouse Sensitivity\n INT 33H 001cH: Set Inport Mouse Interrupt Rate\n INT 33H 001dH: Set Mouse Display Page\n INT 33H 001eH: Query Mouse Display Page\n INT 33H 001fH: Deactivate Mouse Driver\n INT 33H 0020H: Reenable Mouse Driver\n INT 33H 0021H: Reset Mouse Driver\n INT 33H 0024H: Query Mouse Type/Driver Version/IRQ#\n\n INT 40H: Diskette BIOS Revector\n INT 41H and INT 46H: Hard Disk Parameter Pointers\n INT 43H: EGA/VGA Graphics Character Font Pointer\n INT 4aH: User Alarm Handler\n───────────────────────────────────────────────────────────── EMM Functions\n INT 67H 4000H: Get EMM Status\n INT 67H 4100H: Get Frame Segment Address\n INT 67H 4200H: Get EMS Memory Total / Available\n INT 67H 4300H: Open EMM Handle and Allocate Memory\n INT 67H 44xxH: Map Memory into Page Frame\n INT 67H 4500H: Close EMM Handle and Free Memory\n INT 67H 4600H: Get EMM Version Number\n INT 67H 4700H: Save Mapping Context\n INT 67H 4800H: Restore Mapping Context\n INT 67H 4b00H: Count Handle's Pages\n INT 67H 4c00H: Count Active Handles\n INT 67H 4d00H: Get Page Information For All Handles\n INT 67H 4exxH: Get/Set Entire Page Map\n INT 67H 4fxxH: Get/Set Partial Page Map\n INT 67H 50xxH: Map/Unmap Multiple Pages\n INT 67H 5100H: Resize EMS Handle\n INT 67H 52xxH: Get/Set Handle Attribute\n INT 67H 53xxH: Get/Set Handle Name\n INT 67H 54xxH: Find Named Handle\n INT 67H 55xxH: Alter Page Map and JMP\n INT 67H 56xxH: Alter Page Map and CALL\n INT 67H 57xxH: Move/Exchange Memory\n INT 67H 58xxH: Get Mappable Physical Address Array\n INT 67H 59xxH: Get Hardware Configuration\n INT 67H 5axxH: Allocate Standard or Raw Pages\n INT 67H 5bxxH: Alternate Map Register Set\n INT 67H 5c00H: Prepare for warm boot\n INT 67H 5dxxH: Enable/Disable OS Function Set Functions\n\n INT 70H: Real-Time Clock Interrupt Handler\n\nSee Also: API Index\n DOS Fns QuickRef by Number by DOS Version Obsolete Fns\n DOS Interrupts\n Service Groups\n General Index\n -♦-"
  },
  {
    "id": "28-dos___bios_data_structures.html",
    "t": "DOS & BIOS Data Structures",
    "b": "About Structures\n┌─ DOS - File System ───────┐┌─ DOS - Other ───────────┐┌─ Dblspace/MRCI ──┐\n│BPB: BIOS Parameter Block ││ListOfLists (undoc'ed) ││CVF Layout │\n│CDS: Current Directories ││MCB: Memory Control Block││MDBPB │\n│DPB: Drive Parameter Block ││PSP: Prgrm Segment Prefix││BitFAT │\n│DTA: Disk Transfer Address ││ ││MDFAT │\n│FAT: File Allocation Table ││Environment Layout ││BootSect │\n│FCB: File Control Block ││Predefined E-vars ││FAT │\n│ ││ ││RootDir │\n│AbsDiskIORec ││ExecParamRec ││Sector Heap │\n│Boot Sector Layout ││ExecStateRec ││\"MD Stamps\" │\n│Directory Entry Layout ││ExecOverlayRec ││ │\n│Disk Partition Table ││ExecLoadRec ││Mapping FAT═►MDFAT│\n│Extended DOS Partition ││EXE File Header ││DBLSPACE.INI │\n│FileInfoRec ││ ││ │\n│Media Descriptor ││Error Codes ErrorMode ││MRCInfoRec │\n│ ││ErrorInfoRec InDOS Flag ││MRCRequestRec │\n│File Access Mode │└─────────────────────────┘└──────────────────┘\n│File Attribute │┌─ BIOS - General ────────────────────────────┐\n│File Handle ││BIOS Data Area CMOS Memory │\n│File Time/Date Format ││General Memory Map Equipment List │\n└───────────────────────────┘│ROM-Scan Switch Settings │\n┌─ Device Drivers & IOCTL ──┐└─────────────────────────────────────────────┘\n│Device Header Layout │┌─ BIOS - Video ──────────────────────────────┐\n│Device Attribute ││Video Modes SVGA Video Modes │\n│Device Request Header ││Video Attributes SVGA Info Block │\n│Device Status Word ││Video Font Definition SVGA Mode Info │\n│ ││Video Memory Layouts │\n│IOCTL Device Info ││Color Table │\n│IoctlDriveInfoRec ││ │\n│IoctlHandleInfoRec ││EGA/VGA Data Areas │\n│ ││VgaDynamicStateRec EgaDynamicSaveRec │\n│Generic IOCTL Data Packets ││VgaStaticFnalityRec EgaGfxFontRec │\n│IoctlCpIdRec ││VgaDccRec EgaMiscInfoRec │\n│IoctlCpListRec ││VgaFlagsRec EgaSavePtrRec │\n│IoctlCpPrepRec ││VgaPaletteProfileRec EgaTxtFontRec │\n│IoctlDisplayModeRec ││VgaSavePtr2Rec EgaVidParmsRec │\n│IoctlDeviceParmsRec ││ │\n│IoctlFmtVrfyTrackRec ││VidInitRec │\n│IoctlMediaIdRec │└─────────────────────────────────────────────┘\n│IoctlRdWrtTrackRec │┌─ BIOS - Keyboard ───────────────────────────┐\n│TrackLayoutRec ││Extended ASCII Keystrokes ASCII Table │\n│ ││Keyboard Scan Codes Control Codes │\n│CLOCK$ I/O Structure ││Shift-Key Status Flags │\n└───────────────────────────┘└─────────────────────────────────────────────┘\n┌─ National Language ───────┐┌─ BIOS - Disk ───────────────────────────────┐\n│Country Codes ││Diskette Parameter Table Master Boot Record│\n│Code Page ││Hard Disk Parameter Table Hard Disk Types │\n│Code Page Font Files │└─────────────────────────────────────────────┘\n│Country ID Codes │┌─ Error Codes ───────────────────────────────┐\n│Country Info Block ││APM API Error Codes DPMI Error Codes │\n│Extended Country Info ││BIOS COM status codes EMM Status │\n└───────────────────────────┘│BIOS disk error codes MRCI Error Codes │\n┌─ DOS Shell/Task Switcher ─┐│BIOS Printer Status Flags XMS Error Codes │\n│SwApiInfoRec ││Device Driver Errors │\n│SwCallbackInfoRec ││DOS Error Codes POST Error Codes │\n│SwStartupInfoRec ││DoubleSpace Error Codes │\n│SwInstanceItemRec │└─────────────────────────────────────────────┘\n│SwVersionRec │\n└───────────────────────────┘\nSee Also: BIOS Data Area\n General Memory Map\n Cables and Pin Outs\n General Index\n -♦-"
  },
  {
    "id": "29-advance_power_management__apm__functions.html",
    "t": "Advance Power Management (APM) Functions",
    "b": "The Intel/Microsoft APM specification provides a system that allows\n computers (especially laptops) to conserve electricity.\n\n See About Advanced Power Management for background information.\n\n The APM specification defines the following functions:\n │Connection\n ─────────────── Interface Connect Services │needed?\n INT 15H 5300H Installation check │ No\n │\n INT 15H 5301H Interface Connect │ No\n INT 15H 5302H Interface Connect (Protected Mode/16-bit) │ No\n INT 15H 5303H Interface Connect (Protected Mode/32-bit) │ No\n INT 15H 5304H Interface Disconnect │ Yes\n ─────────────── CPU Control Services │\n INT 15H 5305H CPU Idle │ Yes\n INT 15H 5306H CPU Busy │ Yes\n INT 15H 5307H Set Power State │ Yes\n ─────────────── Status/Control Services │\n INT 15H 5308H Enable/Disable APM Functionality │ Yes\n INT 15H 5309H Restore APM BIOS Defaults │ No\n INT 15H 530aH Query Status │ No\n ─────────────── Power Management Event Notification │\n INT 15H 530bH Get Power Management Event │ Yes\n\nSee Also: About APM\n INT 15H (AT Extended Services)\n -♦-"
  },
  {
    "id": "30-about_advanced_power_management.html",
    "t": "About Advanced Power Management",
    "b": "As laptop computers gain in popularity the need to extend battery life has\n become acute. And as people become more environmentally aware, we are\n seeing a greater need to conserve electricity, even on desktop models.\n\n Laptop makers have been using power-management techniques for some years,\n but it has been a haphazard affair, and there has been no way that an\n operating system or an application program can cooperate in reducing power\n consumption.\n\n In 1993, Intel and Microsoft announced the Advanced Power Management\n specification. It describes a standard interface that allows the system\n BIOS, the operating system, and applications to work together to save\n power.\n\n Here's how application programs can become power-aware:\n\n ■ Use INT 15H 5300H to see of APM services exist; if not forget it.\n ■ Use INT 15H 5301H to inform the BIOS that you are savvy.\n ■ Use INT 15H 5305H (CPU Idle) when you're waiting around for a\n keystroke or mouse click or other event.\n ■ Use INT 15H 530bH (Get APM Event) and take action when requested.\n\nSee Also: APM API\n INT 15H (AT Extended Services)\n -♦-"
  },
  {
    "id": "31-int_15h_5300h__installation_check.html",
    "t": "INT 15H 5300H: Installation Check",
    "b": "Expects: AX 5300H\n BX 0000H (power device ID = System BIOS)\n ──────────────────────────────────────────────────────────────────\n Returns: AH 86H = APM not installed (and CF=CY)\n APM major version number, in BCD (if CF=NC)\n AL APM minor version number, in BCD\n BX 504dH (BH='P' and BL='M')\n CX flags: bit 0: 1 = 16-bit protected-mode interface supported\n bit 1: 1 = 32-bit protected-mode interface supported\n bit 2: 1 = CPU Idle calls slow the CPU clock speed\n bit 3: 1 = BIOS power management is disabled\n 4-15: (reserved)\n ──────────────────────────────────────────────────────────────────\n Info: This function checks to see whether the BIOS supports APM and\n obtains the version of the APM spec that is supported.\n\n AX the version number is in BCD; e.g., 0312H is version 3.12\n\n BX See INT 15H 5305H (CPU Busy) for info on bit 3.\n\nSee Also: APM API\n About APM\n -♦-"
  },
  {
    "id": "32-int_15h_5301h__interface_connect.html",
    "t": "INT 15H 5301H: Interface Connect",
    "b": "Expects: AX 5301H\n BX 0000H (power device ID = System BIOS)\n ──────────────────────────────────────────────────────────────────\n Returns: AH APM error code (if CF=CY)\n ──────────────────────────────────────────────────────────────────\n Info: This function informs the BIOS that you intend to cooperate with\n the BIOS in power management. For instance, it announces that\n you will be making INT 15H 5305H (CPU Idle) and INT 15H 5306H\n (CPU Busy) and INT 15H 5307H (Set Power State) calls.\n\n This makes the connection for real-mode. See INT 15H 5302H or\n INT 15H 5303H for protected-mode connection.\n\n You must make a connection via this fn or before using most other\n APM API services. Before you make this call, the BIOS will\n supply its own default power management services; you would make\n a connection if you think you can do a better job of keeping\n track of power in some cases.\n\nSee Also: APM API\n About APM\n -♦-"
  },
  {
    "id": "33-int_15h_5302h__interface_connect__prot__mode_16_bit_.html",
    "t": "INT 15H 5302H: Interface Connect (Prot. Mode/16-bit)",
    "b": "Expects: AX 5302H\n BX 0000H (power device ID = System BIOS)\n ──────────────────────────────────────────────────────────────────\n Returns: AH APM error code (if CF=CY) else...\n AX:BX Protected mode entry address\n CX protected mode data segment\n ──────────────────────────────────────────────────────────────────\n Info: This function informs the BIOS that you intend to cooperate with\n the BIOS in power management while the CPU is in 16-bit protected\n mode. (see INT 15H 5301H for related info).\n\n AX:BX On return, this is a real-mode segment:offset address that can be\n used as the entry point for accessing APM services while the CPU\n is in 16-bit protected mode (see notes).\n\n CX On return, this is a real-mode segment of a data area that APM\n will use later on.\n\n Notes: On return, you must prepare selectors in either the LDT or GDT so\n that CS and DS will be valid while APM is operating. See\n DPMI API for info on preparing selectors.\n\n After making this connection (and preparing the selectors), you\n can access power management fns while in 16-bit protected mode by\n preparing AX (et al.) and issuing a FAR CALL to the address\n returned in AX:BX.\n\nSee Also: APM API\n About APM\n -♦-"
  },
  {
    "id": "34-int_15h_5303h__interface_connect__prot__mode_32_bit_.html",
    "t": "INT 15H 5303H: Interface Connect (Prot. Mode/32-bit)",
    "b": "Expects: AX 5303H\n BX 0000H (power device ID = System BIOS)\n ──────────────────────────────────────────────────────────────────\n Returns: AH APM error code (if CF=CY) else...\n AX protected mode 32-bit CS of entry address\n EBX protected mode 32-bit IP of entry address\n CX protected mode 16-bit code segment\n DX protected mode data segment\n ──────────────────────────────────────────────────────────────────\n Info: This function informs the BIOS that you intend to cooperate with\n the BIOS in power management while the CPU is in 32-bit protected\n mode. (see INT 15H 5301H for related info).\n\n AX:EBX On return, this is a real-mode segment:offset address that can be\n used as the entry point for accessing APM services while the CPU\n is in 32-bit protected mode (see notes).\n\n CX On return, this is a real-mode segment that APM will use as a\n code segment later on.\n\n DX On return, this is a real-mode segment that APM will use as a\n data segment later on.\n\n Notes: On return, you must prepare selectors in either the LDT or GDT so\n that CS and DS will be valid while APM is operating. See\n DPMI API for info on preparing selectors.\n\n After making this connection (and preparing the selectors), you\n can access power management fns while in 32-bit protected mode by\n preparing AX (et al.) and issuing a FAR CALL to the address\n returned in AX:BX.\n\nSee Also: APM API\n About APM\n -♦-"
  },
  {
    "id": "35-int_15h_5304h__interface_disconnect.html",
    "t": "INT 15H 5304H: Interface Disconnect",
    "b": "Expects: AX 5304H\n BX 0000H (power device ID = System BIOS)\n ──────────────────────────────────────────────────────────────────\n Returns: AH APM error code (if CF=CY)\n ──────────────────────────────────────────────────────────────────\n Info: This breaks a connection between an application and system BIOS\n made by a previous call to INT 15H 5301H, INT 15H 5302H, or\n INT 15H 5303H.\n\n This says, \"I no longer wish to help manage power.\"\n\n Notes: This restore the BIOS defaults for power management. However,\n timers and device enable/disable settings (such as made via\n INT 15H 5307H) will remain in effect.\n\nSee Also: APM API\n -♦-"
  },
  {
    "id": "36-int_15h_5305h__cpu_idle.html",
    "t": "INT 15H 5305H: CPU Idle",
    "b": "Expects: AX 5305H\n ──────────────────────────────────────────────────────────────────\n Returns: CY clear (always succeeds)\n ──────────────────────────────────────────────────────────────────\n Info: This function informs the BIOS that the system is currently idle\n and that processing should be suspended until the next system\n event (typically an interrupt) occurs. The BIOS may then take\n action such as issuing a HLT opcode or slowing or stopping the\n CPU clock.\n\n You may access this service via INT 15H or by using the APM entry\n address obtained via INT 15H 5302H or INT 15H 5303H (protected\n mode connect).\n\nSee Also: APM API\n About APM\n -♦-"
  },
  {
    "id": "37-int_15h_5306h__cpu_busy.html",
    "t": "INT 15H 5306H: CPU Busy",
    "b": "Expects: AX 5306H\n ──────────────────────────────────────────────────────────────────\n Returns: CY clear (always succeeds)\n ──────────────────────────────────────────────────────────────────\n Info: This function informs the BIOS that processing should continue at\n full speed.\n\n You may access this service via INT 15H or by using the APM entry\n address obtained via INT 15H 5302H or INT 15H 5303H (protected\n mode connect).\n\n The BIOS will usually be able to tell when it should switch back\n to full-speed operation, but it is possible that an interrupt has\n been hooked which keeps the BIOS uninformed. In that case, you\n may wish to use this call once or twice per second to tell the\n BIOS to keep the CPU awake.\n\nSee Also: APM API\n -♦-"
  },
  {
    "id": "38-int_15h_5307h__set_power_state.html",
    "t": "INT 15H 5307H: Set Power State",
    "b": "Expects: AX 5307H\n BX power device ID (0000H = entire system)\n CX desired state: 0000H = Ready (not supported for BX=0001H)\n 0001H = Stand-by\n 0002H = Suspend\n 0003H = Off (not supported for BX=0001H)\n else = (reserved)\n ──────────────────────────────────────────────────────────────────\n Returns: AH APM error code (if CF=CY)\n ──────────────────────────────────────────────────────────────────\n Info: This places a device or the system into a desired power-\n conservation state.\n\n You may access this service via INT 15H or by using the APM entry\n address obtained via INT 15H 5302H or INT 15H 5303H (protected\n mode connect).\n\n BX is a Power Device ID. For instance, 0100H is the display.\n\n CX options are:\n\n 0000H Ready - the system or device is fully powered and ready for\n action. This does not differentiate between active and idle\n states.\n\n You cannot specify a device ID of 0001H (all devices) with this\n setting.\n\n 0001H Stand-by - the system or device is in an intermediate state which\n attempts to conserve power while maintaining operational data and\n parameters. The BIOS automatically enters this state when the\n CPU is idle and no device activity has occurred within a machine-\n defined period or time. The system or device will remain in\n stand-by until a device raises an interrupt or any controlled\n device is accessed.\n\n 0002H Suspend - the system or device is at its lowest level of\n operation which still maintains operational data and parameters.\n Computations are halted. Resumption of activity will not occur\n until signaled by an external event such as a button press, timer\n alarm, etc.\n\n 0003H Off - the system or device is powered-down and inactive.\n Operational data and parameters may or may not be preserved.\n\n You cannot specify a device ID of 0001H (all devices) with this\n setting.\n\n Notes: Two combinations of BX and CX have important meanings:\n\n ■ BX=0001H and CX=0001H\n specifies to put the entire system into stand-by mode.\n\n ■ BX=0001H and CX=0002H\n specifies to put the entire system into suspend mode. In this\n case, the call does not return until an external event re-\n awakens the BIOS.\n\n These two options are normally used after a Notification Event\n (see INT 15H 530bH) tells you that the system is about to go into\n stand-by or suspend mode. However, an application can initiate\n this if it detects some idle time.\n\nSee Also: APM API\n -♦-"
  },
  {
    "id": "39-int_15h_5308h__enable_disable_power_management.html",
    "t": "INT 15H 5308H: Enable/Disable Power Management",
    "b": "Expects: AX 5308H\n BX ffffH\n CX request code: 0000H=disable power management\n 0001H=enable power management\n ──────────────────────────────────────────────────────────────────\n Returns: AH APM error code (if CF=CY)\n ──────────────────────────────────────────────────────────────────\n Info: This function lets you disable or enable all power management\n power-down functionality.\n\n When disabled, the BIOS will not power-down devices, or enter the\n stand-by or suspend state or take power-saving steps in response\n to CPU Idle calls (INT 15H 5305H).\n\n You may access this service via INT 15H or by using the APM entry\n address obtained via INT 15H 5302H or INT 15H 5303H (protected\n mode connect).\n\nSee Also: APM API\n About APM\n -♦-"
  },
  {
    "id": "40-int_15h_5309h__restore_system_bios_power_on_defaults.html",
    "t": "INT 15H 5309H: Restore System-BIOS Power-On Defaults",
    "b": "Expects: AX 5309H\n BX ffffH\n ──────────────────────────────────────────────────────────────────\n Returns: AH APM error code (if CF=CY)\n ──────────────────────────────────────────────────────────────────\n Info: This function resets the power management BIOS and reinitializes\n all of its default settings.\n\n You may access this service via INT 15H or by using the APM entry\n address obtained via INT 15H 5302H or INT 15H 5303H (protected\n mode connect).\n\nSee Also: APM API\n -♦-"
  },
  {
    "id": "41-int_15h_530ah__query_power_status.html",
    "t": "INT 15H 530aH: Query Power Status",
    "b": "Expects: AX 5309H\n BX 0001H\n ──────────────────────────────────────────────────────────────────\n Returns: AH APM error code (if CF=CY) else...\n BH AC line status: 00H = off-line\n 01H = on-line\n ffH = unknown\n BL Battery status: 00H = high\n 01H = low\n 02H = critical\n 03H = charging\n ffH = unknown\n CL Remaining battery life: 00H-64H (0-100) percent full charge\n ffH = unknown\n ──────────────────────────────────────────────────────────────────\n Info: This function returns information about the status of the power\n and battery.\n\n You may access this service via INT 15H or by using the APM entry\n address obtained via INT 15H 5302H or INT 15H 5303H (protected\n mode connect).\n\nSee Also: APM API\n About APM\n -♦-"
  },
  {
    "id": "42-int_15h_530bh__get_power_management_event.html",
    "t": "INT 15H 530bH: Get Power Management Event",
    "b": "Expects: AX 530bH\n ──────────────────────────────────────────────────────────────────\n Returns: AH APM error code (if CF=CY)\n (AH=80H means no events pending) else...\n BX event code: 0001H System Stand-by Request Notification\n 0002H System Suspend Request Notification\n 0003H Normal Resume Request Notification\n 0004H Critical Resume Request Notification\n 0005H Battery Low Notification\n ──────────────────────────────────────────────────────────────────\n Info: You should poll this fn once or twice per second to see if the\n APM BIOS wants to tell you something.\n\n You may access this service via INT 15H or by using the APM entry\n address obtained via INT 15H 5302H or INT 15H 5303H (protected\n mode connect).\n\n BX on return (when CF is clear), this contains the code indicating\n the event that APM wants you to know about and take action upon.\n It is one of:\n\n 0001H APM wants to go into Stand-by state. Upon receipt of this code,\n you should call INT 15H 5307H with BX=0001H and CX=0001H to put\n the system into stand-by state.\n\n 0002H APM wants to go into Suspend state. Upon receipt of this code,\n you should do any necessary cleanup and call INT 15H 5307H with\n BX=0001H and CX=0002H to put the system into suspend state.\n\n 0003H APM had to go into suspend state without notifying you and it has\n now resumed operation. You should recover from the unexpected\n suspend state as best you can.\n\n 0004H APM had to go into suspend state without notifying you and it has\n now resumed operation, but the battery is critically low. You\n should recover from the unexpected suspend state as best you can,\n but try to conserve power.\n\n 0005H APM is telling you that the battery is running low. You may want\n to minimize disk activity or take action to prepare for low-power\n operation.\n\n Notes: Notice that this is not a callback. You must poll this fn every\n so often to see if any events are waiting. But don't hog the CPU\n with these calls; once per second (or even less often) is\n probably fine.\n\nSee Also: APM API\n About APM\n -♦-"
  },
  {
    "id": "43-apm_api_error_return_codes.html",
    "t": "APM API Error/Return Codes",
    "b": "The Intel/Microsoft Advanced Power Management functions indicate failure\n by setting the Carry Flag and returning one of following error codes in\n the AH register:\n\n 01H APM functionality disabled\n\n 02H Interface connection already established\n 03H Interface not connected\n 04H Real mode connection not established\n 05H 16-bit protected-mode interface already established\n 06H 16-bit protected-mode interface not supported\n 07H 32-bit protected-mode interface already established\n 08H 32-bit protected-mode interface not supported\n\n 09H Unrecognized APM Device ID\n 0aH Parameter in CX is out of range\n\n 60H Can't enter requested state\n\n 80H No power management events pending\n\n 86H (reserved) no APM present\n\nSee Also: APM API\n About APM\n INT 15H (Misc AT Services)\n -♦-"
  },
  {
    "id": "44-apm_device_id.html",
    "t": "APM Device ID",
    "b": "Several APM API functions require a device ID in BX. This is a 16-bit\n value in the form:\n\n ApmDevIdRec\n 1 1 1 1 1 1\n ╓5┬4┬3┬2┬1┬0┬9┬8╥7┬6┬5┬4┬3┬2┬1┬0╖\n ║ device class ║ device unit ║\n ╙─┴─┴─┴─┴─┴─┴─┴─╨─┴─┴─┴─┴─┴─┴─┴─╜ bits\n ╚══════╦══════╝ ╚══════╦══════╝\n ║ ╚═══════► 0-7: device unit; ffH=ALL (see below)\n ╚═══════════════════════► 8-15: device class\n 00H = system\n 01H = display\n 02H = secondary storage\n 03H = parallel ports\n 04H = serial ports\n 05H-FFH (reserved)\n\n bits 8-15 (high byte) identify the device type. The value 00xxH has\n the special meaning \"the system as a whole\".\n\n bits 0-7 (low byte) identify the unit number of the (possibly several)\n units attached of the device type in the high byte.\n\n This value is 0-based. For instance, an ID of 0301H is the\n second parallel printer.\n\n A value of ffH indicates all devices of that type.\n\n Notes: ID 0000H identifies the system BIOS.\n ID 0001H identifies all devices power-managed by the system BIOS.\n\nSee Also: APM API\n About APM\n -♦-"
  },
  {
    "id": "45-ascii.html",
    "t": "ASCII",
    "b": "ASCII is an acronym for\n ┌─┐ ┌─┐ ┌─┐ ┌─┐ ┌─┐\n │A│merican │S│tandard │C│ode for │I│nformation │I│nterchange\n └─┘ └─┘ └─┘ └─┘ └─┘\n It is a set of 256 arbitrary assignments of text and control characters.\n The lower 128 members of the ASCII set are formally defined. Values above\n 127 (7fH) are interpreted different ways by various computers, printers,\n languages, etc.\n\n ASCII■Decimal■Hex■Binary Cross Reference\n\n Box, Line & Special Characters\n\n Extended ASCII Keystrokes\n\n Character Set Matrix\n\n Control Codes\n\n Press <Esc> to Return to the Previous Topic\n -♦-"
  },
  {
    "id": "46-ascii_decimal_hex_binary_cross_reference.html",
    "t": "ASCII■Decimal■Hex■Binary Cross Reference",
    "b": "ChrDecHex Binary ChrDecHex Binary ChrDecHex Binary ChrDecHex Binary\n╒═╤═══════════════ ╒═╤═══════════════ ╒═╤═══════════════ ╒═╤═══════════════\n│ │ 0 00 oooooooo │►│ 16 10 ooo1oooo │ │ 32 20 oo1ooooo │0│ 48 30 0o11oooo\n│☺│ 1 01 ooooooo1 │◄│ 17 11 ooo1ooo1 │!│ 33 21 oo1oooo1 │1│ 49 31 oo11ooo1\n│☻│ 2 02 oooooo1o │↕│ 18 12 ooo1oo1o │\"│ 34 22 oo1ooo1o │2│ 50 32 oo11oo1o\n│♥│ 3 03 oooooo11 │‼│ 19 13 ooo1oo11 │#│ 35 23 oo1ooo11 │3│ 51 33 oo11oo11\n│♦│ 4 04 ooooo1oo │¶│ 20 14 ooo1o1oo │$│ 36 24 oo1oo1oo │4│ 52 34 oo11o1oo\n│♣│ 5 05 ooooo1o1 │§│ 21 15 ooo1o1o1 │%│ 37 25 oo1oo1o1 │5│ 53 35 oo11o1o1\n│♠│ 6 06 ooooo11o │▬│ 22 16 ooo1o11o │&│ 38 26 oo1oo11o │6│ 54 36 oo11o11o\n│•│ 7 07 ooooo111 │↨│ 23 17 ooo1o111 │'│ 39 27 oo1oo111 │7│ 55 37 oo11o111\n│◘│ 8 08 oooo1ooo │↑│ 24 18 ooo11ooo │(│ 40 28 oo1o1ooo │8│ 56 38 oo111ooo\n│○│ 9 09 oooo1oo1 │↓│ 25 19 ooo11oo1 │)│ 41 29 oo1o1oo1 │9│ 57 39 oo111oo1\n│◙│ 10 0a oooo1o1o │→│ 26 1a ooo11o1o │*│ 42 2a oo1o1o1o │:│ 58 3a oo111o1o\n│♂│ 11 0b oooo1o11 │←│ 27 1b ooo11o11 │+│ 43 2b oo1o1o11 │;│ 59 3b oo111o11\n│♀│ 12 0c oooo11oo │∟│ 28 1c ooo111oo │,│ 44 2c oo1o11oo │<│ 60 3c oo1111oo\n│♪│ 13 0d oooo11o1 │↔│ 29 1d ooo111o1 │─│ 45 2d oo1o11o1 │=│ 61 3d oo1111o1\n│♫│ 14 0e oooo111o │▲│ 30 1e ooo1111o │.│ 46 2e oo1o111o │>│ 62 3e oo11111o\n│☼│ 15 0f oooo1111 │▼│ 31 1f ooo11111 │/│ 47 2f oo1o1111 │?│ 63 3f oo111111\n└─┘ └─┘ └─┘ └─┘\n\nChrDecHex Binary ChrDecHex Binary ChrDecHex Binary ChrDecHex Binary\n╒═╤═══════════════ ╒═╤═══════════════ ╒═╤═══════════════ ╒═╤═══════════════\n│@│ 64 40 o1oooooo │P│ 80 50 o1o1oooo │`│ 96 60 o11ooooo │p│112 70 o111oooo\n│A│ 65 41 o1ooooo1 │Q│ 81 51 o1o1ooo1 │a│ 97 61 o11oooo1 │q│113 71 o111ooo1\n│B│ 66 42 o1oooo1o │R│ 82 52 o1o1oo1o │b│ 98 62 o11ooo1o │r│114 72 o111oo1o\n│C│ 67 43 o1oooo11 │S│ 83 53 o1o1oo11 │c│ 99 63 o11ooo11 │s│115 73 o111oo11\n│D│ 68 44 o1ooo1oo │T│ 84 54 o1o1o1oo │d│100 64 o11oo1oo │t│116 74 o111o1oo\n│E│ 69 45 o1ooo1o1 │U│ 85 55 o1o1o1o1 │e│101 65 o11oo1o1 │u│117 75 o111o1o1\n│F│ 70 46 o1ooo11o │V│ 86 56 o1o1o11o │f│102 66 o11oo11o │v│118 76 o111o11o\n│G│ 71 47 o1ooo111 │W│ 87 57 o1o1o111 │g│103 67 o11oo111 │w│119 77 o111o111\n│H│ 72 48 o1oo1ooo │X│ 88 58 o1o11ooo │h│104 68 o11o1ooo │x│120 78 o1111ooo\n│I│ 73 49 o1oo1oo1 │Y│ 89 59 o1o11oo1 │i│105 69 o11o1oo1 │y│121 79 o1111oo1\n│J│ 74 4a o1oo1o1o │Z│ 90 5a o1o11o1o │j│106 6a o11o1o1o │z│122 7a o1111o1o\n│K│ 75 4b o1oo1o11 │[│ 91 5b o1o11o11 │k│107 6b o11o1o11 │{│123 7b o1111o11\n│L│ 76 4c o1oo11oo │\\│ 92 5c o1o111oo │l│108 6c o11o11oo │|│124 7c o11111oo\n│M│ 77 4d o1oo11o1 │]│ 93 5d o1o111o1 │m│109 6d o11o11o1 │}│125 7d o11111o1\n│N│ 78 4e o1oo111o │^│ 94 5e o1o1111o │n│110 6e o11o111o │~│126 7e o111111o\n│O│ 79 4f o1oo1111 │_│ 95 5f o1o11111 │o│111 6f o11o1111 │⌂│127 7f o1111111\n└─┘ └─┘ └─┘ └─┘\n\nChrDecHex Binary ChrDecHex Binary ChrDecHex Binary ChrDecHex Binary\n╒═╤═══════════════ ╒═╤═══════════════ ╒═╤═══════════════ ╒═╤═══════════════\n│Ç│128 80 1ooooooo │É│144 90 1oo1oooo │á│160 a0 1o1ooooo │░│176 b0 1o11oooo\n│ü│129 81 1oooooo1 │æ│145 91 1oo1ooo1 │í│161 a1 1o1oooo1 │▒│177 b1 1o11ooo1\n│é│130 82 1ooooo1o │Æ│146 92 1oo1oo1o │ó│162 a2 1o1ooo1o │▓│178 b2 1o11oo1o\n│â│131 83 1ooooo11 │ô│147 93 1oo1oo11 │ú│163 a3 1o1ooo11 │││179 b3 1o11oo11\n│ä│132 84 1oooo1oo │ö│148 94 1oo1o1oo │ñ│164 a4 1o1oo1oo │┤│180 b4 1o11o1oo\n│à│133 85 1oooo1o1 │ò│149 95 1oo1o1o1 │Ñ│165 a5 1o1oo1o1 │╡│181 b5 1o11o1o1\n│å│134 86 1oooo11o │û│150 96 1oo1o11o │ª│166 a6 1o1oo11o │╢│182 b6 1o11o11o\n│ç│135 87 1oooo111 │ù│151 97 1oo1o111 │º│167 a7 1o1oo111 │╖│183 b7 1o11o111\n│ê│136 88 1ooo1ooo │ÿ│152 98 1oo11ooo │¿│168 a8 1o1o1ooo │╕│184 b8 1o111ooo\n│ë│137 89 1ooo1oo1 │Ö│153 99 1oo11oo1 │⌐│169 a9 1o1o1oo1 │╣│185 b9 1o111oo1\n│è│138 8a 1ooo1o1o │Ü│154 9a 1oo11o1o │¬│170 aa 1o1o1o1o │║│186 ba 1o111o1o\n│ï│139 8b 1ooo1o11 │¢│155 9b 1oo11o11 │½│171 ab 1o1o1o11 │╗│187 bb 1o111o11\n│î│140 8c 1ooo11oo │£│156 9c 1oo111oo │¼│172 ac 1o1o11oo │╝│188 bc 1o1111oo\n│ì│141 8d 1ooo11o1 │¥│157 9d 1oo111o1 │¡│173 ad 1o1o11o1 │╜│189 bd 1o1111o1\n│Ä│142 8e 1ooo111o │₧│158 9e 1oo1111o │«│174 ae 1o1o111o │╛│190 be 1o11111o\n│Å│143 8f 1ooo1111 │ƒ│159 9f 1oo11111 │»│175 af 1o1o1111 │┐│191 bf 1o111111\n└─┘ └─┘ └─┘ └─┘\n\nChrDecHex Binary ChrDecHex Binary ChrDecHex Binary ChrDecHex Binary\n╒═╤═══════════════ ╒═╤═══════════════ ╒═╤═══════════════ ╒═╤═══════════════\n│└│192 c0 11oooooo │╨│208 d0 11o1oooo │α│224 e0 111ooooo │≡│240 f0 1111oooo\n│┴│193 c1 11ooooo1 │╤│209 d1 11o1ooo1 │ß│225 e1 111oooo1 │±│241 f1 1111ooo1\n│┬│194 c2 11oooo1o │╥│210 d2 11o1oo1o │Γ│226 e2 111ooo1o │≥│242 f2 1111oo1o\n│├│195 c3 11oooo11 │╙│211 d3 11o1oo11 │π│227 e3 111ooo11 │≤│243 f3 1111oo11\n│─│196 c4 11ooo1oo │╘│212 d4 11o1o1oo │Σ│228 e4 111oo1oo │⌠│244 f4 1111o1oo\n│┼│197 c5 11ooo1o1 │╒│213 d5 11o1o1o1 │σ│229 e5 111oo1o1 │⌡│245 f5 1111o1o1\n│╞│198 c6 11ooo11o │╓│214 d6 11o1o11o │µ│230 e6 111oo11o │÷│246 f6 1111o11o\n│╟│199 c7 11ooo111 │╫│215 d7 11o1o111 │τ│231 e7 111oo111 │≈│247 f7 1111o111\n│╚│200 c8 11oo1ooo │╪│216 d8 11o11ooo │Φ│232 e8 111o1ooo │°│248 f8 11111ooo\n│╔│201 c9 11oo1oo1 │┘│217 d9 11o11oo1 │Θ│233 e9 111o1oo1 │∙│249 f9 11111oo1\n│╩│202 ca 11oo1o1o │┌│218 da 11o11o1o │Ω│234 ea 111o1o1o │·│250 fa 11111o1o\n│╦│203 cb 11oo1o11 │█│219 db 11o11o11 │δ│235 eb 111o1o11 │√│251 fb 11111o11\n│╠│204 cc 11oo11oo │▄│220 dc 11o111oo │∞│236 ec 111o11oo │ⁿ│252 fc 111111oo\n│═│205 cd 11oo11o1 │▌│221 dd 11o111o1 │φ│237 ed 111o11o1 │²│253 fd 111111o1\n│╬│206 ce 11oo111o │▐│222 de 11o1111o │ε│238 ee 111o111o │■│254 fe 1111111o\n│╧│207 cf 11oo1111 │▀│223 df 11o11111 │∩│239 ef 111o1111 │ │255 ff 11111111\n└─┘ └─┘ └─┘ └─┘\n\n Box & Special Characters ASCII Control Codes Character Set ASCII"
  },
  {
    "id": "47-character_set_matrix.html",
    "t": "Character Set Matrix",
    "b": "x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 xa xb xc xd xe xf\n ┌────────────────────────────────────────────────────────────────\n 0x │nul ☺ ☻ ♥ ♦ ♣ ♠ • ◘ ○ ◙ ♂ ♀ ♪ ♫ ☼\n 1x │ ► ◄ ↕ ‼ ¶ § ▬ ↨ ↑ ↓ → ← ∟ ↔ ▲ ▼\n 2x │spc ! \" # $ % & ' ( ) * + , - . /\n 3x │ 0 1 2 3 4 5 6 7 8 9 : ; < = > ?\n 4x │ @ A B C D E F G H I J K L M N O\n 5x │ P Q R S T U V W X Y Z [ \\ ] ^ _\n 6x │ ` a b c d e f g h i j k l m n o\n 7x │ p q r s t u v w x y z { | } ~ ⌂\n 8x │ Ç ü é â ä à å ç ê ë è ï î ì Ä Å\n 9x │ É æ Æ ô ö ò û ù ÿ Ö Ü ¢ £ ¥ ₧ ƒ\n ax │ á í ó ú ñ Ñ ª º ¿ ⌐ ¬ ½ ¼ ¡ « »\n bx │ ░ ▒ ▓ │ ┤ ╡ ╢ ╖ ╕ ╣ ║ ╗ ╝ ╜ ╛ ┐\n cx │ └ ┴ ┬ ├ - ┼ ╞ ╟ ╚ ╔ ╩ ╦ ╠ ═ ╬ ╧\n dx │ ╨ ╤ ╥ ╙ ╘ ╒ ╓ ╫ ╪ ┘ ┌ █ ▄ ▌ ▐ ▀\n ex │ α ß Γ π Σ σ µ τ Φ Θ Ω δ ∞ φ ε ∩\n fx │ ≡ ± ≥ ≤ ⌠ ⌡ ÷ ≈ ° ∙ · √ ⁿ ² ■\n──────────────────────────────────────────────────────────────────────────────\n Box & Special Characters ASCII■Decimal■Hex■Binary XRef ASCII"
  },
  {
    "id": "48-ascii_control_codes.html",
    "t": "ASCII Control Codes",
    "b": "Dec Hex Ctl Name Control Meaning │ Dec Hex Ctl Name Control Meaning\n▀▀▀ ▀▀▀ ▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀ │ ▀▀▀ ▀▀▀ ▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n 0 00 ^@ NUL null (end string) │ 16 10 ^P DLE data line escape\n 1 01 ^A SOH start of heading │ 17 11 ^Q DC1 dev ctrl 1 (X-ON)\n 2 02 ^B STX start of text │ 18 12 ^R DC2 device ctrl 2\n 3 03 ^C ETX end of text │ 19 13 ^S DC3 dev ctrl 3 (X-OFF)\n 4 04 ^D EOT end of transmission │ 20 14 ^T DC4 device ctrl 4\n 5 05 ^E ENQ enquiry │ 21 15 ^U NAK negative acknowledge\n 6 06 ^F ACK acknowledge │ 22 16 ^V SYN synchronous idle\n 7 07 ^G BEL bell │ 23 17 ^W ETB end transmit block\n 8 08 ^H BS backspace │ 24 18 ^X CAN cancel\n 9 09 ^I HT TAB horizontal tab │ 25 19 ^Y EM end of medium\n 10 0a ^J LF line feed │ 26 1a ^Z SUB substitute\n 11 0b ^K VT vertical tab │ 27 1b ^[ ESC escape\n 12 0c ^L FF form feed │ 28 1c ^\\ FS file separator\n 13 0d ^M CR carriage return │ 29 1d ^] GS group separator\n 14 0e ^N SO shift out │ 30 1e ^^ RS record separator\n 15 0f ^O SI shift in │ 31 1f ^_ US unit separator\n─────────────────────────────────────┴────────────────────────────────────────\n Box & Special Characters ASCII■Decimal■Hex■Binary XRef ASCII"
  },
  {
    "id": "49-box__line___special_characters.html",
    "t": "Box, Line & Special Characters",
    "b": "Summary of some ASCII characters used in programming.\n\n Decimal Chr Hex Dec Chr Hex Dec Chr Hex Dec Chr Hex\n ▀▀▀▀▀▀▀▀▀▀▀ ▀▀▀▀▀ ▀▀▀▀▀▀▀▀ ▀▀▀ ▀▀▀ ▀▀▀ ▀▀▀ ▀▀▀ ▀▀▀ ▀▀▀ ▀▀▀ ▀▀▀\n 218 194 191 ┌ ┬ ┐ da c2 bf 196 - c4 24 ↑ 18 4 ♦ 04\n 195 197 180 ├ ┼ ┤ c3 c5 b4 179 │ b3 25 ↓ 19 7 • 07\n 192 193 217 └ ┴ ┘ c0 c1 d9 205 ═ cd 26 → 1a 9 ○ 09\n 186 ║ ba 27 ← 1b 15 ☼ 0f\n 201 203 187 ╔ ╦ ╗ c9 cb bb 42 * 2a\n 204 206 185 ╠ ╬ ╣ cc ce b9 176 ░ b0 30 ▲ 1e 46 . 2e\n 200 202 188 ╚ ╩ ╝ c8 ca bc 177 ▒ b1 31 ▼ 1f 127 ⌂ 7f\n 178 ▓ b2 16 ► 10 249 ∙ f9\n 214 210 183 ╓ ╥ ╖ d6 d2 b7 219 █ db 17 ◄ 11 250 · fa\n 199 215 182 ╟ ╫ ╢ c7 d7 b6 251 √ fb\n 211 208 189 ╙ ╨ ╜ d3 d0 bd 220 ▄ dc 3 ♥ 03 254 ■ fe\n 221 ▌ dd 4 ♦ 04\n 213 209 184 ╒ ╤ ╕ d5 d1 b8 222 ▐ de 5 ♣ 05 171 ½ ab\n 198 216 181 ╞ ╪ ╡ c6 d8 b5 223 ▀ df 6 ♠ 06 172 ¼ ac\n 212 207 190 ╘ ╧ ╛ d4 cf be\n────────────────────────────────────────────────────────────────────────────\n ASCII Control Codes ASCII■Decimal■Hex■Binary XRef Character Set ASCII"
  },
  {
    "id": "50-ansi_console_escape_sequences.html",
    "t": "ANSI Console Escape Sequences",
    "b": "ANSI Escape codes have no effect unless ANSI.SYS has been installed via a\n DEVICE= command in CONFIG.SYS. Use INT 2fH 1a00H to see if it is\n installed. Just output the codes to the CON device (see Character I/O).\n Several examples are included at the end of this topic.\n\n Note: Since you can't be certain that all computers have ANSI.SYS\n installed, most programmers do not rely on using these codes in\n commercial applications.\n\n In the following list, items in this color are parameters (usually numeric\n values in decimal) and the ← character is an ESC (ASCII 27 or 1bH).\n\nSequence (← is ESC) Function\n▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n █▌Cursor Motion▐█\n ←[row;clmH positions the cursor. Default is 1;1 (top left corner)\n\n ←[row;clmf (same as above)\n\n ←[rowsA moves the cursor up. Default: 1. Won't go above top.\n\n ←[rowsB moves cursor down. Default: 1. Won't go below bottom.\n\n ←[clmsC moves the cursor forward (to the right) Default: 1\n\n ←[clmsD moves the cursor backward (to the left) Default: 1\n\n █▌Erase Operations▐█\n ←[2J erases the screen and homes the cursor\n\n ←[K erases to the end of the current line\n\n █▌Miscellaneous▐█\n ←[6n outputs the current line and column in the form:\n ←[row;clmR\n\n ←[s saves the current cursor position (see ←[u)\n\n ←[u restores cursor to last position saved by ←[s\n\n █▌Screen Control▐█\n ←[attr;...;attrm sets display attributes. attr values are:\n 0 normal (white on black)\n 1 bold (character colors are high-intensity)\n 4 underline (IBM Monochrome monitor only)\n 5 blink (foreground blinks)\n 7 reverse (black on white)\n 8 no display (foreground = background)\n 30 BLACK foreground 40 BLACK background\n 31 RED foreground 41 RED background\n 32 GREEN foreground 42 GREEN background\n 33 YELLOW foreground 43 YELLOW background\n 34 BLUE foreground 44 BLUE background\n 35 MAGENTA foreground 45 MAGENTA background\n 36 CYAN foreground 46 CYAN background\n 37 WHITE foreground 47 WHITE background\n\n ←[=modeh sets screen width and mode where mode values are:\n 0 40x25 text mode black and white\n 1 40x25 text mode color\n 2 80x25 text mode black and white\n 3 80x25 text mode color\n 4 320x200 graphics mode color\n 5 320x200 graphics mode black and white\n 6 640x200 graphics mode black and white\n 7 Causes cursor to wrap to new line at end of line.\n\n ←[=7l stops cursor from wrapping at end of line\n\n █▌Keyboard Redefinition▐█\n ←[num;num...nump redefines a keystroke so it yields different values.\n or The first num (or first character of string) is\n ←[\"string\"p the key being redefined. The following values are the\n or new value for the key.\n ←[num;\"string\"p The following redefines Ctrl-D key to be: DIR C:[Enter]\n or ←[4;\"DIR C:\";13p\nvarious\n combinations Certain keystrokes must be defined with two nums.\n For example, [F1] is: 0;59; and [Home] is: 0;71;\n The following redefines the F10 key to be: DIR [Enter]\n ←[0;68;\"DIR\";13p\n\n See Extended ASCII Keystrokes for a full listing.\n\n Note: To reset a key to its original value, use its\n num code(s) twice. The following resets [F10].\n ←[0;68;0;68p\n▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄ ▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\n\n One way to find if ANSI.SYS is installed, is to display the ←[6n function\n and immediately read standard input. It should yield a value in the form:\n ←[row;clmR.\n\n Another way is to use INT 2fH 1a00H (get ANSI.SYS state) DOS 3.0+\n\n────────────────────────────────────────────────────────────────────────────\n Here are some examples usages in two programming languages:\n\n ;============================= ASM example =========================\n data_seg segment\n ColorMode db 1bH,'=3h','$'\n SetF10 db 1bH,'0;68;\"F10 was pressed\"p','$'\n data_seg ends\n\n code_seg segment\n mov dx,offset ColorMode ;set screen to 80x25 color mode\n mov ah,9 ;DOS display string function\n int 21H\n mov dx,offset SetF10 ;redefine F10 key to a string of text\n mov ah,9\n int 21H\n code_seg ends\n\n /* ====================== C function example ======================= */\n set_cursor(row,clm)\n int row,clm;\n {\n printf(\"%c[%d;%dH\",27,row,clm)\n }\n────────────────────────────────────────────────────────────────────────────\n It is difficult to experiment with ANSI sequences from the DOS command\n line since DOS does not allow direct keyboard input of the ESC character.\n Here are three ways to experiment:\n\n • Use DOS's Edit command (DOS 5.0+) to create a batch file:\n ┌────────────────────────────────────── (BLUEIT.BAT)\n │@ECHO OFF\n │REM -- clears screen to yellow on blue\n │ECHO ←[0;33;44m←[2J\n └───────────────────────────────────────────────────\n Note: To make the ← character in Edit, press Ctrl+P then press Esc.\n\n • Use the PROMPT command to output an ESC to the console. For instance:\n ┌─────────────────── (SETANSI.BAT)\n │ECHO ON\n │PROMPT $e[7m sets up to display in reverse video\n │PROMPT $e[0;68;\"DIR\";13p redefines the F10 key\n │PROMPT $p$g sets the prompt back to normal\n └────────────────────────────────\n\n • Create a disk file with BASIC and then TYPE it from DOS:\n OPEN \"ansitest.txt\" FOR OUTPUT AS #1\n PRINT #1,CHR$(27);\"[7m\" '** display reverse video\n PRINT #1,CHR$(27);\"[0;68;'DIR';13p\" '** define F10 key as DIR<Enter>\n SYSTEM\n TYPE ansitest.txt\n\nSee Also: Extended ASCII Keystrokes\n CONFIG.SYS\n ASCII Control Codes\n Character Set Matrix\n ASCII\n -♦-"
  },
  {
    "id": "51-epson_ibm_printer_control_codes.html",
    "t": "Epson/IBM Printer Control Codes",
    "b": "These are the printer control codes for IBM/Epson - compatible printers.\n\n Hex Dec Description\n ▀▀▀ ▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n 07 7 (BEL) sounds a beep\n 09 9 (HT) move to next tab stop (See ESC D)\n 0a 10 (LF) Linefeed: moves the paper up on line\n 0b 11 (VT) feed lines to next vertical tab stop (See ESC B)\n 0c 12 (FF) Formfeed: advance to top of page (See ESC C)\n 0d 13 (CR) Carriage Return: prints line (no linefeed)\n 0e 14 start DOUBLE-WIDTH printing (ends on CR or LF. See ESC W)\n 0f 15 start COMPRESSED mode printing\n 11 17 select printer\n 12 18 end COMPRESSED mode printing\n 13 19 deselect printer\n 14 20 end DOUBLE WIDTH printing\n 18 24 (CAN) clears the printer buffer\n 1b 27 (ESC) lead-in code for multi-character sequences (See below)\n 7f 127 (DEL) clears the printer buffer\n\n These ESC sequences are arranged by rough functional groups. Values shown\n in the form ◄n► indicate binary codes.\n\n ASCII Hex Description\n ▀▀▀▀▀▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n Fonts / Print Options\n ESC - ◄1► 1b 2d 01 begin UNDERLINE\n ESC - ◄0► 1b 2d 00 end underline\n\n ESC E 1b 45 start EMPHASIZED-MODE printing\n ESC F 1b 46 end emphasized-mode printing\n\n ESC G 1b 47 start DOUBLE-STRIKE printing\n ESC H 1b 48 end double-strike printing\n\n ESC S ◄0► 1b 53 00 start SUPERSCRIPT printing\n ESC S ◄1► 1b 53 01 start SUBSCRIPT printing\n ESC T 1b 54 end Superscript or Subscript printing\n\n ESC W ◄1► 1b 57 01 start DOUBLE-WIDTH printing (not canceled by LF)\n ESC W ◄0► 1b 57 00 end double-width printing\n\n ESC 6 1b 36 select character set 2\n ESC 7 1b 37 select character set 1\n\n Line Spacing / Page Length\n ESC 0 1b 30 8 LPI: start 1/8-inch line height\n ESC 1 1b 31 start 7/72-inch line height\n\n ESC 3 ◄n► 1b 33 xx set variable line spacing to ◄n►/216-inch\n ESC J ◄n► 1b 4a xx set line height to ◄n►/216-inch for next LF (0aH)\n ESC 2 1b 32 execute variable-height line feed (See ESC A) also\n 6 LPI: set 1/6\" line height (if no prior ESC 2)\n ESC A ◄n► 1b 41 xx select a line height of ◄n►/72-inch.\n (this is a one-shot linefeed triggered by ESC 2)\n\n ESC C ◄n► 1b 43 xx set lines per page to n (0-7fH)\n ESC N ◄n► 1b 4e xx set skip perforation to ◄n► lines\n ESC O 1b 4f cancel perforation skip\n\n Miscellaneous\n ESC 8 1b 38 ignore end of paper\n ESC 9 1b 39 cancel ignore end of paper\n ESC < 1b 3c home head\n ESC U ◄1► 1b 55 01 start uni-directional printing\n ESC U ◄0► 1b 55 00 start bi-directional printing\n\n ESC B ◄n..0► set VERTICAL TAB STOPS (send ESC B followed by a\n 1b 42 xx..00 series of binary values, ending in a byte of 0)\n ESC D ◄n..0► set HORIZONTAL TAB STOPS (send ESC D followed by a\n 1b 44 xx..00 series of binary values, ending in a byte of 0)\n\n Graphics\n ESC K ◄n1►◄n2►◄b1..bn► 480-dot bit-image grafix. Print n1+(256*n2) bytes\n 1b 4b xx xx yy..yy (top dot for bit 0, bottom dot for bit 7)\n\n ESC L ... 1b 4c ... 960-dot graphics--slow mode (See ESC K, ESC Y)\n\n ESC Y ... 1b 59 ... 960-dot bit-image graphics--fast mode (See ESC K)\n (can't print in consecutive dot positions)\n ESC Z ... 1b 59 ... 1920-dot bit-image graphics (See ESC K for format)\n (can print only every third consecutive dot)\n\nSee Also: ASCII Control Codes\n Character Set Matrix\n ASCII■Decimal■Hex■Binary XRef\n ASCII\n -♦-"
  },
  {
    "id": "52-diskette_parameter_table.html",
    "t": "Diskette Parameter Table",
    "b": "A series of these 11-byte structures can be found at the vector address of\n INT 1eH (the 4-byte address found at 0:0078). The list is also known as\n the \"Disk Base Table.\"\n\n It specifies a variety of critical variables for diskette drives only.\n The table is set to default values by the ROM-BIOS and may be modified by\n DOS to improve diskette performance or increase battery life on a laptop.\n\nDisketteParmRec\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 1 rSrtHdUnld bits 0-3: SRT step rate time\n bits 4-7: head unload time\n +1 1 rDmaHdLd bit 0: 1=use DMA\n bits 2-7: head load time\n +2 1 bMotorOff 55-ms increments before turning disk motor off\n +3 1 bSectSize sector size (0=128, 1=256, 2=512, 3=1024)\n +4 1 bLastTrack EOT (last sector on a track)\n +5 1 bGapLen gap length for read/write operations\n +6 1 bDTL DTL (Data Transfer Length) max transfer when\n length not set\n +7 1 bGapFmt gap length for format operation\n +8 1 bFillChar fill character for format (normally 0f6H '÷')\n +9 1 bHdSettle head-settle time (in milliseconds)\n +0aH 1 bMotorOn motor-startup time (in 1/8th-second intervals)\n 11 length of DisketteParmRec\n\nSee Also: Int 13H (disk I/O\n Hard Disk Parameter Table\n Data Structures\n -♦-"
  },
  {
    "id": "53-hard_disk_parameter_table.html",
    "t": "Hard Disk Parameter Table",
    "b": "This 16-byte structure can be found at the vector address of INT 41H (the\n 4-byte address at 0:0104).\n\n The parameters for a second hard disk (if any) are found at the vector for\n INT 46H. These tables specify a variety of critical variables for hard\n disk drive operations.\n\n XT The switches on the controller board select one of four drive\n types for each hard disk drive. At boot time, the BIOS sets\n INT 41H and INT 46H as indicated on these switches.\n\n AT The INT 41H and INT 46H vectors are set according to the\n AT Drive Type value which is a CMOS Memory variable stored by\n the \"Setup\" program.\n\nHardDiskParmRec\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 2 wMaxCyls maximum number of cylinders\n +2 1 bMaxHds maximum number of heads\n +3 2 wRWCyl starting reduced-write current cylinder\n +5 2 wWPCyl starting write precompensation cylinder\n +7 1 bECCLen maximum ECC data burst length\n +8 1 rOptFlags drive step options:\n bits 2-0: drive option\n bit 7: disable retries\n bit 6: disable ECC\n +9 1 bTimeOutStd standard timeout value\n +0aH 1 bTimeOutFmt timeout value for format drive\n +0bH 1 bTimeOutChk timeout value for check drive\n +0cH 4 res (reserved)\n 16 length of a HardDiskParmRec\n\nSee Also: INT 13H (disk I/O)\n Diskette Parameter Table\n Data Structures\n -♦-"
  },
  {
    "id": "54-at_bios_hard_disk_types.html",
    "t": "AT BIOS Hard Disk Types",
    "b": "The following drive types are pre-defined in the AT and PS/2 ROM-BIOS.\n During POST, the value in CMOS Memory address 12H (and/or 19H-1aH) is read\n and the vectors for INT 41H and INT 46H are set to a ROM table containing\n the information for the types of drive(s) installed.\n\n Note: This table is probably NOT reliable for your computer. See\n Notes, below.\n\n Write Land Write Land\n Type Cyls Hds PreComp Zone Size Type Cyls Hds PreComp Zone Size\n ▀▀▀▀ ▀▀▀▀ ▀▀▀ ▀▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀ ▀▀▀▀ ▀▀▀▀ ▀▀▀ ▀▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀\n 0 (no fixed disk installed) 17 977 5 300 977 42M\n 1 306 4 128 305 10M 18 977 7 0ffffH 977 59M\n 2 615 4 300 615 21M 19 1024 7 512 1023 62M\n 3 615 6 300 615 32M 20 733 5 300 732 31M\n 4 940 8 512 940 65M 21 733 7 300 732 44M\n 5 940 6 512 940 49M 22 733 5 300 733 31M\n 6 615 4 0ffffH 615 21M 23 306 4 0 336 10M\n 7 462 8 256 511 32M 24 612 4 305 663 22M\n 8 733 5 0ffffH 733 31M 25 306 4 0ffffH 340 10M\n 9 900 15 0ffffH 901 117M 26 612 4 0ffffH 670 21M\n 10 820 3 0ffffH 820 21M 27 698 7 300 732 43M\n 11 855 5 0ffffH 855 37M 28 967 5 488 977 42M\n 12 855 7 0ffffH 855 52M 29 306 4 0 340 11M\n 13 306 8 128 319 21M 30 611 4 306 663 21M\n 14 733 7 0ffffH 733 44M 31 732 7 300 732 46M\n 15 reserved (see notes) 32 1023 5 ffffH 1023 46M\n 16 612 4 0 663 21M (33-255 reserved, see notes)\n\n Notes: ■ The drive-type table in ROM is a major point of departure for\n the various BIOS makers. The above table identifies values\n used in IBM's BIOS. Some BIOSes identify over 100 drive types.\n Alas, there is no documented ROM address where you can hope to\n find the table.\n\n ■ Type 1 is the original XT hard disk\n ■ Type 2 is the standard 20M AT hard disk\n ■ Type 15 is reserved. That value in CMOS address 12H tells the\n system to look in CMOS address 19H for drive C: and 1aH for\n drive D:\n ■ Types 16-23 were added to ROM-BIOS of 11/15/85\n ■ Types 24-32 were added to PS/2 BIOS\n\n ■ Write PreComp selects the lowest cylinder at which the\n controller is to use different timing for writing. ffffH\n means none; 0 means all.\n\n Newer BIOSes provide a means to define a custom setting. The setting will\n be stored in an undocumented location in CMOS memory (and is lost if the\n battery ever fails -- so write it down!)\n\n On older BIOSes it is difficult (but possible) to use drives that are not\n in the table. You must install a table with the correct parameters and\n force BIOS and DOS to notice the changes. Some hard-disk peprearation\n tools handle this by creating a custom Master Boot Record that\n installs the table at boot time.\n\nSee Also: Hard Disk Parameter Table\n POST\n INT 15H (extended AT services)\n BIOS Data Area\n -♦-"
  },
  {
    "id": "55-extended_ascii_keystrokes.html",
    "t": "Extended ASCII Keystrokes",
    "b": "When INT 16H Fn 00H returns AL=0, then AH will contain an extended ASCII\n keystroke as listed in these tables. When a DOS Character I/O function\n returns a character of 00H, you should make a second call to obtain the\n extended ASCII value.\n\n ╓─────────────╥───────────────────╥───────────────────╥──────────────────╖\n ║ Key Hex Dec ║ Key Hex Dec ║ Key Hex Dec ║ Key Hex Dec ║\n ╟─────────────╫───────────────────╫───────────────────╫──────────────────╢\n ║ F1 3b 59 ║ Shift-F1 54 84 ║ Ctrl-F1 5e 94 ║ Alt-F1 68 104 ║\n ║ F2 3c 60 ║ Shift-F2 55 85 ║ Ctrl-F2 5f 95 ║ Alt-F2 69 105 ║\n ║ F3 3d 61 ║ Shift-F3 56 86 ║ Ctrl-F3 60 96 ║ Alt-F3 6a 106 ║\n ║ F4 3e 62 ║ Shift-F4 57 87 ║ Ctrl-F4 61 97 ║ Alt-F4 6b 107 ║\n ║ F5 3f 63 ║ Shift-F5 58 88 ║ Ctrl-F5 62 98 ║ Alt-F5 6c 108 ║\n ║ F6 40 64 ║ Shift-F6 59 89 ║ Ctrl-F6 63 99 ║ Alt-F6 6d 109 ║\n ║ F7 41 65 ║ Shift-F7 5a 90 ║ Ctrl-F7 64 100 ║ Alt-F7 6e 110 ║\n ║ F8 42 66 ║ Shift-F8 5b 91 ║ Ctrl-F8 65 101 ║ Alt-F8 6f 111 ║\n ║ F9 43 67 ║ Shift-F9 5c 92 ║ Ctrl-F9 66 102 ║ Alt-F9 70 112 ║\n ║ F10 44 68 ║ Shift-F10 5d 93 ║ Ctrl-F10 67 103 ║ Alt-F10 71 113 ║\n ╙─────────────╨───────────────────╨───────────────────╨──────────────────╜\n ╓───────────────╥────────────────╥───────────────────╥───────────────────╖\n ║ Key Hex Dec║ Key Hex Dec ║ Key Hex Dec ║ Key Hex Dec ║\n ╟───────────────╫────────────────╫───────────────────╫───────────────────╢\n ║ Alt-A 1e 30 ║ Alt-P 19 25 ║ Alt-3 7a 122 ║ down ↓ 50 80 ║\n ║ Alt-B 30 48 ║ Alt-Q 10 16 ║ Alt-4 7b 123 ║ left ← 4b 75 ║\n ║ Alt-C 2e 46 ║ Alt-R 13 19 ║ Alt-5 7c 124 ║ right → 4d 77 ║\n ║ Alt-D 20 32 ║ Alt-S 1f 31 ║ Alt-6 7d 125 ║ up ↑ 48 72 ║\n ║ Alt-E 12 18 ║ Alt-T 14 20 ║ Alt-7 7e 126 ║ End 4f 79 ║\n ║ Alt-F 21 33 ║ Alt-U 16 22 ║ Alt-8 7f 127 ║ Home 47 71 ║\n ║ Alt-G 22 34 ║ Alt-V 2f 47 ║ Alt-9 80 128 ║ PgDn 51 81 ║\n ║ Alt-H 23 35 ║ Alt-W 11 17 ║ Alt-- 82 130 ║ PgUp 49 73 ║\n ║ Alt-I 17 23 ║ Alt-X 2d 45 ║ Alt-= 83 131 ║ ║\n ║ Alt-J 24 36 ║ Alt-Y 15 21 ║ ║ ^left 73 115 ║\n ║ Alt-K 25 37 ║ Alt-Z 2c 44 ║ NUL 03 3 ║ ^right 74 116 ║\n ║ Alt-L 26 38 ║ ║ Shift-Tab 0f 15 ║ ^End 75 117 ║\n ║ Alt-M 32 50 ║ Alt-0 81 129 ║ Ins 52 82 ║ ^Home 77 119 ║\n ║ Alt-N 31 49 ║ Alt-1 78 120 ║ Del 53 83 ║ ^PgDn 76 118 ║\n ║ Alt-O 18 24 ║ Alt-2 79 121 ║ ^PrtSc 72 114 ║ ^PgUp 84 132 ║\n ╙───────────────╨────────────────╨───────────────────╨───────────────────╜\n ╔═══════════════════════════════════════════════╗\n ║ 101-key Keyboard Extensions Supported by BIOS ║\n ╓─────────╨─────────╥───────────────────────╥─────────────╨──────────╖\n ║ Key Hex Dec ║ Key Hex Dec ║ Key Hex Dec ║\n ╟───────────────────╫───────────────────────╫────────────────────────╢\n ║ F11 85 133 ║ Alt-Bksp 0e 14 ║ Alt- K / a4 164 ║\n ║ F12 86 134 ║ Alt-Enter 1c 28 ║ Alt- K * 37 55 ║\n ║ Shft-F11 87 135 ║ Alt-Esc 01 1 ║ Alt- K - 4a 74 ║\n ║ Shft-F12 88 136 ║ Alt-Tab a5 165 ║ Alt- K + 4e 78 ║\n ║ Ctrl-F11 89 137 ║ Ctrl-Tab 94 148 ║ Alt- K Enter a6 166 ║\n ║ Ctrl-F12 8a 138 ║ ║ ║\n ║ Alt-F11 8b 139 ║ Alt-up ↑ 98 152 ║ Ctrl- K / 95 149 ║\n ║ Alt-F12 8c 140 ║ Alt-down ↓ a0 160 ║ Ctrl- K * 96 150 ║\n ║ Alt-[ 1a 26 ║ Alt-left ← 9b 155 ║ Ctrl- K - 8e 142 ║\n ║ Alt-] 1b 27 ║ Alt-right → 9d 157 ║ Ctrl- K + 90 144 ║\n ║ Alt-; 27 39 ║ ║ ║\n ║ Alt-' 28 40 ║ Alt-Delete a3 163 ║ Ctrl- K ↑ [8] 8d 141 ║\n ║ Alt-` 29 41 ║ Alt-End 9f 159 ║ Ctrl- K 5 [5] 8f 143 ║\n ║ Alt-\\ 2b 43 ║ Alt-Home 97 151 ║ Ctrl- K ↓ [2] 91 145 ║\n ║ Alt-, 33 51 ║ Alt-Insert a2 162 ║ Ctrl- K Ins[0] 92 146 ║\n ║ Alt-. 34 52 ║ Alt-PageUp 99 153 ║ Ctrl- K Del[.] 93 147 ║\n ║ Alt-/ 35 53 ║ Alt-PageDown a1 161 ║ ║\n ╙───────────────────╨───────────────────────╨────────────────────────╜\n K indicates a key on the numeric keypad▲ (when not in NumLock mode)\n\n█▌Detecting the press and release of Alt▐█\n The BIOS does not put the Alt key or other shift keys into the keyboard\n buffer. If you want to take notice of the press (and release) of say,\n Alt, you will need to either intercept INT 09H and read the raw scan\n codes, or poll the byte at 0040:0017 regularly and watch for changes to\n the keyboard shift-state flags.\n\nSee Also: Keyboard Scan Codes\n Keyboard Flags\n Character I/O Functions\n INT 16H\n -♦-"
  },
  {
    "id": "56-numeric_keypad.html",
    "t": "Numeric Keypad",
    "b": "The separate keys arranged in a square on\nthe rightmost side of the keyboard.\n\nIt is possible to differentiate between,\nsay, the standard plus key (+) and the\n\"grey plus\" key on the numeric keypad by\nusing INT 16H 10H on later BIOSes. On\nolder computers you may need to intercept\nINT 09H if you need that functionality."
  },
  {
    "id": "57-keyboard_scan_codes.html",
    "t": "Keyboard Scan Codes",
    "b": "When the keyboard forces a hardware interrupt, it passes a Scan Code to\n the INT 09H interrupt handler. The handler converts this to an ASCII or\n Extended ASCII value. For compatibility across the various keyboards, it\n is wise to avoid using scan codes and stick to the BIOS translation of a\n keystroke.\n\n█▌Original PC/XT Keyboard▐█\n When a key is released, the keyboard sends the same value, ORed with 80H\n (e.g., [Ctrl] sends 1dH when pressed and 9dH when released).\n\n────────────┬─────────────┬───────────────┬───────────────┬─────────────────\nHex Dec Key │Hex Dec Key │Hex Dec Key │Hex Dec Key │Hex Dec Key\n────────────┼─────────────┼───────────────┼───────────────┼─────────────────\n01 1 Esc │12 18 E │23 35 H │34 52 . > │45 69 NumLock\n02 2 1 ! │13 19 R │24 36 J │35 53 / ? │46 70 ScrollLck\n03 3 2 @ │14 20 T │25 37 K │36 54 Shft(R)│47 71 Home [7]\n04 4 3 # │15 21 Y │26 38 L │37 55 * PrtSc│48 72 ↑ [8]\n05 5 4 $ │16 22 U │27 39 ; : │38 56 Alt │49 73 PgUp [9]\n06 6 5 % │17 23 I │28 40 \" ' │39 57 space │4a 74 K -\n07 7 6 ^ │18 24 O │29 41 ` ~ │3a 58 CapsLck│4b 75 ← [4]\n08 8 7 & │19 25 P │2a 42 Shft(L)│3b 59 F1 │4c 76 [5]\n09 9 8 * │1a 26 [ { │2b 43 \\ | │3c 60 F2 │4d 77 → [6]\n0a 10 9 ( │1b 27 ] } │2c 44 Z │3d 61 F3 │4e 78 K +\n0b 11 0 ) │1c 28 Enter│2d 45 X │3e 62 F4 │4f 79 End [1]\n0c 12 - _ │1d 29 Ctrl │2e 46 C │3f 63 F5 │50 80 ↓ [2]\n0d 13 + = │1e 30 A │2f 47 V │40 64 F6 │51 81 PgDn [3]\n0e 14 bksp│1f 31 S │30 48 B │41 65 F7 │52 82 Ins [0]\n0f 15 Tab │20 32 D │31 49 N │42 66 F8 │53 83 Del [.]\n10 16 Q │21 33 F │32 50 M │43 67 F9 │\n11 17 W │22 34 G │33 51 , < │44 68 F10 │\n────────────┴─────────────┴───────────────┴───────────────┴─────────────────\n K indicates a key on the numeric keypad▲ (when not in NumLock mode)\n\n█▌84-key AT Keyboard▐█\n The 84-key keyboard sends the same scan codes as the 83-key (original PC)\n keyboard with the addition that\n\n [SysReq] sends scan code 54H (84 decimal).\n\n However, the BIOS never lets an application program see this scan code.\n Instead, it invokes INT 15H 85H on make or break of the SysReq key.\n\n The 'break' (release of a key) is handled differently. Upon a break, the\n keyboard sends a two-byte sequence: 0f0H, followed by the 'make' scan\n code. See AT Keyboard Functions for information on programming this\n keyboard.\n\n█▌101-key Keyboard▐█\n This keyboard has three separate mappings of the scan codes, selected by\n communication through port 64H. The keyboard comes to life with scan code\n set 2 (which is wildly different from the 84-key mapping. However, the\n scan codes are translated by the hardware keyboard interface before they\n are made available to programs that read the keyboard.\n\n The result is that all of the scan codes identified in the above table are\n valid when the 101-key 'board comes up naturally. The following table\n lists the additional scan-codes that are sent by the 101-key 'board. Note\n that all keys mentioned here refer to the keys that are unique to this\n keyboard; e.g., [Insert] is the dedicated insert key (not KeyPad Ins).\n\n ────────────────────────────────────────────┬───────────────────────────\n Key Hex Sequence │ Key Hex Sequence\n ────────────────────────────────────────────┼───────────────────────────\n F11 ..................... 57 │ Home ........ e0 47\n F12 ..................... 58 │ Shft-Home ... e0 aa e0 47\n Right-Alt ............... e0 38 │ End ......... e0 4f\n Right-Ctrl .............. e0 1d │ Shft-End .... e0 aa e0 4f\n PrintScreen ............. e0 2a e0 37 │ ↑ ........... e0 48\n Shft-PrintScreen (SysReq) e0 37 │ Shft-↑ ...... e0 aa e0 48\n Ctrl-PrintScreen (SysReq) e0 37 │ ↓ ........... e0 50\n Alt-PrintScreen ......... 54 │ Shft-↓ ...... e0 aa e0 50\n Pause ................... e1 1d 45 e1 9d c5 │ PageUp ...... e0 49\n Ctrl-Pause (Break) ...... e0 46 e0 c6 │ Shft-PageUp . e0 aa e0 49\n Insert .................. e0 52 │ PageDown .... e0 51\n Shft-Insert ............. e0 aa e0 52 │ Shft-PageDown e0 aa e0 51\n Delete .................. e0 53 │ → ........... e0 4d\n Shft-Delete ............. e0 aa e0 53 │ Shft-→ ...... e0 aa e0 4d\n ← ....................... e0 4b │ K Enter ..... e0 1c\n Shft-← .................. e0 aa e0 4b │ K / ......... e0 35\n │ Shft-K / .... e0 aa e0 35\n ────────────────────────────────────────────┴───────────────────────────\n K indicates a key on the numeric keypad▲\n\n Note that in cases where a key is similar to another (pre-101) key, the\n second scan code byte is the same as the original key. Thus, some\n programs that work at the scan-code level can get away with simply\n ignoring the e0H prefix.\n\nSee Also: INT 09H\n Keyboard Flags\n Extended ASCII Keystrokes\n INT 16H\n -♦-"
  },
  {
    "id": "58-keyboard_shift_status_flags.html",
    "t": "Keyboard Shift Status Flags",
    "b": "Two bytes at address 0040:0017 and 0040:0018 identify the status of the\n keyboard shift keys and keyboard toggles.\n\n INT 16H 02H returns one byte in the AL register; it is exactly as found in\n the byte at 0040:0017 in the BIOS Data Area:\n\n KbdShiftFlagsRec\n ╓7┬6┬5┬4┬3┬2┬1┬0╖\n ║i│c│n│s│A│^│S│S║\n ╙─┴─┴─┴─┴─┴─┴L┴R╜ bit mask\n ║ ║ ║ ║ ║ ║ ║ ╚═► 0: 01H alpha-shift (right side) DOWN\n ║ ║ ║ ║ ║ ║ ╚═══► 1: 02H alpha-shift (left side) DOWN\n ║ ║ ║ ║ ║ ╚═════► 2: 04H Ctrl-shift (either side) DOWN\n ║ ║ ║ ║ ╚═══════► 3: 08H Alt-shift (either side) DOWN\n ║ ║ ║ ╚═════════► 4: 10H ScrollLock state\n ║ ║ ╚═══════════► 5: 20H NumLock state\n ║ ╚═════════════► 6: 40H CapsLock state\n ╚═══════════════► 7: 80H Insert state\n\n INT 16H 12H returns 16 bits in the AX register. It is similar to the word\n at 0040:0017:\n\n KbdShiftFlags101Rec\n 1 1 1 1 1 1\n ╓5┬4┬3┬2┬1┬0┬9┬8╥7┬6┬5┬4┬3┬2┬1┬0╖\n ║q│c│n│s│A│^│A│^║i│c│n│s│A│^│S│S║\n ╙d┴d┴d┴d┴r┴r┴l┴l╨s┴s┴s┴s┴─┴─┴L┴R╜ bit mask\n ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ╚═► 0: 0001H alpha-shift (right side) DOWN\n ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ╚═══► 1: 0002H alpha-shift (left side) DOWN\n ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ╚═════► 2: 0004H Ctrl-shift (either side) DOWN\n ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ╚═══════► 3: 0008H Alt-shift (either side) DOWN\n ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ╚═════════► 4: 0010H ScrollLock state\n ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ╚═══════════► 5: 0020H NumLock state\n ║ ║ ║ ║ ║ ║ ║ ║ ║ ╚═════════════► 6: 0040H CapsLock state\n ║ ║ ║ ║ ║ ║ ║ ║ ╚═══════════════► 7: 0080H Insert state\n ║ ║ ║ ║ ║ ║ ║ ╚═════════════════► 8: 0100H Ctrl-shift (left side) DOWN\n ║ ║ ║ ║ ║ ║ ╚═══════════════════► 9: 0200H Alt-shift (left side) DOWN\n ║ ║ ║ ║ ║ ╚═════════════════════►10: 0400H Ctrl-shift (right side) DOWN\n ║ ║ ║ ║ ╚═══════════════════════►11: 0800H Alt-shift (right side) DOWN\n ║ ║ ║ ╚═════════════════════════►12: 1000H ScrollLock DOWN\n ║ ║ ╚═══════════════════════════►13: 2000H NumLock DOWN\n ║ ╚═════════════════════════════►14: 4000H CapsLock DOWN\n ╚═══════════════════════════════►15: 8000H SysReq DOWN\n\n The byte at 0040:0018 is somewhat different from than that returned in\n AH by INT 16H 12H. Its layout is::\n\n KbdShiftFlags0018Rec\n ╓7┬6┬5┬4┬3┬2┬1┬0╖\n ║i│c│n│s│p│q│A│^║\n ╙d┴d┴d┴d┴─┴d┴l┴l╜ bit mask\n ║ ║ ║ ║ ║ ║ ║ ╚═► 0: 01H Ctrl-shift (left side) DOWN\n ║ ║ ║ ║ ║ ║ ╚═══► 1: 02H Alt-shift (left side) DOWN\n ║ ║ ║ ║ ║ ╚═════► 2: 04H SysReq DOWN\n ║ ║ ║ ║ ╚═══════► 3: 08H hold/pause state\n ║ ║ ║ ╚═════════► 4: 10H ScrollLock DOWN\n ║ ║ ╚═══════════► 5: 20H NumLock DOWN\n ║ ╚═════════════► 6: 40H CapsLock DOWN\n ╚═══════════════► 7: 80H Insert DOWN\n\n Note: Bits 0-2 of 0:0418 are defined only for the 101-key enhanced\n keyboard (older keyboards don't have two copies of Alt and Ctrl).\n\n█▌NumLock and CapsLock Mode▐█\n Bits 5-6 of 0040:0017 affect how the BIOS interprets certain keystrokes.\n\n Each press of NumLock toggles bit 5. When set, keys on the numeric keypad\n are interpreted as digits 1-9 and period (.). When bit 5 is clear, the\n same keys are interpreted as cursor control keystrokes.\n\n Each press of CapsLock toggles bit 6. When set, alphabetic keys A-Z are\n interpreted as uppercase (A-Z). When bit 5 is clear, the same keys are\n interpreted as lowercase (a-z).\n\n Pressing the SHIFT key reverses the current sense of these \"lock bits\" so\n that, for instance, in CapsLock mode, Shift+A result in lowercase 'a'.\n\n█▌ScrollLock Mode▐█\n The BIOS doesn't care about 0040:0017 bit 4 other than to toggle the bit\n each time ScrollLock is pressed. If you want your program to react to the\n ScrollLock setting, you'll need to check this bit each time you process a\n scrolling key. Most programs don't bother.\n\n█▌Insert Mode▐█\n The BIOS toggles 0040:0017 bit 8 each time the Insert key is pressed.\n Note that the BIOS also places the keycode for insert into the keyboard\n buffer. Most programs set bit 8 to a known state before processing input.\n\n█▌LED Shift-State Indicators▐█\n Starting with early AT keyboards, the status of CapsLock, NumLock, and\n ScrollLock has been indicated by a light on the keyboard itself. You can\n program these lights using port I/O to talk to the keyboard controller.\n See AT Keyboard for details.\n\n However, recent BIOSes periodically update the keyboard LEDs, so just\n setting or clearing bits of 0040:0017 will set the lights automatically.\n\n█▌Detecting the press and release of Alt▐█\n The BIOS does not put the Alt key or other shift keys into the keyboard\n buffer. If you want to take notice of the press (and release) of say,\n Alt, you will need to either intercept INT 09H an read the raw scan codes,\n or poll the byte at 0040:0017 regularly and watch for changes to the\n keyboard flags.\n\nSee Also: AT Keyboard\n BIOS Data Area\n INT 16H\n -♦-"
  },
  {
    "id": "59-equipment_list.html",
    "t": "Equipment List",
    "b": "This identifies equipment and peripheral options which are installed\n and/or active. It is returned from INT 11H (in AX) and can be found in\n the BIOS Data Area at 0040:0010.\n\n EquipmentListRec\n 1 1 1 1 1 1\n ╓5┬4┬3┬2┬1┬0┬9┬8╥7┬6┬5┬4┬3┬2┬1┬0╖\n ║prt│ │j│ aux │ ║drv│vid│ram│n│d║\n ╙─┴─┴╥┴╥┴─┴─┴─┴╥╨─┴─┴─┴─┴─┴─┴╥┴╥╜ bits mask\n ╚╦╝ ║ ║ ╚═╦═╝ ║ ╚╦╝ ╚╦╝ ╚╦╝ ║ ╚═► 0: 0001H disk drives are present\n ║ ║ ║ ║ ║ ║ ║ ║ ╚═══► 1: 0002H numeric coprocessor present\n ║ ║ ║ ║ ║ ║ ║ ╚══════► 2-3: 000eH motherboard RAM\n ║ ║ ║ ║ ║ ║ ╚══════════► 4-5: 0030H Initial/active video mode\n ║ ║ ║ ║ ║ ╚══════════════► 6-7: 00c0H total diskettes drives-1\n ║ ║ ║ ║ ╚═════════════════► 8: 0100H DMA present\n ║ ║ ║ ╚═════════════════════► 9-11: 0e00H RS232 serial ports\n ║ ║ ╚═════════════════════════► 12: 1000H game adapter present\n ║ ╚═══════════════════════════► 13: 2000H serial printer (PCjr)\n ╚══════════════════════════════►14-15: c000H printers installed\n\n bit 0 When this is 0, the computer has no diskette drives.\n bit 1 1 means that a numeric coprocessor is present. This is not\n always reliable on older BIOSes.\n bits 2-3 motherboard memory: 01=16K; 10=32K; 11=64K+ (usually 00 on\n most modern PCs, so has no meaning)\n On PS/2s, bit 2 is 1 when a mouse is detected by the POST\n bits 4-5 Currently-active video adaptor. It is one of:\n 00=(reserved) 10=80-clm color\n 01=40-clm color 11=TTL Monochrome\n bits 6-7 number of detected diskette drives -1:\n 00=1; 01=2; 10=3; 11=4\n bit 8 1 = DMA hardware is present (not reliable)\n bits 9-11 detected RS-232 serial ports detected:\n 000=0; 001=1...100=4...111=7\n bit 12 1=game adaptor (joystick) was detected by POST.\n bit 13 (on PCjr only) 1=serial printer attached\n bits 14-15 number of parallel printer ports:\n 00=0; 01=1; 10=2; 11=3\n\n Notes: ■ This data word is often used to ascertain the active video\n adaptor and the location of video RAM.\n\n If (AX & 30H) == 30H then the Monochrome adapter is active\n and video RAM segment is at b000H, otherwise use b800H. See\n Video Memory Layouts.\n\n ■ In general, the Equipment List word does not impart much useful\n information reliably. For instance, even when bits 9-11\n indicate 4 serial ports, the computer may provide support for\n 4 ports, but the hardware to handle only one or two is actually\n present.\n\nSee Also: BIOS Data Area\n INT 11H\n -♦-"
  },
  {
    "id": "60-cmos_storage_layout.html",
    "t": "CMOS Storage Layout",
    "b": "AT-class PCs contain a battery-powered real-time clock (RTC) and 64-bytes\n of low-power non-volatile CMOS memory.\n\n This memory contains a variety of information, including the current time\n and date, along with hardware configuration and a shut-down status byte\n (the shutdown byte is used in the mechanism which permits the AT to\n restart where it left off after issuing a processor reset to exit from\n protected mode).\n\n When you see the \"Run Setup\" prompt during POST it is usually because some\n hardware did not match the configuration record or because of some other\n problem with the CMOS RAM.\n\n Address Summary (detailed information follows)\n ▀▀▀▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n 00H-0dH used by real-time clock\n 0eH POST diagnostics status byte\n 0fH shutdown status byte\n 10H diskette drive type ─────┐\n 11H (reserved) │\n 12H hard disk types (if < 15) │\n 13H (reserved) ╞═► checksum-protected\n 14H equipment byte │ configuration record\n 15H-16H Base memory size │ (addresses 10H-20H)\n 17H-18H extended memory above 1M │\n 19H hard disk C type (if > 15) │\n 1aH hard disk D type (if > 15) │\n 1bH-20H (reserved) ─────┘\n 21H-2dH (reserved)\n 2eH-2fH storage for checksum of CMOS addresses 10H through 20H\n 30H-31H extended memory above 1M\n 32H current century in BCD (e.g., 19H)\n 33H miscellaneous info.\n 34H-3fH (reserved)\n\n█▌Using CMOS Data▐█\n To read a byte from CMOS, do an OUT 70H,addr followed by IN 71H. To\n write a byte to CMOS, do an OUT 70H,addr followed by OUT 71H,value.\n\n Example: ;---------------- read what type of hard disk is installed\n mov al,12H\n out 70H,al ;select CMOS address 12H\n jmp $+2 ;this forces a slight delay to settle things\n in al,71H ;AL now has drive type (0-15)\n\n Addresses 10H through 20H are protected by a checksum to be able to detect\n when the battery has died or invalid information has been written into the\n configuration record. This a simple 16-bit sum of the protected bytes.\n\n█▌CMOS Memory Layout Detail▐█\n This layout applies to AT-class PC only. PS/2 machines define some fields\n differently.\n\nAddr Description\n▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n 0 current second (real-time clock)╔═════════════════════════════════════╗\n 1 alarm second ║ All RTC quantities are stored in ║\n 2 current minute ║ BCD-format as two decimal nibbles; ║\n 3 alarm minute ║ e.g., 31 (decimal) is stored as 31H.║\n 4 current hour ╚═════════════════════════════════════╝\n 5 alarm hour ┌────────────────────────────┐\n 6 current day of week (1=Sunday) │ Note: For more info on the │\n 7 current date of month │ real-time clock, refer to │\n 8 current month │ Motorolla MC146818 specs. │\n 9 current year (final two digits; eg, 94) └────────────────────────────┘\n─── ───────────────────────────────────────────────────────────────────────\n0aH RTC status register A\n ╓7┬6┬5┬4┬3┬2┬1┬0╖\n ║ │ │ ║\n ╙╥┴─┴─┴─┴─┴─┴─┴─╜\n ║ ╚═╦═╝ ╚═════╩═► rate selector (set to 0110)\n ║ ╚═══════════► 22-stage divider (set to 010)\n ╚═══════════════► Update in progress (UIP) flag. 0 means OK to read.\n─── ───────────────────────────────────────────────────────────────────────\n0bH RTC status register B\n ╓7┬6┬5┬4┬3┬2┬1┬0╖\n ║ │ │ │ │ │ │ │ ║\n ╙╥┴╥┴╥┴╥┴╥┴╥┴╥┴╥╜\n ║ ║ ║ ║ ║ ║ ║ ╚═► daylight savings enable. 0=standard time (set to 0)\n ║ ║ ║ ║ ║ ║ ╚═══► 12 or 24-hr mode. 0=12-hr mode (is set to 1)\n ║ ║ ║ ║ ║ ╚═════► BCD date mode. 1=binary, 0=BCD. (is set to 0)\n ║ ║ ║ ║ ╚═══════► enable square wave. 1=turn on sqr wave. (set to 0)\n ║ ║ ║ ╚═════════► enable update-ended interrupt.0 disables. (set to 0)\n ║ ║ ╚═══════════► enable alarm int. 0 disables (set to 0) See INT 1aH\n ║ ╚═════════════► enable periodic interrupt 0 disables (set to 0)\n ╚═══════════════► Update in progress (UIP) flag. 0 = OK to read CMOS.\n─── ───────────────────────────────────────────────────────────────────────\n0cH RTC status register C. Read-only interrupt status bits.\n─── ───────────────────────────────────────────────────────────────────────\n0dH RTC status register D. Bit 7=1 when a CMOS-RAM is receiving power\n =0 to indicate a dead battery.\n─── ───────────────────────────────────────────────────────────────────────\n0eH POST diagnostics status byte\n ╓7┬6┬5┬4┬3┬2┬1┬0╖\n ║ │ │ │ │ │ │0 0║\n ╙╥┴╥┴╥┴╥┴╥┴╥┴─┴─╜\n ║ ║ ║ ║ ║ ╚═════► Time is valid (After POST, 1 means it's not Feb 30)\n ║ ║ ║ ║ ╚═══════► Hard disk bad. 1 = can't boot from hard disk\n ║ ║ ║ ╚═════════► RAM size error. 1 = POST found different RAM size\n ║ ║ ╚═══════════► Configuration record error. 1=different equipment\n ║ ╚═════════════► Checksum invalid. 1 = bad checksum in CMOS RAM\n ╚═══════════════► Power Lost. 1 = real-time clock battery died\n─── ───────────────────────────────────────────────────────────────────────\n0fH shutdown status byte\n This byte is read upon startup after CPU reset in order to determine if\n the reset was used as a way to get out of 80286 protected mode.\n 0 = soft reset (Ctrl-Alt-Del) or unexpected shutdown. Skip POST\n 1 = shutdown after memory size is determined\n 2 = shutdown after memory test is performed\n 3 = shutdown after memory error (parity check 1 or 2)\n 4 = shutdown with bootstrap loader request\n 5 = shutdown with FAR JMP (restart int ctrlr and jmp to 0:[0467H])\n 6,7,8 = shutdown after passing a protected mode test\n 9 = shutdown after performing block move. See INT 15H 87H\n 0aH = shutdown with FAR JMP (immediate jmp to address at 0:[0467H])\n─── ───────────────────────────────────────────────────────────────────────\n10H diskette drive types\n ╓7┬6┬5┬4┬3┬2┬1┬0╖\n ║ │ ║\n ╙─┴─┴─┴─┴─┴─┴─┴─╜\n ╚══╦══╝ ╚═════╩═►second diskette drive ═╦═► 0000 = 0 = not installed\n ╚════════════► first diskette drive ═╝ 0001 = 1 = 360K drive\n 0010 = 2 = 1.2M drive\n For instance, 24H means drive A is 1.2M 0011 = 3 = 720K drive\n drive B is 1.44M 0100 = 4 = 1.44M drive\n─── ───────────────────────────────────────────────────────────────────────\n11H reserved on ▌AT▐\n PS/2 uses addresses 11H and 12H to identify the Hard Disk Types for\n the first and second hard disks (drives C: and D:), respectively.\n─── ───────────────────────────────────────────────────────────────────────\n12H hard disk drive type (for drives C: and D:, when between 1 and 14)\n ╓7┬6┬5┬4┬3┬2┬1┬0╖\n ║ │ ║\n ╙─┴─┴─┴─┴─┴─┴─┴─╜\n ╚══╦══╝ ╚═════╩═►second hard disk (drive D) ═╦═►0000 =not present\n ╚════════════► first hard disk (drive C) ═╝ else =type ID (below)\n 1111 =use addr 19H/1aH\n\n See AT BIOS Hard Disk Types for a list of IBM BIOS-supported drives.\n─── ───────────────────────────────────────────────────────────────────────\n13H reserved\n─── ───────────────────────────────────────────────────────────────────────\n14H Equipment byte\n ╓7┬6┬5┬4┬3┬2┬1┬0╖\n ║drv│dsp│0 0│7│d║\n ╙─┴─┴─┴─┴─┴─┴╥┴─╜\n ╚╦╝ ╚╦╝ ║ ╚═► 1 = diskette drive(s) installed\n ║ ║ ╚═══► 1 = 80287 math co-processor installed\n ║ ╚══════════► primary display 00 = none or EGA▲\n ║ 01 = 40-clm CGA, EGA or VGA\n ║ 10 = 80-clm CGA, EGA or VGA\n ║ 11 = Monochrome\n ╚══════════════► diskette drives-1 (00=1, 01=2, 10=3, 11=4)\n─── ───────────────────────────────────────────────────────────────────────\n15H Base memory (low byte) ══╦═► 0100H=256K, 0200H=512K, 0280H=640K\n16H Base memory (high byte) ═╝\n17H extended memory above 1M (low byte) ══╦═► (in K bytes; 0-3c00H)\n18H extended memory (high byte) ══════════╝ See INT 15H 88H.\n─── ───────────────────────────────────────────────────────────────────────\n19H disk 0 (drive C:) hard disk type if (CMOS addr 12H & 0fH) is 0fH\n1aH disk 1 (drive D:) hard disk type if (CMOS addr 12H & f0H) is f0H\n (reserved on PS/2)\n─── ───────────────────────────────────────────────────────────────────────\n1bH-2dH reserved\n─── ───────────────────────────────────────────────────────────────────────\n2eH checksum of CMOS addresses 10H through 20H (high byte)\n2fH (low byte)\n─── ───────────────────────────────────────────────────────────────────────\n30H extended memory above 1M (low byte) ══╦═► (in K bytes; 0-3c00H)\n31H extended memory (high byte) ══════════╝ See INT 15H 88H.\n─── ───────────────────────────────────────────────────────────────────────\n32H century in BCD (e.g., 19H)\n PS/2 addresses 32H and 33H contain a CRC-style checksum of bytes 10H\n through 31H. 32H is the high byte, 33H is the low byte.\n─── ───────────────────────────────────────────────────────────────────────\n33H miscellaneous info. Bit 7=IBM 128K memory option installed\n Bit 6=used by \"Setup\" utility\n─── ───────────────────────────────────────────────────────────────────────\n34H-3fH reserved. Put your name here for everlasting amusement.\n PS/2 Date Century byte is at address 37H.\n PS/2 Password is contained in bytes 38H-3fH on Model 50. To read or\n modify the password, trick IBM by using addresses 78H-7fH (these\n invalid address \"wrap around\" and map to 38h-3fh).\n\nSee Also: POST\n INT 11H (get equipment list)\n INT 15H (extended AT services)\n AT BIOS Hard Disk Types\n BIOS Data Area\n -♦-"
  },
  {
    "id": "61-switch_settings.html",
    "t": "Switch Settings",
    "b": "PC Switch Settings (includes PC-1 and PC-2)\n XT Switch Settings\n AT Switch Settings\n\n EGA Switch Settings\n\n DIP switches on the PC and XT tell the BIOS what equipment and how much\n memory is installed. These switches are read during the POST and bit\n flags are set into the BIOS Equipment List variable and are made available\n to the programmer via INT 11H (Equipment Check).\n\n The topics above show details of the DIP switch settings, as well as\n jumpers and other hardware configuration for the different standard IBM\n models.\n\n Non-IBM PCs usually don't adhere to these settings. For instance, Compaq\n Portable switches bear no resemblance to those of the standard PC and\n aren't documented in any manual available to Compaq owners. Deskpro\n switches are labeled inside the chassis.\n\nSee Also: POST\n Cables and Pin Outs\n INT 11H (get equipment list)\n INT 15H (extended AT services)\n BIOS Data Area\n -♦-"
  },
  {
    "id": "62-pc_switch_settings.html",
    "t": "PC Switch Settings",
    "b": "This topic discusses the switches as defined for IBM logoed PCs only. On\n PC-compatible computers, there may be more or fewer switches and they may\n have different meanings.\n\n On the original PC (64K byte motherboard; sometimes called the PC-1),\n there are two DIP switch banks labeled SW1 and SW2. This is a summary of\n switch meanings:\n SW1 SW 2 (PC-1)\nON ╓1┬2┬3┬4┬5┬6┬7┬8╖ ON ╓1┬2┬3┬4┬5┬6┬7┬8╖\n ↑ ║ │ │ │ │ ║ ↑ ║ │▄│▄│▄│▄║\n ╙╥┴╥┴─┴─┴─┴─┴─┴─╜ ╙─┴─┴─┴─┴─┴─┴─┴─╜\n ║ ║ ╚╦╝ ╚╦╝ ╚═╩═►7-8: diskette drives ╚══╦══╝ ╚═════╩═► 5-8: always OFF\n ║ ║ ║ ╚══════►5-6: active display ╚════════════► 1-4: total RAM\n ║ ║ ╚══════════►3-4: system board RAM\n ║ ╚═════════════► 2: 8087 coprocessor\n ╚═══════════════► 1: diskette drives\n\n A later version of the PC (sometimes SW 2 (PC-2)\n called the PC-2) has a different BIOS ON ╓1┬2┬3┬4┬5┬6┬7┬8╖\n which interprets the switches somewhat ↑ ║ │▄│▄│▄║\n differently. SW1 is the same but SW2 ╙─┴─┴─┴─┴─┴─┴─┴─╜\n differs as shown: ╚═══╦═══╝ ╚═══╩═► 6-8: always OFF\n ╚═══════════► 1-5: total RAM\n\n On PCs and XTs, you can change the effect of the switch settings by\n changing the Equipment List bytes in BIOS Data Area 0:0410, then rebooting\n DOS. First store address 0:0472 with the value 1234H, then do an INT 19H.\n\n█▌PC and XT SW1: Diskette Drives▐█\n This indicates how many diskette drives are attached to the system.\n SW1\n ON ╓1┬2┬3┬4┬5┬6┬7┬8╖\n ↑ ║▄│ │ │ │ │ │▀│▀║ 1 diskette drive (Note: position 1 is ON if 0 drives)\n ╙─┴─┴─┴─┴─┴─┴─┴─╜\n ON ╓1┬2┬3┬4┬5┬6┬7┬8╖\n ↑ ║▄│ │ │ │ │ │▄│▀║ 2 diskette drives\n ╙─┴─┴─┴─┴─┴─┴─┴─╜\n ON ╓1┬2┬3┬4┬5┬6┬7┬8╖\n ↑ ║▄│ │ │ │ │ │▀│▄║ 3 diskette drives\n ╙─┴─┴─┴─┴─┴─┴─┴─╜\n ON ╓1┬2┬3┬4┬5┬6┬7┬8╖\n ↑ ║▄│ │ │ │ │ │▄│▄║ 4 diskette drives\n ╙─┴─┴─┴─┴─┴─┴─┴─╜\n\n█▌PC and XT SW1: Active Monitor▐█\n These switches tell the system which display adapter is to be used when\n the system is turned on. If the PC displays nothing after power-up, it\n may be because of an incorrect switch setting.\n SW1\n ON ╓1┬2┬3┬4┬5┬6┬7┬8╖\n ↑ ║ │ │ │ │▀│▀│ │ ║ None or EGA\n ╙─┴─┴─┴─┴─┴─┴─┴─╜\n ON ╓1┬2┬3┬4┬5┬6┬7┬8╖\n ↑ ║ │ │ │ │▄│▀│ │ ║ 40x25 Color/Graphics Adapter (CGA)\n ╙─┴─┴─┴─┴─┴─┴─┴─╜\n ON ╓1┬2┬3┬4┬5┬6┬7┬8╖\n ↑ ║ │ │ │ │▀│▄│ │ ║ 80x25 Color/Graphics Adapter (CGA)\n ╙─┴─┴─┴─┴─┴─┴─┴─╜\n ON ╓1┬2┬3┬4┬5┬6┬7┬8╖\n ↑ ║ │ │ │ │▄│▄│ │ ║ Monochrome Adapter (MDA) or both MDA and CGA\n ╙─┴─┴─┴─┴─┴─┴─┴─╜\n\n█▌PC and XT SW1: 8087▐█\n This switch enables the 8087 Coprocessor to interrupt CPU (via INT 02H\n Non-Maskable Interrupt) when it encounters an exception condition (as in\n division by 0). When OFF, software should be installed to trap INT 02H\n and determine if the interrupt was caused by a memory parity error or an\n 8087 exception condition.\n SW1\n ON ╓1┬2┬3┬4┬5┬6┬7┬8╖\n ↑ ║ │▄│ │ │ │ │ │ ║ 8087 is installed\n ╙─┴─┴─┴─┴─┴─┴─┴─╜\n ON ╓1┬2┬3┬4┬5┬6┬7┬8╖\n ↑ ║ │▀│ │ │ │ │ │ ║ 8087 is NOT installed\n ╙─┴─┴─┴─┴─┴─┴─┴─╜\n\n█▌PC SW1: System board RAM▐█\n These switches should both be OFF on systems that have 64K of memory or\n more.\n SW1\n ON ╓1┬2┬3┬4┬5┬6┬7┬8╖\n ↑ ║ │ │▄│▄│ │ │ │ ║ 64K or more on the system board\n ╙─┴─┴─┴─┴─┴─┴─┴─╜\n\n█▌PC-1 SW2: System board RAM▐█\n These settings are for the original PC (64K maximum on the system board)\n which does not have a later version of the ROM-BIOS; i.e., it does not\n have ROM-Scan and does not connect to an expansion unit or have a\n self-booting hard disk. The maximum settings for this system is 544K.\n\n SW2 (PC-1)\n ON ╓1┬2┬3┬4┬5┬6┬7┬8╖ Note: on PC-1, SW2 positions 5-8 are always OFF\n ↑ ║▀│▀│▀│▀│ │ │ │ ║ 64K\n ╙─┴─┴─┴─┴─┴─┴─┴─╜\n ON ╓1┬2┬3┬4┬5┬6┬7┬8╖ ┌───────────────────────────────────────────────┐\n ↑ ║▀│▄│▀│▀│ │ │ │ ║ 128K │ The settings reflect a binary number of 32K │\n ╙─┴─┴─┴─┴─┴─┴─┴─╜ │ blocks where an OFF is a 1-bit. To set the │\n ON ╓1┬2┬3┬4┬5┬6┬7┬8╖ │ switches without using a chart, just remember:│\n ↑ ║▀│▀│▄│▀│ │ │ │ ║ 192K │ │\n ╙─┴─┴─┴─┴─┴─┴─┴─╜ │ Position 4 = 256Ks (ON=0, OFF=1) │\n ON ╓1┬2┬3┬4┬5┬6┬7┬8╖ │ Position 3 = 128Ks │\n ↑ ║▀│▄│▄│▀│ │ │ │ ║ 256K │ Position 2 = 64Ks │\n ╙─┴─┴─┴─┴─┴─┴─┴─╜ │ Position 1 = 32Ks │\n ON ╓1┬2┬3┬4┬5┬6┬7┬8╖ │ │\n ↑ ║▀│▀│▀│▄│ │ │ │ ║ 320K │ Add them up, then add 64K (system board RAM) │\n ╙─┴─┴─┴─┴─┴─┴─┴─╜ │ to get the total system memory. │\n ON ╓1┬2┬3┬4┬5┬6┬7┬8╖ └───────────────────────────────────────────────┘\n ↑ ║▀│▄│▀│▄│ │ │ │ ║ 384K\n ╙─┴─┴─┴─┴─┴─┴─┴─╜\n ON ╓1┬2┬3┬4┬5┬6┬7┬8╖\n ↑ ║▀│▀│▄│▄│ │ │ │ ║ 448K\n ╙─┴─┴─┴─┴─┴─┴─┴─╜\n ON ╓1┬2┬3┬4┬5┬6┬7┬8╖\n ↑ ║▀│▄│▄│▄│ │ │ │ ║ 512K\n ╙─┴─┴─┴─┴─┴─┴─┴─╜\n ON ╓1┬2┬3┬4┬5┬6┬7┬8╖\n ↑ ║▄│▄│▄│▄│ │ │ │ ║ 544K\n ╙─┴─┴─┴─┴─┴─┴─┴─╜\n\n█▌PC-2 SW2: System board RAM▐█\n These settings are for a later version of the IBM-PC (sometimes called the\n PC-2) which is capable of having 256K on the system board. These setting\n also apply to the PC-1 (64K system board) if a later version of the\n ROM-BIOS has been installed. If you have a self-booting hard disk or an\n IBM expansion chassis, you have PC-2 ROMS. The maximum memory for this\n model is 640K.\n\n SW2 (PC-2)\n ON ╓1┬2┬3┬4┬5┬6┬7┬8╖ Note: on PC-2, SW2 positions 6-8 are always OFF\n ↑ ║▀│▀│▀│▀│▀│ │ │ ║ 64K\n ╙─┴─┴─┴─┴─┴─┴─┴─╜\n ON ╓1┬2┬3┬4┬5┬6┬7┬8╖ ┌───────────────────────────────────────────────┐\n ↑ ║▀│▄│▀│▀│▀│ │ │ ║ 128K │ The settings reflect a binary number of 32K │\n ╙─┴─┴─┴─┴─┴─┴─┴─╜ │ blocks where an OFF is a 1-bit. To set the │\n ON ╓1┬2┬3┬4┬5┬6┬7┬8╖ │ switches without using a chart, just remember:│\n ↑ ║▀│▀│▄│▀│▀│ │ │ ║ 192K │ │\n ╙─┴─┴─┴─┴─┴─┴─┴─╜ │ Position 5 = 512Ks (ON=0, OFF=1) │\n ON ╓1┬2┬3┬4┬5┬6┬7┬8╖ │ Position 4 = 256Ks │\n ↑ ║▀│▄│▄│▀│▀│ │ │ ║ 256K │ Position 3 = 128Ks │\n ╙─┴─┴─┴─┴─┴─┴─┴─╜ │ Position 2 = 64Ks │\n ON ╓1┬2┬3┬4┬5┬6┬7┬8╖ │ Position 1 = 32Ks │\n ↑ ║▀│▀│▀│▄│▀│ │ │ ║ 320K │ │\n ╙─┴─┴─┴─┴─┴─┴─┴─╜ │ Add them up, then add 64K to get the total RAM│\n ON ╓1┬2┬3┬4┬5┬6┬7┬8╖ └───────────────────────────────────────────────┘\n ↑ ║▀│▄│▀│▄│▀│ │ │ ║ 384K\n ╙─┴─┴─┴─┴─┴─┴─┴─╜\n ON ╓1┬2┬3┬4┬5┬6┬7┬8╖\n ↑ ║▀│▀│▄│▄│▀│ │ │ ║ 448K\n ╙─┴─┴─┴─┴─┴─┴─┴─╜\n ON ╓1┬2┬3┬4┬5┬6┬7┬8╖\n ↑ ║▀│▄│▄│▄│▀│ │ │ ║ 512K\n ╙─┴─┴─┴─┴─┴─┴─┴─╜\n ON ╓1┬2┬3┬4┬5┬6┬7┬8╖\n ↑ ║▀│▀│▀│▀│▄│ │ │ ║ 576K\n ╙─┴─┴─┴─┴─┴─┴─┴─╜\n ON ╓1┬2┬3┬4┬5┬6┬7┬8╖\n ↑ ║▀│▄│▀│▀│▄│ │ │ ║ 640K\n ╙─┴─┴─┴─┴─┴─┴─┴─╜\n\nSee Also: Equipment List\n Switch Settings\n -♦-"
  },
  {
    "id": "63-xt_switch_settings.html",
    "t": "XT Switch Settings",
    "b": "This topic discusses the switches as defined for IBM logoed PCs only. On\n PC-compatible computers, there may be more or fewer switches and they may\n have different meanings.\n\n The IBM XT has a single bank of DIP switches. They are summarized as\n follows:\n\n SW1 (XT)\nON ╓1┬2┬3┬4┬5┬6┬7┬8╖\n ↑ ║▄│ │ │ │ ║\n ╙╥┴╥┴─┴─┴─┴─┴─┴─╜\n ║ ║ ╚╦╝ ╚╦╝ ╚═╩═► 7-8: diskette drives\n ║ ║ ║ ╚══════► 5-6: initial active display monitor\n ║ ║ ╚══════════► 3-4: system board RAM\n ║ ╚═════════════► 2: 8087\n ╚═══════════════► 1: POST loop (always OFF)\n\n Positions 2,5-6,and 7-8 are the same as on the PC. See PC Switch Settings\n\n█▌XT RAM▐█\n The XT POST determines the total system memory by scanning RAM address\n space to locate 32K blocks (it displays numbers in the top left corner of\n the screen as it does this). Therefore, you do not need to change switch\n settings when you add or remove memory option cards. Moreover, you need\n not populate the system board fully (above 128K) to add additional memory\n option cards.\n\n Switches 3-4 indicate the memory on the XT system board as follows:\n\n SW1 (XT)\nON ╓1┬2┬3┬4┬5┬6┬7┬8╖\n ↑ ║ │ │▄│▀│ │ │ │ ║ 128K\n ╙─┴─┴─┴─┴─┴─┴─┴─╜\nON ╓1┬2┬3┬4┬5┬6┬7┬8╖\n ↑ ║ │ │▀│▄│ │ │ │ ║ 192K\n ╙─┴─┴─┴─┴─┴─┴─┴─╜\nON ╓1┬2┬3┬4┬5┬6┬7┬8╖\n ↑ ║ │ │▄│▄│ │ │ │ ║ 256K\n ╙─┴─┴─┴─┴─┴─┴─┴─╜\n\nSee Also: Equipment List\n Switch Settings\n -♦-"
  },
  {
    "id": "64-at_switch_settings.html",
    "t": "AT Switch Settings",
    "b": "The IBM AT and clones do not have any DIP switch banks. The equipment\n configuration is set by the SETUP program which is incorporated into the\n DIAGNOSTICS diskette or changeable by another method (e.g., pressing\n Ctrl+Alt+Esc while booting, depending upon the BIOS type).\n\n See CMOS Memory for related information.\n\n Older IBM-logoed ATs do have two system board options which are set by\n physical switches.\n\n A 3-pin Berg-strip connect is located on the front edge of the system\n board labeled J18 affects the usage of system board RAM.\n\n ╔J18╗\n1 ║┌•┐║ ENABLE second bank of 256K (512K on system board)\n2 ║└•┘║\n3 ║ • ║\n ╚═══╝\n ╔J18╗\n1 ║ • ║\n2 ║┌•┐║\n3 ║└•┘║ DISABLE second bank of 256K (256K on system board)\n ╚═══╝\n\n A single slide switch near the back of the system board, labeled SW1,\n selects the initial display adapter. This is used by the POST but has\n meaning only when the CMOS Memory (which contains the full equipment list)\n has lost power or has become invalid for some other reasons. In other\n words, this switch indicates the primary display adapter that will be used\n by the SETUP program.\n\n ╔SW1╗\n ║▐█▌║ ON ON (toward the rear) Color/Graphics Adapter (CGA) is primary\n ║ ║ OFF\n ╚═══╝\n ╔SW1╗\n ║ ║ ON\n ║▐█▌║ OFF OFF (to the front) Monochrome Display Adapter (MDA) is primary\n ╚═══╝\n\n Note: The EGA reference contradicts this, saying to use OFF for a CGA\n alone and ON for any other display adapter or combination of\n adapters. You figure it out!\n\nSee Also: Equipment List\n CMOS Memory\n Switch Settings\n -♦-"
  },
  {
    "id": "65-ega_switch_settings.html",
    "t": "EGA Switch Settings",
    "b": "This topic discusses the switches on older IBM-logoed EGA cards ONLY.\n On non-IBM EGA cards, there may be more or fewer switches and they may\n have different meanings.\n\n The DIP switches on the rear of the EGA indicate which display monitor\n is connected to the card and which (if any) other adapters are in the\n system at the same time. The switches are mirrored in memory. See\n EGA Data Areas.\n\n There is one CRITICAL thing to watch for: never plug a Monochrome monitor\n into the EGA adapter unless the switches are set to accept it. A wrong\n setting will actually do physical damage to the monitor!\n\n In the following table, Primary indicates the adapter/monitor which is\n first enabled when the computer is turned on. Secondary indicates an\n optional second adapter/monitor which may be connected.\n\nON ╓4┬3┬2┬1╖ Primary EGA connected to 40x25 color monitor\n ↑ ║▀│▄│▄│▀║ Secondary MDA\n ╙─┴─┴─┴─╜\nON ╓4┬3┬2┬1╖ Primary EGA connected to 80x25 color monitor\n ↑ ║▀│▄│▄│▄║ Secondary MDA\n ╙─┴─┴─┴─╜\nON ╓4┬3┬2┬1╖ Primary EGA connected to enhanced color monitor (CGA emulation)\n ↑ ║▄│▀│▀│▀║ Secondary MDA\n ╙─┴─┴─┴─╜\nON ╓4┬3┬2┬1╖ Primary EGA connected to enh. color monitor (best resolution)\n ↑ ║▄│▀│▀│▄║ Secondary MDA\n ╙─┴─┴─┴─╜\nON ╓4┬3┬2┬1╖ Primary EGA connected to Monochrome monitor\n ↑ ║▄│▀│▄│▀║ Secondary CGA connected to 40x25 color monitor\n ╙─┴─┴─┴─╜\nON ╓4┬3┬2┬1╖ Primary EGA connected to Monochrome monitor\n ↑ ║▄│▀│▄│▄║ Secondary CGA connected to 80x25 color monitor\n ╙─┴─┴─┴─╜\n\nON ╓4┬3┬2┬1╖ Primary MDA\n ↑ ║▀│▀│▀│▀║ Secondary EGA connected to 40x25 color monitor\n ╙─┴─┴─┴─╜\nON ╓4┬3┬2┬1╖ Primary MDA\n ↑ ║▀│▀│▀│▄║ Secondary EGA connected to 80x25 color monitor\n ╙─┴─┴─┴─╜\nON ╓4┬3┬2┬1╖ Primary MDA\n ↑ ║▀│▀│▄│▀║ Secondary EGA connected to enh. color monitor (CGA emulation)\n ╙─┴─┴─┴─╜\nON ╓4┬3┬2┬1╖ Primary MDA\n ↑ ║▀│▀│▄│▄║ Secondary EGA connected to enh. monitor (best resolution)\n ╙─┴─┴─┴─╜\nON ╓4┬3┬2┬1╖ Primary CGA connected to 40x25 color monitor\n ↑ ║▀│▄│▀│▀║ Secondary EGA connected to Monochrome monitor\n ╙─┴─┴─┴─╜\nON ╓4┬3┬2┬1╖ Primary CGA connected to 80x25 color monitor\n ↑ ║▀│▄│▀│▄║ Secondary EGA connected to Monochrome monitor\n ╙─┴─┴─┴─╜\n\n█▌EGA Jumpers▐█\n The three jumpers on the EGA control various features of the card. The\n jumper/connectors are used as follows:\n ╔P1═╗\n 1 ║┌•┐║ Supports enhanced color monitor\n 2 ║└•┘║ (640x350 and 64 color capability)\n 3 ║ • ║\n ╚═══╝\n ╔P1═╗\n 1 ║ • ║\n 2 ║┌•┐║ Supports color monitor only\n 3 ║└•┘║ (640x200 and 16 color capability)\n ╚═══╝\n\n P2 (not shown) is a connector for a light pen.\n\n ╔P3═╗\n 1 ║┌•┐║ Sets EGA I/O ports to 3xxH\n 2 ║└•┘║ (normal setting)\n 3 ║ • ║\n ╚═══╝\n ╔P3═╗\n 1 ║ • ║\n 2 ║┌•┐║ Sets EGA I/O ports to 2xxH\n 3 ║└•┘║ NOT supported by EGA BIOS\n ╚═══╝\n\nSee Also: Equipment List\n EGA Data Areas\n Switch Settings\n EGA Video Adaptor Pin Outs\n -♦-"
  },
  {
    "id": "66-color_graphics_adapter__cga_.html",
    "t": "Color Graphics Adapter (CGA)",
    "b": "█▌Overview▐█\n The CGA is the \"lowest common denominator\" color video system. It is\n the original color system shipped with the IBM-PC circa 1981. TECH Help!\n covers the following CGA and general video topics:\n\n Video Services ..... INT 10H video services\n Video Modes ........ includes CGA modes\n Video Memory Layouts accessing CGA video memory\n Video Snow ......... about CGA video programming peculiarities\n\n BIOS Data Area ..... includes video-specific variables in low memory\n\n Screen Attributes .. codes determine colors for text mode\n Color Table ........ exhaustive listing of screen attributes\n\n CGA I/O Ports ...... I/O port addresses; video controller registers\n CGA Pin Outs ....... connectors on CGA cards\n\n INT 1dH ............ video initialization table\n INT 1fH ............ font definitions of chars 128-255 in graphics modes\n\n CGAs are limited to 25-lines or 80 or 40 columns in text mode. In\n graphics mode, it supports 320x200 4-color and 640-200 2-color modes only.\n Its video memory begins at b800:0000 and it supports up to 8 \"pages\" of\n video in text mode.\n\n If your program writes directly to CGA video memory, it is important to\n write special code to avoid annoying screen flicker. See Video Snow.\n\n EGA, VGA, and SuperVGA are all upwardly-compatible with CGA, supporting\n all of its modes, I/O ports, and BIOS variables.\n\n█▌Testing for a CGA▐█\n Use INT 11H (equipment list) and check bits 4 & 5; if (w AND 30H) is 30H,\n then you are running on an MDA (video memory is at b000:0). Otherwise,\n its a CGA, EGA, VGA or other compatible color system (video memory is at\n b800:0). See EGA and VGA if you need to narrow it down.\n\nSee Also: MDA\n EGA\n VGA\n SuperVGA\n CGA I/O Ports\n Video Memory Layouts\n -♦-"
  },
  {
    "id": "67-enhanced_graphics_adapter__ega_.html",
    "t": "Enhanced Graphics Adapter (EGA)",
    "b": "█▌Overview▐█\n The EGA is generally upwardly-compatible with the CGA▲ and the MDA▲, but\n it has loads of additional features. It was introduced in 1985 and has\n been popular since about 1986. It is mostly replaced by VGA and SVGA\n systems. TECH Help! covers the following EGA and general video topics:\n\n Video Modes ........... includes EGA modes\n Video Services ........ INT 10H video services\n\n Video Memory Layouts .. accessing EGA video memory\n\n EGA Data Areas ........ BIOS data variables specific to EGA\n BIOS Data Area ........ includes video-specific variables in low memory\n Screen Attributes ..... codes determine colors for text mode\n Color Table ........... exhaustive listing of screen attributes\n\n EGA I/O Ports ......... I/O port addresses; video controller registers\n EGA Switch Settings ... those pesky switches at the rear of the adaptor\n EGA Pin Outs .......... connectors on EGA cards\n\n Font Definition Data .. layout of binary data that defines a font\n .CPI Font Files ....... the DOS interface for EGA font definition\n\n The EGA supports 25- and 43-line text modes and graphics modes up to\n 640x350 with 16 colors. You can redefine fonts and remap the color\n palette. It is upwardly-compatible with CGA. VGA, and SuperVGA are all\n upwardly-compatible with EGA, supporting all of its modes, I/O ports, and\n BIOS variables.\n\n In text modes, video memory begins at b800:0. In graphics modes 0dH-10H,\n video memory is at a000:0 (see Video Memory Layouts).\n\n█▌Testing for an EGA▐█\n To see if you are running on an EGA, use INT 10H 12H BL=10H. If on\n return, BL>4 then the EGA BIOS is not present, so you must be running\n on a CGA or MDA.\n\nSee Also: CGA\n MDA\n VGA\n SuperVGA\n Video Memory Layouts\n -♦-"
  },
  {
    "id": "68-monochrome_display_adapter__mda_.html",
    "t": "Monochrome Display Adapter (MDA)",
    "b": "█▌Overview▐█\n The MDA is one of the original video systems shipped with the IBM-PC\n circa 1981. It has been mostly replaced by EGA, VGA, and SVGA systems.\n TECH Help! covers the following MDA and general video topics:\n\n Video Services ..... INT 10H video services\n Video Modes ........ includes MDA modes\n\n Video Memory Layouts accessing MDA video memory\n BIOS Data Area ..... includes video-specific variables in low memory\n\n Screen Attributes .. codes determine \"colors\" for text mode\n\n CGA I/O Ports ...... I/O port addresses; video controller registers\n MDA Pin Outs ....... connectors on MDA cards\n\n INT 1dH ............ video initialization table\n\n The MDA provides NO graphics support and is limited to a single text mode\n (80x25). Its video memory begins at b000:0000 and it supports only one\n \"page\" of video.\n\n A popular variant known as Hercules and MonoGraphics also exists. These\n versions do support a 720x348 2-color graphics mode and they work with\n the same low-cost video display as the MDA.\n\n█▌Testing for an MDA▐█\n Use INT 11H (equipment list) and check bits 4 & 5. If (w AND 30H) is 30H,\n then you are running on an MDA or compatible and video memory begins at\n b000:0; otherwise, its a CGA, EGA, VGA or other color system (text-mode\n video memory begins at b800:0).\n\nSee Also: CGA\n EGA\n VGA\n SuperVGA\n CGA I/O Ports\n Video Memory Layouts\n -♦-"
  },
  {
    "id": "69-supervga_display_adapters__svga_.html",
    "t": "SuperVGA Display Adapters (SVGA)",
    "b": "█▌Overview▐█\n VESA is an acronym for Video Electronics Standards Association. In 1989,\n this group saw that IBM was not taking up the reigns to define standards\n for advanced SVGA or SuperVGA video systems that were evolving. Each\n manufacturer had different video mode numbers and wildly-varying BIOS\n support functions.\n\n The VESA standard has not been adopted universally, and with the growing\n popularity of Windows, emphasis has been placed on Windows video drivers.\n However, OEMs that do implement VESA support enjoy some compatibility with\n a wider range of non-Windows SuperVGA-aware applications. OEMs may\n include VESA support in ROM or distribute a device driver or TSR that adds\n the new support.\n\n TECH Help! covers the following SVGA topics:\n\n VESA/SVGA BIOS Functions··· includes VGA modes\n VESA/SVGA Video Modes······ covers VGA services available via ROM-BIOS\n\n All features of the VGA (and lesser systems) are supported on all SVGA\n adaptors. In text modes, the SVGA's video memory begins at b800:0000 and\n in hi-res graphics modes, video memory begins at a000:0.\n\n█▌Testing for an SVGA▐█\n Alas, there is NO certain way to know if you are running on a SuperVGA;\n witness the chaos when you choose the wrong video driver with some\n software!\n\n However, you can check for VESA support via INT 10H 4f00H. If VESA/SVGA\n BIOS is present, it returns with AX=004fH and lots of useful information\n at ES:BX.\n\n Although some SuperVGAs support some new text-mode capabilities (such as\n 132-column screen modes), SVGA-awareness is usually needed only by high-\n end, non-Windows graphics applications.\n\nSee Also: CGA\n EGA\n MDA\n VGA\n -♦-\n .E"
  },
  {
    "id": "70-video_graphics_array__vga_.html",
    "t": "Video Graphics Array (VGA)",
    "b": "█▌Overview▐█\n The VGA is generally upwardly-compatible with the CGA▲, EGA▲, and MDA▲,\n but it has increased graphics resolution and color capabilities. It was\n introduced in 1987 with IBM's PS/2 line and is currently the most often\n seen video standard. TECH Help! covers the following VGA and general\n video topics:\n\n Video Modes ........... includes VGA modes\n Video Services ........ INT 10H video services\n Video Memory Layouts .. accessing VGA video memory\n\n VGA Data Areas ........ BIOS data variables specific to EGA\n BIOS Data Area ........ includes video-specific variables in low memory\n\n Screen Attributes ..... codes determine colors for text mode\n Color Table ........... exhaustive listing of screen attributes\n\n VGA I/O Ports ......... I/O port addresses; video controller registers\n VGA Pin Outs .......... connectors on VGA cards\n\n Font Definition Data .. layout of binary data that defines a font\n .CPI Font Files ....... the DOS interface for EGA font definition\n\n It supports 25-, 43-, and 50-line text modes and graphics modes up to\n 640x400 with 256 colors. You can redefine fonts and remap the color\n palette.\n\n In text mode, video memory begins at b800:0. In graphics modes 0dH-10H,\n video memory is at a000:0 (see Video Memory Layouts).\n\n█▌Testing for a VGA▐█\n To see if you are running on a VGA, use INT 10H 1bH. If that fails, see\n EGA, CGA, or MDA for fall-back tests.\n\nSee Also: CGA\n EGA\n MDA\n SuperVGA\n -♦-"
  },
  {
    "id": "71-ega_vga_data_areas.html",
    "t": "EGA/VGA Data Areas",
    "b": "These data variables are defined when an EGA or VGA is installed.\n\n Address Size Contents (most are in BIOS Data Area)\n ▀▀▀▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n 0000:0074 4 prVidInit INT 1dH address of VidInitRec\n 0000:010c 4 prFont INT 43H addr of Font Definition Data for gfx\n\n 0040:0085 2 wPoints height of character matrix (scan lines)\n 0040:0087 1 bInfo bit fields in EgaMiscInfoRec layout\n 0040:0088 1 bInfo2 bit fields in EgaMiscInfo2Rec layout\n 0040:0089 1 rFlags bit fields in VgaFlagsRec layout (VGA only)\n 0040:008A 1 bDccIdx current display combo in VgaDccRec (VGA only)\n 0040:00a8 4 pfrSavePtr far address of an EgaSavePtrRec ═══╗\n ╔═══════════════════════════════════════════════════════════╝\n ╚►┌ EgaSavePtrRec ─┐\n │ pfrVidParms ════► EgaVidParmsRec\n │ pfrDynParms ════► EgaDynamicSaveRec or 0000:0000\n │ pfrTxtAuxFnt ════► EgaTxtFontRec ════╗ or 0000:0000\n │ pfrGfxAuxFnt ════► EgaGfxFontRec ═══╗║ or 0000:0000\n │ pfrSavePtr2 ════► VgaSavePtr2Rec ═╗║║\n └────────────────┘ ║║║\n╔═════════════════════════════════════════╝║║\n║╔═════════════════════════════════════════╝║\n║║╔═════════════════════════════════════════╝\n║║╚►┌ EgaTxtFontRec ──┐\n║║ │ font info │\n║║ │ pfFontDefData ════► Font Definition Data\n║║ └─────────────────┘\n║║\n║╚═►┌ EgaGfxFontRec ──┐\n║ │ font info │\n║ │ pfFontDefData ════► Font Definition Data\n║ └─────────────────┘\n║\n╚══►┌ VgaSavePtr2Rec ┐ (VGA only)\n │ pfrDccRec ════► VgaDccRec\n │ pfrTxtAuxFnt ════► EgaTxtFontRec or 0000:0000\n │ pfrPalProf ════► VgaPaletteProfileRec or 0000:0000\n └────────────────┘\n\n INT 10H 1bH ════► VgaDynamicStateRec ════► VgaStaticFnalityRec\n\nSee Also: EGA\n VGA\n Video Memory Layouts\n EGA I/O Ports\n VGA I/O Ports\n BIOS Data Area\n -♦-"
  },
  {
    "id": "72-egamiscinforec.html",
    "t": "EgaMiscInfoRec",
    "b": "The bytes at 0040:0087 and 0040:0088 in the BIOS Data Area are bit flags\n containing information pertaining to the status of the EGA▲ and\n VGA▲. Most of this can be obtained via INT 10H 12H.\n\n EgaMiscInfoRec\n ╓7┬6┬5┬4┬3┬2┬1┬0╖\n ║ │ram│0│a│0│m│c║ 0040:0087 -- EGA Miscellaneous Information\n ╙╥┴─┴─┴─┴╥┴─┴╥┴╥╜ bit\n ║ ╚╦╝ ║ ║ ╚═► 0: 1=cursor emulation enabled; see INT 10H 12H BL=34H\n ║ ║ ║ ╚═══► 1: 1=EGA is attached to a Monochrome Display\n ║ ║ ╚═══════► 3: 1=EGA is not active\n ║ ╚════════════► 5-6: EGA total RAM (00=64K; 01=128K; 10=192K; 11=246K)\n ╚═══════════════► 7: high bit of video mode (1=screen is not cleared)\n\n EgaMiscInfo2Rec\n ╓7┬6┬5┬4┬3┬2┬1┬0╖\n ║feature│ DIPs ║ 0040:0088 -- son of EGA Miscellaneous Information\n ╙─┴─┴─┴─┴─┴─┴─┴─╜ bit\n ╚══╦══╝ ╚═════╩═► 0-3: DIP switch settings. See EGA Switch Settings\n ╚════════════► 4-7: Feature bits\n\nSee Also: EGA Data Areas\n EGA I/O Ports\n EGA\n -♦-"
  },
  {
    "id": "73-vgaflagsrec.html",
    "t": "VgaFlagsRec",
    "b": "The byte at 0040:0089 in the BIOS Data Area is a set of bit flags\n containing information pertaining to the status of the VGA▲.\n\n VgaFlagsRec\n ╓7┬6┬5┬4┬3┬2┬1┬0╖\n ║r│s│0│r│p│m│g│a║ 0040:0089 -- VGA Miscellaneous Flags\n ╙╥┴╥┴─┴╥┴╥┴╥┴╥┴╥╜ bit mask\n ║╔║═══╝ ║ ║ ║ ╚═► 0: 01H VGA is active; 0=VGA is disabled/inactive\n ║║║ ║ ║ ╚═══► 1: 02H gray-scale summing is enabled; 0=disabled\n ║║║ ║ ╚═════► 2: 04H using monochrome monitor; 0=color display\n ║║║ ╚═══════► 3: 08H default palette loading; 0=keeps same colors\n ║║╚═════════════► 5: 20H DCC display switching enabled; 0=not enabled\n ╚╩══════════════►7,4: 90H text mode scan lines (bits 7 and 4 together)\n bit7 bit4 masked\n 0 0 00H 350-line mode\n 0 1 10H 400-line mode\n 1 0 80H 200-line mode\n 1 1 90H (reserved)\nSee Also: EGA/VGA Data Areas\n BIOS Data Area\n -♦-"
  },
  {
    "id": "74-egasaveptrrec.html",
    "t": "EgaSavePtrRec",
    "b": "The 4-byte pointer at 0040:00a8 has been named SAVE_PTR by an imaginative\n programmer. It points to a table of EGA/VGA data block pointers. You can\n change this address to point to a different data area in which you define\n your own fonts and other options.\n\n To make a change, copy the current table and then modify the copy. You\n can use TSR techniques to make your customized table resident in memory to\n enable it with each mode change.\n\nEgaSavePtrRec\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 4 pfrVidParms addr of a table of EgaVidParmsRec structures\n +4 4 pfrDynParms addr of an EgaDynamicSaveRec or 0:0\n +8 4 pfrTxtAuxFnt addr of an EgaTxtFontRec structure or 0:0\n +0cH 4 pfrGfxAuxFnt addr of an EgaGfxFontRec structures or 0:0\n +10H 4 pfrSavePtr2 (VGA only) addr of a VgaSavePtr2Rec or 0:0\n +14H 8 res reserved (two far pointers)\n 28 size of an EgaSavePtrRec structure\n\n pfrVidParms This MUST exist. It is initially set to point to a table in\n ROM. The table should be 1472 bytes long, with 64 bytes for\n each of 23 (17H) different video modes. In this parameter\n table: Modes 0-10H are the modes listed in Video Modes for 64K\n EGAs. Modes 11H-12H are for 350-line graphics with 128K+ RAM\n on board. Modes 13H-17H are the 350-line versions of text\n modes 0-3 when used with the Enhanced Color Display.\n\n See EgaVidParmsRec for the layout.\n\n pfrDynParms Initially 0000:0000 (not used). When present, this points to\n an EgaDynamicSaveRec to hold the current settings for EGA and\n VGA palettes. This is updated when the BIOS updates the\n Attribute Controller registers (as in INT 10H 1000H).\n\npfrTxtAuxFnt Initially 0000:0000 (not used). When present, this points to\n an EgaTxtFontRec structure that overrides all or part of the\n font definition for specified text modes; the font will be\n loaded to the character generator when selected text modes are\n initialized. You can use this vector to setup unusual and\n exotic fonts or to override just a few characters for national\n language support.\n\n On VGAs, an additional character set may be set up for\n selected modes by setting up a VgaSavePtr2Rec.\n\npfrGfxAuxFnt Initially 0000:0000 (not used). When present, this points to\n an EgaGfxFontRec structure. The font information will be used\n to generate characters is specified graphics modes.\n\n pfrSavePtr2 This field contains an address on VGAs only. It points to a\n VgaSavePtr2Rec which sets special options foe VGA video\n systems.\n\nSee Also: EGA Data Areas\n EGA I/O Ports\n EGA\n -♦-"
  },
  {
    "id": "75-egavidparmsrec.html",
    "t": "EgaVidParmsRec",
    "b": "One field of the EgaSavePtrRec points to an EgaVidParmsRec. This\n structure is initialized by the video system BIOS.\n\nEgaVidParmsRec\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 1 bCrtClms screen columns (e.g., 80)\n +1 1 bCrtRows screen rows (e.g., 25)\n +2 1 bCrtPoints height of character matrix (e.g., 14 or 8)\n +3 2 wCrtLen size of video buffer, in bytes (e.g., 2000)\n +5 4 abSeqRegs values for Sequencer regs 1-4 (port 3c5H)\n +9 1 bMiscOutReg value of Miscellanous Output reg (port 32cH)\n +0aH 25 abCrtcRegs values for CRTC regs 00-18H (port 3d5H)\n +23H 20 abAttrRegs values for Attrib Ctrlr regs 00-13H (port 3c0H)\n +37H 9 abGfxRegs values for Graphics Ctrlr regs 0-8 (port 3cfH)\n 64 size of an EgaVidParmsRec\n\nSee Also: EGA Data Areas\n EGA I/O Ports\n EGA\n -♦-"
  },
  {
    "id": "76-egadynamicsaverec.html",
    "t": "EgaDynamicSaveRec",
    "b": "One field of the EgaSavePtrRec points to an EgaDynamicSaveRec. Initially,\n this structure does not exist, but may be installed by task switching or\n other TSR code.\n\nEgaDynamicSaveRec\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 16 abCtrPal current contents Graphics Controller Palette regs\n +10H 1 bCrtOvrScan current contents Graphics Controller Overscan reg\n +11H 239 res (reserved)\n 256 size of an EgaDynamicSaveRec\n\nSee Also: EGA Data Areas\n EGA I/O Ports\n EGA\n -♦-"
  },
  {
    "id": "77-egatxtfontrec.html",
    "t": "EgaTxtFontRec",
    "b": "One field of the EgaSavePtrRec points to an EgaTxtFontRec. Initially,\n this structure does not exist, but it may be installed by DOS national\n language support or other TSR code.\n\nEgaTxtFontRec\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 1 bLenOneChar size, in bytes, of one character definition\n +1 1 bRamBank character generator RAM bank\n +2 2 wCharCnt number of characters defined\n +4 2 wFirstChar ASCII code of first character defined\n +6 4 pfabDefTbl far address of the Font Definition Data table.\n The table is a set of wCharCnt bitmaps, each\n containing bLenOneChar bytes (usually 8 or 14).\n See INT 1FH for related info.\n +0aH 1 bAplcblRows applies when video mode has this many text lines\n +0bH n abModes use for these video modes (variable-length table)\n +n+0bH 1 ffH ffH indicates end of abModes table\n n+0cH size of an EgaTxtFontRec\n\n On VGA systems, a second 256-character font may be setup by initializing\n the EgaSavePtrRec.pfSavePtr2 to a VgaSavePtr2Rec and setting its\n pfTxtAuxFont field to point to another EgaTxtFontRec structure. This\n secondary character set would be activated according to the mode values\n in the abModes field.\n\nSee Also: Font Definition Data\n EGA Data Areas\n EGA I/O Ports\n EGA\n -♦-"
  },
  {
    "id": "78-egagfxfontrec.html",
    "t": "EgaGfxFontRec",
    "b": "One field of the EgaSavePtrRec points to an EgaGfxFontRec. Initially,\n this structure does not exist, but it may be installed by DOS national\n language support or other TSR code.\n\n This structure affects how characters are drawn when using the BIOS\n interface to display character while in a graphics mode. Most software\n that displays text in graphics mode avoid the sluggish BIOS interface--so\n this structure is used rarely.\n\nEgaGfxFontRec\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 1 bAplcblRows use when video mode has this many text lines\n +1 2 wLenOneChar size, in bytes, of one character definition\n +3 4 pfabDefTbl far address of the font definition table.\n The table is a set of wCharCnt bitmaps, each\n containing bLenOneChar bytes (usually 8 or 14).\n See INT 1FH for related info.\n +7 n abModes use for these video modes (variable-length table)\n +n+7 1 ffH ffH indicates end of abModes table\n n+8 size of an EgaGfxFontRec\n\nSee Also: Font Definition Data\n EGA Data Areas\n EGA I/O Ports\n EGA\n -♦-"
  },
  {
    "id": "79-vgasaveptr2rec.html",
    "t": "VgaSavePtr2Rec",
    "b": "One field of the EgaSavePtrRec is a pointer to a VgaSavePtr2Rec. This\n structure is initialized by the VGA video system BIOS.\n\nVgaSavePtr2Rec\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 2 wRecLen size of this structure, in bytes (normally 1aH)\n +2 4 pfrDccRec address of a VgaDccRec (Display Combo Code table)\n +6 4 pfrTxtAuxFnt address of an EgaTxtFontRec\n +0aH 4 pfrPalProf address of a VgaPaletteProfileRec (user palette\n profile table) or 0000:0000\n +0eH 12 res (three dword values reserved)\n 30 size of a VgaSavePtr2Rec\n\n wRecLen the size, in bytes of this structure.\n\n pfrDccRec address of a VgaDccRec structure which lists all combinations\n of video subsystems supported by the VGA BIOS. This structure\n has meaning only on systems in which two video systems are\n active. The BIOS initializes this to point to a table in ROM.\n\npfrTxtAuxFnt Initially 0000:0000 (not used). When present, this points to\n an EgaTxtFontRec structure that overrides all or part of the\n font definition for specified text modes; the font will be\n loaded to the character generator when selected text modes are\n initialized.\n\n Note that the EgaSavePtrRec also defines a text mode character\n set override. You would use this one only to define an\n additional font used in video modes other than those covered\n by the record pointed to in EgaSavePtrRec.\n\n pfrPalProf Initially 0000:0000 (not used). When present this points to a\n VgaPaletteProfileRec containing various palette settings to be\n used for defaults no mode resets.\n\nSee Also: VGA Data Areas\n VGA I/O Ports\n VGA\n -♦-"
  },
  {
    "id": "80-vgapaletteprofilerec.html",
    "t": "VgaPaletteProfileRec",
    "b": "One field of the VgaSavePtr2Rec points to a VgaPaletteProfileRec.\n Initially, this structure does not exist, but may be installed by task\n switching or other TSR code.\n\n This is especially needed when secondary fonts are used; you will want to\n define palettes which are consistent and independent of video attribute\n bit 3 (which switches character sets).\n\nVgaPaletteProfileRec\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 2 wRecLen size of this structure, in bytes (normally 1aH)\n +0 1 bUnderline underlining: 01=enable in all text modes\n 00=enable in monochrome text mode\n ff=disable in all text modes\n +1 3 res (reserved)\n +4 2 wAtcRegCnt internal palette count: 0-17 (17 is normal)\n +6 2 wAtcRegIdx internal palette index: 0-16 (16 is normal)\n +8 4 pfabRegTbl address of internal palette data\n +0cH 2 wDacRegCnt external palette count: 0-256 (0 is normal)\n +0eH 2 wDacRegIdx external palette index: 0-255 (0 is normal)\n +10H 4 pfabDacTbl address of external palette data\n +14H n abModes use for these video modes (variable-length table)\n +n+14H 1 ffH 0ffH indicates end of abModes table\n n+21 size of a VgaPaletteProfileRec\n\nSee Also: VGA Data Areas\n VGA I/O Ports\n VGA\n -♦-"
  },
  {
    "id": "81-vgadccrec.html",
    "t": "VgaDccRec",
    "b": "One field of the VgaSavePtr2Rec points to a VgaDccRec. This structure is\n initialized by the VGA video system BIOS to point to a table in ROM.\n\n Information in this structure identifies valid combinations of video\n subsystems which are supported by your VGA BIOS. For instance, your VGA\n BIOS may support both an EGA and a VGA while mine won't.\n\n See INT 10H 1aH for info on querying valid combinations and switching back\n and forth between monitors.\n\nVgaDccRec\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 1 bEntries entries in wCombos\n +1 1 bVersion DCC table version number\n +2 1 bMaxTypeCode maximum display type code\n +3 1 res (reserved)\n +4 2 wCombos a variable-length list of byte-pairs identifying\n valid display combinations. For instance, 0108H\n means supports a monochrome adapter and a color\n VGA adapter. See INT 10H 1aH for codes.\n 4+(2*n) size of a VgaDccRec structure\n\nSee Also: VGA Data Areas\n VGA I/O Ports\n VGA\n -♦-"
  },
  {
    "id": "82-vga_dynamic_state_table.html",
    "t": "VGA Dynamic State Table",
    "b": "BIOS function INT 10H 1bH provides a mechanism for obtaining a bunch of\n information about the capabilities of and the current state of the active\n display. That information is generated dynamically when called and\n returned in the 64-byte buffer addressed by ES:DI. It is formatted as\n follows:\n\nVgaDynamicStateRec\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 4 pfrFnality address of a VgaStaticFnalityRec. This is a\n static (unchanging) table in ROM that describes\n your VGA system's capabilities.\n +4 1 bCurMode current video mode\n +5 2 bCrtClms screen columns (e.g., 80)\n +7 2 wCrtBufLen size of displayed portion of video buffer\n +9 2 pCrtPgStart starting address (offset) in regen buffer\n +0bH 16 awCrsrPos cursor positions for pages 0-7 (row,column,\n row,column,...)\n +1bH 2 wCrsrType cursor shape (start/end) as CX in INT 10H 01H\n +1dH 1 bCurPg current active video page\n +1eH 2 wCrtcPort CGA/MDA CRT ctrlr port addr (3b?=mono; 3d?=color)\n +20H 1 bModeSetReg current setting of 3?8 reg (CGA Mode Select reg)\n +21H 1 bClrSetReg current setting of 3?9 reg (CGA Color Select reg)\n +22H 1 bCrtRows character rows on screen\n +23H 2 bCrtPoints height of character matrix (scan lines per\n character cell; e.g., 14 or 8)\n +25H 1 bCurDcc active Display Combination Code (see INT 10H 1aH)\n +26H 1 bAltDcc alternate DCC (00 if only one video system)\n +27H 2 wMaxClrs colors in current video mode (0000=monochrome)\n +29H 1 bMaxPgs count of display pages in current video mode\n +2aH 1 bScanLnsCode scan lines in current video mode:\n 0=200, 1=350, 2=400, 3=480\n +2bH 1 bFont1 primary font block (based on INT 10H 1103H)\n +2cH 1 bFont2 secondary font block\n +2dH 1 rMiscFlags miscellaneous state information\n ┌7┬6┬5┬4┬3┬2┬1┬0┐\n │0 0│b│c│p│m│g│ │\n └─┴─┴╥┴╥┴╥┴╥┴╥┴╥┘ bit mask\n ║ ║ ║ ║ ║ ╚══► 0: 01H all modes on all displays active\n ║ ║ ║ ║ ╚════► 1: 02H gray-scale summing is active\n ║ ║ ║ ╚══════► 2: 04H monochrome display attached\n ║ ║ ╚════════► 3: 08H default palette loading disabled\n ║ ╚══════════► 4: 10H cursor emulation active\n ╚════════════► 5: 20H blinking enabled; 0=bold bkgnd\n +2eH 3 res (reserved)\n +31H 1 bVidMemCode video memory available:\n 0=64K, 1=128K, 2=192K, 3=256K\n +32H 1 rSaveStatus status of EgaSavePtrRec information\n ┌7┬6┬5┬4┬3┬2┬1┬0┐\n │0 0│d│p│g│t│s│c│\n └─┴─┴╥┴╥┴╥┴╥┴╥┴╥┘ bit mask\n ║ ║ ║ ║ ║ ╚══► 0: 01H 512-character set active\n ║ ║ ║ ║ ╚════► 1: 02H dynamic save area active\n ║ ║ ║ ╚══════► 2: 04H text font override active\n ║ ║ ╚════════► 3: 08H graphics font override active\n ║ ╚══════════► 4: 10H palette override active\n ╚════════════► 5: 20H DCC extension active\n +33H 0dH res (reserved)\n 64 size of a VgaDynamicStateRec\n\nSee Also: INT 10H 1aH\n VgaStaticFnalityRec\n VGA Data Areas\n VGA I/O Ports\n VGA\n -♦-"
  },
  {
    "id": "83-vga_static_functionality_table.html",
    "t": "VGA Static Functionality Table",
    "b": "A field of the VgaDynamicStateRec obtained via INT 10H 1bH points to a\n data area in ROM that is formatted as a VgaStaticFnalityRec.\n\n This structure contains details of the capabilities of the active video\n system. You cannot install your own version of this record.\n\nVgaStaticFnalityRec\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 1 bModes1 Video modes supported:\n bit 0=mode 00H∙∙∙bit 7=mode 07H\n +1 1 bModes2 bit 0=mode 08H∙∙∙bit 7=mode 0FH\n +2 1 bModes3 bit 0=mode 10H∙∙∙bit 3=mode 13H\n +3 4 res (reserved could contain modes up to 56)\n +7 1 bScanLnsFlgs scan lines available in text modes:\n bit 0=200, bit 1=350, bit 2=400\n +8 1 bFontBlks font blocks available in text modes\n (4 for EGA, 8 for VGA)\n +9 1 bMaxFonts max active font blocks in text mode\n (2 for EGA and VGA)\n +0aH 1 rMiscFlags1 miscellaneous capabilities:\n ┌7┬6┬5┬4┬3┬2┬1┬0┐\n │p│p│p│c│p│f│g│m│\n └╥┴╥┴╥┴╥┴╥┴╥┴╥┴╥┘ bit mask\n ║ ║ ║ ║ ║ ║ ║ ╚══► 0: 01H all modes on all displays\n ║ ║ ║ ║ ║ ║ ╚════► 1: 02H gray-scale summing (INT 10H 101bH)\n ║ ║ ║ ║ ║ ╚══════► 2: 04H char set loading (INT 10H 11H)\n ║ ║ ║ ║ ╚════════► 3: 08H default palette loading\n ║ ║ ║ ╚══════════► 4: 10H cursor emulation\n ║ ║ ╚════════════► 5: 20H 64-color palette (INT 10H 10H)\n ║ ╚══════════════► 6: 40H video DAC palette loading\n ╚════════════════► 7: 80H palette loading via ATC\n\n +0bH 1 rMiscFlags2 more miscellaneous capabilities:\n ┌7┬6┬5┬4┬3┬2┬1┬0┐\n │0 0 0 0│d│b│s│l│\n └─┴─┴─┴─┴╥┴╥┴╥┴╥┘ bit mask\n ║ ║ ║ ╚══► 0: 01H light pen support (INT 10H 04H)\n ║ ║ ╚════► 1: 02H save/restore state (INT 10H 1cH)\n ║ ╚══════► 2: 04H blink/bold mapping (INT 10H 1003H)\n ╚════════► 3: 08H DCC control (INT 10H 1aH)\n\n +0cH 2 res (reserved)\n\n +0eH 1 rSaveCaps save area capabilities\n ┌7┬6┬5┬4┬3┬2┬1┬0┐\n │0 0│d│p│g│t│s│c│\n └─┴─┴╥┴╥┴╥┴╥┴╥┴╥┘ bit mask\n ║ ║ ║ ║ ║ ╚══► 0: 01H multiple 512-character set\n ║ ║ ║ ║ ╚════► 1: 02H dynamic save area\n ║ ║ ║ ╚══════► 2: 04H text font override\n ║ ║ ╚════════► 3: 08H graphics font override\n ║ ╚══════════► 4: 10H palette override\n ╚════════════► 5: 20H DCC extension\n\n +0fH 1 res (reserved)\n 16 size of a VgaStaticFnalityRec structure\n\nSee Also: INT 10H 1aH\n VgaDynamicStateRec\n VGA Data Areas\n VGA I/O Ports\n VGA\n -♦-"
  },
  {
    "id": "84-supervga_info_block.html",
    "t": "SuperVGA Info Block",
    "b": "This structure describes the capabilities of a VESA SuperVGA-compliant\n video system. Use INT 10H 4f00H to obtain this information.\n\nSvgaInfoRec\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 4 abSignature will contain 'VESA'\n +4 2 wVersion VESA version number; hi-byte=major; low=minor\n +6 4 pfszOEMStr ASCIIZ▲ Manufacture ID or other text info\n +0aH 4 rAbilities four bytes of bit flags\n +0eH 4 pfawModes address of a list of 16-bit supported mode values\n 18 size of formatted portion of an SvgaInfoRec\n +12H 238 abData may be filled with mode data\n 256 required size for return buffer\n\n abSignature must be 'VESA' (that is, 56H, 45H, 53H, 42H)\n\n wVersion version number for compatibilities test. The high byte\n (offset 5) is the major number and the low byte (offset 4) is\n the minor revision number (e.g., 0201h is version 1.2).\n Higher-numbered versions are guaranteed to be fully-compatible\n with lower-numbered versions.\n\n pfszOEMStr 32-bit far address of an ASCIIZ▲ string defined by the\n manufacturer. This may contain the OEM's name and any other\n info desired, such as the name of the video chip, developers\n names, whatever.\n\n rAbilities This is a 32-bit bit array, presumable with each bit\n identifying some capability of this implementation of VESA.\n With version 1.0, all bits are reserved and must be 0.\n\n pfawModes far address of a variable-length list of supported video\n modes. These are 16-bit VESA mode numbers, followed by ffffH\n to indicate the end of the list.\n\n See VESA/SVGA Video Modes for related information.\n\nSee Also: INT 10H 4F00H\n VESA/SVGA Video Modes\n SvgaModeInfoRec\n SVGA\n -♦-"
  },
  {
    "id": "85-vesa_svga_video_modes.html",
    "t": "VESA/SVGA Video Modes",
    "b": "VESA SuperVGA mode numbers are 16-bit values. Bit 15 must be 0 and bit 8\n must be 1; thus potential mode numbers range from 100H through 7ffH. You\n may also use any of the pre-VESA mode numbers in VESA/SVGA BIOS Services.\n\n As of VESA ver. #VS911922, the following extended video modes are defined:\n\n Mode # Resolution Colors Memory Model\n ▀▀▀▀▀▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀ ▀▀▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n 00H-13H (see Video Modes)\n 14H-7fH (old OEM-dependant modes)\n 100H 640x400 256 packed pixel\n 101H (1) 640x480 256 packed pixel\n 102H (2) 800x600 16 4-plane planar\n 103H 800x600 256 packed pixel\n 104H 1024x768 16 4-plane planar\n 105H 1024x768 256 packed pixel\n ─────────────────────────────────────────\n 108H 80x60 16 text mode\n 109H 132x25 16 text mode\n 10aH 132x43 16 text mode\n ─────────────────────────────────────────\n 110H 640x480 32768 packed pixel\n 111H 640x480 65536 packed pixel\n 112H 640x480 16.7M packed pixel\n 113H 800x600 32768 packed pixel\n 114H 800x600 65536 packed pixel\n 116H 1024x768 32768 packed pixel\n 117H 1024x768 65536 packed pixel\n ??? (OEM-defined codes supported by OEM implementation of VESA)\n ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n (1) This mode (640x480x256) is defined as VGA mode 13H when using the\n standard INT 10H 00H function.\n (2) This mode (800x600x16) is defined as 6aH (via INT 10H 00H) by\n various video BIOS makers prior to VESA adoption.\n\n Use INT 10H 4f00H to see which video modes are supported.\n Use INT 10H 4f02H to select a mode.\n Use INT 10H 4f01H to get information about a mode.\n\n█▌Mode-Switch Memory Clear▐█\n On video mode initialization, video memory is normally cleared to blanks\n or black pixels.\n\n You can switch modes without clearing video memory by ORing 80H (that is,\n setting bit 7) to a mode number when you select the mode.\n\nSee Also: SVGA\n VESA/SVGA BIOS Services\n -♦-"
  },
  {
    "id": "86-supervga_mode_info_block.html",
    "t": "SuperVGA Mode Info Block",
    "b": "This structure is returned by INT 10H 4f01H to obtain information about a\n specified video mode when VESA/SCGA support is present. It will return\n info about standard CGA/EGA/VGA modes as well.\n\nSvgaInfoRec\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 2 rModeAttrs bit fields: mode characteristics\n +2 1 rWinAAttrs bit fields: windowing system characteristics\n +3 1 rWinBAttrs bit fields: windowing system characteristics\n +4 2 wWinGran window granularity, in Kbytes\n +6 2 wWinSize window size, in KB\n +8 2 wWinASeg window A segment address\n +0aH 2 wWinBSeg window B segment address\n +0cH 4 pfWinFnPtr far address of window-handling function\n +10H 2 wScanLineSiz bytes per scan line\n────────────────────────── Extended/optional information; present only\n when rModeAttrs bit 1 is 1.\n +12H 2 wHorizRes horizontal resolution, in pixels or char cells\n +14H 2 wVertRes vertical resolution, in pixels or char cells\n +16H 1 bCharWide character cell width\n +17H 1 bCharHigh character cell height\n +18H 1 bPlaneCnt number of video memory planes\n +19H 1 bBitsPerPel number of bits per pixel\n +1aH 1 bBankCnt number of video memory banks\n +1bH 1 bMemModel memory model type code\n +1cH 1 bBankSize video memory bank size, in Kbytes\n +1dH 227 res reserved\n 256 required size of caller buffer\n\n rModeAttrs bit flags, defined as follows:\n 1\n ┌5- -8╥7┬6┬5┬4┬3┬2┬1┬0┐\n │0...0║0 0 0│g│c│o│x│s│\n └─ - ─╨─┴─┴─┴╥┴╥┴╥┴╥┴╥┘ bit mask\n ║ ║ ║ ║ ╚══► 0: 01H mode supported with this hardware\n ║ ║ ║ ╚════► 1: 02H extended information, starting at\n ║ ║ ║ offset 12H, is present\n ║ ║ ╚══════► 2: 04H supports output fns such as\n ║ ║ INT 10H 0aH and INT 10H 0eH\n ║ ╚════════► 3: 08H 1=color mode; 0=monochrome mode\n ╚══════════► 4: 10H 1=graphics mode; 0=text mode\n rWinAAttrs and...\n rWinBAttrs bit flags that describe characteristics of the CPU memory\n windowing scheme for the (maximum of two) windows:\n ┌7┬6┬5┬4┬3┬2┬1┬0┐\n │0 0 0 0 0│w│r│s│\n └─┴─┴─┴─┴─┴╥┴╥┴╥┘ bit mask\n ║ ║ ╚══► 0: 01H 1=window (A or B) supported\n ║ ╚════► 1: 02H 1=window is readable\n ╚══════► 2: 04H 1=window is writable\n\n wWinGran Window granularity: Specifies the smallest boundary, in KB,\n on which the window can be placed in the video memory.\n\n wWinSize specifies the size of the window in KB.\n\n wWinASeg and...\n wWinBSeg address specify the segment addresses where the windows are\n located in the CPU address space.\n\n pfWinFnPtr is the far address of the video memory windowing function.\n The windowing function can be invoked either through VESA BIOS\n fn 05H, or by calling the function directly. A direct call\n will provide faster access to the hardware paging registers\n than using INT 10h, and is intended to be used by high\n performance applications. See INT 10H 4f05H for details.\n\nwScanLineSiz size, in bytes, of a video-memory scan line. This is the\n \"logical\" width, which may be larger than the dimensions\n implied by the physical video mode.\n\n───────────── Extended/optional info; present when rModeAttrs bit 1 is set.\n wHorizRes and...\n wVertRes horizontal and vertical resolution of this mode. In graphics\n modes (wModeAttrs bit 4 is set), this is expressed in pixels.\n In text modes (wModeAttrs bit 4 is clear), this is expressed\n in character cells.\n\n bCharWide and...\n bCharHigh width and height of a character cell, in pixels\n\n bPlaneCnt video memory planes.\n\n bBitsPerPel specifies the number of bits that define the color of one\n pixel. 16-color and 256-color graphics modes would specify 4\n and 8 respectively.\n\n Nonstandard memory organizations can be specified using this\n field and the bPlaneCnt field. For example, a 16-color\n packed-pixel mode would be described as having 1 plane and\n 4 bits per pixel.\n\n bBankCnt number of banks (groups of scan lines). Given a scan line s,\n you should select bank s MOD bBankCnt and address the scan\n line as line INT(s/bBankCnt).\n\n For instance, CGA graphics modes have two banks; even numbered\n lines start at b800:0000 and odd-numbered lines start at\n b800:2000. Hercules graphics modes have four banks starting\n at b000:0000, 2000, 4000, and 6000.\n\n bMemModel specifies the general type of memory organization used in this\n mode. The following models have been defined:\n\n 00H = Text mode\n 01H = CGA graphics\n 02H = Hercules graphics\n 03H = 4-plane planar\n 04H = Packed pixel\n 05H = Non-chain 4, 256 color\n 06H-0fH = Reserved, to be defined by VESA\n 10H-ffH = To be defined by OEM\n\n bBankSize specifies the size of a bank (group of scan lines) in units\n of 1K. For CGA and Hercules graphics modes this is 8, as each\n bank is 8192 (2000H) bytes in length. For modes that don't\n have scanline banks (such as VGA modes 0Dh-13h), this field\n should be set to 0.\n\nSee Also: SVGA\n VESA/SVGA BIOS Services\n -♦-"
  },
  {
    "id": "87-screen_attributes.html",
    "t": "Screen Attributes",
    "b": "The text-mode screen is laid out as a series of byte-pairs, where the\n first byte is any of 256 ASCII characters and the second byte is a video\n attribute; see Color Table for a complete list. For color/graphics\n adapters in text mode, the attribute is defined as:\n\n ScrnAttrRec -- blink enabled (default BIOS setting)\n ╓7┬6┬5┬4┬3┬2┬1┬0╖\n ║ │bkgnd│ frgnd ║\n ╙─┴─┴─┴─┴─┴─┴─┴─╜ bits mask\n ║ ╚═╦═╝ ╚═════╩═► 0-3: 0fH foreground color\n ║ ╚═══════════► 4-6: 70H background color\n ╚═══════════════► 7: 80H 1=foreground flashes\n\n ScrnAttrRec -- blink disabled\n ╓7┬6┬5┬4┬3┬2┬1┬0╖\n ║ bkgnd │ frgnd ║\n ╙─┴─┴─┴─┴─┴─┴─┴─╜ bits mask\n ╚══╦══╝ ╚═════╩═► 0-3: 0fH foreground color\n ╚════════════► 4-6: f0H background color\n\n bits 0-3 the foreground color (the color of the character itself). It\n may have one of the values:\n 00H black 08H gray\n 01H blue 09H bright blue\n 02H green 0aH bright green\n 03H cyan 0bH bright cyan\n 04H red 0cH bright red\n 05H magenta 0dH bright magenta\n 06H brown 0eH yellow\n 07H white 0fH bright white\n\n bits 4-6 the background color. When blink is enabled (the default BIOS\n setting), this may have only values 0xH-7xH; that is, dark\n colors. When blink is disabled, the background may be any of\n the 16 colors (0xH-fxH).\n\n bit 7 foreground blinks. When blink is enabled (the default), this\n bit may be 1 (values 8xH-FxH) to make the foreground color\n flash. When blinks is disabled, this bit is part of the\n background color.\n\n█▌Blink Enabled/Disabled▐█\n By default, the video hardware is set to interpret attribute bit 7 as the\n \"foreground blinks\" flag. This makes it possible to use only 8 background\n colors. Many modern programs enable all 16 background colors (256\n combinations) by disabling character blink. All standard monitor types\n (MDA▲, CGA▲, EGA▲, and VGA▲) are capable of disabling blink.\n\n On EGA and VGA, just use INT 10H 1003H to enable or disable blinking.\n On MDA and CGA, you can turn off blinking by clearing bit 5 of the Mode\n Select Register. For instance:\n\n mov ax,40H\n mov es,ax\n mov dx,es:[063H] ;get port address of the card\n add dx,4\n\n mov al,es:[065H] ;get current value of Mode Select Register\n and al,0dfH ;mask value by 1101 1111 (to clear bit 5)\n out dx,al ;disable blink\n mov es:[065H],al ;save the new setting\n\n When DOS 4.0+ ANSI.SYS is installed, you may use DOS fn 440cH 5fH to\n change the blink/bold status; see the IoctlDisplayModeRec.wFlags field.\n\n█▌EGA and VGA Colors▐█\n On EGA and VGA adapters, the color attributes can be redefined. An\n attribute byte stored in video memory actually specifies one of 64\n different color combinations (plus blink).\n\n For instance, you can use fn INT 10H 1000H to set the color attribute\n that normally displays as \"black-on-white\" to show as \"yellow-on-blue\" or\n any other combination.\n\n On VGAs, you can have very fine control over the colors displayed. You\n can use INT 10H 1010H (et. al) to reprogram the DAC color registers to\n select any of 262,144 possible colors for any attribute.\n\n█▌EGA and VGA 512-character Fonts▐█\n EGAs and VGAs can be set in a rarely-seen mode in which bit 3 of the\n attribute selects a different screen font. For instance, this provides a\n way to display both italics and upright text simultaneously (though you\n end up with only 8 foreground colors).\n\n ScrnAttrRec -- 512-character set enabled\n ╓7┬6┬5┬4┬3┬2┬1┬0╖\n ║ │bkgnd│s│frgnd║\n ╙─┴─┴─┴─┴─┴─┴─┴─╜ bits mask\n ║ ╚═╦═╝ ║ ╚═══╩═► 0-2: 07H foreground color (0-7)\n ║ ║ ╚═══════► 3: 08H character set (font) number (0-1)\n ║ ╚═══════════► 4-6: 70H background color\n ╚═══════════════► 7: 80H foreground flashes (or bold background)\n\n See INT 10H 1103H (enable/select 512-character font) for details.\n\n█▌MDA Limitations▐█\n Although any attribute can be used on any monitor, some monitors aren't\n capable of displaying the full range of colors. Use this chart for\n selecting pleasing and readable combinations for your target monitor:\n\n TTL Monochrome Monitors▲ █ Black-and-White Monitors\n ▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄█▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\n 01H underline █ 07H normal (white on black)\n 07H normal (white on black) █ 08H grey on black\n 09H bright underline █ 0fH bold (bright white on black)\n 0fH bold (bright white on black) █ 70H reverse (black on white)\n 70H reverse (black on white) █ 78H grey on white\n 81H blinking underline █ 7fH bright white on white\n 87H blinking normal █ 87H blinking normal\n 89H blinking bright underline █ 8fH blinking bold\n 8fH blinking bold █\n\n The IBM Monochrome monitor▲ is able to display only the combinations\n listed above. Other attributes are displayed as \"normal\" white on black.\n\nSee Also: CGA MDA EGA VGA\n Color Table\n Video Modes\n Video Memory Layouts\n BIOS Data Area\n INT 10H\n CGA I/O Ports\n -♦-"
  },
  {
    "id": "88-color_table.html",
    "t": "Color Table",
    "b": "This is an exhaustive list of all text-mode screen attributes. These\ncodes are easily calculated via a simple algorithm; see Screen Attributes.\n\n 00 Black on Black 10 Black on Blue\n 01 Blue on Black 11 Blue on Blue\n 02 Green on Black 12 Green on Blue\n 03 Cyan on Black 13 Cyan on Blue\n 04 Red on Black 14 Red on Blue\n 05 Magenta on Black 15 Magenta on Blue\n 06 Brown on Black 16 Brown on Blue\n 07 White on Black 17 White on Blue\n 08 Grey on Black 18 Grey on Blue\n 09 Brt Blue on Black 19 Brt Blue on Blue\n 0A Brt Green on Black 1A Brt Green on Blue\n 0B Brt Cyan on Black 1B Brt Cyan on Blue\n 0C Brt Red on Black 1C Brt Red on Blue\n 0D Brt Magenta on Black 1D Brt Magenta on Blue\n 0E Brt Yellow on Black 1E Brt Yellow on Blue\n 0F Brt White on Black 1F Brt White on Blue\n\n 20 Black on Green 30 Black on Cyan\n 21 Blue on Green 31 Blue on Cyan\n 22 Green on Green 32 Green on Cyan\n 23 Cyan on Green 33 Cyan on Cyan\n 24 Red on Green 34 Red on Cyan\n 25 Magenta on Green 35 Magenta on Cyan\n 26 Brown on Green 36 Brown on Cyan\n 27 White on Green 37 White on Cyan\n 28 Grey on Green 38 Grey on Cyan\n 29 Brt Blue on Green 39 Brt Blue on Cyan\n 2A Brt Green on Green 3A Brt Green on Cyan\n 2B Brt Cyan on Green 3B Brt Cyan on Cyan\n 2C Brt Red on Green 3C Brt Red on Cyan\n 2D Brt Magenta on Green 3D Brt Magenta on Cyan\n 2E Brt Yellow on Green 3E Brt Yellow on Cyan\n 2F Brt White on Green 3F Brt White on Cyan\n\n 40 Black on Red 50 Black on Magenta\n 41 Blue on Red 51 Blue on Magenta\n 42 Green on Red 52 Green on Magenta\n 43 Cyan on Red 53 Cyan on Magenta\n 44 Red on Red 54 Red on Magenta\n 45 Magenta on Red 55 Magenta on Magenta\n 46 Brown on Red 56 Brown on Magenta\n 47 White on Red 57 White on Magenta\n 48 Grey on Red 58 Grey on Magenta\n 49 Brt Blue on Red 59 Brt Blue on Magenta\n 4A Brt Green on Red 5A Brt Green on Magenta\n 4B Brt Cyan on Red 5B Brt Cyan on Magenta\n 4C Brt Red on Red 5C Brt Red on Magenta\n 4D Brt Magenta on Red 5D Brt Magenta on Magenta\n 4E Brt Yellow on Red 5E Brt Yellow on Magenta\n 4F Brt White on Red 5F Brt White on Magenta\n\n 60 Black on Brown 70 Black on White\n 61 Blue on Brown 71 Blue on White\n 62 Green on Brown 72 Green on White\n 63 Cyan on Brown 73 Cyan on White\n 64 Red on Brown 74 Red on White\n 65 Magenta on Brown 75 Magenta on White\n 66 Brown on Brown 76 Brown on White\n 67 White on Brown 77 White on White\n 68 Grey on Brown 78 Grey on White\n 69 Brt Blue on Brown 79 Brt Blue on White\n 6A Brt Green on Brown 7A Brt Green on White\n 6B Brt Cyan on Brown 7B Brt Cyan on White\n 6C Brt Red on Brown 7C Brt Red on White\n 6D Brt Magenta on Brown 7D Brt Magenta on White\n 6E Brt Yellow on Brown 7E Brt Yellow on White\n 6F Brt White on Brown 7F Brt White on White\n\n The final 128 color attributes codes have two interpretations,\n depending upon the setting of the video controller's blink/bold bit.\n See INT 10H 1003H (disable/enable blink).\n\n 80 Black on Grey -or- flashing Black on Black\n 81 Blue on Grey -or- flashing Blue on Black\n 82 Green on Grey -or- flashing Green on Black\n 83 Cyan on Grey -or- flashing Cyan on Black\n 84 Red on Grey -or- flashing Red on Black\n 85 Magenta on Grey -or- flashing Magenta on Black\n 86 Brown on Grey -or- flashing Brown on Black\n 87 White on Grey -or- flashing White on Black\n 88 Grey on Grey -or- flashing Grey on Black\n 89 Brt Blue on Grey -or- flashing Brt Blue on Black\n 8A Brt Green on Grey -or- flashing Brt Green on Black\n 8B Brt Cyan on Grey -or- flashing Brt Cyan on Black\n 8C Brt Red on Grey -or- flashing Brt Red on Black\n 8D Brt Magenta on Grey -or- flashing Brt Magenta on Black\n 8E Brt Yellow on Grey -or- flashing Brt Yellow on Black\n 8F Brt White on Grey -or- flashing Brt White on Black\n\n 90 Black on Brt Blue -or- flashing Black on Blue\n 91 Blue on Brt Blue -or- flashing Blue on Blue\n 92 Green on Brt Blue -or- flashing Green on Blue\n 93 Cyan on Brt Blue -or- flashing Cyan on Blue\n 94 Red on Brt Blue -or- flashing Red on Blue\n 95 Magenta on Brt Blue -or- flashing Magenta on Blue\n 96 Brown on Brt Blue -or- flashing Brown on Blue\n 97 White on Brt Blue -or- flashing White on Blue\n 98 Grey on Brt Blue -or- flashing Grey on Blue\n 99 Brt Blue on Brt Blue -or- flashing Brt Blue on Blue\n 9A Brt Green on Brt Blue -or- flashing Brt Green on Blue\n 9B Brt Cyan on Brt Blue -or- flashing Brt Cyan on Blue\n 9C Brt Red on Brt Blue -or- flashing Brt Red on Blue\n 9D Brt Magenta on Brt Blue -or- flashing Brt Magenta on Blue\n 9E Brt Yellow on Brt Blue -or- flashing Brt Yellow on Blue\n 9F Brt White on Brt Blue -or- flashing Brt White on Blue\n\n A0 Black on Brt Green -or- flashing Black on Green\n A1 Blue on Brt Green -or- flashing Blue on Green\n A2 Green on Brt Green -or- flashing Green on Green\n A3 Cyan on Brt Green -or- flashing Cyan on Green\n A4 Red on Brt Green -or- flashing Red on Green\n A5 Magenta on Brt Green -or- flashing Magenta on Green\n A6 Brown on Brt Green -or- flashing Brown on Green\n A7 White on Brt Green -or- flashing White on Green\n A8 Grey on Brt Green -or- flashing Grey on Green\n A9 Brt Blue on Brt Green -or- flashing Brt Blue on Green\n AA Brt Green on Brt Green -or- flashing Brt Green on Green\n AB Brt Cyan on Brt Green -or- flashing Brt Cyan on Green\n AC Brt Red on Brt Green -or- flashing Brt Red on Green\n AD Brt Magenta on Brt Green -or- flashing Brt Magenta on Green\n AE Brt Yellow on Brt Green -or- flashing Brt Yellow on Green\n AF Brt White on Brt Green -or- flashing Brt White on Green\n\n B0 Black on Brt Cyan -or- flashing Black on Cyan\n B1 Blue on Brt Cyan -or- flashing Blue on Cyan\n B2 Green on Brt Cyan -or- flashing Green on Cyan\n B3 Cyan on Brt Cyan -or- flashing Cyan on Cyan\n B4 Red on Brt Cyan -or- flashing Red on Cyan\n B5 Magenta on Brt Cyan -or- flashing Magenta on Cyan\n B6 Brown on Brt Cyan -or- flashing Brown on Cyan\n B7 White on Brt Cyan -or- flashing White on Cyan\n B8 Grey on Brt Cyan -or- flashing Grey on Cyan\n B9 Brt Blue on Brt Cyan -or- flashing Brt Blue on Cyan\n BA Brt Green on Brt Cyan -or- flashing Brt Green on Cyan\n BB Brt Cyan on Brt Cyan -or- flashing Brt Cyan on Cyan\n BC Brt Red on Brt Cyan -or- flashing Brt Red on Cyan\n BD Brt Magenta on Brt Cyan -or- flashing Brt Magenta on Cyan\n BE Brt Yellow on Brt Cyan -or- flashing Brt Yellow on Cyan\n BF Brt White on Brt Cyan -or- flashing Brt White on Cyan\n\n C0 Black on Brt Red -or- flashing Black on Red\n C1 Blue on Brt Red -or- flashing Blue on Red\n C2 Green on Brt Red -or- flashing Green on Red\n C3 Cyan on Brt Red -or- flashing Cyan on Red\n C4 Red on Brt Red -or- flashing Red on Red\n C5 Magenta on Brt Red -or- flashing Magenta on Red\n C6 Brown on Brt Red -or- flashing Brown on Red\n C7 White on Brt Red -or- flashing White on Red\n C8 Grey on Brt Red -or- flashing Grey on Red\n C9 Brt Blue on Brt Red -or- flashing Brt Blue on Red\n CA Brt Green on Brt Red -or- flashing Brt Green on Red\n CB Brt Cyan on Brt Red -or- flashing Brt Cyan on Red\n CC Brt Red on Brt Red -or- flashing Brt Red on Red\n CD Brt Magenta on Brt Red -or- flashing Brt Magenta on Red\n CE Brt Yellow on Brt Red -or- flashing Brt Yellow on Red\n CF Brt White on Brt Red -or- flashing Brt White on Red\n\n D0 Black on Brt Magenta -or- flashing Black on Magenta\n D1 Blue on Brt Magenta -or- flashing Blue on Magenta\n D2 Green on Brt Magenta -or- flashing Green on Magenta\n D3 Cyan on Brt Magenta -or- flashing Cyan on Magenta\n D4 Red on Brt Magenta -or- flashing Red on Magenta\n D5 Magenta on Brt Magenta -or- flashing Magenta on Magenta\n D6 Brown on Brt Magenta -or- flashing Brown on Magenta\n D7 White on Brt Magenta -or- flashing White on Magenta\n D8 Grey on Brt Magenta -or- flashing Grey on Magenta\n D9 Brt Blue on Brt Magenta -or- flashing Brt Blue on Magenta\n DA Brt Green on Brt Magenta -or- flashing Brt Green on Magenta\n DB Brt Cyan on Brt Magenta -or- flashing Brt Cyan on Magenta\n DC Brt Red on Brt Magenta -or- flashing Brt Red on Magenta\n DD Brt Magenta on Brt Magenta -or- flashing Brt Magenta on Magenta\n DE Brt Yellow on Brt Magenta -or- flashing Brt Yellow on Magenta\n DF Brt White on Brt Magenta -or- flashing Brt White on Magenta\n\n E0 Black on Brt Yellow -or- flashing Black on Brown\n E1 Blue on Brt Yellow -or- flashing Blue on Brown\n E2 Green on Brt Yellow -or- flashing Green on Brown\n E3 Cyan on Brt Yellow -or- flashing Cyan on Brown\n E4 Red on Brt Yellow -or- flashing Red on Brown\n E5 Magenta on Brt Yellow -or- flashing Magenta on Brown\n E6 Brown on Brt Yellow -or- flashing Brown on Brown\n E7 White on Brt Yellow -or- flashing White on Brown\n E8 Grey on Brt Yellow -or- flashing Grey on Brown\n E9 Brt Blue on Brt Yellow -or- flashing Brt Blue on Brown\n EA Brt Green on Brt Yellow -or- flashing Brt Green on Brown\n EB Brt Cyan on Brt Yellow -or- flashing Brt Cyan on Brown\n EC Brt Red on Brt Yellow -or- flashing Brt Red on Brown\n ED Brt Magenta on Brt Yellow -or- flashing Brt Magenta on Brown\n EE Brt Yellow on Brt Yellow -or- flashing Brt Yellow on Brown\n EF Brt White on Brt Yellow -or- flashing Brt White on Brown\n\n F0 Black on Brt White -or- flashing Black on White\n F1 Blue on Brt White -or- flashing Blue on White\n F2 Green on Brt White -or- flashing Green on White\n F3 Cyan on Brt White -or- flashing Cyan on White\n F4 Red on Brt White -or- flashing Red on White\n F5 Magenta on Brt White -or- flashing Magenta on White\n F6 Brown on Brt White -or- flashing Brown on White\n F7 White on Brt White -or- flashing White on White\n F8 Grey on Brt White -or- flashing Grey on White\n F9 Brt Blue on Brt White -or- flashing Brt Blue on White\n FA Brt Green on Brt White -or- flashing Brt Green on White\n FB Brt Cyan on Brt White -or- flashing Brt Cyan on White\n FC Brt Red on Brt White -or- flashing Brt Red on White\n FD Brt Magenta on Brt White -or- flashing Brt Magenta on White\n FE Brt Yellow on Brt White -or- flashing Brt Yellow on White\n FF Brt White on Brt White -or- flashing Brt White on White\n\nSee Also: Screen Attributes\n Video Modes\n BIOS Data Area\n INT 10H\n CGA I/O Ports\n -♦-"
  },
  {
    "id": "89-video_memory_layouts.html",
    "t": "Video Memory Layouts",
    "b": "BIOS video output services such as INT 10H 0aH (write character) are\n typically far too slow for most purposes. Nearly all programs write\n directly to video memory for performance reasons.\n\n This topic describes the location and layout of video memory for the\n various video systems.\n\n█▌Text Modes▐█\n Video modes 00H-03H and 07H (see Video Modes) use the following video-\n memory layout:\n\n 0 1 ║ 2 3 ║ 4 5 ║ ... ║158 159\n ┌───┼───╫───┼───╫───┼───╫─────╫───┼───╖\n 0│chr│atr║chr│atr║chr│atr║ ... ║chr│atr║ line 0, video page 0\n ├───┼───╫───┼───╫───┼───╫─────╫───┼───╢\n 160│chr│atr║chr│atr║chr│atr║ ... ║chr│atr║ line 1\n ├───┼───╫───┼───╫───┼───╫─────╫───┼───╢\n 320│chr│atr║chr│atr║chr│atr║ ... ║chr│atr║ line 2\n ├───┼───╫───┼───╫───┼───╫─────╫───┼───╢\n 480│chr│atr║chr│atr║chr│atr║ ... ║chr│atr║\n ├───┼───╫───┼───╫───┼───╫─────╫───┼───╢\n \\ \\\n ├───┼───╫───┼───╫───┼───╫─────╫───┼───╢\n 3840│chr│atr║chr│atr║chr│atr║ ... ║chr│atr║ line 24\n └───┴───╨───┴───╨───┴───╨─────╨───┴───╜\n ...small gap...\n ┌───┼───╫───┼───╫───┼───╫─────╫───┼───╖\n 4096│chr│atr║chr│atr║chr│atr║ ... ║chr│atr║ line 0, video page 1\n ...etc...\n\n All even-numbered addresses contain characters (see Character Set) and\n all odd-numbered addresses contain video attributes.\n\n The width of a standard 80-column line is 160 bytes and there are 25 lines\n (0-24) in most cases. But these can be changed by various video services\n or TSRs or device drivers. Programs should check the width and height of\n the screen via INT 10H 0fH or INT 10H 1130H or by examining variables in\n the BIOS Data Area.\n\n On EGAs and VGAs, it is possible to remap the video attributes so that\n any attribute byte can represent any desired color (see INT 10H 10H).\n You can also redefine the characters; for instance, to display italics or\n foreign-language text. See INT 10H 11H and Video Font Definition.\n\n Accessing Text Mode Video Memory\n ■ Text mode video memory begins at b800:0 on CGA, EGA and VGA and at\n b000:0 on MDA.\n\n Use INT 12H to see if MDA is active and set up a segment register\n accordingly.\n\n ■ Given an X,Y coordinate (clm,row), calculate a memory location as:\n\n vidAddr = (row * 160 )+ (clm * 2)\n\n Note: For best flexibility, don't hard-code \"160\". Instead, fetch\n the word at 0040:004a in the BIOS Data Area and multiply it by 2.\n\n ■ Store a character at that position and an attribute one address\n higher. Most applications use 16-bit commands such as...\n\n mov word ptr ES:[DI],AX\n or\n stosw\n\n ...to write both a character and attribute to video memory in one\n operation.\n\n Special care must be taken when using direct-memory access on CGA\n adapters. See Video Snow for a discussion.\n\n Also, all video systems except MDA provide multiple \"pages\" of video\n memory. It is possible to write to a secondary page then swap it into\n view via INT 10H 05H. But this is seen rarely: CPUs are now fast enough\n to update the screen in place without flicker. If you are writing to a\n video page other than 0, check 0040:004e for the offset of the start of\n the video page.\n\n█▌Graphics Modes▐█\n Graphics-mode video memory layouts vary considerably, depending on the\n mode. The following summarizes each standard video graphics mode:\n\n CGA Low-res 320x200, 4-color (video modes 04H and 05H)\n Segment: b800\n Layout: Interleaved scan lines, packed-pixel. Even-numbered scan lines\n begin at b800:0, and odd-numbered lines begin at b800:2000.\n\n Each scan line is 80-bytes long and there are 200 scan lines\n (regen size=8000 bytes * 2 regions). Each byte contains 4 pixels\n (16,000 total pixels):\n ╓7┬6┬5┬4┬3┬2┬1┬0╖\n ║ │ │ │ ║\n ╙─┴─┴─┴─┴─┴─┴─┴─╜ bits mask\n ╚╦╝ ╚╦╝ ╚╦╝ ╚═╩═► 0-1: 03H fourth pixel in byte\n ║ ║ ╚══════► 2-3: 0cH third pixel in byte\n ║ ╚══════════► 4-5: 30H second pixel in byte\n ╚══════════════► 6-7: c0H first pixel in byte\n 00=black; 01=green/cyan\n 10=red/magenta; 11=brown/white\n\n Each 2-bit field selects one of four colors, depending on the\n setting of the CGA palette. Use INT 10H 0bH.\n ──────────────────────────────────────────────────────────────────────────\n CGA Hi-res 640x200, 2-color (video mode 06H)\n Segment: b000\n Layout: Interleaved scan lines, packed-pixel. Even-numbered scan lines\n begin at b800:0, and odd-numbered lines begin at b800:2000.\n\n Each scan line is 80-bytes long and there are 200 scan lines\n (regen size=8000 bytes * 2 regions). Each byte contains 8 pixels\n (32,000 total pixels):\n ╓7┬6┬5┬4┬3┬2┬1┬0╖\n ║ │ │ │ │ │ │ │ ║\n ╙╥┴╥┴╥┴╥┴╥┴╥┴╥┴╥╜ bits mask\n ║ ║ ║ ║ ║ ║ ║ ╚══► 0: 01H eighth pixel in byte\n ║ ║ ║ ║ ║ ║ ╚════► 1: 02H seventh pixel in byte\n ║ ║ ║ ║ ║ ╚══════► 2: 04H sixth pixel in byte\n ║ ║ ║ ║ ╚════════► 3: 08H fifth pixel in byte\n ║ ║ ║ ╚══════════► 4: 10H fourth pixel in byte\n ║ ║ ╚════════════► 5: 20H third pixel in byte\n ║ ╚══════════════► 6: 40H second pixel in byte\n ╚════════════════► 7: 80H first pixel in byte\n 0=black; 1=white\n\n Each 1-bit field selects black (0) or white (1).\n ──────────────────────────────────────────────────────────────────────────\n EGA 320x200, 16-color (video mode 0dH)\n Segment: a000\n Layout: 4-plane planar. Each pixel color is determined by the combined\n value of bits in the four color planes. Each color plane begins\n at a000:0. To select a plane, use:\n\n OUT 3ceH, 0005H ;set up for plane masking\n OUT 3c4H, n ;n is: 0102H=plane 0; 0202H=plane 1\n ; 0402H=plane 2; 0802H=plane 3\n ...(write video data)...\n OUT 3c4H, 0f02H ;restore normal plane mask\n\n Each scan line is 40 bytes long and there are 200 scan lines\n (regen size=16,000 bytes * 4 planes). Each byte contains\n 8 pixels (64,000 total pixels):\n ╓7┬6┬5┬4┬3┬2┬1┬0╖\n ║ │ │ │ │ │ │ │ ║\n ╙╥┴╥┴╥┴╥┴╥┴╥┴╥┴╥╜ bits mask\n ║ ║ ║ ║ ║ ║ ║ ╚══► 0: 01H eighth pixel in byte\n ║ ║ ║ ║ ║ ║ ╚════► 1: 02H seventh pixel in byte\n ║ ║ ║ ║ ║ ╚══════► 2: 04H sixth pixel in byte\n ║ ║ ║ ║ ╚════════► 3: 08H fifth pixel in byte\n ║ ║ ║ ╚══════════► 4: 10H fourth pixel in byte\n ║ ║ ╚════════════► 5: 20H third pixel in byte\n ║ ╚══════════════► 6: 40H second pixel in byte\n ╚════════════════► 7: 80H first pixel in byte\n 0=color OFF; 1=color ON\n\n The pixel color depends on the 4-bit value (0-15) obtained by\n combining the same bit position in each plane. Default settings\n are: 0H black 8H gray\n 1H blue 9H bright blue\n 2H green aH bright green\n 3H cyan bH bright cyan\n 4H red cH bright red\n 5H magenta dH bright magenta\n 6H brown eH yellow\n 7H white fH bright white\n For instance, to make a pixel blue, the combined planes must\n equal 01H; that is the bit in plane 0 is set and the bits in\n planes 1,2, and 3 are clear.\n\n The actual colors depend on the palette (see INT 10H 1000H).\n ──────────────────────────────────────────────────────────────────────────\n EGA 640x200, 16-color (video mode 0eH)\n Segment: a000\n Layout: 4-plane planar. Each pixel color is determined by the combined\n value of bits in the four color planes. Each color plane begins\n at a000:0.\n\n Each scan line is 80 bytes long and there are 200 scan lines\n (regen size=16,000 bytes * 4 planes). Each byte contains\n 8 pixels (128,000 total pixels).\n\n The layout and access is the same as mode 0dH.\n───────────────────────────────────────────────────────────────────────────\n EGA 640x350, 4-color (video mode 0fH)\n Segment: a000\n Layout: 2-plane planar. Video layout is the same as modes 0dH and 0eH,\n except that only planes 0 and 2 are used. The effect is to have\n only two bits per pixel and the four colors are determined by\n palette registers 0, 1, 4, and 5.\n\n Each scan line is 80 bytes long and there are 350 scan lines\n (regen size=28,000 bytes * 2 planes). Each byte contains\n 8 pixels (224,000 total pixels).\n\n On really-old EGAs with only 64K, the even-numbered bit positions\n in video memory are displayed for planes 0 and 2 and odd-numbered\n pixels are in planes 1 and 3. This variation is seen rarely.\n ──────────────────────────────────────────────────────────────────────────\n EGA 640x350, 16-color (video mode 10H)\n Segment: a000\n Layout: 4-plane planar. Video layout is the same as modes 0dH and 0eH,\n where the pixel is determined by the combined value in all four\n color planes.\n\n Each scan line is 80 bytes long and there are 350 scan lines\n (regen size=28,000 bytes * 4 planes). Each byte contains\n 8 pixels (224,000 total pixels).\n ──────────────────────────────────────────────────────────────────────────\n VGA 640x480, 2-color (video mode 11H)\n Segment: a000\n Layout: 4-plane planar. In this mode, there is a one-to-one\n correspondence to bits in color plane 0 and the displayed data.\n\n Each scan line is 80 bytes long and there are 480 scan lines\n (regen size=38,400 bytes). Each byte contains 8 pixels (307,200\n total pixels).\n ──────────────────────────────────────────────────────────────────────────\n VGA 640x480, 16-color (video mode 12H)\n Segment: a000\n Layout: 4-plane planar. Video layout is the same as modes 0dH and 0eH,\n where the pixel is determined by the combined value in all four\n color planes.\n\n Each scan line is 80 bytes long and there are 480 scan lines\n (regen size=38,400 bytes * 4 planes). Each byte contains 8 pixels\n (307,200 total pixels).\n ──────────────────────────────────────────────────────────────────────────\n VGA 320x200, 256-color (video mode 13H)\n Segment: a000\n Layout: Linear, packed-pixel. This mode uses one byte (8 bits) per\n pixel. The colors displayed depend on the palette settings.\n\n Each scan line is 320 bytes long and there are 200 scan lines\n (regen size=64,000 bytes). Each byte contains 1 pixel (64,000\n total pixels).\n\nSee Also: Screen Attributes\n Video Modes\n Video Font Definition\n INT 10H (Video Services)\n SVGA Video Modes\n -♦-"
  },
  {
    "id": "90-video_initialization_table.html",
    "t": "Video Initialization Table",
    "b": "This table is pointed to by the vector for INT 1dH (0:0074).\n\n It is used by INT 10H 00H when a video mode-change takes place. The\n values in this table describe the register values that must be stored into\n the 6845 CRT controller, along with other data (such as the number of\n columns, etc.) for the video variables stored in the BIOS Data Area\n starting at 0:0449.\n\n You may reset the INT 1dH vector to point it to your own TSR tables. Then\n the next mode change will use the values in your tables.\n\nVidInitRec\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 16 abRegs40x25 6845 reg values for 40x25 modes (see below)\n +10H 16 abRegs80x25 6845 reg values for 80x25 modes\n +20H 16 abRegsGfx 6845 reg values for graphics modes\n +30H 16 abRegsMono 6845 reg values for 80x25 Monochrome\n +40H 2 wSize40x25 40x25 modes: regen RAM for one screen page\n +42H 2 wSize80x25 80x25 modes: regen RAM for one screen page\n +44H 2 wSizeLoRes low-res graphics modes: regen RAM size\n +46H 2 wSizeHiRes hi-res graphics modes: regen RAM size\n +48H 8 abClmCnts column count for each of 8 modes\n +50H 8 abModeCodes values for the mode-set register (port 3d8H) for\n each mode. Current setting is at 0040:0065.\n 88 size of a VidParmRec\n\n The first 40H bytes of the table consists of four 16-byte tables that\n each contain a set of 1-byte register values for each of the 6845\n CRT-controller registers in their sequential order (R0...R15):\n\n R0: horizontal total -- horizontal sync in character clocks\n R1: horizontal displayed -- characters per line\n R2: horizontal sync pos. -- use to move display left or right\n R3: sync width -- vert. and horiz. pulse (4 bits each)\n R4: vertical total -- total vertical lines of characters\n R5: vertical adjust -- adjusts for 50 or 60 Hz refresh\n R6: vertical displayed -- lines of characters displayed\n R7: vertical sync pos -- lines shifted up or down\n R8: interlace/skew -- (bits 4 and 5) interlace mode\n (bits 6 and 7) skew mode\n R9: max scan line addr. -- scan lines per character row\n R10: cursor start -- starting scan line of cursor\n R11: cursor stop -- ending scan line of cursor\n R12: video RAM start addr -- start of displayed page (high byte)\n R13: (low byte)\n R14: cursor pos -- offset address in vid mem (high byte)\n R15: (low byte)\n\n 6845 Registers 16-17 are not stored in the table. But they are:\n\n R16: light pen address (high byte)\n R17: (low byte)\n\nSee Also: CGA MDA\n BIOS Data Area\n INT 10H\n INT 1dH\n CGA I/O Ports\n Video Modes\n -♦-"
  },
  {
    "id": "91-video_font_definition.html",
    "t": "Video Font Definition",
    "b": "┌76543210┐ ┌76543210┐ ┌76543210┐\n │ │=00000000=00 │ │=00000000=00 │ │=00000000=00\n │ │=00000000=00 │ │=00000000=00 │ │=00000000=00\n │ ■■■ │=00111000=38 │■■■■■■ │=11111100=FC │ ■■ │=00001100=0C\n │ ■■ ■■ │=01101100=6C │ ■■ ■■ │=01100110=66 │ ■■ │=00001100=0C\n │■■ ■■ │=11000110=C6 │ ■■ ■■ │=01100110=66 │ │=00000000=00\n │■■ ■■ │=11000110=C6 │ ■■ ■■ │=01100110=66 │ ■■■ │=00011100=1C\n │■■ ■■ │=11000110=C6 │ ■■■■■ │=01111100=7C │ ■■ │=00001100=0C\n │■■■■■■■ │=11111110=FE │ ■■ ■■ │=01100110=66 │ ■■ │=00001100=0C\n │■■ ■■ │=11000110=C6 │ ■■ ■■ │=01100110=66 │ ■■ │=00001100=0C\n │■■ ■■ │=11000110=C6 │ ■■ ■■ │=01100110=66 │ ■■ │=00001100=0C\n │■■ ■■ │=11000110=C6 │ ■■ ■■ │=01100110=66 │ ■■ │=00001100=0C\n ├■■ ■■ ┤=11000110=C6 ├■■■■■■ ┤=11111100=FC ├■■ ■■ ┤=11001100=CC\n │ │=00000000=00 │ │=00000000=00 │■■ ■■ │=11001100=CC\n │ │=00000000=00 │ │=00000000=00 │ ■■■■ │=01111000=78\n │ │=00000000=00 │ │=00000000=00 │ │=00000000=00\n │ │=00000000=00 │ │=00000000=00 │ │=00000000=00\n └────────┘ ║ └────────┘ ║ └────────┘\n ╔════════════════════╝ ║\n╔║═══════════════════════════════════════════╝\n║║ c000:n+(m*0) 00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00 ASCII 0=\n║║ c000:n+(m*1) 00,00,7E,81,A5,81,81,BD,99,81,81,7E,00,00,00,00 ASCII 1=☺\n║║ c000:n+(m*2) 00,00,7C,FE,FE,D6,FE,FE,BA,C6,FE,7C,00,00,00,00 ASCII 2=☻\n║║ .\n║║ :\n║╚►c000:n+(m*65) 00,00,38,6C,C6,C6,C6,FE,C6,C6,C6,C6,00,00,00,00 ASCII 65=A\n╚═►c000:n+(m*66) 00,00,FC,66,66,66,7C,66,66,66,66,FC,00,00,00,00 ASCII 66=B\n .\n :\n In the 8x16 font above, each character of the ASCII table is represented\n by 16 bytes. In each of those 16 bytes, each bit represents one pixel,\n with the high-order bit representing the leftmost of eight pixels.\n\n On an EGA or VGA you may obtain the address of any ROM-defined font via\n INT 10H 1130H. The definition of a particular ASCII character, c, starts\n c*m bytes from the returned address (where m is the height of the\n character matrix and thus the bytes-per character--usually 8, 14, or 16).\n\n On a CGA or MDA, the font data is internal to the (inaccessible) character\n generator. However, the data layout used in the INT 1fH vector (which\n defines ASCII characters > 127 for CGA graphics modes) is laid out as an\n 8x8 font.\n\n ┌76543210┐ ┌76543210┐\n │ ■■■■ │=00111100=3C │ │=00000000=00\n │ ■■ ■■ │=01100110=66 │■■ ■■ │=11000110=C6\n │■■ │=11000000=C0 │ │=00000000=00\n │ ■■ ■■ │=01100110=66 │■■ ■■ │=11000110=C6\n │ ■■■■ │=00111100=3C │■■ ■■ │=11000110=C6\n │ ■■ │=00011000=18 │■■ ■■■ │=11001110=CE\n │■■ ■■ │=11001100=CC │ ■■■ ■■ │=01110110=76\n │ ■■■■ │=01111000=78 │ │=00000000=00\n └────────┘ ║ └────────┘ ║\n ╔════════════════════╝ ║\n╔║═══════════════════════════════════════════╝\n║╚►[0:7c]+(8*0) 3C,66,C0,66,3C,18,CC,78 ASCII 128=Ç\n╚═►[0:7c]+(8*1) 00,C6,00,C6,C6,CE,76,00 ASCII 129=ü\n .\n :\n On EGAs and VGAs, the INT 43H vector points to a table of character\n definitions for graphics mode. The BIOS refers to the word at 0040:85 in\n the BIOS Data Area to determine the size of each character definition.\n\n█▌VGA Implied 9th Bit▐█\n When displaying in text mode, the VGA uses an internally-handled 720-\n pixel-wide screen width (in graphics mode, 640 is the highest supported\n width). Thus, VGA characters are really 9 pixels wide. The 9th pixel is\n usually displayed as blank (0).\n\n However, certain Box & Special Characters would look bad if the rightmost\n dot were blank. So characters c0H through dfH are given special treatment\n by the VGA character generator. On these characters, the 8th bit is\n extended into the 9th position. Examine the Character Set Matrix to\n verify that all of these characters are box-and-line characters which must\n connect on the right side. Although you can turn this off this \"9th-bit\n extension\" feature (via ATC register 10H, bit 2; see EGA I/O Ports), there\n is no way to select a different range.\n\n█▌Dynamic Character Redefinition▐█\n You may be aware of a wave of semi-graphical text-mode applications (such\n as Norton Utilities and Central Point tools). These programs redefine\n certain characters to look like checkboxes, round \"radio buttons\" and so\n forth. The most interesting idea is the \"semi-graphical\" mouse pointer.\n\n This appears miraculous at first, but is technically not too difficult.\n You can use INT 10H 1100H to modify the \"bank 0\" character definitions to\n instantly change the definition of a character. The trick in tracking a\n \"graphical mouse cursor\" is to replace a 2x2 character matrix at the mouse\n position with some little-used characters (say, d0H-d3H). Then redefine\n those characters so that they look a lot like the characters they replace,\n except that a mouse pointer overlays them.\n\n Actually, the BIOS font-redefinition interface may be a bit too slow on\n some VGAs, so programmers use direct port I/O to make the character-\n generator RAM accessible and programmable on-the-fly.\n\n When choosing which characters to redefine, you must keep in mind the\n \"9th-bit extension\" described above; if you just pick some arbitrary\n characters, your mouse pointer will appear to have \"seams\" when displayed\n on VGA screens. Only characters c0H-dfH will fill the gaps.\n\n Programming for Direct Access to Character Generator RAM\n The following sequence sets up the EGA and VGA for accessing character-\n generator memory. See EGA I/O Ports for related information.\n\n out 3c4H, 0402H Mask reg; enable write to map 2\n out 3c4H, 0704H Memory Mode reg ; alpha, ext mem, non-interleaved\n out 3ceH, 0005H Graphics Mode reg; non-interleaved access\n out 3ceH, 0406H Graphics Misc reg; map char gen RAM to a000:0\n out 3ceH, 0204H Graphics ReadMapSelect reg; enable read chargen RAM\n\n After these OUTs, the font data begins at a000:0 and the first byte of\n font data for a character begins at the character's ASCII value * 32.\n After reading or writing the font data, the following sequence restores\n the EGA/VGA to normal operations:\n\n out 3c4H, 0302H Mask reg; disable write to map 2\n out 3c4H, 0304H Memory Mode reg; alpha, ext mem, interleaved\n out 3ceH, 1005H Graphics Mode reg; interleaved access\n out 3ceH, 0e06H Graphics Misc reg; regen buffer to b800:0\n out 3ceH, 0004H Graphics ReadMapSelect reg; disable read chargen RAM\n\nSee Also: EGA VGA\n EGA I/O Ports\n VGA I/O Ports\n Video Modes\n -♦-"
  },
  {
    "id": "92-cga_video_snow_and_cls_flash.html",
    "t": "CGA Video Snow and CLS Flash",
    "b": "█▌Video Snow▐█\n When writing a program that may run on a CGA, you must take special action\n to avoid annoying artifacts that appear on the screen when you access\n video memory directly. (Note: This is NOT a problem with any other\n monitor types; even many CGAs, such as emulated CGA on an LCD screen, do\n not have the \"video snow\" problem).\n\n To avoid video snow, you must write to video memory only during the\n retrace period. You can check for retrace by using:\n\n les di,vidAddr ;ES:DI=> address to write (e.g., b800:0000)\n cli ;stop interrupts from screwing up the timing\n waitForNoRetrace:\n mov dx,3daH ;CRT Status register. See CGA I/O Ports.\n in al,dx\n test al,01h ;out of retrace yet?\n jz waitForNoRetrace\n\n waitForRetrace:\n in al,dx\n test al,01h ;in retrace yet?\n jz waitForRetrace\n\n okToWrite:\n mov ax,charAndAttr ;get character and attribute to write\n stosw ;write it\n sti ;let interrupts happen\n\n This sequence first waits until the CGA is NOT in retrace, then waits\n until retrace begins, then immediately writes the data. On the oldest\n 4.77 Mhz PCs, there is just enough time to write one or maybe two\n characters to video memory before horizontal retrace ends.\n\n A CGA-optimized video library can squeeze out better performance by\n waiting for vertical retrace (test dx,08h). At that point, you can\n write just over 160 bytes without causing snow.\n\n There is no way to know if a CGA has this problem. Most software provides\n a means, such as a command-line option, to enable or disable the code that\n synchronizes video access with video retrace.\n\n█▌CLS Flash▐█\n The oldest CGA BIOS uses an irritating technique when it clears the screen\n (for instance, via INT 10H 06H. It disables the video signal, so it can\n write lots of data to video memory without awaiting retrace.\n\n This works fine when most of the screen is black, but if the screen is\n mostly blue (or other color), then you see an annoying flash of black\n whenever the screen scrolls.\n\n A complete video library should include its own CGA-aware CLS function to\n avoid this problem.\n\nSee Also: CGA\n Video Memory Layouts\n Video Modes\n -♦-"
  },
  {
    "id": "93-rom_bios_variables.html",
    "t": "ROM-BIOS Variables",
    "b": "This maps the most important of the ROM-BIOS variables and data areas.\n All addresses are documented and should be valid in future BIOSes. The\n map is sequential by memory address, with blank lines indicating rough\n functional groups. Addresses not shown should be considered reserved.\n\n Note: Although this table shows addresses as offsets from segment 40H,\n it is valid to use offsets from absolute segment 00H. For\n instance, a variable shown to be at address 40:0012 can also be\n addressed at 0:0412.\n\nAddress Size Contents\n▀▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n40:0000 2 Base port address of first RS-232 adapter (COM1) See COM Ports\n40:0002 2 Port of COM2\n40:0004 2 Port of COM3\n40:0006 2 Port of COM4\n40:0008 2 Base port addr of first parallel printer (LPT1) Printer Ports\n40:000A 2 Port of LPT2\n40:000C 2 Port of LPT3\n40:000E 2 Port of LPT4\n40:0010 2 Equipment/hardware installed/active; see Equipment List\n40:0012 1 Errors in PCjr infrared keyboard link\n40:0013 2 Total memory in K-bytes (same as obtained via INT 12H)\n40:0015 2 Scratch pad for manufacturing error tests\n\n40:0017 2 Keyboard status bits; see Keyboard Shift Status Flags\n40:0019 1 Current (accumulating) value of Alt+numpad pseudo-key input;\n normally 0. When [Alt] is released, value is stored in\n keyboard buffer at 001e.\n40:001a 2 Addr of keyboard buffer head (keystroke at that addr is next)\n40:001c 2 Address of keyboard buffer tail\n40:001e 32 Keyboard buffer. BIOS stores keystrokes here (head and tail\n point to addresses from 041eH to 043dH inclusive).\n\n40:003e 1 Diskette drive needs recalibration (bit 0=A, bit 1=B, etc.)\n bits 4-5 indicate which drive is currently selected\n40:003f 1 Diskette motor is running (bit 0=drive A, bit 1=B, etc.)\n40:0040 1 Time until motor off. INT 08H turns motor off when this is 0.\n40:0041 1 Diskette error status; same as status returned by INT 13H\n40:0042 7 Diskette controller status information area\n\n40:0049 1 Current active video mode. See Video Modes and INT 10H.\n40:004a 2 Screen width in text columns\n40:004c 2 Length (in bytes) of video area (regen size)\n40:004e 2 Offset from video segment of active video memory page\n40:0050 16 Cursor location (8 byte-pairs; low byte=clm, hi byte=row)\n40:0060 2 Cursor size/shape. Low byte=end scan line; hi byte=start line.\n40:0062 1 Current active video page number\n40:0063 2 Port address for 6845 video controller chip; see CGA I/O Ports\n40:0065 1 Current value of 6845 video ctrlr CRT_MODE (port 3x8H register)\n40:0066 1 Current value of 6845 video ctrlr CRT_PALETTE (port 3x9H reg)\n\n40:0067 5 Cassette data area or POST data area\n40:006c 4 Timer tick counter (count of 55ms ticks since CPU reset)\n40:0070 1 Timer overflow flag (timer has rolled over 24 hr)\n40:0071 1 Ctrl-Break flag. Bit 7=1 when break was pressed. This never\n gets reset unless you do it yourself.\n\n40:0072 2 1234H means Ctrl+Alt+Del reboot is in progress. BIOS checks\n this to avoid doing a \"cold boot\" with the time-consuming POST\n 4321H means reset, preserving memory\n 5678H, 9abcH, and abcdH (are internal PC Convertible codes)\n\n40:0074 4 PCjr diskette or AT hard disk control area\n (0074) 1 Status of last fixed-disk drive operation\n (0075) 1 Number of hard disk drives for AT\n (0077) 1 Hard disk port for XT. See XT Hard Disk Ports.\n40:0078 4 Printer time-out values (478H=Lpt1, 478H=Lpt2...)\n40:007c 4 RS-232 time-out values (47cH=Com1, 47dH=Com2...)\n\n40:0080 2 AT PS/2 keyboard buffer offset start address (usually 01eH)\n40:0082 2 end address (usually 003eH)\n\n40:0084 1 EGA text rows-1 (maximum valid row value)\n40:0085 2 EGA bytes per character (scan-lines/char used in active mode)\n40:0087 1 EGA flags; see EgaMiscInfoRec\n40:0088 1 EGA flags; see EgaMiscInfo2Rec\n40:0089 1 VGA flags; see VgaFlagsRec\n See also: EGA/VGA Data Areas\n\n40:008b 1 AT PS/2 Media control: data rate, step rate\n40:008c 1 AT PS/2 Hard disk drive controller status\n40:008d 1 AT PS/2 Hard disk drive error status\n40:008e 1 AT PS/2 Hard disk drive interrupt control\n\n40:0090 1 AT PS/2 Disk media state bits for drive 0\n40:0091 1 for drive 1\n40:0092 1 AT PS/2 Disk operation started flag for drive 0\n40:0093 1 for drive 1\n40:0094 1 AT PS/2 Present cylinder number for drive 0\n40:0095 1 for drive 1\n\n40:0096 1 AT Keyboard flag bit 4=1 (10H) if 101-key keyboard is attached\n40:0097 1 AT Keyboard flag for LED 'key lock' display\n bits 0-2 are ScrollLock, NumLock, CapsLock\n\n40:0098 4 AT Pointer to 8-bit user wait flag; see INT 15H 86H\n40:009c 4 AT Microseconds before user wait is done\n40:00a0 1 AT User wait activity flag:\n 01H=busy, 80H=posted, 00H=acknowledged\n\n40:00a1 7 AT Reserved for network adapters\n\n40:00a8 4 EGA Address of table of pointers; see EgaSavePtrRec\n\n40:00f0 16 (IAC) Inter-Aapplication Communication area. Programs may use\n this area to store status, etc. Might get overwritten by\n another program.\n\n40:0100 1 Print-screen status:\n 00H=ok; 01H=printing; 0ffH=error while printing screen\n\n40:0104 1 Phantom-floppy status; see also DOS fn 440eH\n 01H=drive A is acting as drive B.\n40:0110 17 Used by BASIC interpreter\n40:0130 3 Used by MODE command\n─────── ──── ───────────────────────────────────────────────────────────────\nf000:fff0 5 FAR JMP instruction to begin POST\n (after a hard reset, the CPU jumps here)\nf000:fff5 8 ROM-BIOS release date in ASCII (eg, \"04/24/81\" is original PC)\nf000:fffc 2 (unused)\nf000:fffe 1 IBM computer-type code; see also BIOS INT 15H C0H\n 0ffH = original PC\n 0feH = XT or Portable PC\n 0fdH = PCjr\n 0fcH = AT (or XT model 286) (or PS/2 Model 50/60)\n 0fbH = XT with 640K motherboard\n 0faH = PS/2 Model 30\n 0f9H = Convertible PC (easily converts into a paperweight)\n 0f8H = PS/2 Model 80\n\nSee Also: General Memory Map\n EGA/VGA Data Areas\n I/O Port Map\n ROM-BIOS Functions\n -♦-"
  },
  {
    "id": "94-general_memory_map.html",
    "t": "General Memory Map",
    "b": "Overview of the general memory-layout of PC/XT/AT while operating.\n\nAddress Name / Description\n▀▀▀▀▀▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n ┌─────────────────────────────────────────────────────────────────\n0000:0000 │ Interrupt vector table: 256 4-byte addresses\n──────────┼─────────────────────────────────────────────────────────────────\n0040:0000 │ ROM-BIOS data area.\n──────────┼──────────────────────── See BIOS Data Area for details\n0050:0000 │ DOS data area.\n──────────┼─────────────────────────────────────────────────────────────────\nxxxx:0000 │ DOS low-level BIOS code (read from IO.SYS on boot disk)\n──────────┼─────────────────────────────────────────────────────────────────\nxxxx:0000 │ DOS interrupt handlers, including INT 21H (IBMDOS.COM)\n ├─────────────────────────────────────────────────────────────────\nxxxx:0000 │ DOS buffers, data areas, and installed device drivers\n──────────┼─────────────────────────────────────────────────────────────────\nxxxx:0000 │ resident portion of COMMAND.COM\n │ includes handlers for INT 22H INT 23H and INT 24H\n──────────┼─────────────────────────────────────────────────────────────────\nxxxx:0000 │ TSR-style programs and data\n──────────┼─────────────────────────────────────────────────────────────────\nxxxx:0000 | Currently-executing application program (.COM or .EXE program)\n | Programs initially own all of memory up to 640K (a000:0000) or\n | whatever is the memory-ceiling in the PC.\n──────────┼─────────────────────────────────────────────────────────────────\nxxxx:0000 │ Transient portion of COMMAND.COM. Command processor, internal\n │ commands, etc. Gets reloaded if any program overwrites this are\n──────────┼─────────────────────────────────────────────────────────────────\nxxxx:0000 │ Extended BIOS Data Area on PS/2 (highest memory below 640K)\n──────────┼─────────────────────────────────────────────────────────────────\na000:0000 │ On 386+ CPUs, addresses from a000:0 to f000:0 that are not\n through │ occupied by ROM are available as UMBs▲ when supported by\ne000:ffff │ EMM386.EXE or other memory-management software\n──────────┼─────────────────────────────────────────────────────────────────\na000:0000 │ EGA and VGA memory for certain video modes\n ├─────────────────────────────────────────────────────────────────\nb000:0000 │ MDA display adapter video memory (also Hercules & clones)\n ├─────────────────────────────────────────────────────────────────\nb800:0000 │ CGA video memory (also Hercules page 2)\n──────────┼─────────────────────────────────────────────────────────────────\nc800:0000 │ External ROM code. ROM-BIOS looks here (in 2K-block increments)\n through │ for code to be executed at boot time. Such ROMS usually install\ne000:0000 │ a device handler (e.g., hard disk or EGA BIOS); see ROM-Scan\n ├─────────────────────────────────────────────────────────────────\n also │ Physical paging addresses for EMS expanded memory.\n──────────┼─────────────────────────────────────────────────────────────────\ne000:0000 │ AT motherboard ROM modules in 64K-block increments.\n through │ See ROM-Scan\ne000:ffff │\n──────────┼─────────────────────────────────────────────────────────────────\nf600:0000 │ ROM-resident BASIC interpreter (ancient IBM-logoed PC only)\n──────────┼─────────────────────────────────────────────────────────────────\nfe00:0000 │ ROM-BIOS: POST, boot code, interrupt handlers, the whole banana\n──────────┼─────────────────────────────────────────────────────────────────\nf000:fff0 │ JMP instruction to first opcode to execute on power up or reset\n ├─────────────────────────────────────────────────────────────────\nf000:fff5 │ BIOS release date (in ASCII)\n ├─────────────────────────────────────────────────────────────────\nf000:fffe │ IBM PC identification code. See BIOS Data Area (end of table)\n └─────────────────────────────────────────────────────────────────\n ┌─────────────────────────────────────────────────────────────────\nffff:0000 │ This is the High Memory Area, available to 286+ computers.\n through │ It is the first 64K (less 16 bytes) of extended▲ memory, but is\nffff:fff0 │ set up to be accessible while in real mode.\n └─────────────────────────────────────────────────────────────────\n█▌Above 1M▐█\n Area above 1 MB is extended▲ memory available to AT-class computers via\n BIOS function INT 15H and (when HIMEM.SYS or other XMS provider is\n installed) XMS Services. The CPU is switched into protected mode to make\n this memory accessible. See also: About DPMI.\n\n Extended memory is currently used by DOS only for RAM-disk, disk caching,\n and by a few DOS TSRs.\n\n Windows, OS/2, Xenix, and other operating systems or control programs may\n use this area for multitasking or general-purpose memory.\n\nSee Also: BIOS Data Area\n EGA/VGA Data Areas\n I/O Port Map\n -♦-"
  },
  {
    "id": "95-interrupts_and_bios_services.html",
    "t": "Interrupts and BIOS Services",
    "b": "Services Interrupts Pointers\n ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n 10H Video services 00H Division by 0 1bH Keyboard break\n 11H Equipment list 01H Single-step 1cH User timer interrupt\n 12H Conv. memory size 02H Non-Maskable 1dH Video parms\n 13H Disk I/O 03H Breakpoint 1eH Diskette parms\n 14H Serial port I/O 04H Overflow 1fH Graphics chars\n 15H AT services; APM 05H Print screen\n 16H Keyboard I/O 06H Invalid opcode 22H Terminate addr\n 17H Printer I/O 07H no math chip 23H Ctrl+Break addr\n 18H ROM-BASIC 08H IRQ 0 Timer 24H Critical Error addr\n 19H Bootstrap 09H IRQ 1 Keyboard\n 1aH Time I/O; MRCI hook 0aH IRQ 2 cascade 40H diskette revector\n 0bH IRQ 3 COM 2/4 41H hard disk 0 parms\n 20H-2fH: DOS Interrupts 0cH IRQ 4 COM 1/3 46H hard disk 1 parms\n 0dH IRQ 5 LPT 2\n 2fH: Multiplex Services 0eH IRQ 6 diskette 43H EGA font table\n 0fH IRQ 7 LPT 1\n 31H DPMI services 4aH User alarm address\n 33H Mouse Support 70H IRQ 8 RT Clock\n 67H Expanded Memory Fns 71H IRQ 9 redir IRQ 2\n 72H IRQ 10 (reserved)\n 73H IRQ 11 (reserved)\n 74H IRQ 12 (reserved)\n 75H IRQ 13 math chip\n 76H IRQ 14 hard disk\n 77H IRQ 15 (reserved)\n\nSee Also: IRQs: Hardware Interrupts\n DOS Functions\n API Service Index\n DOS & BIOS Data Structures\n BIOS Data Area\n -♦-"
  },
  {
    "id": "96-irqs__hardware_interrupts.html",
    "t": "IRQs: Hardware Interrupts",
    "b": "█▌Overview▐█\n Devices such as the keyboard and disk controller are connected to the\n CPU via Interrupt ReQuest lines (IRQs). When these devices need\n servicing, they signal to the CPU which immediately begins executing\n code at a particular interrupt vector.\n\n█▌Standard IRQs▐█\n\n INT 08H IRQ 0 Timer Interrupts every 55ms (18.2 times per second)\n\n INT 09H IRQ 1 Keyboard Interrupts on each press and release of a key\n and periodically while the key is held down.\n See Keyboard Ports.\n\n INT 0aH IRQ 2 cascade Connected to the secondary 8259a interrupt\n controller on ATs; may be used by EGA for\n vertical retrace. See EGA I/O Ports.\n\n INT 0bH IRQ 3 COM 2/4 Interrupts when COM2 or COM4 has something to\n say. See Serial Ports.\n\n INT 0cH IRQ 4 COM 1/3 Interrupts when COM1 or COM3 has something to\n say. See Serial Ports.\n\n INT 0dH IRQ 5 LPT 2 AT: Interrupts when the printer on LPT2 is ready\n for another character (only if printer port 27aH\n is set up for this). See Printer Ports.\n\n PC/XT: This was used for the hard disk. See\n XT Hard Disk Ports.\n\n INT 0eH IRQ 6 diskette Interrupts after each action of the floppy\n diskette controller (read, write, seek, etc).\n See FDC Ports.\n\n INT 0fH IRQ 7 LPT 1 Interrupts when LPT1 is ready for another\n character (only when controller port 37aH is set\n up for this). See Printer Ports.\n\n INT 70H IRQ 8 RT Clock Interrupts 1024 times per second (on AT-class or\n better computers). This is generated by the\n same hardware that handles the non-volatile data\n in the CMOS Memory.\n\n INT 71H IRQ 9 redir IRQ2 On AT-class computers, IRQ 2 is used as the\n connection to a secondary 8259a interrupt\n controller. Actual occurrences of IRQ 2 are\n redirected to IRQ 9. This IRQ may be generated\n by EGA/VGA. See EGA I/O Ports.\n\n INT 72H IRQ 10 (reserved) There is no default device for this IRQ.\n INT 73H IRQ 11 (reserved) There is no default device for this IRQ.\n INT 74H IRQ 12 (reserved) There is no default device for this IRQ.\n\n INT 75H IRQ 13 math chip The 80x87 math coprocessor generates this\n interrupt on exceptions (errors).\n\n INT 76H IRQ 14 hard disk Interrupts when the hard disk controller\n finishes an operation. See AT Hard Disk Ports.\n\n INT 77H IRQ 15 (reserved) There is no default device for this IRQ.\n\nSee Also: Interrupts and BIOS Services\n I/O Port Map\n -♦-"
  },
  {
    "id": "97-int_00h__division_overflow.html",
    "t": "INT 00H: Division Overflow",
    "b": "The CPU automatically executes this interrupt after a DIV or IDIV is\n performed and the result (quotient) of a division operation will not fit\n into the destination. This includes division by 0. For instance...\n\n mov ax,4000H ;dividend\n mov bl,2 ;divisor is byte so destination is byte (AL)\n div bl ;4000H/2 is 2000H which will not fit in AL\n ; so INT 00H is executed\n ...or simply:...\n mov bx,0\n div bx ;any division by 0\n\n Note: Division-by-0 errors on the numeric coprocessor may be routed\n through the NMI. See INT 02H.\n\nSee Also: ROM-BIOS Functions\n DOS Functions\n Process Control Functions\n -♦-"
  },
  {
    "id": "98-int_01h__single_step_interrupt.html",
    "t": "INT 01H: Single-Step Interrupt",
    "b": "When the CPU Trap Flag is set (TF=1), the CPU executes this interrupt\n after each instruction.\n\n Debuggers which allow you to single-step through the instructions of a\n program use this interrupt to recapture execution to display the\n registers, memory, etc.\n\n Trapping is turned off (TF=0) upon execution of any INT instruction, so\n the INT 01H itself is not executed in single-step fashion. Upon leaving\n the interrupt (via IRET), all flags are restored, thus the next\n instruction will be trapped.\n\n The normal way to begin single-stepping is to PUSH a word containing all\n the desired flags (including TF=1), PUSH the desired CS and IP address to\n execute, then perform an IRET to begin single-stepping at that address.\n\nSee Also: INT 03H\n ROM-BIOS Functions\n DOS Functions\n Process Control Functions\n -♦-"
  },
  {
    "id": "99-int_02h__non_maskable_interrupt.html",
    "t": "INT 02H: Non-Maskable Interrupt",
    "b": "The non-maskable interrupt (NMI) is the only interrupt which is not\n disabled by the CLI instruction, so it can be used in special cases that\n need immediate attention.\n\n It is designed to handle catastrophic problems such as a power failure.\n In a fail-safe system, the NMI could dump RAM to disk storage in an\n attempt to save data before all was lost.\n\n In the standard PC BIOS, the NMI is hard-wired to be executed in the event\n of a memory parity error. When it occurs, the PC locks up and dies. Now\n don't you feel safer knowing that everything in memory will be lost rather\n than a few bits?\n\n The 8087/80287 math coprocessor is tied to the NMI line and causes an\n interrupt when it encounters an exception condition (e.g., division by 0).\n\n Typically you must read I/O Port 64H to find if a memory error occurred\n and if not, perform an FNSAVE to find what caused the 8087 exception, then\n FNCLX to clear the error.\n\n Note: PCjr uses the NMI to detect keystrokes from the infrared linkup.\n\nSee Also: ROM-BIOS Functions\n DOS Functions\n -♦-"
  },
  {
    "id": "100-int_03h__breakpoint_interrupt.html",
    "t": "INT 03H: Breakpoint Interrupt",
    "b": "The INT 03H vector is used by debugging utilities in order to intercept\n execution when it reaches a user-selected address.\n\n The opcode for INT 03H is one byte (c0H), so it can lay over top of the\n start of any CPU instruction, without any chance of overwriting the code\n that follows it.\n\nSee Also: ROM-BIOS Functions\n DOS Functions\n -♦-"
  },
  {
    "id": "101-int_04h__overflow_interrupt.html",
    "t": "INT 04H: Overflow Interrupt",
    "b": "The INT 04H vector can be used as one way to minimize the size of programs\n that perform a lot of arithmetic operations.\n\n After any arithmetic operation, the INTO instruction will test for\n arithmetic overflow, and if the CPU flag is set (OF=OV=1), then INT 04H\n is executed.\n\n You might see code such as:\n\n mov ax,var_1\n add ax,var_2\n into ;2-byte test for arithmetic overflow\n ... etc. ... ;either no overflow or it has been handled\n ; by the interrupt handler\n\nSee Also: INT 00H (division by 0)\n ROM-BIOS Functions\n DOS Functions\n -♦-"
  },
  {
    "id": "102-int_05h__print_screen___bounds_exception.html",
    "t": "INT 05H: Print Screen / Bounds Exception",
    "b": "█▌Software Interrupt▐█\n INT 05H, to the dismay of Intel (which considers this a CPU-reserved\n interrupt), is used in the PC to execute the screen-to-printer dump\n routine in ROM BIOS.\n\n It is called directly by the keyboard interrupt INT 09H when it senses the\n press of the PrtSc (or PrintScreen) key. It may also be invoked by\n software, and you can intercept this interrupt if you want to write a\n custom screen-dump routine.\n\n The EGA BIOS has a function to replace the normal Print-Screen with one\n that works for a variety of screen character layouts. See INT 10H 12H.\n\n The DOS Graphics command replaces this routine with one that will print\n screen graphics (dot patterns) on a few types of printer.\n\n█▌CPU Exception Interrupt▐█\n 286+ computers execute INT 05H when the BOUND opcode is executed and the\n parameters are found to be out of range.\n\nSee Also: IRQs (hardware interrupts)\n ROM-BIOS Functions\n DOS Functions\n -♦-"
  },
  {
    "id": "103-int_06h__invalid_opcode.html",
    "t": "INT 06H: Invalid Opcode",
    "b": "286+ computers execute INT 06H when executing and invalid opcode.\n\nSee Also: IRQs (hardware interrupts)\n ROM-BIOS Functions\n DOS Functions\n -♦-"
  },
  {
    "id": "104-int_07h__math_coprocessor_not_present.html",
    "t": "INT 07H: Math Coprocessor Not Present",
    "b": "INT 07H is executed automatically when any 80x87 Floating Point Opcodes\n are executed and no math chip is there to handle it.\n\n More generally, this takes place when an ESC or WAIT opcode is executed\n specifying a coprocessor that's not present.\n\n Math chip emulators intercept this interrupt to provide floating-point\n support (very slowly, I might add).\n\nSee Also: IRQs (hardware interrupts)\n ROM-BIOS Functions\n DOS Functions\n -♦-"
  },
  {
    "id": "105-int_08h__timer_interrupt.html",
    "t": "INT 08H: Timer Interrupt",
    "b": "This hardware-generated interrupt (IRQ 0) is executed upon each tick of\n the PC's real-time clock. The clock ticks every 55ms, or about 18.2 ticks\n per second.\n\n The ROM-BIOS (default) code for this interrupt updates the clock values at\n 0:046c. It also turns off the diskette drive motors after about 2 seconds\n without read/write activity. See BIOS Data Area for other variables.\n\n If you want to use this interrupt for custom timer-keyed activities (as\n with a TSR program) you must be sure to include the code that tells the\n system when the interrupt is finished. The magic sequence is:\n\n mov al,20H ;send End-Of-Interrupt signal\n out 20H,al ; to the 8259 Interrupt Controller\n\n Most TSRs let the default code do this. For instance, when the TSR is\n installed, the original vector is saved in a variable named cs:[old_int8].\n Then the following code is executed on each INT 08H:\n\n pushf ;simulate an INT\n call dword ptr cs:[old_int8] ;perform normal timer actions\n cmp cs:my_var,test_value ;now do customized stuff\n ... etc. ...\n iret ;return to interrupted foreground application program\n\n█▌CPU Exception Interrupt▐█\n 286+ computer execute INT 08H when encountering a Double Exception Error\n (an exception while processing an exception).\n\nSee Also: IRQs: Hardware Interrupts\n Timer Ports\n TSR Functions\n ROM-BIOS Functions\n DOS Functions\n -♦-"
  },
  {
    "id": "106-int_09h__keyboard_interrupt.html",
    "t": "INT 09H: Keyboard Interrupt",
    "b": "This hardware-generated interrupt (IRQ 1) is executed upon each press and\n release of a key. The ROM-BIOS code interprets the keystroke, storing\n values into the keyboard buffer at 0040:001e. It also handles the special\n cases of the PrtSc, SysReq, Ctrl+Alt+Del, Ctrl+NumLock (or Pause) keys,\n and tracks the status of the shift and case-lock keys.\n\n See: INT 16H ......... BIOS service to access keys stored in the buffer\n and obtain status of the certain shift keys.\n Scan Codes ....... a list of the values of each possible keystroke\n as it is received by INT 09H.\n ASCII Table\n Extended ASCII ... a summary of the values that BIOS stores into the\n keyboard buffer after it translates a scan code.\n Keyboard Flags ... a summary of how to obtain, test for, and modify\n the bit-settings of shift and case-lock flags.\n\n TSRs that have a hot-key to trigger a popup usually intercept INT 09H and\n test for a certain key with a sequence such as this:\n\n push ax\n in al,60H ;read the key\n cmp al,POP_KEY ;is this the hot key?\n je do_pop ; yes, trigger the popup\n ; no, drop through to original driver\n pop ax\n jmp cs:[int9_vect] ;just hop out to original int handler\n\n do_pop: ;------ following housekeeping is needed to satisfy the hdwr int\n\n in al,61H ;get value of keyboard control lines\n mov ah,al ; save it\n or al,80h ;set the \"enable kbd\" bit\n out 61H,al ; and write it out the control port\n xchg ah,al ;fetch the original control port value\n out 61H,al ; and write it back\n\n mov al,20H ;send End-Of-Interrupt signal\n out 20H,al ; to the 8259 Interrupt Controller\n ;------ other code handles other tests and finally triggers popup\n\n█▌CPU Exception Interrupt▐█\n 286+ computer execute INT 09H when the math coprocessor encounters an\n Segment Overrun exception.\n\nSee Also: IRQs: Hardware Interrupts\n TSR Functions\n BIOS Data Area\n I/O Port Map\n ROM-BIOS Functions\n DOS Functions\n -♦-"
  },
  {
    "id": "107-int_0ah__irq_2_cascade___invalid_task_state.html",
    "t": "INT 0aH: IRQ 2 Cascade / Invalid Task State",
    "b": "On ATs, INT 0aH is a hardware-generated interrupt (IRQ 2) forced by any\n occurrence of IRQ 7 through IRQ 15. These are cascaded into the secondary\n interrupt controller.\n\n The actual handler for IRQ 2 is IRQ 9, handled by INT 71H. Normally, no\n device uses IRQ 2, but an EGA or VGA may be programmed to use it to\n interrupt at the start of vertical retrace (see EGA I/O Ports).\n\n█▌CPU Exception Interrupt▐█\n 286+ computer execute INT 0aH when the CPU is in protected mode and it\n detects an Invalid Task Segment State during a JMP, CALL, IRET, or INT\n opcode.\n\nSee Also: IRQs: Hardware Interrupts\n FDC I/O Ports\n BIOS Data Area\n ROM-BIOS Functions\n DOS Functions\n -♦-"
  },
  {
    "id": "108-int_0bh__irq_3_com2_4___segment_not_present.html",
    "t": "INT 0bH: IRQ 3 COM2/4 / Segment Not Present",
    "b": "INT 0bH is a hardware-generated interrupt (IRQ 3) forced by COM2 or COM4\n when it is done sending or receiving a byte of data.\n\n█▌CPU Exception Interrupt▐█\n 286+ computer execute INT 0bH when the CPU is in protected mode and it\n detects a Segment Not Present exception.\n\nSee Also: IRQs: Hardware Interrupts\n Serial Ports\n BIOS Data Area\n ROM-BIOS Functions\n DOS Functions\n -♦-"
  },
  {
    "id": "109-int_0ch__irq_4_com1_3___stack_overflow.html",
    "t": "INT 0cH: IRQ 4 COM1/3 / Stack Overflow",
    "b": "INT 0cH is a hardware-generated interrupt (IRQ 4) forced by COM1 or COM3\n when it is done sending or receiving a byte of data.\n\n█▌CPU Exception Interrupt▐█\n 286+ computer execute INT 0cH when the CPU is in protected mode and it\n detects a stack access that is outside of the bounds of the SS selector.\n\n Protected-mode operating systems can watch for this and increase the size\n of the stack.\n\nSee Also: IRQs: Hardware Interrupts\n Serial Ports\n BIOS Data Area\n ROM-BIOS Functions\n DOS Functions\n -♦-"
  },
  {
    "id": "110-int_0dh__irq_5_lpt2___general_protection_fault.html",
    "t": "INT 0dH: IRQ 5 LPT2 / General Protection Fault",
    "b": "INT 0fH is a hardware-generated interrupt (IRQ 7) forced by LPT1 when it\n is ready to receive a character (but only when the printer controller has\n been programmed to generate the interrupt).\n\n█▌CPU Exception Interrupt▐█\n 286+ computer execute INT 0dH when the CPU is in protected mode and it\n detects any memory access outside of the areas available to a task.\n\nSee Also: IRQs: Hardware Interrupts\n Printer Ports\n BIOS Data Area\n ROM-BIOS Functions\n DOS Functions\n -♦-"
  },
  {
    "id": "111-int_0eh__diskette_interrupt___page_fault.html",
    "t": "INT 0eH: Diskette Interrupt / Page Fault",
    "b": "INT 0eH is a hardware-generated interrupt (IRQ 6) forced by the floppy\n disk controller.\n\n The ROM-BIOS code sets bit 7 in the BIOS \"seek_status\" variable (0040:3e)\n which indicates that a diskette seek is in progress. This flag is used by\n INT 13H to determine if a diskette controller recalibration is required\n before the next action.\n\n█▌CPU Exception Interrupt▐█\n 286+ computer execute INT 0eH when the CPU is in protected mode and it\n detects access to a page or memory which has been swapped out to disk.\n\n Protected-mode operating systems watch for this and read the data back\n into memory and handle the needs of virtual memory management.\n\nSee Also: IRQs: Hardware Interrupts\n FDC I/O Ports\n BIOS Data Area\n ROM-BIOS Functions\n DOS Functions\n -♦-"
  },
  {
    "id": "112-int_0fh__irq_7_lpt1.html",
    "t": "INT 0fH: IRQ 7 LPT1",
    "b": "INT 0fH is a hardware-generated interrupt (IRQ 7) forced by LPT1 when it\n is ready to receive a character (but only when the printer controller has\n been programmed to generate the interrupt).\n\nSee Also: IRQs: Hardware Interrupts\n Printer Ports\n BIOS Data Area\n ROM-BIOS Functions\n DOS Functions\n -♦-"
  },
  {
    "id": "113-int_10h__video_services.html",
    "t": "INT 10H: Video Services",
    "b": "AH Std BIOS Services AH EGA/VGA/VESA Extensions\n ▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀ ▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n 00H set video mode Note: See full list, below\n 01H set cursor size/shape 10H palette functions EGA VGA\n 02H set cursor position 11H character generator fns EGA VGA\n 03H query cursor position & size 12H special functions EGA VGA\n 04H read light pen 13H write string+attr/cells AT EGA VGA\n 05H select active display page\n 06H scroll window up (or cls) 1aH query/set DCC (display combo) VGA\n 07H scroll window down (or cls) 1bH query functionality/status VGA\n 08H read character/attribute 1cH save/restore video state fns VGA\n 09H write character/attribute\n 0aH write character 4f00H query SVGA support\n 0bH select color palette/border 4f01H query SVGA mode info\n 0cH write graphics pixel dot 4f02H set SVGA video mode\n 0dH read graphics pixel dot 4f03H query SVGA video mode\n 0eH write character as TTY 4f04H save/restore SVGA state\n 0fH read video mode 4f05H query/set SVGA video mem window\n\n AX AT/PS2/EGA/VGA/VESA Extensions Support\n ▀▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀ ▀▀▀▀▀▀▀\n 1000H set one palette register EGA/VGA\n 1001H set overscan/border color EGA/VGA\n 1002H set all palette registers & border color EGA/VGA\n 1003H select foreground blink or bold background EGA/VGA\n 1007H read one palette register VGA\n 1008H read overscan/border color VGA\n 1009H read all pallet registers & border color VGA\n 1010H set one DAC color register VGA\n 1012H set block of DAC color registers VGA\n 1013H DAC color paging functions VGA\n 1015H read one DAC color register VGA\n 1017H read block of DAC color registers VGA\n 101aH query DAC color paging state VGA\n 101bH convert DAC colors to grey scale VGA\n\n 1100H load user-defined font EGA/VGA\n 1101H load ROM 8x14 font EGA/VGA\n 1102H load ROM 8x8 font EGA/VGA\n 1103H activate font block; 512-character set EGA/VGA\n 1104H load ROM 8x16 font VGA\n 1110H load and activate user-defined font EGA/VGA\n 1111H load and activate ROM 8x14 font EGA/VGA\n 1112H load and activate ROM 8x8 font EGA/VGA\n 1114H load and activate ROM 8x16 font VGA\n 1120H setup INT 1fH graphics font pointer VGA\n 1121H setup user-defined font for graphics VGA\n 1122H ROM 8x14 font for graphics modes VGA\n 1123H ROM 8x8 font for graphics modes VGA\n 1124H ROM 8x16 font for graphics modes VGA\n 1130H get video font information VGA\n\n 12xxH 10H get EGA info EGA/VGA\n 12xxH 20H use alternate print screen EGA/VGA\n 12xxH 30H set text-mode scan-lines VGA\n 12xxH 31H enable default palette loading VGA\n 12xxH 32H enable access to video VGA\n 12xxH 33H enable gray-scale summing VGA\n 12xxH 34H enable cursor emulation VGA\n 12xxH 35H PS/2 display switching VGA\n 12xxH 36H screen refresh on/off VGA\n\n 1300H display string AT/EGA/VGA\n 1301H display string and update cursor AT/EGA/VGA\n 1302H display character/attribute cells AT/EGA/VGA\n 1303H display char/attr cells & update cursor AT/EGA/VGA\n\n 14xxH PC Convertible LCD fns (not covered)\n 15xxH PC Convertible LCD fns\n 16-19 (reserved)\n\n 1axxH query/set Display Combination Code (DCC) PS2/VGA\n 1bxxH query functionality/status VGA\n\n 1c00H query size of save buffer VGA\n 1c01H save current video state VGA\n 1c02H restore video state from saved data VGA\n\nSee Also: VESA/SVGA BIOS Services\n CGA I/O Ports\n BIOS Data Area\n EGA/VGA Data Areas\n -♦-"
  },
  {
    "id": "114-video_modes.html",
    "t": "Video Modes",
    "b": "AL Type Format Cell Colors Adapter Addr Monitor\n ═══ ═══════ ═══════ ════ ═════════════ ═══════ ════ ═════════════\n 0 text 40x25 8x8* 16/8 (shades) CGA,EGA b800 Composite\n 1 text 40x25 8x8* 16/8 CGA,EGA b800 Comp,RGB,Enh\n 2 text 80x25 8x8* 16/8 (shades) CGA,EGA b800 Composite\n 3 text 80x25 8x8* 16/8 CGA,EGA b800 Comp,RGB,Enh\n 4 graphic 320x200 8x8 4 CGA,EGA b800 Comp,RGB,Enh\n 5 graphic 320x200 8x8 4 (shades) CGA,EGA b800 Composite\n 6 graphic 640x200 8x8 2 CGA,EGA b800 Comp,RGB,Enh\n 7 text 80x25 9x14* 3 (b/w/bold) MDA,EGA b000 TTL Mono\n 8,9,0aH PCjr modes\n 0bH,0cH (reserved; internal to EGA BIOS)\n 0dH graphic 320x200 8x8 16 EGA,VGA a000 Enh,Anlg\n 0eH graphic 640x200 8x8 16 EGA,VGA a000 Enh,Anlg\n 0fH graphic 640x350 8x14 3 (b/w/bold) EGA,VGA a000 Enh,Anlg,Mono\n 10H graphic 640x350 8x14 4 or 16 EGA,VGA a000 Enh,Anlg\n 11H graphic 640x480 8x16 2 VGA a000 Anlg\n 12H graphic 640x480 8x16 16 VGA a000 Anlg\n 13H graphic 640x480 8x16 256 VGA a000 Anlg\n\n Notes: With EGA, VGA, and PCjr you can add 80H to AL to initialize a\n video mode without clearing the screen.\n\n * The character cell size for modes 0-3 and 7 varies, depending on\n the hardware. On modes 0-3: CGA=8x8, EGA=8x14, and VGA=9x16.\n For mode 7, MDPA and EGA=9x14, VGA=9x16, LCD=8x8.\n\nSee Also: SVGA Video Modes\n Video Memory Layouts\n -♦-"
  },
  {
    "id": "115-int_10h_00h__set_video_mode.html",
    "t": "INT 10H 00H: Set Video Mode",
    "b": "Compatibility: All\n Expects: AH 00H\n AL video mode number (optionally, +80H for don't clear data)\n ──────────────────────────────────────────────────────────────────\n Returns: (none)\n ──────────────────────────────────────────────────────────────────\n Info: This initializes the video hardware to display in the specified\n video mode.\n\n See Video Modes for a list of standard video modes.\n\n See Video Memory Layouts for info on accessing screen memory.\n\nSee Also: INT 10H: Video Services\n VESA/SVGA BIOS Services\n -♦-"
  },
  {
    "id": "116-int_10h_01h__set_cursor_shape___size.html",
    "t": "INT 10H 01H: Set Cursor Shape & Size",
    "b": "Compatibility: All\n Expects: AH 01H\n CH start scan line of character matrix (0-1fH; 20H=no cursor)\n CL end scan line of character matrix (0-1fH)\n ──────────────────────────────────────────────────────────────────\n Returns: (none)\n ──────────────────────────────────────────────────────────────────\n Info: This sets the size of the hardware (blinking) cursor and its\n location within the character cell matrix. Programs often use\n this fn to indicate \"insert mode\" vs. \"overstrike mode\". You can\n also use it to turn off the blinking cursor altogether.\n\n CH selects the start of the cursor, in terms of the character cell\n matrix. For instance, if CH=0, the cursor will start at the top\n of the cell matrix.\n\n CL selects the end of the cursor, in terms of the character cell\n matrix. This setting usually depends on the height of the cell\n matrix.\n\n On EGA/VGA, you may check the word at 0040:0085 to see how many\n scan lines per character are used in the current video mode. On\n VGA you may use INT 10H 1bH to obtain the size of the character\n matrix.\n CGA 25-line mode\n EGA 43-line mode\n VGA 25 EGA 25 VGA 50-line mode\n ■■■■■■■■■ 0 ■■■■■■■■■ 0 ■■■■■■■■■ 0\n ■■■■■■■■■ 1 ■■■■■■■■■ 1 ■■■■■■■■■ 1\n ■■■■■■■■■ 2 ■■■■■■■■■ 2 ■■■■■■■■■ 2 ┌─────────────────────┐\n ■■■■■■■■■ 3 ■■■■■■■■■ 3 ■■■■■■■■■ 3 │■ = cell point │\n ■■■■■■■■■ 4 ■■■■■■■■■ 4 ■■■■■■■■■ 4 │■ = descender area │\n ■■■■■■■■■ 5 ■■■■■■■■■ 5 ■■■■■■■■■ 5 │■ = gap between lines│\n ■■■■■■■■■ 6 ■■■■■■■■■ 6 ■■■■■■■■■ 6 └─────────────────────┘\n ■■■■■■■■■ 7 ■■■■■■■■■ 7 ■■■■■■■■■ 7\n ■■■■■■■■■ 8 ■■■■■■■■■ 8 8\n ■■■■■■■■■ 9 ■■■■■■■■■ 9 9\n ■■■■■■■■■ 10 ■■■■■■■■■ 10 10\n ■■■■■■■■■ 11 ■■■■■■■■■ 11 11\n ■■■■■■■■■ 12 ■■■■■■■■■ 12 12\n ■■■■■■■■■ 13 ■■■■■■■■■ 13 13\n ■■■■■■■■■ 14 14 14\n ■■■■■■■■■ 15 15 15\n\n However, you can use CL=1fH to set the bottom of the cursor at\n the bottom of the character cell\n\n Notes: ■ One way to turn off the cursor is to set CH and CL both to 20H.\n Another way its to position the hardware cursor below the\n bottom of the screen (INT 10H 02H). When the blinking cursor\n is hidden, you may wish to display your own, non-blinking\n cursor (for instance, ASCII 219 (█) or 220 (▄).\n\n ■ Older PC/CGA BIOSes supported odd cursor shapes, including\n \"wrap-around\" cursors with a gap in the middle. In many later\n BIOSes, the start line should be less than the end line.\n\n ■ The original \"standard\" cursor-handling technique is to thicken\n the cursor when the keyboard is in \"insert mode\". Later, many\n products stopped doing this; they leave the cursor the same\n size, regardless of input mode or toggle the shape on a mode\n change.\n\n I, for one, prefer the reliable visual feedback of the original\n standard.\n\n ■ EGA/VGA systems can be set to \"emulate\" CGA cursor size. When\n emulation is in effect, the values of CL and CH are assumed to\n be relative to a 8x8 character matrix and are scaled up,\n according to the actual size of the character matrix. See\n INT 10H 12H BL=34H and the EgaMiscInfoRec.\n\nSee Also: INT 10H: Video Services\n INT 10H 03H (query cursor position/shape)\n INT 10H 12H BL=34H (VGA: cursor emulation/scaling)\n INT 10H 1bH (VGA: Query functionality/state)\n -♦-"
  },
  {
    "id": "117-int_10h_02h__set_cursor_position.html",
    "t": "INT 10H 02H: Set Cursor Position",
    "b": "Compatibility: All\n Expects: AH 02H\n BH video page number (0-based)\n DH row (0-based)\n DL column (0-based)\n ──────────────────────────────────────────────────────────────────\n Returns: (none)\n ──────────────────────────────────────────────────────────────────\n Info: Sets the position for the blinking (hardware) cursor. The cursor\n position is used in other video fns as a way to select the next\n place to write text.\n\n BH specifies a video page (use 0 in most cases). The BIOS maintains\n the cursor position for each video page; they are saved starting\n at 0040:0050.\n\n DH,DL select the row,column for the cursor. 0,0 is the top-left corner\n of the screen. To change just the row or just the column, use\n INT 10H 03H (query cursor position) to preset DH,DL.\n\n Notes: One way to hide the blinking cursor is to position it below the\n lowest visible screen line; for instance, set DH=25 in 25-line\n screen modes (the byte at 0040:0084 identifies the screen height\n in rows, on EGA/VGA BIOSes).\n\nSee Also: INT 10H 03H (query cursor position)\n INT 10H: Video Services\n -♦-"
  },
  {
    "id": "118-int_10h_03h__query_cursor_position_and_size.html",
    "t": "INT 10H 03H: Query Cursor Position and Size",
    "b": "Compatibility: All\n Expects: AH 03H\n BH video page number (0-based)\n ──────────────────────────────────────────────────────────────────\n Returns: CH cursor starting scan-line\n CL cursor ending scan-line\n DH current row (0-based)\n DL current column (0-based)\n ──────────────────────────────────────────────────────────────────\n Info: This obtains the current cursor position and the size/shape of\n the cursor for a specified video page.\n\n BH specifies a video page (use 0 in most cases). The BIOS maintains\n the cursor position for each video page; they are saved starting\n at 0040:0050. The cursor size is saved only for the current\n video page, so you may need to maintain it separately if you are\n using a page-switching technique.\n\n DH,DL and CH,CL return containing cursor information.\n\nSee Also: INT 10H 01H (set cursor size)\n INT 10H 02H (set cursor position)\n INT 10H: Video Services\n -♦-"
  },
  {
    "id": "119-int_10h_04h__query_light_pen.html",
    "t": "INT 10H 04H: Query Light Pen",
    "b": "Compatibility: All\n Expects: AH 04H\n ──────────────────────────────────────────────────────────────────\n Returns: AH 0=not triggered (ignore other registers)\n 1=is triggered (other regs have valid info)\n DH,DL text mode row,column at which pen was triggered\n CX,BX graphics mode row,column (in pixels)\n (on oldest BIOSes, row returned in CL and CH not used)\n ──────────────────────────────────────────────────────────────────\n Info: Checks to see if the light pen has been triggered and returns the\n screen location at which the pen was pointing when it was\n triggered.\n\n Notes: Old CGA cards always included a light pen connector, but later\n EGA/VGA cards often do not.\n\nSee Also: INT 10H: Video Services\n -♦-"
  },
  {
    "id": "120-int_10h_05h__select_video_page.html",
    "t": "INT 10H 05H: Select Video Page",
    "b": "Compatibility: All\n Expects: AH 05H\n AL video page number (0-based)\n ──────────────────────────────────────────────────────────────────\n Returns: (none)\n ──────────────────────────────────────────────────────────────────\n Info: This selects a different video page. CGAs,EGAs, and VGAs support\n eight video pages, but most MDAs▲ support only one.\n\n Historically, some text-mode programs have gotten a performance\n boost by using multiple video pages. For instance, you can make\n a series of changes to the second video page and then use this fn\n to display the entire page all at once.\n\n Notes: ■ On VGAs, you may use INT 10H 1bH (get functionality/state info)\n to see how many pages the active display supports.\n\n ■ Most programmers select page 0 and leave it there for these\n reasons:\n • Page-switching is not possible with MDAs.\n • All newer computers are fast enough to update the screen in\n place (see Video Memory Layouts).\n • On older CGAs, writing to non-visible pages still causes\n Video Snow (so there is no performance gain).\n • Some popular mouse support driver will honor only page 0.\n\n However, TSRs should be aware of page-switching techniques in\n order to avoid screwing up the interrupted application.\n\n ■ The active video page number can be obtained via INT 10H 0fH.\n\n ■ The starting address of the start of the active page can be\n found in the 2-byte word at 0040:004e. See BIOS Data Area.\n\nSee Also: INT 10H: Video Services\n -♦-"
  },
  {
    "id": "121-int_10h_06h__scroll_up___clear_screen_rectangle.html",
    "t": "INT 10H 06H: Scroll Up / Clear Screen Rectangle",
    "b": "Compatibility: All\n Expects: AH 06H\n AL number of lines to scroll in (0=blank entire rectangle)\n BH video attribute to be used on blank line(s)\n CH,CL row,clm of lower-right corner of rectangle to scroll/blank\n DH,DL row,clm of upper-left corner of rectangle to scroll/blank\n ──────────────────────────────────────────────────────────────────\n Returns: (none)\n ──────────────────────────────────────────────────────────────────\n Info: You may use this to scroll screen text up; that is, move each\n line of text higher on the screen and add one or more blank lines\n at the bottom.\n\n This fn can be used to scroll a rectangular subset of the screen.\n It may also be used to clear the entire screen or any rectangular\n subset.\n\n Notes: ■ The standard way to clear the screen is to set DX to 0000H, CL\n to 0040:[004a]-1 (usually 79), CH to 0040:[0084] (usually 24),\n BH to 07H (white-on black video attribute), and AL to 00H (to\n clear the entire screen).\n\n ■ To scroll the text up (as when the user presses the down\n arrow), set CX and DX to cover the entire screen (or a\n rectangular subset), and set AL to 1.\n\n ■ CGAs: When most of the screen is a color other than black, you\n should avoid using this function for scrolling. Original CGA\n BIOSes display an annoying flicker with each scroll operation.\n It is usually best to write a special routine to move the text\n yourself. See CGA Video Snow and CLS Flash.\n\nSee Also: INT 10H 07H (scroll down)\n INT 10H: Video Services\n -♦-"
  },
  {
    "id": "122-int_10h_07h__scroll_down___clear_screen_rectangle.html",
    "t": "INT 10H 07H: Scroll Down / Clear Screen Rectangle",
    "b": "Compatibility: All\n Expects: AH 07H\n AL number of lines to scroll in (0=blank entire rectangle)\n BH video attribute to be used on blank line(s)\n CH,CL row,clm of lower-right corner of rectangle to scroll/blank\n DH,DL row,clm of upper-left corner of rectangle to scroll/blank\n ──────────────────────────────────────────────────────────────────\n Returns: (none)\n ──────────────────────────────────────────────────────────────────\n Info: You may use this to scroll screen text down; that is, move each\n line of text lower on the screen and add one or more blank lines\n at the top.\n\n This fn can be used to scroll a rectangular subset of the screen.\n It may also be used to clear the entire screen or any rectangular\n subset.\n\n See INT 10H 06H (scroll up / cls) for notes and related info.\n\nSee Also: INT 10H 06H (scroll up / cls)\n INT 10H: Video Services\n -♦-"
  },
  {
    "id": "123-int_10h_08h__read_character_attribute_at_cursor_location.html",
    "t": "INT 10H 08H: Read Character/Attribute at Cursor Location",
    "b": "Compatibility: All\n Expects: AH 08H\n BH video page number (0-based)\n ──────────────────────────────────────────────────────────────────\n Returns: (none)\n AL character read\n BH video attribute (text modes only)\n ──────────────────────────────────────────────────────────────────\n Info: This obtains the ASCII character code and the Video Attribute of\n the character at the current cursor location.\n\n When the screen is in graphics mode, BH (the character color) is\n not returned.\n\n To read the screen at a particular location, use INT 10H 02H (set\n cursor location) before calling here.\n\n This is too slow for most apps. See Video Memory Layouts.\n\nSee Also: INT 10H 09H (write char/attr to cursor location)\n INT 10H: Video Services\n -♦-"
  },
  {
    "id": "124-int_10h_09h__write_character_attribute_to_cursor_location.html",
    "t": "INT 10H 09H: Write Character/Attribute to Cursor Location",
    "b": "Compatibility: All\n Expects: AH 09H\n AL character to write (see ASCII Table)\n Note: Graphics chars > 127 are defined in INT 1fH table.\n BH video page number (0-based)\n BL text modes: video attribute for character\n graphics modes: color number\n CX repeat count\n ──────────────────────────────────────────────────────────────────\n Returns: (none)\n ──────────────────────────────────────────────────────────────────\n Info: This writes a character and attribute to the current cursor\n location.\n\n This is too slow for most apps. See Video Memory Layouts.\n\n CX To write just one character, set CX=1.\n\n You may use the fn to write a series of the same character--for\n instance, to fill an entire screen line with blanks--by setting\n CX to a repeat count.\n\n Notes: This does not update the cursor position. Use INT 10H 0eH to\n write a character and advance the cursor.\n\n Use INT 10H 0aH to write a character without modifying the video\n attributes of the affected screen positions.\n\nSee Also: INT 10H: Video Services\n -♦-"
  },
  {
    "id": "125-int_10h_0ah__write_character_to_cursor_location.html",
    "t": "INT 10H 0aH: Write Character to Cursor Location",
    "b": "Compatibility: All\n Expects: AH 0aH\n AL character to write (see ASCII Table)\n Note: Graphics chars > 127 are defined in INT 1fH table.\n BH video page number (0-based)\n CX repeat count\n ──────────────────────────────────────────────────────────────────\n Returns: (none)\n ──────────────────────────────────────────────────────────────────\n Info: This writes a character to the current cursor location. It does\n not modify the video attribute of the affected screen position.\n\n This is too slow for most apps. See Video Memory Layouts.\n\n CX To write just one character, set CX=1.\n\n You may use the fn to write a series of the same character--for\n instance, to fill a screen line with blanks--by setting CX to a\n repeat count.\n\n Notes: This does not update the cursor position. Use INT 10H 0eH to\n write a character and advance the cursor.\n\n Use INT 10H 09H to write a character and specify a desired video\n attribute.\n\nSee Also: INT 10H: Video Services\n INT 10H 13H (display a string of characters)\n -♦-"
  },
  {
    "id": "126-int_10h_0bh__select_graphics_palette_or_text_border_color.html",
    "t": "INT 10H 0bH: Select Graphics Palette or Text Border Color",
    "b": "Compatibility: All\n Expects: AH 0bH\n BL text modes: select overscan (border) color\n 00H-0fH low-intensity colors\n 10H-1fH high-intensity colors\n graphics: select palette combination\n 0 = green/red/brown\n 1 = cyan/magenta/white\n ──────────────────────────────────────────────────────────────────\n Returns: (none)\n ──────────────────────────────────────────────────────────────────\n Info: In text modes, this selects a color for the overscan (border)\n area of the display.\n\n In CGA-style 4-color graphics video modes 04H and 05H, this\n selects one of two supported color-combination palettes.\n\n To set colors for EGA and VGA graphics modes, use INT 10H 10H.\n\nSee Also: INT 10H 1000H (EGA: set one color)\n INT 10H 1001H (EGA: set border color)\n INT 10H 1002H (EGA: set entire palette and border)\n -♦-"
  },
  {
    "id": "127-int_10h_0ch__write_graphics_pixel.html",
    "t": "INT 10H 0cH: Write Graphics Pixel",
    "b": "Compatibility: All\n Expects: AH 0cH\n AL color number (+80H means XOR with current value)\n BH video page (0-based)\n CX graphics column\n DX graphics row\n ──────────────────────────────────────────────────────────────────\n Returns: (none)\n ──────────────────────────────────────────────────────────────────\n Info: Even on the FASTEST computers, this fn is WAY TOO SLOW to expect\n to get any reasonable amount of drawing done.\n\n The BIOS does not support line-drawing or other standard graphics\n primitives. To draw graphics with reasonable speed, you must\n access video memory directly. See Video Memory Layouts.\n\n Notes: When you add 80H to the color value in AL, the specified color is\n XORed with the color that is currently at that position. That is\n a useful graphics operation since XORing the same value twice\n ends up with the original value.\n\nSee Also: INT 10H 0dH (read graphics pixel)\n INT 10H: Video Services\n -♦-"
  },
  {
    "id": "128-int_10h_0dh__read_graphics_pixel.html",
    "t": "INT 10H 0dH: Read Graphics Pixel",
    "b": "Compatibility: All\n Expects: AH 0dH\n BH video page (0-based)\n CX graphics column\n DX graphics row\n ──────────────────────────────────────────────────────────────────\n Returns: AL color value of dot at specified position\n ──────────────────────────────────────────────────────────────────\n Info: This obtains the color value of the dot at the specified graphics\n screen location.\n\n The BIOS provides very little graphics drawing support. To use\n graphics with reasonable speed, you must access video memory\n directly. See Video Memory Layouts.\n\nSee Also: INT 10H 0cH (write graphics pixel)\n INT 10H: Video Services\n -♦-"
  },
  {
    "id": "129-int_10h_0eh__write_character_as_tty.html",
    "t": "INT 10H 0eH: Write Character as TTY",
    "b": "Compatibility: All\n Expects: AH 0eH\n AL character to write\n BL (graphics modes only) foreground color number\n ──────────────────────────────────────────────────────────────────\n Returns: (none)\n ──────────────────────────────────────────────────────────────────\n Info: Writes the specified character to the current cursor position and\n updates the cursor position. When the cursor advances to the end\n of the last screen line, this scrolls the text up one line.\n\n This writes the character only. It is displayed with whatever\n video attribute is currently at the cursor position. Also, when\n the screen scrolls, it fills the next line with the current\n attribute of the lower-right corner of the screen.\n\n This function treats these characters specially:\n\n CR (0dH) ─── cursor to start of next line\n LF (0aH) ─── cursor to current clm on next lower line\n BEL (07H) ─── beep the speaker\n\n This is too slow for most apps. See Video Memory Layouts.\n\nSee Also: INT 10H 13H (display a string of characters)\n INT 10H 09H (write a character and attribute)\n -♦-"
  },
  {
    "id": "130-int_10h_0fh__query_current_video_info.html",
    "t": "INT 10H 0fH: Query Current Video Info",
    "b": "Compatibility: All\n Expects: AH 0fH\n ──────────────────────────────────────────────────────────────────\n Returns: AL current video mode\n AH width of screen, in character columns\n BH current active video page (0-based)\n ──────────────────────────────────────────────────────────────────\n Info: This obtains a certain data regarding the current video mode.\n\n Use INT 10H 12H (special fns) and\n see EGA/VGA Data Areas to get info on EGA modes.\n\n Use INT 10H 1bH (get functionality/state info) for VGA modes.\n\n Use INT 10H 4f03H (get SVGA info) to get info on VESA modes\n\nSee Also: INT 10H: Video Services\n -♦-"
  },
  {
    "id": "131-int_10h_13h__at_ega_vga_string_display_functions.html",
    "t": "INT 10H 13H: AT/EGA/VGA String Display Functions",
    "b": "Compatibility: AT EGA VGA\n\n See: INT 10H 1300H (display string)\n\n INT 10H 1301H (display string and update cursor)\n\n INT 10H 1302H (display character/attribute cells)\n\n INT 10H 1303H (display character/attribute cells & update cursor)\n\nSee Also: INT 10H: Video Services\n -♦-"
  },
  {
    "id": "132-int_10h_1300h__display_string.html",
    "t": "INT 10H 1300H: Display String",
    "b": "Compatibility: AT EGA VGA\n Expects: AX 1300H\n BH video page\n BL video attribute\n CX length of string\n DH,DL row,column to start writing\n ES:BP address of start of text to write\n ──────────────────────────────────────────────────────────────────\n Returns: (none)\n ──────────────────────────────────────────────────────────────────\n Info: This displays a string of text, using a specified video attribute\n and starting at a specified screen location.\n\n This does not change the cursor position.\n\n This function treats these characters specially:\n\n CR (0dH) ─── cursor to start of same line\n LF (0aH) ─── cursor to current clm on next lower line\n BEL (07H) ─── beep the speaker\n\n Notice that you must supply both CR+FL to perform a natural\n \"newline\" (that is, to move the cursor to the start of the next\n lower line).\n\n Note: This fn requires that you modify BP. When calling from high-\n level languages such as C, be very careful to save and restore\n BP, since it is used to keep track of the \"stack frame\".\n\nSee Also: INT 10H 1301H (write string & update cursor)\n INT 10H 1302H (write char/attr cells)\n INT 10H: Video Services\n -♦-"
  },
  {
    "id": "133-int_10h_1301h__display_string_and_update_cursor.html",
    "t": "INT 10H 1301H: Display String and Update Cursor",
    "b": "Compatibility: AT EGA VGA\n Expects: AX 1301H\n BH video page\n BL video attribute\n CX length of string\n DH,DL row,column to start writing\n ES:BP address of start of text to write\n ──────────────────────────────────────────────────────────────────\n Returns: (none)\n ──────────────────────────────────────────────────────────────────\n Info: This displays a string of text, using a specified video attribute\n and starting at a specified screen location.\n\n It automatically updates the cursor location, leaving it one\n column beyond the last character written.\n\n This function treats these characters specially:\n\n CR (0dH) ─── cursor to start of same line\n LF (0aH) ─── cursor to current clm on next lower line\n BEL (07H) ─── beep the speaker\n\n Notice that you must supply both CR+FL to perform a natural\n \"newline\" (that is, to move the cursor to the start of the next\n lower line).\n\n Note: This fn requires that you modify BP. When calling from high-\n level languages such as C, be very careful to save and restore\n BP, since it is used to keep track of the \"stack frame\".\n\nSee Also: INT 10H 1300H (write string)\n INT 10H 1302H (write char/attr cells)\n INT 10H 1303H (write char/attr cells & update cursor)\n INT 10H: Video Services\n -♦-"
  },
  {
    "id": "134-int_10h_1302h__display_character_attribute_cells.html",
    "t": "INT 10H 1302H: Display Character/Attribute Cells",
    "b": "Compatibility: AT EGA VGA\n Expects: AX 1302H\n BH video page\n CX number of characters to display (see below)\n DH,DL row,column to start writing\n ES:BP address of start of char/attr string to write\n ──────────────────────────────────────────────────────────────────\n Returns: (none)\n ──────────────────────────────────────────────────────────────────\n Info: This displays a specially-formatted string, letting you specify a\n video attribute for each character.\n\n ES:BP This must point to an array of character/attribute pairs. For\n instance,\n\n DB 'H',07H, 'e',07H, 'l',07H, 'l',07H, 'o',07H, '!',0fH\n\n Would display Hello! (actually, the \"Hello\" would be in white\n characters on a black background (video attribute 07H), and \"!\"\n would be in bright white on a black background (attribute 0fH).\n\n Warning! This function treats these characters specially:\n\n CR (0dH) ─── cursor to start of same line\n LF (0aH) ─── cursor to current clm on next lower line\n BEL (07H) ─── beep the speaker\n\n When it encounters one of these characters, it takes the listed\n control action, and then treats the next byte as a character-not\n the attribute for the (undisplayed) control action.\n\n CX specifies the number of characters in the string (it will\n typically be half the length of the char/attr array).\n\n Notes: ■ This fn requires that you modify BP. When calling from high-\n level languages such as C, be very to save and restore BP,\n since it is used to keep track of the \"stack frame\".\n\n ■ Be careful about the odd handling of CR, LF, and BEL. After\n \"displaying\" any of these characters, the char/attr pairs are\n out of sync. Thus, this is not useful as a generic tool for\n restoring screen data that has been copied directly from video\n memory (see Video Memory Layouts).\n\nSee Also: INT 10H 1300H (write string)\n INT 10H 1301H (write string & update cursor)\n INT 10H 1303H (write char/attr cells and update cursor)\n INT 10H: Video Services\n -♦-"
  },
  {
    "id": "135-int_10h_1303h__display_char_attr_cells___update_cursor.html",
    "t": "INT 10H 1303H: Display Char/Attr Cells & Update Cursor",
    "b": "Compatibility: AT EGA VGA\n Expects: AX 1303H\n BH video page\n CX number of characters to display (see below)\n DH,DL row,column to start writing\n ES:BP address of start of char/attr string to write\n ──────────────────────────────────────────────────────────────────\n Returns: (none)\n ──────────────────────────────────────────────────────────────────\n Info: This displays a specially-formatted string, letting you specify a\n video attribute for each character.\n\n This works like fn 1302H, except that it updates the cursor\n location, leaving it one column beyond the last character\n written.\n\n See INT 10H 1302H for important notes on using this fn.\n\nSee Also: INT 10H 1300H (write string)\n INT 10H 1301H (write string & update cursor)\n INT 10H: Video Services\n -♦-"
  },
  {
    "id": "136-int_10h_10h__ega_vga_palette_functions.html",
    "t": "INT 10H 10H: EGA/VGA Palette Functions",
    "b": "Compatibility: EGA VGA\n See: 1000H EGA/VGA (set one palette register)\n 1001H EGA/VGA (set overscan/border color)\n 1002H EGA/VGA (set all palette registers & border color)\n 1003H EGA/VGA (select foreground blink or bold background)\n\n 1007H VGA (read one palette register)\n 1008H VGA (read overscan/border color)\n 1009H VGA (read all pallet registers & border color)\n\n 1010H VGA (set one DAC color register)\n 1012H VGA (set block of DAC color registers)\n 1013H VGA (DAC color paging functions)\n\n 1015H VGA (read one DAC color register)\n\n 1017H VGA (read block of DAC color registers)\n\n 101aH VGA (query DAC color paging state)\n 101bH VGA (convert DAC colors to grey scale)\n\n These functions are put in place by ROM-Scan when an EGA▲ or VGA▲ card is\n installed and are built into the standard ROMS for PS/2 systems. They are\n not available on CGA▲ or MDA▲ systems.\n\nSee Also: INT 10H: Video Services\n EGA/VGA Data Areas\n EGA\n VGA\n -♦-"
  },
  {
    "id": "137-int_10h_1000h__set_one_palette_register.html",
    "t": "INT 10H 1000H: Set One Palette Register",
    "b": "Compatibility: EGA VGA\n Expects: AX 1000H\n BL register number to set (a 4-bit attribute nibble: 00-0fH)\n BH 6-bit RGB color to display for that attribute\n ──────────────────────────────────────────────────────────────────\n Returns: (none)\n ──────────────────────────────────────────────────────────────────\n Info: This sets a specified palette register on and EGA/VGA card to a\n specified 6-bit RGB value; thereby changing the color that is\n displayed for a graphics-mode color and a text-mode attribute.\n\n BL is a palette register, 00H=0fH. By default the palette is\n programmed with the 16 colors described in the Video Attributes\n topic.\n\n BH is a 6-bit rgbRGB color setting, as follows:\n\n ╓7┬6┬5┬4┬3┬2┬1┬0╖\n ║ │r│g│b│R│G│B║ Note: R,G,B are 2/3-intensity\n ╙─┴─┴╥┴╥┴╥┴╥┴╥┴╥╜ bit r,g,b are 1/3-intensity\n ║ ║ ║ ║ ║ ╚═► 0: 01H Blue\n ║ ║ ║ ║ ╚═══► 1: 02H Green\n ║ ║ ║ ╚═════► 2: 04H Red\n ║ ║ ╚═══════► 3: 08H blue' (also MDA-emulation underline)\n ║ ╚═════════► 4: 10H green' (also CGA-emulation intensity)\n ╚═══════════► 5: 20H red'\n\n For example, video attribute 07H usually means white-on-black.\n But after calling this with BL=00H and BH=24H, you have changed\n all \"black\" attributes to mean \"bright red\", so video attribute\n 07H now displays as white characters on a bright red background\n and 70H displays as bright red on white.\n\n Notes: EGA/VGA BIOS does not check the validity of BL and will program\n any of the ATC registers to the value in BH. Thus, you can use\n this to modify the border color, mode control and other ATC\n registers at port 3c0H. See EGA I/O Ports.\n\nSee Also: INT 10H 10H: EGA/VGA Palette Functions\n INT 10H: Video Services\n EGA/VGA Data Areas\n -♦-"
  },
  {
    "id": "138-int_10h_1001h__set_overscan_border_color_register.html",
    "t": "INT 10H 1001H: Set Overscan/Border Color Register",
    "b": "Compatibility: EGA VGA\n Expects: AX 1001H\n BH 6-bit RGB color to display for that attribute\n ──────────────────────────────────────────────────────────────────\n Returns: (none)\n ──────────────────────────────────────────────────────────────────\n Info: This sets the EGA/VGA screen border to a specific rgbRGB color.\n\n BH is a 6-bit rgbRGB color setting, as follows:\n\n ╓7┬6┬5┬4┬3┬2┬1┬0╖\n ║ │r│g│b│R│G│B║ Note: R,G,B are 2/3-intensity\n ╙─┴─┴╥┴╥┴╥┴╥┴╥┴╥╜ bit r,g,b are 1/3-intensity\n ║ ║ ║ ║ ║ ╚═► 0: 01H Blue\n ║ ║ ║ ║ ╚═══► 1: 02H Green\n ║ ║ ║ ╚═════► 2: 04H Red\n ║ ║ ╚═══════► 3: 08H blue'\n ║ ╚═════════► 4: 10H green' (also CGA-emulation intensity)\n ╚═══════════► 5: 20H red'\n\n Notes: ■ To make the border color match a particular video attribute,\n you may use need to use INT 10H 1007H (read one palette\n register) to obtain the rgbRGB setting for that attribute.\n\n ■ The CGA-compatible fn, INT 10H 0bH also sets the border color.\n\n ■ The EGA/VGA overscan area is so anemic, that it is probably\n best to leave this as 00H (black).\n\nSee Also: INT 10H 10H: EGA/VGA Palette Functions\n INT 10H: Video Services\n EGA/VGA Data Areas\n -♦-"
  },
  {
    "id": "139-int_10h_1002h__set_all_palette_registers_and_overscan.html",
    "t": "INT 10H 1002H: Set All Palette Registers and Overscan",
    "b": "Compatibility: EGA VGA\n Expects: AX 1002H\n ES:BX address of 17 bytes; an rgbRGB value for each of 16 palette\n registers plus one for the border.\n ──────────────────────────────────────────────────────────────────\n Returns: (none)\n ──────────────────────────────────────────────────────────────────\n Info: This reprograms the entire palette and the overscan/border\n register.\n\n ES:BX is a far address of a series of 17 one-byte rgbRGB values. See\n INT 10H 1000H and EGA I/O Ports for info on rgbRGB palette\n register settings.\n\nSee Also: INT 10H 10H: EGA/VGA Palette Functions\n INT 10H: Video Services\n EGA/VGA Data Areas\n -♦-"
  },
  {
    "id": "140-int_10h_1003h__select_foreground_blink_or_bold_background.html",
    "t": "INT 10H 1003H: Select Foreground Blink or Bold Background",
    "b": "Compatibility: EGA VGA\n Expects: AX 1003H\n BL 00H = enable bold backgrounds (16 background colors)\n 01H = enable blinking foreground (8 background colors)\n ──────────────────────────────────────────────────────────────────\n Returns: (none)\n ──────────────────────────────────────────────────────────────────\n Info: This enables or disables blinking foreground colors in EGA/VGA\n text modes. By default, the BIOS enables blinking foregrounds\n (characters blink when bit 7 of the Video Attribute is set).\n\n When foreground blink is disabled (BL=00H), all 16 colors are\n available for use as background colors.\n\n Notes: This fn is not available on CGAs▲ and MDAs▲. To use this\n attractive and often-seen effect, you must program the CGA Mode\n Select Register, manually clearing bit 5. See CGA I/O Ports.\n For instance:\n mov ax,40H\n mov es,ax\n mov dx,es:[063H] ;get port address of the card\n add dx,4\n mov al,es:[065H] ;get current value of Mode Select Register\n and al,0dfH ;mask value by 1101 1111 (to clear bit 5)\n out dx,al ;disable blink (set for bold background)\n mov es:[065H],al ;save the new setting\n\nSee Also: INT 10H 10H: EGA/VGA Palette Functions\n INT 10H: Video Services\n EGA/VGA Data Areas\n -♦-"
  },
  {
    "id": "141-int_10h_1007h__read_one_palette_register.html",
    "t": "INT 10H 1007H: Read One Palette Register",
    "b": "Compatibility: VGA\n Expects: AX 1007H\n BL palette register to read (00H-0fH)\n ──────────────────────────────────────────────────────────────────\n Returns: BH current rgbRGB value of specified register\n ──────────────────────────────────────────────────────────────────\n Info: This obtains the current value of rgbRGB of the specified VGA\n palette register. See INT 10H 1000H and EGA I/O Ports for info\n on rgbRGB palette register settings.\n\n Notes: BIOS does not check the validity of BL on this fn and will return\n any of the ATC registers (00H-14H). See EGA I/O Ports.\n\nSee Also: INT 10H 10H: EGA/VGA Palette Functions\n INT 10H: Video Services\n EGA/VGA Data Areas\n -♦-"
  },
  {
    "id": "142-int_10h_1008h__read_overscan_register.html",
    "t": "INT 10H 1008H: Read Overscan Register",
    "b": "Compatibility: VGA\n Expects: AX 1008H\n ──────────────────────────────────────────────────────────────────\n Returns: BH current rgbRGB value of the overscan/border register\n ──────────────────────────────────────────────────────────────────\n Info: This obtains the current value of rgbRGB of the VGA overscan\n (border) register. See INT 10H 1000H and EGA I/O Ports for info\n on rgbRGB palette register settings.\n\nSee Also: INT 10H 10H: EGA/VGA Palette Functions\n INT 10H: Video Services\n EGA/VGA Data Areas\n -♦-"
  },
  {
    "id": "143-int_10h_1009h__read_all_palette_registers.html",
    "t": "INT 10H 1009H: Read All Palette Registers",
    "b": "Compatibility: VGA\n Expects: AX 1009H\n ES:BX address of 17-byte buffer to receive data\n ──────────────────────────────────────────────────────────────────\n Returns: ES:BX buffer contains 16 palette regs + overscan reg\n ──────────────────────────────────────────────────────────────────\n Info: This obtains the current rgbRGB values of all the VGA palette\n registers and the overscan (border) register. See INT 10H 1000H\n and EGA I/O Ports for info on rgbRGB palette register settings.\n\n ES:BX must point to a 17-byte buffer to receive the data.\n\n Notes: ■ This is typically used by a program which wants to save the\n palette in order to restore it later. You may prefer to use\n INT 10H 1cH for save/restore operations.\n\n ■ Since the EGA BIOS does not support this fn, palette\n manipulation by TSRs and task-switchers is difficult. The\n standard DOS device driver, EGA.SYS intercepts INT 10H and\n emulates this function (it tracks the current palette as set\n via BIOS calls, but cannot track direct I/O port manipulation).\n\nSee Also: INT 10H 10H: EGA/VGA Palette Functions\n INT 10H: Video Services\n EGA/VGA Data Areas\n -♦-"
  },
  {
    "id": "144-int_10h_1010h__set_one_dac_color_register.html",
    "t": "INT 10H 1010H: Set One DAC Color Register",
    "b": "Compatibility: VGA\n Expects: AX 1010H\n BX color register to set (0-255)\n CH green value (00H-3fH)\n CL blue value (00H-3fH)\n DH red value (00H-3fH)\n ──────────────────────────────────────────────────────────────────\n Returns: (none)\n ──────────────────────────────────────────────────────────────────\n Info: This sets a specified DAC color register on a VGA card to a\n specified 18-bit value. It allows you to make very subtle\n changes to color settings--the VGA can display 256 of the 262,144\n different colors at once (when in a 256-color video mode).\n\n BX selects one of the 256 DAC color registers (00H-ffH). The high-\n order 8 bits are ignored.\n\n In text modes, DAC registers 00-0fH normally represent palette\n registers 00-0fH (and thereby affect the color settings of text-\n mode video attributes). You can use INT 10H 1013H to set the 256\n color registers as 16 banks of 16 colors and then activate any of\n the 16 banks for instant redefinition of the entire palette.\n\n DH,CH,CL are Red, Green, and Blue settings. Only the low 6 bits of each\n element are used, so each can range from 0 to 3fH (64 possible\n shades). Thus, there are 64x64x64=262,144 possible RGB settings.\n\n Notes: Use INT 10H 1015H to obtain the RGB values of a DAC register.\n Use INT 10H 1012H to set a block of DAC registers all at once.\n\nSee Also: INT 10H 10H: EGA/VGA Palette Functions\n INT 10H: Video Services\n EGA/VGA Data Areas\n -♦-"
  },
  {
    "id": "145-int_10h_1012h__set_a_block_of_dac_color_register.html",
    "t": "INT 10H 1012H: Set a Block of DAC Color Register",
    "b": "Compatibility: VGA\n Expects: AX 1012H\n BX first DAC register to set (0-00ffH)\n CX number of registers to set (0-00ffH)\n ES:DX addr of a table of R,G,B values (it will be CX*3 bytes long)\n ──────────────────────────────────────────────────────────────────\n Returns: (none)\n ──────────────────────────────────────────────────────────────────\n Info: On VGAs, this sets the RGB values for a consecutive block of DAC\n color registers. Starting with register number in BX, CX\n registers are programmed with values from the table at ES:DX.\n\n ES:DX is the address of a series of 3-byte RGB values, laid out as\n Red,Green,Blue, Red,Green,Blue,... The table should be CX*3\n bytes long.\n\n See INT 10H 1010H (set one DAC color register) for related info.\n\n Notes: Use INT 10H 1017H to obtain the current settings for a block of\n DAC color registers.\n See INT 10H 1013H for a reason why you might tend to work with\n 16- or 64-register blocks.\n\nSee Also: INT 10H 10H: EGA/VGA Palette Functions\n INT 10H: Video Services\n EGA/VGA Data Areas\n VGA I/O Ports\n -♦-"
  },
  {
    "id": "146-int_10h_1013h__dac_color_paging_functions.html",
    "t": "INT 10H 1013H: DAC Color Paging Functions",
    "b": "Compatibility: VGA\n Expects: AX 1013H\n BL subfn: 00H = select color paging mode\n BH = paging mode\n 00H = 4 blocks of 64 registers\n 01H = 16 blocks of 16 registers\n\n BL subfn: 01H = activate color page\n BH = DAC color page number\n 00H-03H (4-page/64-reg mode)\n 00H-0fH (16-page/16-reg mode)\n ──────────────────────────────────────────────────────────────────\n Returns: (none)\n ──────────────────────────────────────────────────────────────────\n Info: This lets you choose a DAC color-paging mode to enable groupings\n of color registers. It also lets you activate a particular DAC\n register page.\n\n Text-mode users will prefer 16-color paging mode (BX=0100H),\n making it possible to quickly map any of 16 color set to the 16\n possible text-mode attribute colors.\n\n For instance, imagine setting up 16 groups with gradually-\n increasing brightness of all colors. Then you could cycle\n through the groups (BX=0001H, BX=0101H, BX=0201H...) to brighten\n or dim the entire screen.\n\n Notes: Use INT 10H 101aH (query color paging state) to obtain the\n current settings.\n\nSee Also: INT 10H 10H: EGA/VGA Palette Functions\n INT 10H: Video Services\n EGA/VGA Data Areas\n VGA I/O Ports\n -♦-"
  },
  {
    "id": "147-int_10h_1015h__read_one_dac_color_register.html",
    "t": "INT 10H 1015H: Read One DAC Color Register",
    "b": "Compatibility: VGA\n Expects: AX 1015H\n BX color register to read (0-255)\n ──────────────────────────────────────────────────────────────────\n Returns: CH green value (00H-3fH)\n CL blue value (00H-3fH)\n DH red value (00H-3fH)\n ──────────────────────────────────────────────────────────────────\n Info: This obtains the current 18-bit RGB value of a specified DAC\n color register.\n\n See INT 10H 1010H for background info on 18-bit RGB values for\n DAC color registers.\n\n Notes: Use INT 10H 1017H to obtain the RGB values of a block of DAC\n registers.\n\nSee Also: INT 10H 10H: EGA/VGA Palette Functions\n INT 10H: Video Services\n EGA/VGA Data Areas\n VGA I/O Ports\n -♦-"
  },
  {
    "id": "148-int_10h_1017h__read_a_block_of_dac_color_registers.html",
    "t": "INT 10H 1017H: Read a Block of DAC Color Registers",
    "b": "Compatibility: VGA\n Expects: AX 1017H\n BX first DAC register to read (0-00ffH)\n CX number of registers to read (0-00ffH)\n ES:DX addr of a buffer to hold R,G,B values (CX*3 bytes long)\n ──────────────────────────────────────────────────────────────────\n Returns: ES:DX buffer contains returned data\n ──────────────────────────────────────────────────────────────────\n Info: This obtains the current 18-bit RGB values of a consecutive block\n of DAC color registers.\n\n On entry, the buffer at ES:DX must be large enough to hold the\n requested data. Each register takes 3 bytes, so the buffer must\n be CX*3 bytes long.\n\n On return, the table is laid out as Red,Green,Blue,\n Red,Green,Blue, ... etc. Only the low-order 6 bits of each byte\n has meaning. See INT 10H 1010H for background info on 18-bit RGB\n values for DAC color registers.\n\n Notes: Use INT 10H 1012H to program a block of DAC registers.\n See INT 10H 1013H for a reason why you might tend to work with\n 16- or 64-register blocks.\n\nSee Also: INT 10H 10H: EGA/VGA Palette Functions\n INT 10H: Video Services\n EGA/VGA Data Areas\n VGA I/O Ports\n -♦-"
  },
  {
    "id": "149-int_10h_101ah__query_dac_color_paging_state.html",
    "t": "INT 10H 101aH: Query DAC Color Paging State",
    "b": "Compatibility: VGA\n Expects: AX 101aH\n ──────────────────────────────────────────────────────────────────\n Returns: BH current active DAC color page\n BL current active DAC paging mode\n ──────────────────────────────────────────────────────────────────\n Info: Obtains the current settings in use for DAC color paging. On\n return:\n\n BL 00H = mode 0 (4 blocks of 64 registers)\n 01H = mode 1 (16 blocks of 16 registers\n\n BH active page number (0-3 in mode 0 or 0-15 in mode 1)\n\n See INT 10H 1013H (DAC color paging fns) for related info.\n\nSee Also: INT 10H 10H: EGA/VGA Palette Functions\n INT 10H: Video Services\n EGA/VGA Data Areas\n -♦-"
  },
  {
    "id": "150-int_10h_101bh__convert_dac_colors_to_gray_scale_values.html",
    "t": "INT 10H 101bH: Convert DAC Colors to Gray-Scale Values",
    "b": "Compatibility: VGA\n Expects: AX 101bH\n BX first color register to convert\n CX number of color registers to convert\n ──────────────────────────────────────────────────────────────────\n Returns: (none)\n ──────────────────────────────────────────────────────────────────\n Info: This converts (sums) a range of DAC color values into gray-scale\n values.\n\n The R,G,B of each of the specified registers is weighed according\n to a BIOS internal system and replaced with values that are\n displayed as shades of gray.\n\n Notes: ■ In performing the conversion, the BIOS uses:\n 30% of the Red value\n 59% of the Green value\n 11% of the Blue value\n\n ■ The BIOS performs gray-scale summing by default when it detects\n a monochrome display. That data may be found in the rMiscFlags\n field of the VgaDynamicStateRec.\n\nSee Also: INT 10H 10H: EGA/VGA Palette Functions\n INT 10H: Video Services\n EGA/VGA Data Areas\n -♦-"
  },
  {
    "id": "151-int_10h_11h__ega_vga_character_generator_functions.html",
    "t": "INT 10H 11H: EGA/VGA Character Generator Functions",
    "b": "Compatibility: EGA VGA\n See: 1100H EGA/VGA (load user-defined font)\n 1101H EGA/VGA (load ROM 8x14 font)\n 1102H EGA/VGA (load ROM 8x8 font)\n 1103H EGA/VGA (activate font block; 512-character set)\n 1104H VGA (load ROM 8x16 font)\n\n 1110H EGA/VGA (load and activate user-defined font)\n 1111H EGA/VGA (load and activate ROM 8x14 font)\n 1112H EGA/VGA (load and activate ROM 8x8 font)\n 1114H VGA (load and activate ROM 8x16 font)\n\n 1120H VGA (setup INT 1fH graphics font pointer)\n 1121H VGA (setup user-defined font for graphics)\n 1122H VGA (ROM 8x14 font for graphics modes)\n 1123H VGA (ROM 8x8 font for graphics modes)\n 1124H VGA (ROM 8x16 font for graphics modes)\n\n 1130H VGA (get video font information)\n\n These functions are put in place by ROM-Scan when an EGA▲ or VGA▲ card is\n installed and are built into the standard ROMS for PS/2 systems. They are\n not available on CGA▲ or MDA▲ systems.\n\nSee Also: Video Font Definition\n INT 10H: Video Services\n EGA/VGA Data Areas\n EGA\n VGA\n -♦-"
  },
  {
    "id": "152-int_10h_1100h__load_user_defined_font.html",
    "t": "INT 10H 1100H: Load User-Defined Font",
    "b": "Compatibility: EGA VGA\n Expects: AX 1100H\n BH height of each character (bytes per character definition)\n BL font block to load (EGA: 0-3; VGA: 0-7)\n CX number of characters to redefine\n DX ASCII code of the first character defined at ES:BP\n ES:BP address of font-definition information\n ──────────────────────────────────────────────────────────────────\n Returns: (none)\n ──────────────────────────────────────────────────────────────────\n Info: Redefines one or more characters on EGA/VGA cards. It copies\n user-supplied character-definition information to a table in\n video RAM.\n\n This fn does not program the CRTC or set BIOS variables to make\n allowances for changes in character height, etc. Use\n INT 10H 1110H to have the BIOS do that automatically.\n\n You may use this to change the display of a single character or\n an entire 256-character set. You can also set up a secondary\n font-definition to be selected by bit 3 of the video attribute\n (see INT 10H 1103H).\n\n BH specifies how high each character is, in scan-lines; thus, it\n describes how many byte are needed to define each character (the\n BIOS always uses a width of 8, so one byte describes the bit\n pattern for one line of the character matrix).\n\n BL specifies which of the up-to eight tables in EGA/VGA character-\n definition RAM should be affected. See INT 10H 1103H (activate\n font block). Normally, you will use BL=0, since block 0 is\n normally the active font block.\n\n CX specifies how many characters are to be redefined.\n\n DX identifies the first character you wish to define. Valid values\n are 0-255.\n\n ES:BP points to a table containing the character-definition codes. It\n should be BH*CX bytes long. The table is laid out as a series of\n CX groups of BH bytes in each group.\n\n See Video Font Definition for byte layout.\n\n Note: This fn requires that you modify BP. When calling from high-\n level languages such as C, be very careful to save and restore\n BP, since it is used to keep track of the \"stack frame\".\n\nSee Also: INT 10H 11H: EGA/VGA Character Generator Functions\n INT 10H: Video Services\n EGA/VGA Data Areas\n -♦-"
  },
  {
    "id": "153-int_10h_1101h__load_rom_8x14_character_set.html",
    "t": "INT 10H 1101H: Load ROM 8x14 Character Set",
    "b": "Compatibility: EGA VGA\n Expects: AX 1100H\n BL font block to load (EGA: 0-3; VGA: 0-7)\n ──────────────────────────────────────────────────────────────────\n Returns: (none)\n ──────────────────────────────────────────────────────────────────\n Info: Redefines the characters on EGA/VGA cards to use the 14-scanline-\n high text-mode font.\n\n This is the normal setting for 25-line mode EGAs (25*14=350, the\n height of the EGA display). On VGAs, this makes it possible to\n display in a 28-line mode (14*28=392, of a 400-high screen).\n\n This fn does not program the CRTC or set BIOS variables to make\n allowances for changes in character height, etc. Use\n INT 10H 1111H to have the BIOS do that automatically.\n\n BL specifies which of the up-to eight tables in EGA/VGA character-\n definition RAM should be affected. See INT 10H 1103H (activate\n font block). Normally, you will use BL=0, since block 0 is\n normally the active font block.\n\nSee Also: INT 10H 11H: EGA/VGA Character Generator Functions\n INT 10H: Video Services\n EGA/VGA Data Areas\n -♦-"
  },
  {
    "id": "154-int_10h_1102h__load_rom_8x8_character_set.html",
    "t": "INT 10H 1102H: Load ROM 8x8 Character Set",
    "b": "Compatibility: EGA VGA\n Expects: AX 1102H\n BL font block to load (EGA: 0-3; VGA: 0-7)\n ──────────────────────────────────────────────────────────────────\n Returns: (none)\n ──────────────────────────────────────────────────────────────────\n Info: Redefines the characters on EGA/VGA cards to use the 8-scanline-\n high text-mode font.\n\n This is a small font. On EGAs, this makes it possible to display\n in a 43-line mode (32*8=344, of a max 350 high screen). On VGAs,\n this makes it possible to display in a 50-line mode (50*8=400,\n the max VGA height).\n\n This fn does not program the CRTC or set BIOS variables to make\n allowances for changes in character height, etc. Use\n INT 10H 1112H to have the BIOS do that automatically.\n\n BL specifies which of the up-to eight tables in EGA/VGA character-\n definition RAM should be affected. See INT 10H 1103H (activate\n font block). Normally, you will use BL=0, since block 0 is\n normally the active font block.\n\nSee Also: INT 10H 11H: EGA/VGA Character Generator Functions\n INT 10H: Video Services\n EGA/VGA Data Areas\n -♦-"
  },
  {
    "id": "155-int_10h_1103h__activate_font_block.html",
    "t": "INT 10H 1103H: Activate Font Block",
    "b": "Compatibility: EGA VGA\n Expects: AX 1101H\n BL font block selector code (see below)\n ──────────────────────────────────────────────────────────────────\n Returns: (none)\n ──────────────────────────────────────────────────────────────────\n Info: This fn lets you activate any of the EGAs four font blocks or any\n of the VGAs 8 font blocks.\n\n It also makes it possible to create a 512-element character set.\n Use it to identify which (previously-loaded) font block is to be\n displayed when bit 3 of the Video Attribute is clear and which to\n be displayed when bit 3 of the attribute is set.\n\n Attribute bit 3 normally selects the intensity of the foreground\n color. After using this fn, you will have only 8 possible\n foreground colors, but you can display up to 512 characters\n simultaneously (for instance, you can display italic characters\n along with upright characters).\n\n BL is a set of bit-fields which identify which font block to use\n when video attribute bit 3 is 1 or 0.\n\n EGAFontBlockRec (for EGAs)\n ╓7┬6┬5┬4┬3┬2┬1┬0╖\n ║0 0 0 0│cs1│cs0║\n ╙─┴─┴─┴─┴─┴─┴─┴─╜ bits mask\n ╚╦╝ ╚═╩═► 0-1: 03H (0-3) font when attr bit 3=0\n ╚══════► 2-3: 0cH (0-3) font when attr bit 3=1\n\n VGAFontBlockRec (for VGAs)\n ╓7┬6┬5┬4┬3┬2┬1┬0╖\n ║0 0│a│b│cs1│cs0║\n ╙─┴─┴╥┴┬┴╥┴╥┴┬┴┬╜ bits mask\n ║ └─║-║─┴─┴─► 0,1,4: 13H (0-7) font when attr bit 3=0\n ╚═══╩═╩═════► 2,3,5: 2cH (0-7) font when attr bit 3=1\n\n In the VGA version, bits 4 and 5 are used in an upwardly-\n compatible way to extend the possible selections to 8.\n\n When both selections are the same (for instance, BL=00H selects\n both characters sets to be font block 0), then BIOS disables the\n 512-character set handling and enables normal use of the video\n attribute.\n\n For instance, to enable font block 2 only, use BL=82H. You would\n first need to prepare the font block via INT 10H 1101H (or 1102H\n or 1104H).\n\n Notes: When using a 512-character set, you need not give up high-\n intensity characters. Just use INT 10H 10H functions to program\n the color palette.\n\nSee Also: INT 10H 11H: EGA/VGA Character Generator Functions\n INT 10H: Video Services\n EGA/VGA Data Areas\n -♦-"
  },
  {
    "id": "156-int_10h_1104h__load_rom_8x16_character_set.html",
    "t": "INT 10H 1104H: Load ROM 8x16 Character Set",
    "b": "Compatibility: VGA\n Expects: AX 1104H\n BL font block to load (VGA: 0-7)\n ──────────────────────────────────────────────────────────────────\n Returns: (none)\n ──────────────────────────────────────────────────────────────────\n Info: Redefines the characters on VGA cards to use the standard 16-\n scanline-high text-mode font.\n\n This is the default font initialized by the BIOS on a mode reset\n (such as DOS's Mode Co80 command).\n\n This fn does not reprogram the CRTC or BIOS variables to make\n allowances for changes in character height, etc. Use\n INT 10H 1114H to have the BIOS do that automatically.\n\n BL specifies which of the (up to) eight tables in EGA/VGA character-\n definition RAM should be affected. See INT 10H 1103H (activate\n font block). Normally, you will use BL=0, since block 0 is\n normally the active font block.\n\nSee Also: INT 10H 11H: EGA/VGA Character Generator Functions\n INT 10H: Video Services\n EGA/VGA Data Areas\n -♦-"
  },
  {
    "id": "157-int_10h_1110h__load_and_activate_user_defined_font.html",
    "t": "INT 10H 1110H: Load and Activate User-Defined Font",
    "b": "Compatibility: EGA VGA\n Expects: AX 1110H\n BH height of each character (bytes per character definition)\n BL font block to load (EGA: 0-3; VGA: 0-7)\n CX number of characters to redefine\n DX ASCII code of the first character defined at ES:BP\n ES:BP address of font-definition information\n ──────────────────────────────────────────────────────────────────\n Returns: (none)\n ──────────────────────────────────────────────────────────────────\n Info: Redefines one or more characters on EGA/VGA cards, exactly as\n described for INT 10H 1100H, except that it takes the additional\n steps needed to activate the font.\n\nSee Also: INT 10H 11H: EGA/VGA Character Generator Functions\n INT 10H: Video Services\n EGA/VGA Data Areas\n -♦-"
  },
  {
    "id": "158-int_10h_1111h__load_and_activate_rom_8x14_character_set.html",
    "t": "INT 10H 1111H: Load and Activate ROM 8x14 Character Set",
    "b": "Compatibility: EGA VGA\n Expects: AX 1110H\n BL font block to load (EGA: 0-3; VGA: 0-7)\n ──────────────────────────────────────────────────────────────────\n Returns: (none)\n ──────────────────────────────────────────────────────────────────\n Info: Redefines the characters on EGA/VGA cards to use the 14-scanline-\n high text-mode font, exactly as described for INT 10H 1101H,\n except that it takes the additional steps needed to activate the\n font.\n\nSee Also: INT 10H 11H: EGA/VGA Character Generator Functions\n INT 10H: Video Services\n EGA/VGA Data Areas\n -♦-"
  },
  {
    "id": "159-int_10h_1112h__load_and_activate_rom_8x8_character_set.html",
    "t": "INT 10H 1112H: Load and Activate ROM 8x8 Character Set",
    "b": "Compatibility: EGA VGA\n Expects: AX 1112H\n BL font block to load (EGA: 0-3; VGA: 0-7)\n ──────────────────────────────────────────────────────────────────\n Returns: (none)\n ──────────────────────────────────────────────────────────────────\n Info: Redefines the characters on EGA/VGA cards to use the 8-scanline-\n high text-mode font, exactly as described for INT 10H 1102H,\n except that it takes the additional steps needed to activate the\n font.\n\nSee Also: INT 10H 11H: EGA/VGA Character Generator Functions\n INT 10H: Video Services\n EGA/VGA Data Areas\n -♦-"
  },
  {
    "id": "160-int_10h_1114h__load_and_activate_rom_8x16_character_set.html",
    "t": "INT 10H 1114H: Load and activate ROM 8x16 Character Set",
    "b": "Compatibility: VGA\n Expects: AX 1114H\n BL font block to load (VGA: 0-7)\n ──────────────────────────────────────────────────────────────────\n Returns: (none)\n ──────────────────────────────────────────────────────────────────\n Info: Redefines the characters on VGA cards to use the standard 16-\n scanline-high text-mode font, exactly as described for\n INT 10H 1104H, except that it takes the additional steps needed\n to activate the font.\n\nSee Also: INT 10H 11H: EGA/VGA Character Generator Functions\n INT 10H: Video Services\n EGA/VGA Data Areas\n -♦-"
  },
  {
    "id": "161-int_10h_1120h__setup_int_1fh_vector.html",
    "t": "INT 10H 1120H: Setup INT 1fH Vector",
    "b": "Compatibility: EGA VGA\n Expects: AX 1120H\n ES:BP address of 8x8 font-definition info for > chars 128\n ──────────────────────────────────────────────────────────────────\n Returns: (none)\n ──────────────────────────────────────────────────────────────────\n Info: This just saves ES:BP into the vector for INT 1fH; that is it\n defines how the BIOS will display characters from 80H-ffH when in\n CGA-graphics mode (200 vertical res).\n\n ES:BP points to a table containing the character-definition codes. It\n should be 2048 bytes long.\n\n See Video Font Definition for byte layout.\n\n Note: This fn requires that you modify BP. When calling from high-\n level languages such as C, be very careful to save and restore\n BP, since it is used to keep track of the \"stack frame\".\n\nSee Also: INT 10H 11H: EGA/VGA Character Generator Functions\n INT 10H: Video Services\n EGA/VGA Data Areas\n -♦-"
  },
  {
    "id": "162-int_10h_1121h__setup_user_defined_font_for_graphics_mode.html",
    "t": "INT 10H 1121H: Setup User-Defined Font for Graphics Mode",
    "b": "Compatibility: EGA VGA\n Expects: AX 1121H\n BL screen rows code: 00H = user-specified (in DL)\n 01H = 14 rows\n 02H = 25 rows\n 03H = 43 rows\n CX bytes per character definition\n DL (when BL=0) custom number of character rows on screen\n ES:BP address of font-definition information\n ──────────────────────────────────────────────────────────────────\n Returns: (none)\n ──────────────────────────────────────────────────────────────────\n Info: Sets up a custom character set to be used by the BIOS when\n displaying text while in graphics modes. This sets the INT 43H\n vector and sets BIOS variables so it can use the custom font.\n\n ES:BP points to a table containing the character-definition codes. It\n should be CX*256 bytes long (if you are defining all 256 ASCII\n characters). The table is laid out as a series of groups with\n CX bytes in each group.\n\n See Video Font Definition for byte layout.\n\n Note: This fn requires that you modify BP. When calling from high-\n level languages such as C, be very careful to save and restore\n BP, since it is used to keep track of the \"stack frame\".\n\nSee Also: INT 10H 11H: EGA/VGA Character Generator Functions\n INT 10H: Video Services\n EGA/VGA Data Areas\n -♦-"
  },
  {
    "id": "163-int_10h_1122h__setup_rom_8x14_font_for_graphics_mode.html",
    "t": "INT 10H 1122H: Setup ROM 8x14 Font for Graphics Mode",
    "b": "Compatibility: EGA VGA\n Expects: AX 1122H\n BL screen rows code: 00H = user-specified (in DL)\n 01H = 14 rows\n 02H = 25 rows\n 03H = 43 rows\n DL (when BL=0) custom number of character rows on screen\n ──────────────────────────────────────────────────────────────────\n Returns: (none)\n ──────────────────────────────────────────────────────────────────\n Info: Sets up to use the ROM-defined 8x14 characters when the BIOS\n displays text while in graphics modes. This sets the INT 43H\n vector and sets BIOS variables needed to use the font.\n\nSee Also: INT 10H 11H: EGA/VGA Character Generator Functions\n INT 10H: Video Services\n EGA/VGA Data Areas\n -♦-"
  },
  {
    "id": "164-int_10h_1123h__setup_rom_8x8_font_for_graphics_mode.html",
    "t": "INT 10H 1123H: Setup ROM 8x8 Font for Graphics Mode",
    "b": "Compatibility: EGA VGA\n Expects: AX 1123H\n BL screen rows code: 00H = user-specified (in DL)\n 01H = 14 rows\n 02H = 25 rows\n 03H = 43 rows\n DL (when BL=0) custom number of character rows on screen\n ──────────────────────────────────────────────────────────────────\n Returns: (none)\n ──────────────────────────────────────────────────────────────────\n Info: Sets up to use the ROM-defined 8x8 characters when the BIOS\n displays text while in graphics modes. This sets the INT 43H\n vector and sets BIOS variables needed to use the font.\n\nSee Also: INT 10H 11H: EGA/VGA Character Generator Functions\n INT 10H: Video Services\n EGA/VGA Data Areas\n -♦-"
  },
  {
    "id": "165-int_10h_1124h__setup_rom_8x16_font_for_graphics_mode.html",
    "t": "INT 10H 1124H: Setup ROM 8x16 Font for Graphics Mode",
    "b": "Compatibility: VGA\n Expects: AX 1124H\n BL screen rows code: 00H = user-specified (in DL)\n 01H = 14 rows\n 02H = 25 rows\n 03H = 43 rows\n DL (when BL=0) custom number of character rows on screen\n ──────────────────────────────────────────────────────────────────\n Returns: (none)\n ──────────────────────────────────────────────────────────────────\n Info: Sets up to use the ROM-defined 8x16 characters when the BIOS\n displays text while in graphics modes. This sets the INT 43H\n vector and sets BIOS variables needed to use the font.\n\nSee Also: INT 10H 11H: EGA/VGA Character Generator Functions\n INT 10H: Video Services\n EGA/VGA Data Areas\n -♦-"
  },
  {
    "id": "166-int_10h_1130h__get_current_character_generator_info.html",
    "t": "INT 10H 1130H: Get Current Character Generator Info",
    "b": "Compatibility: EGA VGA\n Expects: AX 1130H\n BH request code: 00H = get addr at INT 1fH vector\n 01H = get addr at INT 43H vector\n 02H = get addr of ROM 8x14 font\n 03H = get addr of ROM 8x8 font\n 04H = get addr of ROM 8x8 font (2nd half)\n 05H = get addr of ROM 9x14 alternate font\n (VGA) 06H = get addr of ROM 8x16 font\n (VGA) 07H = get addr of ROM 8x16 alternate font\n ──────────────────────────────────────────────────────────────────\n Returns: CX height (scan-lines) / bytes per character (from 0040:0085)\n DL screen rows (from 0040:0084)\n ES:BP address of requested font-definition table\n ──────────────────────────────────────────────────────────────────\n Info: This provides a means to locate ROM-defined character-definition\n tables.\n\n A typical use would be to copy the table data, make some custom\n modifications, then modify the EGA/VGA Data Areas to point to you\n changed table, and then use TSR function to make the changes\n permanent.\n\n The tables are always CX*256 bytes long.\n\nSee Also: INT 10H 11H: EGA/VGA Character Generator Functions\n INT 10H: Video Services\n EGA/VGA Data Areas\n -♦-"
  },
  {
    "id": "167-int_10h_12h__ega_vga_special_functions_alternate_select.html",
    "t": "INT 10H 12H: EGA/VGA Special Functions/Alternate Select",
    "b": "Compatibility: EGA VGA\n See: BL=10H EGA/VGA (get EGA info)\n BL=20H EGA/VGA (use alternate print screen)\n BL=30H VGA (set text-mode scan-lines)\n BL=31H VGA (enable default palette loading)\n BL=32H VGA (enable access to video)\n BL=33H VGA (enable gray-scale summing)\n BL=34H VGA (enable cursor emulation)\n BL=35H VGA (PS/2 display switching)\n BL=36H VGA (screen refresh on/off)\n\n These functions are put in place by ROM-Scan when an EGA▲ or VGA▲ card is\n installed and are built into the standard ROMS for PS/2 systems. They are\n not available on CGA▲ or MDA▲ systems.\n\nSee Also: Video Font Definition\n INT 10H: Video Services\n EGA/VGA Data Areas\n EGA\n VGA\n -♦-"
  },
  {
    "id": "168-int_10h_12h_bl_10h__get_ega_information.html",
    "t": "INT 10H 12H BL=10H: Get EGA Information",
    "b": "Compatibility: EGA VGA\n Expects: AH 12H\n BL 10H\n ──────────────────────────────────────────────────────────────────\n Returns: BH default BIOS setup (0=color; 1=monochrome)\n BL mem size code (0=64K; 1=128K; 2=192K; 3=256K)\n (Note: if BL>4, then this is not an EGA BIOS)\n CH feature bits (values of those RCA connectors)\n CL switch settings\n ──────────────────────────────────────────────────────────────────\n Info: This obtains miscellaneous information about the EGA switch\n settings and the current values of the \"feature bits\" as read\n through those rarely-used RCA connectors on some EGA cards.\n\n If upon return from this call, BL>4, then you must be running on\n a CGA or MDA (not an EGA or VGA).\n\nSee Also: INT 10H 12H (EGA/VGA Special Functions/Alternate Select)\n INT 10H: Video Services\n -♦-"
  },
  {
    "id": "169-int_10h_12h_bl_20h__select_alternate_print_screen_handler.html",
    "t": "INT 10H 12H BL=20H: Select Alternate Print Screen Handler",
    "b": "Compatibility: EGA VGA\n Expects: AH 12H\n BL 20H\n ──────────────────────────────────────────────────────────────────\n Returns: (none)\n ──────────────────────────────────────────────────────────────────\n Info: This redirects the INT 05H (print screen) vector to a handler\n within the EGA/VGA ROM-BIOS.\n\n On older PCs, XTs, and ATs, the default ROM-BIOS print-screen\n handler stops printing after 25 lines. The EGA/VGA handler\n correctly prints the number of lines specified in the byte at\n 0040:0084 in the BIOS Data Area.\n\n Notes: Most EGAs and VGAs set this automatically. However, it is good\n practice to use this fn whenever you change the number of video\n lines that are displayed in text mode.\n\nSee Also: INT 10H 12H (EGA/VGA Special Functions/Alternate Select)\n INT 10H: Video Services\n EGA/VGA Data Areas\n -♦-"
  },
  {
    "id": "170-int_10h_12h_bl_30h__select_scan_lines_for_text_modes.html",
    "t": "INT 10H 12H BL=30H: Select Scan Lines for Text Modes",
    "b": "Compatibility: VGA\n Expects: AH 12H\n BL 03H\n AL scan-lines code: 00H = 200 scan lines (EGA/VGA)\n 01H = 350 scan lines (EGA/VGA)\n 02H = 400 scan lines (VGA only)\n ──────────────────────────────────────────────────────────────────\n Returns: AH 12H if a VGA is active\n ──────────────────────────────────────────────────────────────────\n Info: This updates bits 0-3 in the EgaMiscInfo2Rec (at 0040:0088) and\n bits 4 and 7 of the VgaFlagsRec (at 0040:0089).\n\n Then, on the next INT 10H 00H call to switch to a text mode, the\n specified resolution will be in effect.\n\nSee Also: INT 10H 12H (EGA/VGA Special Functions/Alternate Select)\n INT 10H: Video Services\n EGA/VGA Data Areas\n -♦-"
  },
  {
    "id": "171-int_10h_12h_bl_31h__palette_loading_on_mode_set.html",
    "t": "INT 10H 12H BL=31H: Palette Loading on Mode Set",
    "b": "Compatibility: VGA\n Expects: AH 12H\n BL 31H\n AL setting: 00H=enable default palette loading on mode reset\n 01H=disable (use current palette on mode changes)\n ──────────────────────────────────────────────────────────────────\n Returns: AH 12H if a valid value was passed in AL\n ──────────────────────────────────────────────────────────────────\n Info: This changes how the BIOS handles the color palette on subsequent\n calls to INT 10H 00H (set video mode). It updates bit 3 of the\n VgaFlagsRec (at 0040:0089).\n\n When automatic palette loading is enabled (the default setting),\n the BIOS reprograms the ATC with the default palette values each\n time the video mode is reset. You can modify the VgaSavePtr2Rec\n to setup your own palette to be used the default.\n\n When disabled, the current palette setting are left in place on\n mode changes.\n\nSee Also: INT 10H 12H (EGA/VGA Special Functions/Alternate Select)\n INT 10H: Video Services\n EGA/VGA Data Areas\n -♦-"
  },
  {
    "id": "172-int_10h_12h_bl_32h__enable_disable_video_ram___i_o_ports.html",
    "t": "INT 10H 12H BL=32H: Enable/Disable Video RAM & I/O Ports",
    "b": "Compatibility: VGA\n Expects: AH 12H\n BL 32H\n AL setting: 00H enable access\n 01H disable access\n ──────────────────────────────────────────────────────────────────\n Returns: AH 12H if a valid value was passed in AL\n ──────────────────────────────────────────────────────────────────\n Info: You can use this to suppress CPU access to video RAM and I/O\n ports on VGA-compatible displays. It updates bit 0 of the\n VgaFlagsRec (at 0040:0089).\n\n Notes: You can disable an EGA card via bit 1 of port 3c2H.\n\nSee Also: INT 10H 12H (EGA/VGA Special Functions/Alternate Select)\n INT 10H: Video Services\n EGA/VGA Data Areas\n -♦-"
  },
  {
    "id": "173-int_10h_12h_bl_33h__enable_disable_gray_scale_summing.html",
    "t": "INT 10H 12H BL=33H: Enable/Disable Gray-Scale Summing",
    "b": "Compatibility: VGA\n Expects: AH 12H\n BL 33H\n AL setting: 00H enable gray-scale summing\n 01H disable gray-scale summing\n ──────────────────────────────────────────────────────────────────\n Returns: AH 12H if a valid value was passed in AL\n ──────────────────────────────────────────────────────────────────\n Info: This updates bit 1 of the VgaFlagsRec (at 0040:0089).\n\n On the next mode reset (via INT 10H 00H), if that bit is set,\n then the BIOS will automatically reprogram the palette to display\n only shades of gray.\n\nSee Also: INT 10H 12H: EGA/VGA Special Functions/Alternate Select\n INT 10H: Video Services\n EGA/VGA Data Areas\n -♦-"
  },
  {
    "id": "174-int_10h_12h_bl_34h__cursor_emulation__scaling_.html",
    "t": "INT 10H 12H BL=34H: Cursor Emulation (Scaling)",
    "b": "Compatibility: VGA\n Expects: AH 12H\n BL 34H\n AL setting: 00H enable cursor emulation\n 01H disable cursor emulation\n ──────────────────────────────────────────────────────────────────\n Returns: AH 12H if a valid value was passed in AL\n ──────────────────────────────────────────────────────────────────\n Info: This updates bit 0 of the EgaMiscInfoRec (at 0040:0087).\n\n When cursor emulation is in effect, the BIOS assumes that input\n to INT 10H 01H (set cursor size) is meant to be relative to a\n CGA-style 8x8 character matrix and it automatically adjusts\n (scales) the input values to match the true character matrix.\n\nSee Also: INT 10H 12H (EGA/VGA Special Functions/Alternate Select)\n INT 10H: Video Services\n EGA/VGA Data Areas\n -♦-"
  },
  {
    "id": "175-int_10h_12h_bl_35h__switch_ps_2_displays.html",
    "t": "INT 10H 12H BL=35H: Switch PS/2 Displays",
    "b": "Compatibility: VGA\n Expects: AH 12H\n BL 00H\n AL subfn: 00H = prepare for adapter switching off\n ES:DX => 128-byte buffer to hold state data\n 01H = prepare for system board video switching off\n 02H = switch off active video\n ES:DX => 128-byte buffer to hold state data\n 03H = switch on active display\n ES:DX => 128-byte buffer containing saved data\n ──────────────────────────────────────────────────────────────────\n Returns: AH 12H if a valid value was passed in AL\n ──────────────────────────────────────────────────────────────────\n Info: ON PS/2 systems, this provides a means to switch between the\n built-in VGA (on the motherboard) and another, incompatible\n display system.\n\nSee Also: INT 10H 12H (EGA/VGA Special Functions/Alternate Select)\n INT 10H: Video Services\n EGA/VGA Data Areas\n -♦-"
  },
  {
    "id": "176-int_10h_12h_bl_36h__enable_disable_screen_refresh.html",
    "t": "INT 10H 12H BL=36H: Enable/Disable Screen Refresh",
    "b": "Compatibility: VGA\n Expects: AH 12H\n BL 36H\n AL setting: 00H enable refresh\n 01H disable refresh\n ──────────────────────────────────────────────────────────────────\n Returns: AH 12H if a valid value was passed in AL\n ──────────────────────────────────────────────────────────────────\n Info: This modifies bit 5 of the VGA's Sequencer Clocking Mode Register\n (see VGA I/O Ports).\n\n You can draw complex graphics faster while refresh is disabled\n (it avoids some enforced wait states). Be sure to re-enable\n refresh when finished updating video memory.\n\nSee Also: INT 10H 12H (EGA/VGA Special Functions/Alternate Select)\n INT 10H: Video Services\n EGA/VGA Data Areas\n -♦-"
  },
  {
    "id": "177-int_10h_1ah__set_or_query_display_combination_code.html",
    "t": "INT 10H 1aH: Set or Query Display Combination Code",
    "b": "Compatibility: VGA\n Expects: AH 1aH\n AL Subfn: 00H= Query current display combination\n 01H= Select DCC (activate a different display)\n BX BL=ID of active display;\n BH=ID of inactive display\n ──────────────────────────────────────────────────────────────────\n Returns: AL 1aH (if this fn is supported)\n BL ID of active display\n BH ID of inactive display\n ──────────────────────────────────────────────────────────────────\n Info: This returns or updates the DCC byte at 0040:008a.\n\n When AL=00H, the current DCC code is returned in BX.\n When AL=01H, the BIOS examines the DCC table to see if the\n specified combination is valid, and then deactivates the video\n subsystem identified in BH and activates that in BL.\n\n The following display ID codes are recognized\n\n 00H no display (BH=00H if only one display is installed)\n 01H MDPA on monochrome screen\n 02H CGA color 07H VGA analog monochrome\n 04H EGA color 08H VGA analog color\n 05H EGA monochrome 0bH Model 30 analog monochrome\n 06H PGC color 0cH Model 30 analog color\n\n Notes: DCC handling is mainly a feature of PS/2 hardware; it was\n designed as a means to disable the VGA controller on the PS/2's\n motherboard in order to take advantage of future improvements in\n video technology.\n\n Not many VGA BIOSes provide full support of display combination\n switching, though most support subfn AL=00H to indicate type 08H\n in BL.\n\nSee Also: INT 10H: Video Services\n EGA/VGA Data Areas\n -♦-"
  },
  {
    "id": "178-int_10h_1bh__get_vga_functionality_and_state_info.html",
    "t": "INT 10H 1bH: Get VGA Functionality and State Info",
    "b": "Compatibility: VGA\n Expects: AX 1bH\n BX 0000H (implementation type; must be 0)\n ES:DI address of 64-byte buffer to receive a VgaDynamicStateRec\n ──────────────────────────────────────────────────────────────────\n Returns: ES:DI buffer filled with data\n AL 1bH (if this fn and implementation type is supported)\n ──────────────────────────────────────────────────────────────────\n Info: This returns a wheelbarrow full of info about the overall\n capabilities of a VGA system and about the current settings such\n as video mode, cursor size, ATC and CRTC register settings, etc.\n\n See VGA Dynamic State Table and VGA Static Functionality Table\n for the layout of the returned information.\n\n Notes: ■ You will find it much easier to use this fn than to examine the\n various bits and pieces in the BIOS Data Area or by direct port\n I/O.\n\n ■ A common program initialization sequence requests this\n function, and if not available (i.e, not a VGA), collects info\n from other INT 10H calls and from the EGA/VGA Data Areas to\n fill in the missing info.\n\nSee Also: INT 10H: Video Services\n EGA/VGA Data Areas\n -♦-"
  },
  {
    "id": "179-int_10h_1ch__vga_state_save_restore_functions.html",
    "t": "INT 10H 1cH: VGA State Save/Restore Functions",
    "b": "Compatibility: VGA\n See: 1c00H VGA (query size of save buffer)\n\n 1c01H VGA (save current video state)\n\n 1c02H VGA (restore video state from saved data)\n\n These functions are put in place by ROM-Scan when a VGA▲ card is installed\n and are built into the standard ROMS for PS/2 systems. They are not\n available on EGA▲, CGA▲ or MDA▲ systems.\n\nSee Also: INT 10H: Video Services\n EGA/VGA Data Areas\n EGA\n VGA\n -♦-"
  },
  {
    "id": "180-int_10h_1c00h__vga_query_size_of_state_save_buffer.html",
    "t": "INT 10H 1c00H: VGA Query Size of State-Save Buffer",
    "b": "Compatibility: VGA\n Expects: AX 1c00H\n CX type(s) of video-state info expected to be saved (see below)\n ──────────────────────────────────────────────────────────────────\n Returns: AL 1cH (if this fn is supported)\n BX size of save-state buffer, in 64-byte blocks\n ──────────────────────────────────────────────────────────────────\n Info: Use this fn before calling INT 10H 1c01H (save video state). It\n lets you know how much memory will be needed to save the\n specified video state information.\n\n CX is a set of bit-flags indicating what types of video-state\n information you need to save:\n 1 1\n ╓5┬4┬ ┬7┬6┬5┬4┬3┬2┬1┬0╖\n ║0 0•••│0 0 0 0 0│c│d│h║\n ╙─┴─┴ ┴─┴─┴─┴─┴─┴╥┴╥┴╥╜ bit mask\n ║ ║ ╚═► 0: 01H video hardware state info\n ║ ╚═══► 1: 02H video BIOS data area info\n ╚═════► 2: 04H DAC state and color registers\n\nSee Also: INT 10H 1cH (VGA Save/Restore Functions)\n INT 10H: Video Services\n EGA/VGA Data Areas\n -♦-"
  },
  {
    "id": "181-int_10h_1c01h__vga_save_video_state.html",
    "t": "INT 10H 1c01H: VGA Save Video State",
    "b": "Compatibility: VGA\n Expects: AX 1c01H\n CX type(s) of video-state info to save (see below)\n ES:BX address of buffer to hold video-state info\n ──────────────────────────────────────────────────────────────────\n Returns: AL 1cH (if this fn is supported)\n ──────────────────────────────────────────────────────────────────\n Info: This saves the current state of the VGA video system. Use\n INT 10H 1c02H to restore the system state later on.\n\n CX is a set of bit-flags indicating what types of video-state\n information you need to save:\n 1 1\n ╓5┬4┬ ┬7┬6┬5┬4┬3┬2┬1┬0╖\n ║0 0•••│0 0 0 0 0│c│d│h║\n ╙─┴─┴ ┴─┴─┴─┴─┴─┴╥┴╥┴╥╜ bit mask\n ║ ║ ╚═► 0: 01H video hardware state info\n ║ ╚═══► 1: 02H video BIOS data area info\n ╚═════► 2: 04H DAC state and color registers\n\n ES:BX The size of the buffer that this address varies, depending upon\n the value in CX. Be sure to use INT 10H 1c00H (with CX having\n the same value!) to obtain the required size and then be sure\n your buffer is large enough to hold the returned information.\n\n The layout of the video-state information is not documented.\n\n Notes: This is very handy for task-switching software such as the DOS\n Shell and can be useful in systems that switch in-and-out of\n graphics modes.\n\n Alas, EGA, CGAs, and MDAs do not support this fn, so if your\n program needs to save/restore the video state for other types of\n video systems, you still need to do some manual labor to collect\n the information.\n\nSee Also: INT 10H 1cH (VGA Save/Restore Functions)\n INT 10H: Video Services\n EGA/VGA Data Areas\n -♦-"
  },
  {
    "id": "182-int_10h_1c02h__vga_restore_video_state.html",
    "t": "INT 10H 1c02H: VGA Restore Video State",
    "b": "Compatibility: VGA\n Expects: AX 1c02H\n CX type(s) of video-state info to restore (see below)\n ES:BX address of buffer containing video-state info\n ──────────────────────────────────────────────────────────────────\n Returns: AL 1cH (if this fn is supported)\n ──────────────────────────────────────────────────────────────────\n Info: This restores the VGA video system to its state at the time when\n it was saved via INT 10H 1c01H.\n\n CX is a set of bit-flags indicating what types of video-state\n information you need to restore:\n 1 1\n ╓5┬4┬ ┬7┬6┬5┬4┬3┬2┬1┬0╖\n ║0 0•••│0 0 0 0 0│c│d│h║\n ╙─┴─┴ ┴─┴─┴─┴─┴─┴╥┴╥┴╥╜ bit mask\n ║ ║ ╚═► 0: 01H video hardware state info\n ║ ╚═══► 1: 02H video BIOS data area info\n ╚═════► 2: 04H DAC state and color registers\n\n ES:BX Be sure that the data at this address contains valid information\n as saved via INT 10H 1c01H (with CX having the same value!).\n\n The layout of the video-state information is not documented.\n\n Notes: This is very handy for task-switching software such as the DOS\n Shell and can be useful in systems that switch in-and-out of\n graphics modes.\n\nSee Also: INT 10H 1cH (VGA Save/Restore Functions)\n INT 10H: Video Services\n EGA/VGA Data Areas\n -♦-"
  },
  {
    "id": "183-int_11h__equipment_check.html",
    "t": "INT 11H: Equipment Check",
    "b": "INT 11H returns a 16-bit value that provides some information about the\n devices attached to the computer.\n\n See...\n\n Equipment List\n\n ...for a layout of this data.\n\n Note: The same information is found at 0040:0010 in the BIOS Data Area.\n\nSee Also: CMOS Storage Layout (low-level configuration info)\n CONFIG.SYS Commands\n Mouse Functions\n CD-ROM Services\n Expanded Memory Services\n Power Management\n IRQs: Hardware Interrupts\n BIOS Data Area\n -♦-"
  },
  {
    "id": "184-int_12h__conventional_memory_size.html",
    "t": "INT 12H: Conventional Memory Size",
    "b": "Expects: none (just execute INT 12H)\n ──────────────────────────────────────────────────────────────────\n Returns: AX conventional▲ memory size, in Kbytes\n ──────────────────────────────────────────────────────────────────\n Info: This returns the amount of RAM in the conventional memory area.\n\n This is not particularly useful. On most computers it always\n returns 0280H (640 decimal). This is the same as the value found\n at 0040:0013 in the BIOS Data Area.\n\n It does not include expanded▲ memory or extended▲ memory above\n 1 MB. See EMM Functions, XMS Functions and INT 15H for ways to\n obtain that information.\n\n On PCs, this value is taken from the switch settings. PCjrs,\n XTs, and most clones perform a memory scan during the POST to\n determine how much memory is installed. The AT reads its\n CMOS Memory to determine the amount of conventional memory, as\n determined via a \"setup utility\".\n\n The PSP: Program Segment Prefix of any program also contains a\n memory-size value; accessing PSP:0002 is one way to determine how\n much RAM is available for a program to use. (DOS or a control\n program way wish to give your program less than the full amount\n of RAM). See Program Startup & Exit.\n\nSee Also: Memory Control Functions\n BIOS Data Area\n ROM-BIOS Functions\n -♦-"
  },
  {
    "id": "185-int_13h__bios_disk_i_o.html",
    "t": "INT 13H: BIOS Disk I/O",
    "b": "AH BIOS Service AH BIOS Service\n ▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀ ▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n ┌─ 00H reset controller : 0cH seek cylinder\n PC │ 01H get status │ 0dH alternate reset\n XT ┤ 02H read sectors │ 0eH (reserved)\n AT │ 03H write sectors XT ┤ 0fH (reserved)\n │ 04H verify sectors AT │ 10H test drive ready\n └─ 05H format track │ 11H recalibrate\n 06H (reserved) │ 12H (reserved)\n 07H (reserved) │ 13H (reserved)\n ┌─ 08H get drive parms └─ 14H controller diagnostics\n XT │ 09H init drive parm tbls ┌─ 15H get disk/diskette type\n AT ┤ 0aH read long AT ┤ 16H disk change status\n : 0bH write long └─ 17H and 18H: Set media type\n\n Use these service for direct access to the diskette or hard disk adapters.\n It is advisable to use DOS functions (dropping down to INT 25H/26H when\n needed for low-level access), to let the DOS device drivers do all the\n work. Of course, for very low-level access, including reading sectors on\n a non-DOS disk, INT 13H may be the only alternative.\n\n And don't overlook DOS fn 440dH (IOCTL for block devices) as a way to\n format diskettes and access entire tracks of data.\n\n█▌Diskette vs. Hard Disk Access▐█\n The BIOS in the oldest PCs support access to diskette drives only. It\n supported only fns 00H-05H.\n\n Later, the XT and AT hard disk adapter cards patched-in additional\n ROM-Scan code to intercept INT 13H and watch for a drive number (in DL)\n that is 80H or higher. With these later systems, the original INT 13H\n vector is stored as the INT 40H vector. The hard-disk logic checks DL\n and passes control to INT 40H when DL is less than 80H. Note that the\n BIOS disk error code returned in AH will vary, depending on whether the\n function was for a diskette or a hard disk.\n\n Nowadays, most systems support all disk I/O as part of the ROM-BIOS. Also\n operating systems such a Windows may replace the BIOS code altogether to\n obtain faster response--especially for read/write operations to RAM above\n 1 MB.\n\n The most significant difference between diskette access and hard disk\n access is that on multi-sector reads and writes to a hard disk, the BIOS\n will automatically advance to the next head/cylinder. All diskette access\n is limited to a single head/track.\n\n Another thing to watch for is the diskette spin-up time. If you get an\n error accessing a diskette drive, reset the controller and try at least\n three times before giving up.\n\nSee Also: I/O Port Map and Diskette Controller Ports\n Disk Drive Functions\n BIOS Data Area\n ROM-BIOS Functions\n INT 25H/26H (DOS absolute sector access)\n DOS fn 440dH (IOCTL for block devices)\n -♦-"
  },
  {
    "id": "186-int_13h_00h__reset_drive.html",
    "t": "INT 13H 00H: Reset Drive",
    "b": "[PC] [XT] [AT]\n Expects: AH 00H\n ──────────────────────────────────────────────────────────────────\n Returns: AH BIOS disk error code if CF is set to CY\n ──────────────────────────────────────────────────────────────────\n Info: Forces a recalibration of the diskette and hard disk controller.\n\n It places head 0 to track 0 of all drives.\n\n After an unexpected disk error, use this, then retry the\n operation.\n\nSee Also: INT 13H: BIOS Disk I/O\n DOS fn 0eH (reset disk)\n BIOS Data Area\n ROM-BIOS Functions\n -♦-"
  },
  {
    "id": "187-int_13h_01h__query_disk_error_status.html",
    "t": "INT 13H 01H: Query Disk Error Status",
    "b": "Expects: AH 01H\n DL drive: 00H thru 03H for diskette drives\n 80H or 81H for hard disk controller\n ──────────────────────────────────────────────────────────────────\n Returns: AH BIOS disk error code of most recent operation (0=no error)\n (this error code is also at 0040:0041).\n ──────────────────────────────────────────────────────────────────\n Info: Obtains the error/status code of the most recent disk I/O\n operation.\n\nSee Also: INT 13H: BIOS Disk I/O\n BIOS Data Area\n ROM-BIOS Functions\n -♦-"
  },
  {
    "id": "188-int_13h_02h__read_sectors.html",
    "t": "INT 13H 02H: Read Sectors",
    "b": "[PC] [XT] [AT]\n Expects: AH 02H\n AL sector count (see notes)\n CH track (cylinder) number (0-n) ◄═╗\n CL sector number (1-n) ◄═══════════╩══ (see notes)\n DL drive: 0-3=diskette; 80H-81H=hard disk\n DH head number\n ES:BX caller's buffer address\n 0:078 Diskette Parameter Table (for diskette operations)\n 0:104 Hard Disk Parameter Table (for hard disk operations)\n ──────────────────────────────────────────────────────────────────\n Returns: AH BIOS disk error code if CF is set to CY\n ES:BX caller's buffer will contain requested data (if no error)\n ──────────────────────────────────────────────────────────────────\n Info: This reads the specified sectors into memory at ES:BX.\n\n Notes: ■ CX is actually used as a 6-bit and 10-bit field to specify\n sector and cylinder (this is important on hard disks with more\n than 256 cylinders). CX is laid out as:\n\n ┌────── CH ─────┬───── CL ──────┐\n 1 1 1 1 1 1\n ╓5┬4┬3┬2┬1┬0┬9┬8╥7┬6┬5┬4┬3┬2┬1┬0╖\n CX: ║c c c c c c c c C c S s s s s s║\n ╙─┴─┴─┴─┴─┴─┴─┴─╨─┴─┴─┴─┴─┴─┴─┴─╜\n ╚═╩═══► high bits of cylinder number\n\n Note that this imposes a \"hard stop\" low-level limit on the\n number of cylinders on a disk (1024). Some BIOSs may support\n larger values by simulating additional heads and translating\n each request.\n\n ■ On diskette reads, this function stops a multi-sector read at\n the last sector in a track.\n\n ■ On hard disks (with XT and AT BIOSes), a multi-sector read\n continues on the next higher head of the same cylinder and if\n necessary, advances to the next higher cylinder on the first\n head.\n\n ■ Parameters are the same as for INT 13H 03H (write sectors).\n\n ■ Use INT 13H 0aH (extended read to read data+ECC).\n\nSee Also: INT 25H (read absolute sectors)\n DOS fn 440dH 61H (IOCTL read track)\n INT 13H: BIOS Disk I/O\n ROM-BIOS Functions\n -♦-"
  },
  {
    "id": "189-int_13h_03h__write_sectors.html",
    "t": "INT 13H 03H: Write Sectors",
    "b": "[PC] [XT] [AT]\n Expects: AH 03H\n AL sector count (see notes)\n CH track (cylinder) number (0-n) ◄═╗\n CL sector number (1-n) ◄═══════════╩══ (see notes)\n DL drive: 0-3=diskette; 80H-81H=hard disk\n DH head number\n ES:BX caller's buffer, containing data to write\n 0:078 Diskette Parameter Table (for diskette operations)\n 0:104 Hard Disk Parameter Table (for hard disk operations)\n ──────────────────────────────────────────────────────────────────\n Returns: AH BIOS disk error code if CF is set to CY\n ──────────────────────────────────────────────────────────────────\n Info: This writes the data at ES:BX to the specified sectors.\n\n Notes: ■ CX is actually used as a 6-bit and 10-bit field to specify\n sector and cylinder. The maximum cylinder number is 1023\n but some BIOSes support larger values via translation. See\n INT 13H 02H for details.\n\n ■ On diskette writes, this function stops a multi-sector write at\n the last sector in a track.\n\n ■ On hard disks (with XT and AT BIOSes), a multi-sector write\n continues on the next higher head of the same cylinder and if\n necessary, advances to the next higher cylinder on the first\n head.\n\n ■ Parameters are the same as for INT 13H 02H (read sectors).\n\nSee Also: INT 26H (write absolute sectors)\n DOS fn 440dH 41H (IOCTL read track)\n INT 13H: BIOS Disk I/O\n ROM-BIOS Functions\n -♦-"
  },
  {
    "id": "190-int_13h_04h__verify_sectors.html",
    "t": "INT 13H 04H: Verify Sectors",
    "b": "[PC] [XT] [AT]\n Expects: AH 04H\n AL sector count (see notes)\n CH track (cylinder) number (0-n) ◄═╗\n CL sector number (1-n) ◄═══════════╩══ (see notes)\n DL drive: 0-3=diskette; 80H-81H=hard disk\n DH head number\n ──────────────────────────────────────────────────────────────────\n Returns: AH BIOS disk error code if CF is set to CY\n ──────────────────────────────────────────────────────────────────\n Info: This verifies that the CRC▲ was correct for the specified\n sector(s). It does NOT actually compare disk data to memory.\n\n Notes: ■ CX is used as a 6-bit and 10-bit field to specify sector and\n cylinder. See INT 13H 02H for details.\n\n ■ On diskette writes, this function stops a multi-sector\n operation at the last sector in a track.\n\n ■ On hard disks (with XT and AT BIOSes), a multi-sector operation\n continues on the next higher head of the same cylinder and if\n necessary, advances to the next higher cylinder on the first\n head.\n\n ■ Parameters are the same as for INT 13H 02H (read sectors).\n\nSee Also: DOS fn 440dH 62H (IOCTL verify track)\n INT 13H: BIOS Disk I/O\n ROM-BIOS Functions\n -♦-"
  },
  {
    "id": "191-int_13h_05h__format_track.html",
    "t": "INT 13H 05H: Format Track",
    "b": "[PC] [XT] [AT]\n Expects: AH 05H\n CX track (cylinder) number in the high 10 bits (see below)\n DL drive: 0-3=diskette; 80H-81H=hard disk\n DH head number\n ES:BX addr of buffer containing formatting info (see notes)\n ──────────────────────────────────────────────────────────────────\n Returns: AH BIOS disk error code if CF is set to CY\n ──────────────────────────────────────────────────────────────────\n Info: This formats a single track on one head of a diskette or hard\n disk. Any existing data on that track is destroyed.\n\n CX Bits 6-7 of CL are the high two bits of the 10-bit value whose\n low 8 bits are in CH. See INT 13H 02H for details.\n\n ES:BX The layout of the data ate ES:BX varies by drive type and BIOS:\n\n PC (and all diskette operations)\n ES:BX points to a series of 4-byte values, one for each sector on\n the track. The layout is 'CHSL':\n\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 1 bCylinder track number: 0-n\n +1 1 bHead head number: 0-n\n +2 1 bSector sector number: 1-n\n +3 1 bLenCode 0=128, 1=125, 2=512, 3=1024\n\n There is one of these 4-byte structures for each sector on the\n track (for instance, 36 bytes for a 9-sector-per-track diskette).\n Interleave is set up by organizing them non-sequentially (e.g.,\n 1,5,2,6,3,7,4,8)\n\n AT (and all modern hard disk drives and BIOSes)\n ES:BX points to a series of 2-byte values, one for each sector on\n the track. The layout is 'FS':\n\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 1 bFlag 00=good, 80=bad/unusable\n +1 1 bSector head number: 0-n\n 2 length of one record\n\n There is one of these 2-byte structures for each sector on the\n track (for instance, 110 bytes for a 55-sector-per-track hard\n disk). Interleave is set up by organizing them non-sequentially.\n\n XT (very old XT BIOSes only)\n ES:BX is not used; instead AL contains an interleave value\n between 1 and 16.\n\nSee Also: DOS fn 440dH 42H (IOCTL format track)\n INT 13H: BIOS Disk I/O\n BIOS Data Area\n ROM-BIOS Functions\n -♦-"
  },
  {
    "id": "192-int_13h_08h__get_drive_parameters.html",
    "t": "INT 13H 08H: Get Drive Parameters",
    "b": "[XT] [AT]\n Expects: AH 08H\n DL drive: 0-3=diskette; 80H-81H=hard disk\n ──────────────────────────────────────────────────────────────────\n Returns: AH BIOS disk error code if CF is set to CY\n CX maximum value for cylinder and sector (see below)\n DL number of hard disks on first controller\n DH maximum value for head\n ES:DI address of Hard Disk Parameter Table\n ──────────────────────────────────────────────────────────────────\n Info: Returns information about a drive. These values are initially\n set from a table in ROM, determined by the disk-type code stored\n in CMOS Memory.\n\n CX Bits 6-7 of CL are the high two bits of the 10-bit value whose\n low 8 bits are in CH. See INT 13H 02H for details.\n\nSee Also: DOS Fn 440dH 60H (IOCTL get block device parameters)\n INT 13H: BIOS Disk I/O\n BIOS Data Area\n ROM-BIOS Functions\n -♦-"
  },
  {
    "id": "193-int_13h_09h__initialize_drive_parameter_table.html",
    "t": "INT 13H 09H: Initialize Drive Parameter Table",
    "b": "[XT] [AT]\n Expects: AH 09H\n DL hard drive: 80H=drive 0; or 81H=drive 1\n 0:104 Hard Disk Parameter Table for hard drive 0 (INT 41H vector)\n 0:118 Hard Disk Parameter Table for hard drive 1 (INT 46H vector)\n ──────────────────────────────────────────────────────────────────\n Returns: AH BIOS disk error code if CF is set to CY\n ──────────────────────────────────────────────────────────────────\n Info: This reinitializes the hard disk system for a particular hard\n drive (in DL) to use the low-level parameters in the\n corresponding disk parameter tables.\n\n When DL=80H, it sets up hard drive 0 to use the parameters at the\n table pointed to by the INT 41H vector (at 0:0104).\n\n When DL=81H, it sets up hard drive 1 to use the parameters at the\n table pointed to by the INT 46H vector (at 0:0118).\n\n Notes: ■ The only reason to use this would be after changing the\n contents of a Hard Disk Parameter Table; for instance, in\n writing a custom boot sector.\n\n ■ On XT systems, both drives use the parameters at the INT 41H\n vector.\n\nSee Also: INT 13H: BIOS Disk I/O\n BIOS Data Area\n ROM-BIOS Functions\n -♦-"
  },
  {
    "id": "194-int_13h_0ah__read_sector_plus_ecc.html",
    "t": "INT 13H 0aH: Read Sector Plus ECC",
    "b": "[XT] [AT]\n Expects: AH 0aH\n AL sector count (usually 1)\n CH track (cylinder) number (0-n) ◄═╗\n CL sector number (1-n) ◄═══════════╩══ (see below)\n DL drive: 80H-81H=hard disk 0-1\n DH head number\n ES:BX caller's buffer address\n ──────────────────────────────────────────────────────────────────\n Returns: AH BIOS disk error code if CF is set to CY\n ──────────────────────────────────────────────────────────────────\n Info: This works just like the standard Read (INT 13H 02H), except that\n four to seven bytes of data (the ECC▲ or Error Correction Code\n bytes) follow the contents of the sector.\n\n CX Bits 6-7 of CL are the high two bits of the 10-bit value whose\n low 8 bits are in CH. See INT 13H 02H for details.\n\n Notes: ■ This is typically used only by diagnostic software.\n\n ■ On a multiple-sector operation, this returns without finishing\n the read when it encounters an error.\n\nSee Also: INT 13H: BIOS Disk I/O\n BIOS Data Area\n ROM-BIOS Functions\n -♦-"
  },
  {
    "id": "195-int_13h_0bh__write_sector_plus_ecc.html",
    "t": "INT 13H 0bH: Write Sector Plus ECC",
    "b": "[XT] [AT]\n Expects: AH 0bH\n AL sector count (usually 1)\n CH track (cylinder) number (0-n) ◄═╗\n CL sector number (1-n) ◄═══════════╩══ (see below)\n DL drive: 80H-81H=hard disk 0-1\n DH head number\n ES:BX caller's buffer address\n ──────────────────────────────────────────────────────────────────\n Returns: AH BIOS disk error code if CF is set to CY\n ──────────────────────────────────────────────────────────────────\n Info: This works just like the standard Write (INT 13H 03H), except\n instead of allowing the controller to calculate the ECC▲, it uses\n the four to seven bytes that follow the data at ES:BX.\n\n CX Bits 6-7 of CL are the high two bits of the 10-bit value whose\n low 8 bits are in CH. See INT 13H 02H for details.\n\n Notes: ■ This is typically used only by diagnostic software.\n\n ■ On a multiple-sector operation, this returns without finishing\n the write when it encounters an error.\n\nSee Also: INT 13H: BIOS Disk I/O\n BIOS Data Area\n ROM-BIOS Functions\n -♦-"
  },
  {
    "id": "196-int_13h_0ch__seek_cylinder.html",
    "t": "INT 13H 0cH: Seek Cylinder",
    "b": "[XT] [AT]\n Expects: AH 0cH\n CX track (cylinder) number; see below\n DL drive: 80H-81H=hard disk 0-1\n DH head number\n ──────────────────────────────────────────────────────────────────\n Returns: AH BIOS disk error code if CF is set to CY\n ──────────────────────────────────────────────────────────────────\n Info: This moves the read/write head directly to a specified track.\n\n CX Bits 6-7 of CL are the high two bits of the 10-bit value whose\n low 8 bits are in CH. See INT 13H 02H for details.\n\n Notes: ■ It is not necessary to use this seek function before any other\n functions (such as read, write, format or verify).\n\n ■ This is used mainly in benchmark tests and diagnostic programs.\n\nSee Also: INT 13H: BIOS Disk I/O\n BIOS Data Area\n ROM-BIOS Functions\n -♦-"
  },
  {
    "id": "197-int_13h_0dh__alternate_reset_drive.html",
    "t": "INT 13H 0dH: Alternate Reset Drive",
    "b": "[XT] [AT]\n Expects: AH 0dH\n DL drive: 80H-81H=hard disk 0-1\n ──────────────────────────────────────────────────────────────────\n Returns: AH BIOS disk error code if CF is set to CY\n ──────────────────────────────────────────────────────────────────\n Info: This resets the hard disk system. It is like INT 13H 00H, except\n that it does not affect the diskette controller.\n\nSee Also: INT 13H: BIOS Disk I/O\n BIOS Data Area\n ROM-BIOS Functions\n -♦-"
  },
  {
    "id": "198-int_13h_10h__test_drive_ready.html",
    "t": "INT 13H 10H: Test Drive Ready",
    "b": "[XT] [AT]\n Expects: AH 10H\n DL drive: 80H-81H=hard disk 0-1\n ──────────────────────────────────────────────────────────────────\n Returns: AH BIOS disk error code if CF is set to CY\n ──────────────────────────────────────────────────────────────────\n Info: This determines if the drive specified in DL is ready and can\n process a command.\n\nSee Also: INT 13H: BIOS Disk I/O\n BIOS Data Area\n ROM-BIOS Functions\n -♦-"
  },
  {
    "id": "199-int_13h_11h__recalibrate_drive.html",
    "t": "INT 13H 11H: Recalibrate Drive",
    "b": "[XT] [AT]\n Expects: AH 11H\n DL drive: 80H-81H=hard disk 0-1\n ──────────────────────────────────────────────────────────────────\n Returns: AH BIOS disk error code if CF is set to CY\n ──────────────────────────────────────────────────────────────────\n Info: This positions head 0 head of the specified hard drive over\n track 0.\n\n Notes: ■ This is automatically performed by reset fns 00h and 0aH.\n\nSee Also: INT 13H: BIOS Disk I/O\n BIOS Data Area\n ROM-BIOS Functions\n -♦-"
  },
  {
    "id": "200-int_13h_14h__controller_self_test.html",
    "t": "INT 13H 14H: Controller Self-Test",
    "b": "[XT] [AT]\n Expects: AH 14H\n ──────────────────────────────────────────────────────────────────\n Returns: AH BIOS disk error code if CF is set to CY\n ──────────────────────────────────────────────────────────────────\n Info: This forces the hard disk controller to perform an internal self-\n test. Result is returned in AH.\n\nSee Also: INT 13H: BIOS Disk I/O\n BIOS Data Area\n ROM-BIOS Functions\n -♦-"
  },
  {
    "id": "201-int_13h_15h__get_diskette_type_or_check_hard_drive_installed.html",
    "t": "INT 13H 15H: Get Diskette Type or Check Hard Drive Installed",
    "b": "[AT]\n Expects: AH 15H\n DL drive: 00H thru 03H = diskette drive\n 80H or 81H = hard disk\n ──────────────────────────────────────────────────────────────────\n Returns: AH 00H = not installed\n 01H = diskette drive: can't detect disk change\n 02H = diskette drive: CAN detect disk change\n 03H = it's a hard disk\n else= BIOS disk error code if CF is set to CY\n ──────────────────────────────────────────────────────────────────\n Info: This checks to see if a hard drive or diskette drive is\n installed.\n\n For diskette drives, this also finds if the drive is capable of\n detecting change-line status (that is, will it be able to sense\n when the drive door has been opened).\n\n Notes: ■ On diskette drives which detect change-line status, you can use\n INT 13H 16H to learn if the disk has been swapped.\n\nSee Also: DOS fn 440dH 68H (IOCTL sense media type)\n INT 13H: BIOS Disk I/O\n BIOS Data Area\n ROM-BIOS Functions\n -♦-"
  },
  {
    "id": "202-int_13h_16h__detect_media_change.html",
    "t": "INT 13H 16H: Detect Media Change",
    "b": "[AT]\n Expects: AH 16H\n DL diskette drive number: 00H thru 03H\n ──────────────────────────────────────────────────────────────────\n Returns: AH 00H = diskette change line not active\n 01H = invalid drive number\n 06H = either change line is not supported or\n disk change line is active (media was swapped)\n 80H = diskette drive not ready or not installed\n else= BIOS disk error code if CF is set to CY\n ──────────────────────────────────────────────────────────────────\n Info: This determines whether the door of a drive has been opened since\n the last time the change-line was cleared (it is cleared by all\n successful disk accesses).\n\n When change-line is active, it does not necessarily mean a new\n diskette is in place -- only that the drive door has been opened\n at some point.\n\n Notes: ■ Use INT 13H 15H to see if a drive supports change-line\n detection.\n\nSee Also: INT 13H: BIOS Disk I/O\n BIOS Data Area\n ROM-BIOS Functions\n -♦-"
  },
  {
    "id": "203-int_13h_17h__set_media_transfer_rate.html",
    "t": "INT 13H 17H: Set Media Transfer Rate",
    "b": "[AT]\n Expects: AH 17H\n AL transfer rate: 00H = (reserved; don't use)\n 01H = 360K diskette in 360K drive\n 02H = 360K diskette in 1.2 MB drive\n 03H = 1.2 MB diskette in 1.2 MB drive\n 04H = 720K diskette in 720K drive\n DL diskette drive number: 00H thru 03H\n ──────────────────────────────────────────────────────────────────\n Returns: AH BIOS disk error code if CF is set to CY\n ──────────────────────────────────────────────────────────────────\n Info: This should be called before a format operation (INT 13H 05H) to\n set the controller for the correct drive speed and track-stepping\n option.\n\n Notes: ■ This does NOT support 1.44 MB or 2.88 MB drives. Use\n INT 13H 18H, since it is more flexible.\n\nSee Also: INT 13H: BIOS Disk I/O\n BIOS Data Area\n ROM-BIOS Functions\n -♦-"
  },
  {
    "id": "204-int_13h_18h__set_media_type_for_format.html",
    "t": "INT 13H 18H: Set Media Type for Format",
    "b": "[AT]\n Expects: AH 18H\n CH maximum number of tracks\n CL maximum sectors per track\n DL diskette drive number: 00H thru 03H\n ──────────────────────────────────────────────────────────────────\n Returns: AH BIOS disk error code if CF is set to CY\n ──────────────────────────────────────────────────────────────────\n Info: This should be called before a format operation (INT 13H 05H) to\n set the controller for the correct drive speed and track-stepping\n option.\n\nSee Also: DOS fn 440dH 40H (IOCTL set device parms)\n INT 13H: BIOS Disk I/O\n BIOS Data Area\n ROM-BIOS Functions\n -♦-"
  },
  {
    "id": "205-bios_disk_error_codes.html",
    "t": "BIOS Disk Error Codes",
    "b": "INT 13H services return with the Carry Flag set (CF=CY=1) when the\n requested service failed and it places one of the following error codes\n in AH. These are also the values returned when disk status is requested\n (INT 13H 00H) and can be found at 0040:0041 (diskette errors) and\n 0040:0074 (hard disk errors) in the BIOS Data Area.\n\n Note: On any error, you should reset with subfn 00H and retry 3 times.\n\n█▌Diskette I/O Errors▐█\n These errors may be returned when DL < 81H (i.e., on diskette service\n requests).\n\n Err# Error/status Description\n ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n 00H no error on last operation\n 01H bad command: invalid request to controller\n 02H bad address mark\n 03H write protect: attempted to write on write-protected diskette\n 04H sector ID bad or not found\n\n 06H diskette change line is active\n\n 08H DMA failure\n 09H DMA overrun: attempted to write across a 64K-byte boundary.\n\n 0cH Media type not available\n 10H bad CRC: Cyclical Redundancy Code does not agree with data\n 20H diskette controller failure\n 40H bad seek; requested track not found\n 80H time-out\n\n█▌Hard Disk I/O Errors▐█\n These errors may be returned when DL > 7fH (i.e., on hard disk service\n requests).\n\n Err# Error/status Description\n ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n 00H no error on last operation\n 01H bad command: invalid request to controller\n 02H bad address mark\n 03H write protect: attempted to write on write-protected diskette\n 04H sector ID bad or not found\n 05H reset failed\n\n 07H drive parameter activity failed\n 08H DMA failure\n 09H DMA overrun: attempted to write across a 64K-byte boundary.\n 0aH bad sector flag detected\n 0bH bad cylinder detected\n\n 0dH invalid umber of sectors in format\n 0eH control data address mark detected\n 0fH DMA arbitration level out of range\n 10H uncorrectable ECC or CRC\n 11H ECC corrected data error\n 20H hard disk controller failure\n 40H bad seek; requested track not found\n 80H time-out\n aaH drive not ready\n bbH undefined error\n ccH write fault on selected drive\n e0H status error/error register 0\n ffH sense operation failed\n\nSee Also: INT 13H: BIOS Disk I/O\n BIOS Data Area\n ROM-BIOS Functions\n -♦-"
  },
  {
    "id": "206-int_14h__serial_port_i_o.html",
    "t": "INT 14H: Serial Port I/O",
    "b": "AH BIOS Service\n ▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n 00H Initialize communications port\n\n 01H send a character\n\n 02H receive a character\n\n 03H Query communications port status\n\n These functions provide access to the four RS-232 ports supported by BIOS.\n\n Note: BIOS provides only the most rudimentary of unbuffered serial I/O\n (DOS is just as bad) and can initialize only up to 9600 baud.\n For performance reasons, most communications programs perform\n direct I/O port access.\n\n The base address of each of up to four serial ports is stored starting at\n 0040:0000. If the POST does not detect a serial port, it writes 0000H\n into the corresponding BIOS Data Area variable. Also, POST quits checking\n as soon as it hits an unused port (it will never find COM3 if there is no\n COM2).\n\nSee Also: Asynchronous Adapter Ports\n Character I/O Functions\n ROM-BIOS Functions\n DOS Fn 4403H (IOCTL write control data)\n Cables and Pin Outs\n -♦-"
  },
  {
    "id": "207-int_14h_00h__initialize_asynchronous_communication_port.html",
    "t": "INT 14H 00H: Initialize Asynchronous Communication Port",
    "b": "Expects: AH 00H\n AL initialization bit flags (see below)\n DX COMM port number (0 to 3)\n ──────────────────────────────────────────────────────────────────\n Returns: AH line status ═╦══► see BIOS COM status codes\n AL modem status ═╝\n ──────────────────────────────────────────────────────────────────\n Info: Sets the speed, word length, etc for the specified COM port.\n\n AL on entry, AL specifies the COM settings:\n\n ┌7┬6┬5┬4┬3┬2┬1┬0┐\n │baud │par│s│len│\n └─┴─┴─┴─┴─┴╥┴─┴─┘ bit mask\n ╚═╦═╝ ╚╦╝ ║ ╚═╩═►0-1: 03H word length: 10=7 bits; 11=8 bits\n ║ ║ ╚═════► 2: 04H stop bits: 0=1; 1=2;\n ║ ╚════════►3-4: 18H parity code: x0=none; 01=odd; 11=even\n ╚═════════════►5-7: e0H baud rate 000=110; 100=1200\n 001=150; 101=2400\n 010=300; 110=4800\n 011=600; 111=9600\n\n Notes: BIOS does not support speeds beyond 9600 baud, even though most\n hardware is capable of much higher rates.\n\nSee Also: INT 14H: Serial Port I/O\n Asynchronous Adapter Ports\n BIOS Data Area\n ROM-BIOS Functions\n -♦-"
  },
  {
    "id": "208-int_14h_01h__send_a_character.html",
    "t": "INT 14H 01H: Send a Character",
    "b": "Expects: AH 01H\n AL byte to send\n DX COMM port number (0 to 3)\n ──────────────────────────────────────────────────────────────────\n Returns: AH bit 7=0 if no error;\n else, bits 0-6 have Line Status see BIOS COM status codes\n ──────────────────────────────────────────────────────────────────\n Info: Transmits the character in AL over the specified COM line.\n\n Notes: The return status code cannot indicate a time out error, since\n bit 7 is used to flag any error. Thus, after any error, you\n should use INT 14H 03H to get the full story on what went wrong.\n\nSee Also: INT 14H: Serial Port I/O\n Asynchronous Adapter Ports\n BIOS Data Area\n ROM-BIOS Functions\n -♦-"
  },
  {
    "id": "209-int_14h_02h__receive_a_character.html",
    "t": "INT 14H 02H: Receive a Character",
    "b": "Expects: AH 02H\n DX COMM port number (0 to 3)\n ──────────────────────────────────────────────────────────────────\n Returns: AH 0 = character received successfully\n else = an error occurred; see BIOS COM status codes\n AL character that came in\n ──────────────────────────────────────────────────────────────────\n Info: Receives one character from the specified COM port. If AH is 00\n on return, the received character is in AL.\n\n Notes: The return status code in AH cannot indicate a time-out error\n since bit 7 is used to flag any error. Thus, after any error,\n you should use INT 14H 03H to get the full story on what went\n wrong.\n\nSee Also: INT 14H: Serial Port I/O\n Asynchronous Adapter Ports\n BIOS Data Area\n ROM-BIOS Functions\n -♦-"
  },
  {
    "id": "210-int_14h_03h__query_serial_port_status.html",
    "t": "INT 14H 03H: Query Serial Port Status",
    "b": "Expects: AH 03H\n DX COMM port number (0 to 3)\n ──────────────────────────────────────────────────────────────────\n Returns: AH line status ═╦══► see BIOS COM status codes\n AL modem status ═╝\n ──────────────────────────────────────────────────────────────────\n Info: Obtains the current modem status and current line status for the\n specified COMM port.\n\nSee Also: INT 14H: Serial Port I/O\n Asynchronous Adapter Ports\n BIOS Data Area\n ROM-BIOS Functions\n -♦-"
  },
  {
    "id": "211-bios_com_status_codes.html",
    "t": "BIOS COM status codes",
    "b": "INT 13H fns return communications port status in AH and AL.\n\n LineStatusRec -- returned in AH by all fns\n ┌7┬6┬5┬4┬3┬2┬1┬0┐\n │ │ │ │ │ │ │ │ │\n └╥┴╥┴╥┴╥┴╥┴╥┴╥┴╥┘ bit mask\n ║ ║ ║ ║ ║ ║ ║ ╚═► 0: 01H data ready status\n ║ ║ ║ ║ ║ ║ ╚═══► 1: 02H overrun error\n ║ ║ ║ ║ ║ ╚═════► 2: 03H parity error\n ║ ║ ║ ║ ╚═══════► 3: 08H framing error\n ║ ║ ║ ╚═════════► 4: 10H break detect\n ║ ║ ╚═══════════► 5: 20H trans holding reg empty\n ║ ╚═════════════► 6: 40H trans shift reg empty\n ╚═══════════════► 7: 80H time-out (or used to flag any error)\n\n ModemStatusRec -- returned in AL by fns 00H, 01H, and 03H.\n ┌7┬6┬5┬4┬3┬2┬1┬0┐\n │ │ │ │ │ │ │ │ │\n └╥┴╥┴╥┴╥┴╥┴╥┴╥┴╥┘ bit mask\n ║ ║ ║ ║ ║ ║ ║ ╚═► 0: 01H delta clear to send\n ║ ║ ║ ║ ║ ║ ╚═══► 1: 02H delta data set ready\n ║ ║ ║ ║ ║ ╚═════► 2: 03H trailing edge ring detector\n ║ ║ ║ ║ ╚═══════► 3: 08H delta recv line signal detect\n ║ ║ ║ ╚═════════► 4: 10H clear to send\n ║ ║ ╚═══════════► 5: 20H data set ready\n ║ ╚═════════════► 6: 40H ring indicator\n ╚═══════════════► 7: 80H received line detect signal\n\nSee Also: INT 14H: Serial Port I/O\n Asynchronous Adapter Ports\n BIOS Data Area\n ROM-BIOS Functions\n -♦-"
  },
  {
    "id": "212-int_15h__at_extended_services___apm.html",
    "t": "INT 15H: AT Extended Services / APM",
    "b": "INT 15H handles a set of AT-specific services.\n\n AH/AX BIOS Service\n ▀▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n 00H Cassette motor ON ═╗\n 01H Cassette motor OFF ╠═►Oldest PCs only (descriptions\n 02H read cassette ║ omitted for lack of interest)\n 03H write cassette ════╝\n\n 4fH keyboard intercept\n\n 53xxH Advanced Power Management (APM) services\n\n (*) 80H device open\n (*) 81H device close\n (*) 82H program termination\n 8300H set event wait interval\n 8301H cancel event wait interval\n 84H joystick\n (*) 85H SysReq key\n 86H wait\n 87H move extended▲ memory block\n 88H get extended memory size\n 89H switch to virtual 8086 mode\n\n (*) 90H device busy loop\n (*) 91H finish interrupt\n\n c0H get system configuration\n\n (*) services marked with (*) are designed for use with multitasking\n operating systems and will only perform the described service if\n they have been intercepted by a multitasking operating system.\n By default (and when MS-DOS is the active system), these fns\n simply clear the Carry Flag and return immediately.\n\nSee Also: ROM-BIOS Functions\n BIOS Data Area\n -♦-"
  },
  {
    "id": "213-int_15h_4fh__keyboard_intercept.html",
    "t": "INT 15H 4fH: Keyboard Intercept",
    "b": "[XT] [AT]\n Expects: AH 4fH\n AL keyboard scan code received from hardware\n CX process ID\n ──────────────────────────────────────────────────────────────────\n Returns: AL keyboard scan code\n CF = CY: replace input scan code with the one on AL\n CF = NC: no change; use hardware scan code\n ──────────────────────────────────────────────────────────────────\n Info: This fn is called by INT 09H when it obtains a keystroke from the\n hardware, but before processing it or placing it in the keyboard\n buffer.\n\n Programs can intercept this fn to provide keyboard remapping or\n to disable certain keystrokes, etc.\n\n When unintercepted, the BIOS simply leaves the CF clear so\n INT 09H will process the scan code without change.\n\n Notes: This intercept is available only in later versions of XT and AT\n BIOSes. Use INT 15H c0H to see if this intercept is available.\n\nSee Also: INT 15H (extended AT services)\n BIOS Data Area\n ROM-BIOS Functions\n -♦-"
  },
  {
    "id": "214-int_15h_80h__device_open.html",
    "t": "INT 15H 80H: Device Open",
    "b": "Expects: AH 80H\n BX device ID\n CX process ID\n CF NC (0) (clear the Carry Flag before when invoking this fn)\n ──────────────────────────────────────────────────────────────────\n Returns: AX 0080H\n ──────────────────────────────────────────────────────────────────\n Info: This service is designed to be intercepted by a multitasking\n operating system. It would be used, along with INT 15H fns 81H\n and 82H to avoid device conflicts.\n\n When unintercepted, the BIOS simply sets AH to 0 and clears CF.\n\nSee Also: INT 15H (extended AT services)\n BIOS Data Area\n ROM-BIOS Functions\n -♦-"
  },
  {
    "id": "215-int_15h_81h__device_close.html",
    "t": "INT 15H 81H: Device Close",
    "b": "[AT]\n Expects: AH 81H\n BX device ID\n CX process ID\n CF NC (0) (clear the Carry Flag before when invoking this fn)\n ──────────────────────────────────────────────────────────────────\n Returns: AX 0081H\n ──────────────────────────────────────────────────────────────────\n Info: This service is designed to be intercepted by a multitasking\n operating system. It would be used, along with INT 15H fns 80H\n and 82H to avoid device conflicts.\n\n When unintercepted, the BIOS simply sets AH to 0 and clears CF.\n\nSee Also: INT 15H (extended AT services)\n BIOS Data Area\n ROM-BIOS Functions\n -♦-"
  },
  {
    "id": "216-int_15h_82h__program_termination.html",
    "t": "INT 15H 82H: Program Termination",
    "b": "[AT]\n Expects: AH 82H\n BX device ID\n ──────────────────────────────────────────────────────────────────\n Returns: AX 0082H\n ──────────────────────────────────────────────────────────────────\n Info: This service is designed to be intercepted by a multitasking\n operating system. It would be used, along with INT 15H fns 80H\n and 81H, to avoid device conflicts.\n\n When unintercepted, the BIOS simply sets AH to 0 and clears CF.\n\nSee Also: INT 15H (extended AT services)\n BIOS Data Area\n ROM-BIOS Functions\n -♦-"
  },
  {
    "id": "217-int_15h_8300h__set_event_wait_interval.html",
    "t": "INT 15H 8300H: Set Event Wait Interval",
    "b": "[AT]\n Expects: AX 8300H\n CX,DX interval in microseconds (1,000,000ths of a second)\n CX is high word, BX is low word\n ES:BX address of byte to be used to flag end of interval\n ──────────────────────────────────────────────────────────────────\n Returns: AH 83H\n AL 00H =means fn is busy (note: only one timer can be set)\n else=CMOS timer has been set\n CF NC (0) no error\n CY (1) error; fn is busy\n ──────────────────────────────────────────────────────────────────\n Info: This sets up to have the BIOS set a flag after a certain amount\n to time.\n\n The interval is set in microseconds with CX and DX being the high\n and low words, respectively.\n\n 1,000,000 microseconds = 1 second; for instance, to set an\n interval for 2 seconds, set CX=001eH and DX=8480H.\n\n Upon expiration of the interval, bit 7 of the byte at ES:BX will\n be set. You must clear this bit before starting the interval.\n\n Notes: ■ Only one timer-interval may be active. Use INT 15H 8301H to\n cancel the current interval.\n\n ■ Remember to cancel the wait before exiting your program!\n Later, some other process will own the memory address you have\n used at the time-done-flag (ES:BX).\n\n ■ If CX and DX are both 0000H on entry, no action is taken.\n\n ■ In most systems, the finest possible resolution is about 1000\n microseconds (about one one-thousandth of a second). Thus, CX\n must be at least 1000 (3e8H) for this to be useful.\n\n ■ This works asynchronously, letting you perform other tasks\n while occasionally polling the byte as ES:BX. Use INT 15H 86H\n if you want the system to wait (delay) for a specific interval.\n\n ■ Other timer functions include INT 1aH (1/18-th second minimum\n interval) and DOS fn 2cH (1/100-th second minimum interval).\n\nSee Also: INT 15H (extended AT services)\n BIOS Data Area\n ROM-BIOS Functions\n -♦-"
  },
  {
    "id": "218-int_15h_8301h__cancel_event_wait_interval.html",
    "t": "INT 15H 8301H: Cancel Event Wait Interval",
    "b": "[AT]\n Expects: AX 8301H\n ──────────────────────────────────────────────────────────────────\n Returns: AX 8300H\n CF NC (0) no error\n CY (1) error; fn is busy\n ──────────────────────────────────────────────────────────────────\n Info: Cancels the most recent timer interval set via INT 15H 8300H.\n\nSee Also: INT 15H (extended AT services)\n BIOS Data Area\n ROM-BIOS Functions\n -♦-"
  },
  {
    "id": "219-int_15h_84h__joystick_support.html",
    "t": "INT 15H 84H: Joystick Support",
    "b": "[AT]\n Expects: AH 84H\n DX subfn code: 0 = read buttons (switches) into AL\n 1 = read joystick positions into AX,BX,CX,DX\n ──────────────────────────────────────────────────────────────────\n Returns: AH 84H\n AL (DX=0) bits 4-7 indicate state of joystick buttons\n AX (DX=1) joystick A horizontal coordinate\n BX joystick A vertical coordinate\n CX joystick B horizontal coordinate\n DX joystick B vertical coordinate\n CF CY (1) if DX was invalid\n NC (0) no error\n ──────────────────────────────────────────────────────────────────\n Info: This reads the current buttons or resistive inputs of the\n joystick (or other general analog-to-digital device).\n\n See Game I/O Adapter Port (201H) for layout of the bits for the\n switches (buttons) and related info.\n\nSee Also: INT 15H (extended AT services)\n BIOS Data Area\n ROM-BIOS Functions\n -♦-"
  },
  {
    "id": "220-int_15h_85h__sysreq_key.html",
    "t": "INT 15H 85H: SysReq Key",
    "b": "[AT]\n Expects: AH 85H\n AL 00H = key make (pressed down)\n 01H = key break (released)\n CF NC (0)\n ──────────────────────────────────────────────────────────────────\n Returns: AX 0085H\n CF NC (0) if no error; CY (1) if invalid value in AL on entry\n ──────────────────────────────────────────────────────────────────\n Info: Called by INT 01H upon press and release of the SysReq key.\n\n A multitasking operating system might intercept this fn in order\n to monitor user-requests to switch tasks.\n\n When unintercepted, the BIOS simply sets AH to 0 and clears CF.\n\nSee Also: INT 15H (extended AT services)\n BIOS Data Area\n ROM-BIOS Functions\n -♦-"
  },
  {
    "id": "221-int_15h_86h__wait.html",
    "t": "INT 15H 86H: Wait",
    "b": "[AT]\n Expects: AH 86H\n CX,DX interval in microseconds (1,000,000ths of a second)\n CX is high word, DX is low word\n ──────────────────────────────────────────────────────────────────\n Returns: AH 86H\n AL mask written to interrupt ctrlr 2 (if successful)\n unmodified (if fn is busy)\n CF NC (0) no error\n CY (1) error; fn is busy\n ──────────────────────────────────────────────────────────────────\n Info: This suspends execution of the caller for the specified interval.\n Interrupts are enabled during the delay.\n\n The interval is set in microseconds with CX and DX being the high\n and low words, respectively.\n\n 1,000,000 microseconds = 1 second; for instance, to set an\n interval for 2 seconds, set CX=001eH and DX=8480H.\n\n Upon expiration of the interval, control returns to the caller\n and bit 7 of the byte at 0040:00A0 in the BIOS Data Area will be\n set.\n\n Notes: ■ If CX and DX are both 0000H on entry, no action is taken.\n\n ■ In most systems, the finest possible resolution is about 1000\n microseconds (about one one-thousandth of a second). Thus, CX\n must be at least 1000 (03e8H) for this to be useful.\n\n ■ If you want to set a timer and continue processing, use\n INT 15H 8300H.\n\n ■ Other timer functions include INT 1AH (1/18-th second minimum\n interval) and DOS fn 2cH (1/100-th second minimum interval).\n\nSee Also: INT 15H (extended AT services)\n BIOS Data Area\n ROM-BIOS Functions\n -♦-"
  },
  {
    "id": "222-int_15h_87h__move_memory_block.html",
    "t": "INT 15H 87H: Move Memory Block",
    "b": "[AT]\n Expects: AH 87H\n CX amount of memory to move, in 2-byte words (max 8000H words)\n ES:SI address of 30-byte structure describing the operation\n ──────────────────────────────────────────────────────────────────\n Returns: AH 00H = successful move\n 01H = RAM parity error occurred\n 02H = other exception interrupt error occurred\n CF NC (0) no error\n CY (1) some sort of error\n ZF NZ (0) error; unsuccessful move\n ZR (1) successful move\n ──────────────────────────────────────────────────────────────────\n Info: You can use this to move chunks of memory around, even when you\n are running in real mode (access to RAM above 1MB is normally\n accessible only when in 80286 protected mode).\n\n Note: Only old programs use this BIOS interface. It is much better to\n use XMS Functions or the DPMI API to access RAM above 1MB.\n\n ES:BX The caller must supply a 30-byte data record which will be used\n as a GDT (Global Descriptor Table). This is used to translate\n between 32-bit addresses and 24-bit addresses. It is laid out as\n follows:\n\n MoveMemGdtRec\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 8 res1 8 bytes of 0\n +8 8 res2 this GDT (filled-in by BIOS)\n +10H 2 wLimits source block limits (filled-in by BIOS)\n +12H 3 p24Source 24-bit physical address of block to copy\n +15H 5 res3 (filled-in by BIOS)\n +1aH 3 p24Dest 24-bit physical address of destination\n +1dH 19 res4 (filled-in by BIOS)\n 30 size of buffer\n\n You need only fill-in the p24Source and p24Dest with 24-bit\n physical memory addresses. Physical memory addresses are linear\n and can range from 000000H to ffffffH (i.e., up to 16 MB).\n\n Notes: Interrupts are disabled during block moves. Therefore, use of\n this fn can interfere with serial I/O or other interrupt-driven\n tasks.\n\nSee Also: INT 15H (extended AT services)\n BIOS Data Area\n ROM-BIOS Functions\n -♦-"
  },
  {
    "id": "223-int_15h_88h__get_extended_memory_size.html",
    "t": "INT 15H 88H: Get Extended Memory Size",
    "b": "[AT]\n Expects: AH 88H\n ──────────────────────────────────────────────────────────────────\n Returns: AX amount of contiguous memory above 1MB, in 1K blocks.\n ──────────────────────────────────────────────────────────────────\n Info: This returns the total amount of memory above 1MB. It is the\n same number as found in CMOS Memory addresses 17H-18H.\n\nSee Also: INT 15H (extended AT services)\n BIOS Data Area\n ROM-BIOS Functions\n -♦-"
  },
  {
    "id": "224-int_15h_89h__switch_to_protected_mode.html",
    "t": "INT 15H 89H: Switch to Protected mode",
    "b": "[AT]\n Expects: AH 89H\n BH index into IDT defining access of IRQ 0-7\n BL index into IDT defining access of IRQ 8-15\n ES:DI addr of a GDT built by the caller\n ──────────────────────────────────────────────────────────────────\n Returns: AH 00 and CY=NC means successful and return ion protected mode\n ff and/or CF=CY means no can do.\n ──────────────────────────────────────────────────────────────────\n Info: This sets the processor into protected mode and passes control to\n the code segment identified by the GDT provided by the caller.\n\n There is no BIOS service to return to real mode.\n\n This is tricky, unless you really know what you're doing; only\n writers of operating systems need bother. You better study the\n BIOS listing on this one. Better yet, use the DPMI API.\n\nSee Also: INT 15H (extended AT services)\n BIOS Data Area\n ROM-BIOS Functions\n -♦-"
  },
  {
    "id": "225-int_15h_90h__device_busy.html",
    "t": "INT 15H 90H: Device Busy",
    "b": "[AT]\n Expects: AH 90H\n AL device type: 00H fixed disk time-out\n 01H diskette time-out\n 02H keyboard\n 03H pointed device time-out\n 21H waiting for keyboard input\n 80H network\n fcH fixed-disk reset time-out\n fdH diskette drive motor start\n feH pointing device time-out\n ES:BX addr of network control block (if AL = 80H or higher)\n CF must be NC (0) before calling\n ──────────────────────────────────────────────────────────────────\n Returns: AH 00h wait time not satisfied\n CF NC (0) wait time not satisfied; use your own wait rtn\n CY (1) minimum wait time satisfied (wait performed)\n ──────────────────────────────────────────────────────────────────\n Info: This service is designed to be intercepted by a multitasking\n operating system. It could be used by BIOS disk handlers or\n other hardware to perform programmed wait-for-I/O-completion,\n which would allow other tasks to be dispatched while I/O is in\n progress.\n\n When unintercepted, the BIOS simply sets AH to 0 and clears CF.\n\nSee Also: INT 15H (extended AT services)\n BIOS Data Area\n ROM-BIOS Functions\n -♦-"
  },
  {
    "id": "226-int_15h_91h__interrupt_finished.html",
    "t": "INT 15H 91H: Interrupt Finished",
    "b": "[AT]\n Expects: AH 91H\n AL device type: 00H fixed disk time-out\n 01H diskette time-out\n 02H keyboard\n 03H pointed device time-out\n 21H waiting foe keyboard input\n 80H network\n fcH fixed-disk reset time-out\n fdH diskette drive motor start\n feH pointing device time-out\n ES:BX addr of network control block (if AL = 80H or higher)\n CF must be NC (0) before calling\n ──────────────────────────────────────────────────────────────────\n Returns: (none)\n ──────────────────────────────────────────────────────────────────\n Info: This service is designed to be intercepted by a multitasking\n operating system. It could be used by disk or other hardware\n handlers so the handler can be notified when I/O is completed.\n This fn could also be used by an operating system to learn when\n I/O is completed so the requesting task could be reactivated.\n\n When unintercepted, the BIOS simply sets AH to 0 and clears CF.\n\nSee Also: INT 15H (extended AT services)\n BIOS Data Area\n ROM-BIOS Functions\n -♦-"
  },
  {
    "id": "227-int_15h_c0h__get_system_parameters.html",
    "t": "INT 15H c0H: Get System Parameters",
    "b": "Expects: AH c0H\n ──────────────────────────────────────────────────────────────────\n Returns: AH 00H (and CF=NC=0) successful, and ES:BX points to valid data\n 86H (and/or CF=CY=1) unsuccessful\n ES:BX addr of system configuration table\n ──────────────────────────────────────────────────────────────────\n Info: This returns a pointer to a table that describes the system.\n\nBiosSysParmsRec\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 2 wLen length of this table, in bytes\n +2 1 yModel PC=ff,XT=fe or fb, PCjr=fd, AT=fc, unknown=ff\n +3 1 ySubModel PC,XT,PCjr,AT=00; AT=01, XT-286=02\n +4 1 yRevLvl BIOS revision level (0=initial release)\n +5 1 rFeatures1 features bits:\n ┌7┬6┬5┬4┬3┬2┬1┬0┐\n │ │ │ │ │ │ │ │0│\n └╥┴╥┴╥┴╥┴╥┴╥┴╥┴-┘ bit mask\n ║ ║ ║ ║ ║ ║ ║ ╚══► 0: 01H (reserved)\n ║ ║ ║ ║ ║ ║ ╚════► 1: 02H 0=PC-type I/O channel\n ║ ║ ║ ║ ║ ╚══════► 2: 04H 1=Extended BIOS area allocated\n ║ ║ ║ ║ ╚════════► 3: 08H 1=wait for ext event supported\n ║ ║ ║ ╚══════════► 4: 10H 1=INT 15H 4fH supported by INT 09H\n ║ ║ ╚════════════► 5: 20H 1=real-time clock is present\n ║ ╚══════════════► 6: 40H second interrupt chip is present\n ╚════════════════► 7: 80H hard disk BIOS uses DMA chnl 3\n\n +6 1 rFeatures2 (reserved)\n +7 1 rFeatures3 (reserved)\n +8 1 rFeatures4 (reserved)\n +9 1 rFeatures5 (reserved)\n 10 size of this structure\n\nSee Also: INT 15H (extended AT services)\n BIOS Data Area\n ROM-BIOS Functions\n -♦-"
  },
  {
    "id": "228-int_16h__keyboard_services.html",
    "t": "INT 16H: Keyboard Services",
    "b": "This is the application-level interface to the keyboard. Keystrokes are\n processed asynchronously (in the background). As each keystroke is\n received from the keyboard, it is processed by INT 09H and placed into a\n circular queue at 40:001e in the BIOS Data Area.\n\n AH BIOS Service Supported by\n ▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n 00H read keyboard input [PC] [XT] [AT]\n 01H query keyboard status/preview key [PC] [XT] [AT]\n 02H query keyboard shift flags [PC] [XT] [AT]\n 03H set typeamatic rate and delay [PC] [XT] [AT]\n 04H (reserved)\n 05H store key data [AT]\n\n 10H read extended keyboard input [AT]\n 11H query extended keyboard status [AT]\n 12H query extended keyboard shift flags [AT]\n\nSee Also: ROM-BIOS Functions\n Character I/O Functions (DOS fns)\n BIOS Data Area\n Cables and Pin Outs\n -♦-"
  },
  {
    "id": "229-int_16h_00h__read__wait_for__next_keystroke.html",
    "t": "INT 16H 00H: Read (Wait for) Next Keystroke",
    "b": "[XT] [AT]\n Expects: AH 00H\n ──────────────────────────────────────────────────────────────────\n Returns: AH scan code\n AL ASCII character code or extended ASCII keystroke\n ──────────────────────────────────────────────────────────────────\n Info: If a keystroke is available in the keyboard buffer, this removes\n it from the queue and returns it in AH and AL.\n\n If no key is available, this waits for a keystroke. If you want\n to avoid the wait, use INT 16H 01H to see if a key is ready.\n\n Notes: ■ On ATs, when the keyboard buffer is empty, this invokes\n INT 15H 90H, allowing an operating system to switch tasks or\n whatever, when awaiting a keystroke.\n\n ■ Also on ATs, this updates the keyboard LEDs to match the\n current shift status.\n\n ■ Extended key filtering: For compatibility with older 83-key\n 'boards, this converts duplicated keys into their older\n equivalent keys. Use INT 16H 10H to get unfiltered key codes.\n\nSee Also: INT 16H (BIOS keyboard services)\n BIOS Data Area\n ROM-BIOS Functions\n -♦-"
  },
  {
    "id": "230-int_16h_01h__query_keyboard_status___preview_key.html",
    "t": "INT 16H 01H: Query Keyboard Status / Preview Key",
    "b": "[XT] [AT]\n Expects: AH 01H\n ──────────────────────────────────────────────────────────────────\n Returns: ZF ZR = no keys in buffer\n NZ = key is ready\n AH (if ZR) scan code\n AL (if ZR) ASCII character code or extended ASCII keystroke\n ──────────────────────────────────────────────────────────────────\n Info: Checks to see if a key is available in the keyboard buffer, and\n if so, returns its keycode in AX. It DOES NOT remove the\n keystroke from the buffer.\n\n This can be used to avoid dropping into a BIOS loop while waiting\n for a keystroke. For instance:\n\n waitForKey: mov ah,01H\n int 16H\n jnz gotKey ;jmp if key is ready\n call doSomething ;do processing while waiting\n jmp waitForKey ;loop back and check for a key\n\n gotKey: mov ah, 00H ;key is ready, get it\n int 16H ;now process the key\n .\n :\n\n Notes: ■ Extended key filtering: For compatibility with older 83-key\n 'boards, this converts duplicated keys into their older\n equivalent keys. Use INT 16H 11H to get unfiltered key codes.\n\nSee Also: INT 16H (BIOS keyboard services)\n BIOS Data Area\n ROM-BIOS Functions\n -♦-"
  },
  {
    "id": "231-int_16h_02h__query_keyboard_shift_status.html",
    "t": "INT 16H 02H: Query Keyboard Shift Status",
    "b": "[XT] [AT]\n Expects: AH 02H\n ──────────────────────────────────────────────────────────────────\n Returns: AL KbdShiftFlagsRec (status of Ctl, Alt, etc.)\n ──────────────────────────────────────────────────────────────────\n Info: Returns the current status of the shift keys. This is the same\n as the byte at 0040:0017 in the BIOS Data Area.\n\n Notes: ■ Additional shift-key information is available via INT 16H 12H\n for systems equipped with 101-key BIOSes.\n\n ■ There is no corresponding fn to set the keyboard shift status.\n\nSee Also: INT 16H (BIOS keyboard services)\n ROM-BIOS Functions\n -♦-"
  },
  {
    "id": "232-int_16h_03h__set_keyboard_typematic_rate_and_delay.html",
    "t": "INT 16H 03H: Set Keyboard Typematic Rate and Delay",
    "b": "[AT]\n Expects: AH 03H\n AL 05H\n BH delay code\n BL typematic rate code\n ──────────────────────────────────────────────────────────────────\n Returns: (none)\n ──────────────────────────────────────────────────────────────────\n Info: This sets how soon the keyboard hardware will begin repeating a\n key and how fast each repeat should occur.\n\n BL delay code: 00H = 250 ms (¼ sec)\n 01H = 500 ms (½ sec)\n 02H = 750 ms\n 03H = 1000 ms (1 second)\n else (reserved)\n\n BH repeat code: 00H = 30 repeats per second\n 01H = 26.7 repeats per second\n 01H = 24 repeats per second\n 01H = 21.8 repeats per second\n ... (etc.) ...\n 1fH = 2 repeats per second\n\n Notes: ■ See AT Keyboard for related details.\n\n ■ Keyboard speed setting has always been awkward to implement\n cleanly since there is no corresponding fn to obtain the\n current rate or delay.\n\nSee Also: INT 16H (BIOS keyboard services)\n BIOS Data Area\n ROM-BIOS Functions\n -♦-"
  },
  {
    "id": "233-int_16h_05h__store_keystroke_data.html",
    "t": "INT 16H 05H: Store Keystroke Data",
    "b": "[AT]\n Expects: AH 05H\n CH scan code to store\n CL ASCII character code or extended ASCII keystroke\n ──────────────────────────────────────────────────────────────────\n Returns: AL 0=successfully stored\n 1=not stored (no room in buffer)\n ──────────────────────────────────────────────────────────────────\n Info: This can be used to stuff data into the keyboard buffer, as if\n the user had typed the keys manually.\n\n This can be used by keyboard macro programs and other such\n utilities.\n\n Notes: ■ The BIOS Data Area contains two addresses to indicate the start\n and end of the keyboard buffer. However, you cant easily\n enlarge the buffer, since it must be within 64K of segment\n 0040H.\n\n ■ Programs which \"stuff the keyboard\" and may need to stuff more\n than 16 keys, usually implement a timer interrupt handler\n (see INT 1CH) to monitor when there is room for a new key in\n the buffer.\n\n ■ This service is available on some XT BIOSes. You can test for\n compatibility by stuffing an oddball key, then reading the\n keyboard to see if it made it.\n\nSee Also: INT 16H (BIOS keyboard services)\n BIOS Data Area\n ROM-BIOS Functions\n -♦-"
  },
  {
    "id": "234-int_16h_10h__read_extended_keyboard_input.html",
    "t": "INT 16H 10H: Read Extended Keyboard Input",
    "b": "[AT]\n Expects: AH 10H\n ──────────────────────────────────────────────────────────────────\n Returns: AH scan code\n AL ASCII character code or extended ASCII keystroke\n ──────────────────────────────────────────────────────────────────\n Info: This is identical to INT 16H 00H, except that it does not perform\n \"extended key filtering\" to map 101-key 'board keystrokes to\n 84-key 'board equivalents.\n\n For instance, you might use this function if you want to\n differentiate between the [Insert] key and the [Ins] key on the\n numeric keypad▲.\n\nSee Also: INT 16H (BIOS keyboard services)\n BIOS Data Area\n ROM-BIOS Functions\n -♦-"
  },
  {
    "id": "235-int_16h_11h__query_extended_keyboard_status___preview_key.html",
    "t": "INT 16H 11H: Query Extended Keyboard Status / Preview Key",
    "b": "[XT] [AT]\n Expects: AH 11H\n ──────────────────────────────────────────────────────────────────\n Returns: ZF ZR = no keys in buffer\n NZ = key is ready\n AH (if ZR) scan code\n AL ASCII character code or extended ASCII keystroke\n ──────────────────────────────────────────────────────────────────\n Info: This is identical to INT 16H 01H, except that it does not perform\n \"extended key filtering\" to map 101-key 'board keystrokes to\n 84-key 'board equivalents.\n\nSee Also: INT 16H (BIOS keyboard services)\n BIOS Data Area\n ROM-BIOS Functions\n -♦-"
  },
  {
    "id": "236-int_16h_12h__query_extended_keyboard_shift_status.html",
    "t": "INT 16H 12H: Query Extended Keyboard Shift Status",
    "b": "[XT] [AT]\n Expects: AH 12H\n ──────────────────────────────────────────────────────────────────\n Returns: AX KbdShiftFlags101Rec (status of Ctl, Alt, Ins, etc)\n ──────────────────────────────────────────────────────────────────\n Info: Returns the current status of the shift keys and 'lock' states.\n This is similar, but not exactly the same as the word at\n 0040:0017 in the BIOS Data Area.\n\n Notes: ■ The low-byte of the return value (AL) is identical for this fn\n and INT 16H 02H. Only the high byte (AH) is encoded with\n additional information.\n\nSee Also: INT 16H (BIOS keyboard services)\n ROM-BIOS Functions\n -♦-"
  },
  {
    "id": "237-int_17h__printer_support.html",
    "t": "INT 17H: Printer Support",
    "b": "These functions provide access to the parallel printer ports (LPT1, etc.)\n\n The printer port addresses are stored starting at 0040:0008. Printer\n time-out intervals start at 0040:0078. See BIOS Data Area.\n\n AH BIOS Service\n ▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n 00H print a character\n 01H setup printer port\n 02H query printer status\n\n Note: The BIOS offers no support for bidirectional parallel\n communications (though standard PC hardware has supported it\n since about 1987).\n\nSee Also: Parallel Printer Adapter Ports\n INT 05H (print screen)\n Printer Functions (DOS fns)\n BIOS Data Area\n ROM-BIOS Functions\n Cables and Pin Outs\n -♦-"
  },
  {
    "id": "238-int_17h_00h__print_one_character.html",
    "t": "INT 17H 00H: Print One Character",
    "b": "Expects: AH 00H\n AL byte to print. See ASCII and ASCII Control Codes.\n DX port number (0=LPT1, 1=LPT2, 2=LPT3)\n ──────────────────────────────────────────────────────────────────\n Returns: AH Bits set as in PrinterStatusRec (bit 0 set on time-out\n error)\n ──────────────────────────────────────────────────────────────────\n Info: Sends the byte in AL to the specified printer port.\n\n Always check the return code in AH to see if the character made\n it to the printer.\n\n Notes: ■ Use INT 11H to see how many printer ports are installed.\n\n ■ Please stop writing those applications that write ONLY to LPT1.\n That is unutterably frustrating for users.\n\n ■ You can write to the PRN device just by using DOS fn 40H with\n BX=0004H. You may want to use fn 3eH now and then to flush the\n data to the printer.\n\nSee Also: INT 17H (BIOS printer support)\n ROM-BIOS Functions\n -♦-"
  },
  {
    "id": "239-int_17h_01h__initialize_printer_port.html",
    "t": "INT 17H 01H: Initialize Printer Port",
    "b": "Expects: AH 01H\n DX port number (0=LPT1, 1=LPT2, 2=LPT3)\n ──────────────────────────────────────────────────────────────────\n Returns: AH Bits set as in PrinterStatusRec (bit 0 set on time-out\n error)\n ──────────────────────────────────────────────────────────────────\n Info: Initializes the specified printer port. Note that this does NOT\n reset the printer itself--it just clears any pending BIOS LPTn\n operations.\n\n Always check the return code in AH to verify the status.\n\nSee Also: INT 17H (BIOS printer support)\n ROM-BIOS Functions\n -♦-"
  },
  {
    "id": "240-int_17h_02h__query_printer_status.html",
    "t": "INT 17H 02H: Query Printer Status",
    "b": "Expects: AH 02H\n DX port number (0=LPT1, 1=LPT2, 2=LPT3)\n ──────────────────────────────────────────────────────────────────\n Returns: AH Bits set as in PrinterStatusRec (bit 0 set on time-out\n error)\n ──────────────────────────────────────────────────────────────────\n Info: This obtains the current status of the specified printer port.\n\nSee Also: INT 17H (BIOS printer support)\n ROM-BIOS Functions\n -♦-"
  },
  {
    "id": "241-bios_printer_status_flags.html",
    "t": "BIOS Printer Status Flags",
    "b": "All INT 17H services return the printer port status as a set of bit flags\n in AH as follows:\n\n PrinterStatusRec\n ┌7┬6┬5┬4┬3┬2┬1┬0┐\n │ │ │ │ │ │0 0│ │\n └╥┴╥┴╥┴╥┴╥┴-┴-┴╥┘ bit mask\n ║ ║ ║ ║ ║ ╚═► 0: 01H 1 = time-out error\n ║ ║ ║ ║ ╚═══════► 3: 08H 1 = I/O error\n ║ ║ ║ ╚═════════► 4: 10H 1 = selected (0 means off-line)\n ║ ║ ╚═══════════► 5: 20H 1 = out of paper\n ║ ╚═════════════► 6: 40H 1 = acknowledge (printer is attached)\n ╚═══════════════► 7: 80H 1 = not busy (note: 0 means busy)\n\nSee Also: Parallel Printer Adapter Ports\n INT 17H (BIOS printer support)\n BIOS Data Area\n ROM-BIOS Functions\n -♦-"
  },
  {
    "id": "242-int_18h__rom_basic.html",
    "t": "INT 18H: ROM-BASIC",
    "b": "This vector (at 0:0060) has the entry point for the ROM-BASIC interpreter\n which is found only on IBM-logoed computers. Clones do not have BASIC in\n ROM and must use a separate program, usually QBASIC or GWBASIC.\n\n If ROM-BIOS could not get a disk to boot, it takes this vector. This\n makes it possible for a ROM-Scan external ROM module to alter this vector\n to point to itself, thus giving itself control if the disks fail or are\n not present.\n\nSee Also: ROM-BIOS Functions\n BIOS Data Area\n -♦-"
  },
  {
    "id": "243-int_19h__bootstrap_loader.html",
    "t": "INT 19H: Bootstrap Loader",
    "b": "This vector is taken after the POST in order to attempt to load and\n execute any bootstrap code on diskette or hard disk.\n\n The data in sector 1 of track 0 of head 0 of the first responding disk\n (diskette or hard disk) is loaded at absolute address 0000:7c00 and\n control is given to that address. On the oldest IBM-logoed systems,\n control goes to INT 18H (to start ROM BASIC) if all disks fail.\n\n On a hard disk, the bootstrap code determines which partition is active,\n and then loads and executes the boot sector for that partition.\n\n See Disk Partition Table for more info on the hard disk boot sequence.\n See Boot Sector Layout for info on the format of the DOS boot sector.\n\n Note: You can use this service to reboot DOS after changing some values\n in the Equipment List or other variables in the BIOS Data Area\n (be sure 0040:0072 is set to 1234H).\n\n After a reboot, DOS will notice any changes you made.\n\nSee Also: ROM-BIOS Functions\n BIOS Data Area\n -♦-"
  },
  {
    "id": "244-int_1ah__timer_i_o__and_mrci_post_hook_.html",
    "t": "INT 1aH: Timer I/O (and MRCI POST Hook)",
    "b": "INT 1aH services provide access to the system clock. Also INT 1aH may be\n intercepted by a hardware-based MRCI compression system.\n AX Service\n ▀▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n b001H Query MRCI hardware support\n\n AH BIOS Service Supported by\n ▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n 00H read the clock (ticks) [PC] [XT] [AT]\n 01H set the clock (ticks) [PC] [XT] [AT]\n\n 02H read time from CMOS RTC [AT]\n 03H set the time on CMOS RTC [AT]\n\n 04H read date from CMOS RTC [AT]\n 05H set the date on CMOS RTC [AT]\n\n 06H set alarm on CMOS RTC [AT]\n 07H cancel alarm on CMOS RTC [AT]\n\n The PC BIOS works with a \"tick count\" of the number of 55ms intervals\n which have occurred since the PC was turned on or reset. The AT BIOS also\n provides access to the real-time clock values which are updated constantly\n without CPU action, and are stored in the AT's CMOS Memory.\n\n On AT-compatible machines, most short-interval timer/alarm operations are\n perfomed via INT 15H.\n\nSee Also: ROM-BIOS Functions\n MRCI API\n System Information Functions (DOS fns)\n BIOS Data Area (0040:006c)\n -♦-"
  },
  {
    "id": "245-int_1ah_00h__read_system_clock__ticks_.html",
    "t": "INT 1aH 00H: Read System Clock (Ticks)",
    "b": "[PC] [XT] [AT]\n Expects: AH 00H\n ──────────────────────────────────────────────────────────────────\n Returns: AL 0 if timer has not overflowed past 24 hrs since reset\n CX,DX Ticks since last reset; CX is high, DX is low\n ──────────────────────────────────────────────────────────────────\n Info: Obtains the current tick-count. The tick count is stored at\n 0040:006E in the BIOS Data Area. It is incremented about once\n every 55 ms by INT 08H:\n\n clock updates at 1193180/65536 (about 18.2) ticks per second.\n counts per second ≈ 18\n counts per minute ≈ 1092\n counts per hour ≈ 65543\n counts per day ≈ 1573040\n\nSee Also: INT 1aH (BIOS Time I/O)\n DOS fn 2cH (get system time)\n ROM-BIOS Functions\n -♦-"
  },
  {
    "id": "246-int_1ah_01h__set_system_clock__ticks_.html",
    "t": "INT 1aH 01H: Set System Clock (Ticks)",
    "b": "[PC] [XT] [AT]\n Expects: AH 01H\n CX,DX desired tick-count setting\n ──────────────────────────────────────────────────────────────────\n Returns: AH 0\n CF NC (0) if no error\n CY (1) on invalid setting\n ──────────────────────────────────────────────────────────────────\n Info: Sets the system clock top the specified tick-count.\n\n Also clears the timer overflow flag at 0040:0070.\n\nSee Also: INT 1aH (BIOS Time I/O)\n DOS fn 2cH (get system time)\n ROM-BIOS Functions\n -♦-"
  },
  {
    "id": "247-int_1ah_02h__read_time_from_real_time_clock.html",
    "t": "INT 1aH 02H: Read Time from Real-Time Clock",
    "b": "[AT]\n Expects: AH 02H\n ──────────────────────────────────────────────────────────────────\n Returns: AH 0\n AL hours, in BCD▲\n CH hours, in BCD\n CL minutes, in BCD\n DH seconds, in BCD\n DL 00h = no Daylight Savings Time option\n 01h = Daylight Savings Time option\n CF NC (0) clock operating\n CY (1) clock not operating or busy being updated\n ──────────────────────────────────────────────────────────────────\n Info: Obtains the current time from the battery-backed CMOS Real-Time\n Clock.\n\n Return values are in BCD▲ in 24-hour format; for instance,\n CX = 1234H = 12:34pm.\n\n The BIOS avoids reentrancy by not returning the time if the clock\n happens to be in the process of being updated. Thus, if CF is\n set on return, you should try a few more times before giving up.\n\nSee Also: INT 1aH (BIOS Time I/O)\n DOS fn 2cH (get system time)\n ROM-BIOS Functions\n -♦-"
  },
  {
    "id": "248-int_1ah_03h__set_time_on_real_time_clock.html",
    "t": "INT 1aH 03H: Set Time on Real-Time Clock",
    "b": "[AT]\n Expects: AH 03H\n CH hours, in BCD▲\n CL minutes, in BCD\n DH seconds, in BCD\n DL 00h = no Daylight Savings Time option\n 01h = Daylight Savings Time option\n ──────────────────────────────────────────────────────────────────\n Returns: AH 0\n AL value written to CMOS 0bH register\n CF NC (0) clock operating\n CY (1) clock not operating or busy being updated\n ──────────────────────────────────────────────────────────────────\n Info: Sets the time for the battery-backed CMOS Real-Time Clock.\n\n All input values are in BCD▲ in 24-hour format; for instance,\n CX = 1234H = 12:34pm.\n\n The BIOS avoids reentrancy by not allowing the time to be set if\n the clock happens to be in the process of being updated. Thus,\n if CF is set on return, you should try a few more times before\n giving up.\n\nSee Also: INT 1aH (BIOS Time I/O)\n DOS fn 2dH (set system time)\n ROM-BIOS Functions\n -♦-"
  },
  {
    "id": "249-int_1ah_04h__read_date_from_real_time_clock.html",
    "t": "INT 1aH 04H: Read Date from Real-Time Clock",
    "b": "[AT]\n Expects: AH 04H\n ──────────────────────────────────────────────────────────────────\n Returns: AH 0\n CH century, in BCD▲ (19H ... 20H)\n CL year, in BCD (00H ... 99H)\n DH month, in BCD (i.e., 01H=Jan ... 12H=Dec)\n DL day, in BCD (00H ... 31H)\n CF NC (0) clock operating\n CY (1) clock not operating or busy being updated\n ──────────────────────────────────────────────────────────────────\n Info: Obtains the current date from the battery-backed CMOS Real-Time\n Clock.\n\n Return values are in BCD▲; for instance, CX = 1998H = 1998.\n\n The BIOS avoids reentrancy by not returning the date if the clock\n happens to be in the process of being updated. Thus, if CF is\n set on return, you should try a few more times before giving up.\n\nSee Also: INT 1aH (BIOS Time I/O)\n DOS fn 2aH (get system date)\n ROM-BIOS Functions\n -♦-"
  },
  {
    "id": "250-int_1ah_05h__set_date_on_real_time_clock.html",
    "t": "INT 1aH 05H: Set Date on Real-Time Clock",
    "b": "[AT]\n Expects: AH 05H\n CH century, in BCD▲ (19H ... 20H)\n CL year, in BCD (00H ... 99H)\n DH month, in BCD (i.e., 01H=Jan ... 12H=Dec)\n DL day, in BCD (00H ... 31H)\n ──────────────────────────────────────────────────────────────────\n Returns: AH 0\n AL value written to CMOS 0bH register\n CF NC (0) clock operating\n CY (1) clock not operating or busy being updated\n ──────────────────────────────────────────────────────────────────\n Info: Sets the date for the battery-backed CMOS Real-Time Clock.\n\n Input values are in BCD▲; for instance, CX = 1998H = 1998.\n\n The BIOS avoids reentrancy by not setting the date if the clock\n happens to be in the process of being updated. Thus, if CF is\n set on return, you should try a few more times before giving up.\n\nSee Also: INT 1aH (BIOS Time I/O)\n DOS fn 2bH (set system date)\n ROM-BIOS Functions\n -♦-"
  },
  {
    "id": "251-int_1ah_06h__set_real_time_clock_alarm.html",
    "t": "INT 1aH 06H: Set Real-Time Clock Alarm",
    "b": "[AT]\n Expects: AH 06H\n CH hours, in BCD▲\n CL minutes, in BCD\n DH seconds, in BCD\n ──────────────────────────────────────────────────────────────────\n Returns: AH 0\n CF NC (0) no error\n CY (1) alarm already operating\n ──────────────────────────────────────────────────────────────────\n Info: Sets the BIOS to invoke INT 4aH at the specified time.\n\n You must supply an INT 4aH handler if you want to get control at\n the specified time (and avoid a system crash!). The vector for\n INT 4aH is at 0000:0128H.\n\n Only one alarm may be set at a time. If an alarm is already\n active, this returns with the Carry Flag set and take no action.\n\n Use INT 1aH 07H to cancel a previously-set alarm.\n\n Note: Using this as described is quite unusual. A more common\n technique is to patch a TSR into INT 08H and keep an eye on the\n system time. That way you can set up multiple timers, etc.\n\nSee Also: INT 1aH (BIOS Time I/O)\n ROM-BIOS Functions\n -♦-"
  },
  {
    "id": "252-int_1ah_07h__cancel_real_time_clock_alarm.html",
    "t": "INT 1aH 07H: Cancel Real-Time Clock Alarm",
    "b": "[AT]\n Expects: AH 07H\n ──────────────────────────────────────────────────────────────────\n Returns: AH 0\n CF NC (0) no error\n CY (1) alarm already operating\n ──────────────────────────────────────────────────────────────────\n Info: Cancels an alarm previously set via INT 1aH 06H.\n\n If you cancel an alarm. you should also restore the original\n vector for INT 4aH (it will normally point to an IRET in ROM-BIOS\n when unused).\n\n Note: Using fns INT 1aH 06H and 07H as described is quite unusual. A\n more common technique is to patch a TSR into INT 08H and keep an\n eye on the system time. That way you can set up multiple timers,\n etc.\n\nSee Also: INT 1aH (BIOS Time I/O)\n INT 15H 86H (wait; delay a specified number of milliseconds)\n INT 15H 8300H (set interval for event wait)\n ROM-BIOS Functions\n -♦-"
  },
  {
    "id": "253-int_1bh__keyboard_break.html",
    "t": "INT 1bH: Keyboard Break",
    "b": "This vector (0:006c) is taken by BIOS when it senses a press of the\n Ctrl-Break key.\n\n INT 1bH initially points to an IRET, but DOS sets it to point to local\n code that sets an internal DOS flag. DOS tests every once in a while and\n acts upon it, depending upon the state of DOS break-testing.\n\n See DOS Fn 33H and INT 23H for descriptions of how DOS handles Ctrl-Break.\n\n A flag in the BIOS Data Area (0:0471) gets set upon the first occurrence\n of Ctrl-Break, but it never gets reset unless you do it yourself. You\n might use this flag as a way to determine if a child process was aborted\n via Ctrl-Break.\n\nSee Also: DOS Interrupts\n ROM-BIOS Functions\n -♦-"
  },
  {
    "id": "254-int_1ch__user_timer_interrupt.html",
    "t": "INT 1cH: User Timer Interrupt",
    "b": "This vector (0:0070) is taken by BIOS upon each tick of the hardware clock\n (every 55ms; approximately 18.2 times per second). It initially points to\n a dummy IRET, but may be changed by a user program to point to a timer-\n based background task.\n\n Since INT 1cH is executed during the lower hardware-based timer interrupt\n (IRQ 0), you must remember that the system has not yet reset the interrupt\n controller. Therefore other hardware interrupts, notably the keyboard\n interrupt, will not occur while INT 1cH is in progress (you can't get user\n input).\n\n Most TSR popup programs prefer to intercept the lower-level INT 08H\n vector, call the original vector, then perform the timer-based operation\n after BIOS has finished its housekeeping chores.\n\n See INT 08H for suggestions and recommendations.\n\nSee Also: Terminate and Stay Resident (TSR)\n ROM-BIOS Functions\n -♦-"
  },
  {
    "id": "255-int_1dh__video_initialization_table_pointer.html",
    "t": "INT 1dH: Video Initialization Table Pointer",
    "b": "This vector (0:0074) is a pointer to a bunch of video parameters that\n are used by INT 10H to set the video controller registers and some\n BIOS Data Area values when the video mode is initialized.\n\n It is possible to create a RAM-resident version of this table, and modify\n parameters in order to change the way some screen modes work. For\n instance, that is how the DOS Mode command shifts the screen left or\n right.\n\n See Video Initialization Table for a layout of the table.\n\nSee Also: BIOS Data Area\n INT 10H 00H\n Video Modes\n ROM-BIOS Functions\n -♦-"
  },
  {
    "id": "256-int_1eh__diskette_parameter_pointer.html",
    "t": "INT 1eH: Diskette Parameter Pointer",
    "b": "This vector (0:0078) is a pointer to a table of diskette parameters that\n BIOS the diskette service INT 13H uses for a variety of diskette\n operations.\n\n This table includes values such as \"head-settle time\" and \"step rate time\"\n which have a tremendous effect on the speed of diskette I/O.\n\n It is possible to change some facets of diskette operation by creating a\n RAM-resident version of this table and modify selected parameters. DOS\n creates a modified version of this table to improve diskette performance.\n Oddly, DOS restores the normal (typically slower) values when it restores\n control to the application program.\n\n See Diskette Parameter Table for a layout of the table.\n\nSee Also: BIOS Data Area\n ROM-BIOS Functions\n -♦-"
  },
  {
    "id": "257-int_1fh__cga_graphics_character_font_pointer.html",
    "t": "INT 1fH: CGA Graphics Character Font Pointer",
    "b": "This vector (0:007c) is a pointer to a table of Font Definition Data that\n defines ASCII characters 128-255 (80H-ffH) that will be used to display\n text (via INT 10H 0eH et al.) while in graphics mode.\n\n The oldest CGA video systems do not provide definitions for these\n characters. On these systems, characters 128-255 (when in graphics modes)\n are displayed as random dots unless you install your own table at the\n INT 1fH vector.\n\n Notes: ■ On CGAs, text-mode font data is inaccessible.\n ■ EGA/VGA systems provide access to all font data. They\n automatically set INT 1fH to point to a table in ROM.\n\n See Font Definition Data for a layout of this data. The CGA BIOS expects\n these character to be eight dots high (eight bytes per character).\n\nSee Also: INT 43H (EGA/VGA Graphics Character Font Pointer)\n BIOS Data Area\n ROM-BIOS Functions\n -♦-"
  },
  {
    "id": "258-int_40h__diskette_bios_revector.html",
    "t": "INT 40H: Diskette BIOS Revector",
    "b": "This vector (0:0100) points to the code that handles INT 13H calls that\n apply to diskette drives.\n\n When hard disks were first introduced on the PC, the BIOS disk API code\n was on the hard disk controller and installed via ROM-Scan. At boot time,\n it would put the original INT 13H vector into the INT 40H vector. Then\n when a service call requested access to a diskette drive, (i.e., DL<80H),\n it would pass control on to the original INT 13H handler (now at INT 40H).\n\n On AT-class computers, the hard disk and diskette BIOSes are often merged\n and handled via the system BIOS (rather than a ROM-Scan add-on). However,\n both INT 13H and INT 40H vectors are maintained for compatibility.\n\nSee Also: BIOS Data Area\n ROM-BIOS Functions\n -♦-"
  },
  {
    "id": "259-int_41h_and_int_46h__hard_disk_parameter_pointers.html",
    "t": "INT 41H and INT 46H: Hard Disk Parameter Pointers",
    "b": "These vectors (0:0104 and 0:0118) are pointers to hard disk operating\n parameter structures on AT-class and better computers.\n\n See Hard Disk Parameter Table for a layout of the data at these vectors.\n\n XT: Depending upon switch settings, one of four addresses are copied to\n these vectors.\n\n AT: At Boot time, the AT BIOS reads the CMOS Memory to learn which type(s)\n of hard disk drives are attached. It then points the vectors...\n\n INT 41H --> first hard disk\n INT 46H --> second hard disk\n\n ...to tables in ROM. Many recent BIOSes are able to handle \"user-defined\"\n hard-disk types. They store the necessary parameters in non-volatile RAM\n and copy them into memory at boot time.\n\nSee Also: BIOS Data Area\n ROM-BIOS Functions\n -♦-"
  },
  {
    "id": "260-int_43h__ega_vga_graphics_character_font_pointer.html",
    "t": "INT 43H: EGA/VGA Graphics Character Font Pointer",
    "b": "This vector (0:010c) is a pointer to a table of Font Definition Data that\n defines all ASCII characters that will be used to display text (via\n INT 10H 0eH et al.) while in graphics mode on EGA and VGA video systems.\n\n A copy of a font is maintained is easily-accessible memory (usually ROM)\n to that BIOS fns such as INT 10H 08H (read character from screen) can\n compare sets of graphics pixels against the defined characters in order to\n return an ASCII value.\n\n See Font Definition Data for a layout of this data. The size of the\n entries (bytes-per-character) varies according to the value in 40:0085\n (see BIOS Data Area).\n\nSee Also: INT 1fH (CGA Graphics Character Font Pointer)\n BIOS Data Area\n ROM-BIOS Functions\n -♦-"
  },
  {
    "id": "261-int_4ah__user_alarm_handler.html",
    "t": "INT 4aH: User Alarm Handler",
    "b": "The INT 4aH vector (at 0:0128) is initialized by BIOS to point to an IRET.\n\n It must be revectored to a user-supplied handler whenever using\n INT 1aH 06H (set RTC alarm).\n\n If you intercept this interrupt, be sure to save all registers on entry\n and restore all registers on exit.\n\n Only AT-class and better computers support this interrupt.\n\nSee Also: INT 1aH 06H (set user alarm)\n CMOS Memory\n BIOS Data Area\n -♦-"
  },
  {
    "id": "262-int_70h__real_time_clock_interrupt_handler.html",
    "t": "INT 70H: Real-Time Clock Interrupt Handler",
    "b": "This vector (0:01c0) is initialized by the BIOS to handle the periodic\n interrupts generated by the Real-Time Clock; IRQ 8.\n\n The RTC is initially programmed to generate approximately 1024 interrupts\n per second.\n\n Only AT-class and better computers use this device.\n\nSee Also: IRQs: Hardware Interrupts\n CMOS Memory\n INT 1aH 06H (set user alarm)\n INT 15H 8300H (set event wait interval)\n INT 15H 86H (wait)\n INT 1cH (user timer interrupt)\n INT 4aH (user alarm handler address)\n BIOS Data Area\n -♦-"
  },
  {
    "id": "263-system_startup_sequence.html",
    "t": "System Startup Sequence",
    "b": "When you turn your computer on, it runs through some built-in diagnostic\n tests (called the POST or Power-On Self-Test). If it detects a problem\n during these tests, you may see an error code (see POST Error Codes) or\n perhaps a full-screen interactive configuration utility will appear (this\n varies from machine to machine, depending on the brand of computer you\n have and the maker of its ROM-BIOS).\n\n After the POST, but before booting the disk, the ROM-BIOS performs\n ROM-Scan to see if any hardware adaptors have installed ROM into the\n areas between c000:0 and e000:0.\n\n Once the system gets past the POST and ROM-Scan, the sequence is basically\n the same for all IBM-compatible computers. The following steps occur\n after the POST or whenever you press Ctrl+Alt+Del to reboot:\n\n 1) If a diskette is in drive A, the boot sector of that drive is read\n and the system attempts to boot using system files from the diskette.\n If it is not a system disk, a message such as...\n\n Non-System disk or disk error\n Replace and press any key when ready\n\n ...appears. You can do as it requests, or just press any key to boot\n from your hard disk.\n\n If no diskette is in drive A, the system attempts to boot from your\n first hard disk (always drive C). The Master Boot Record (MBR)\n of the hard disk is read into memory and executed.\n\n The program code in MBR looks at the disk partition table (also in\n the MBR) and determines which operating system to start. For most of\n us, the hard disk contains a single operating system -- MS-DOS 6 (you\n may use Fdisk to activate a different operating system). The first\n sector of the active partition is used as the boot sector for that\n operating system. From here on, the boot sequence is the same for\n hard disks and diskettes.\n\n 2) The boot sector is read into memory and executed. It contains\n instructions to look for two files in the root of the startup disk.\n\n IO.SYS contains the standard device drivers along with code that\n processes the rest of the boot sequence (IBMBIO.SYS in PC-DOS).\n\n MSDOS.SYS contains the code to handle DOS low-level function calls,\n including INT 21h services (IBMDOS.SYS in PC-DOS).\n\n The files are loaded into memory and control passes to IO.SYS.\n\n 3) IO.SYS looks for DBLSPACE.BIN in the root of the boot disk. If\n found, it is loaded into the upper part of conventional▲ memory.\n\n DBLSPACE.BIN intercepts all disk I/O services. When it initializes,\n it looks for DBLSPACE.INI (also in the root) and using information it\n contains, it may swap one or more drive IDs.\n\n If either DBLSPACE.BIN or DBLSPACE.INI is not found, then DoubleSpace\n support will not be present.\n\n Note: With DOS 6.2+, you can bypass this early load of\n DBLSPACE.BIN by pressing Ctrl+F5 when you boot.\n\n 4) IO.SYS displays:\n\n Starting MS-DOS...\n\n It then looks for a text file▲ named CONFIG.SYS in the root of the\n boot disk. If found, it is read and processed as a series of\n configuration commands. If SWITCHES=/F is not found, there is a\n 2-second delay. In this interval, you can press F5 (see Clean Boot)\n or F8 (see Interactive Boot) to control the rest of the boot\n sequence.\n\n Note that when DoubleSpace is active, DBLSPACE.BIN has already\n intercepted disk I/O calls (and swapped drive C), so IO.SYS will find\n CONFIG.SYS on the compressed volume.\n\n 5) If CONFIG.SYS contains a MultiConfig menu, then the menu is\n displayed:\n MS-DOS 6 Startup Menu\n ═════════════════════\n 1. option\n 2. option\n ... etc. ...\n\n Enter a choice: _\n\n It prompts for user input. The MENUDEFAULT= command can specify a\n time-out value to continue the boot without waiting for a keystroke.\n\n The CONFIG e-var is set to match the option chosen.\n\n 6) IO.SYS executes all commands in [COMMON] sections (including the\n \"implied [COMMON]\" area before the first section or the [MENU] line).\n It then proceeds to execute the particular commands specified in the\n selected (or default) section.\n\n Note that IO.SYS does not necessarily run commands in the order they\n appear in CONFIG.SYS. It internally reorders commands into groups\n and then executes the groups in this order:\n \n ■ DOS=, SWITCHES=, SET etc. general configuration commands.\n \n ■ DEVICE= and DEVICEHIGH= device driver installation commands.\n Note that drive letters are assigned according to the order in\n which the device drivers are loaded in CONFIG.SYS.\n \n ■ INSTALL= and INSTALLHIGH= TSR installation commands.\n\n MultiConfig menu sections cannot override this general order; for\n instance, you can't run an INSTALL= line before a DEVICE= line.\n\n 7) If a SHELL= command appears in CONFIG.SYS, then the program it\n identifies will be used as the DOS command processor. If not, then\n the file COMMAND.COM will be used. IO.SYS will look for COMMAND.COM\n in the root of the boot disk, and if not found, it will search \\DOS\n and \\MSDOS.\n\n IO.SYS sets the COMSPEC e-var to identify the command processor.\n\n 8) COMMAND.COM initially sets up a minimal DOS environment containing a\n simple path (PATH=C:\\DOS) and a standard prompt (PROMPT=$p$g).\n\n 9) By default, COMMAND.COM looks for a text file▲ named AUTOEXEC.BAT in\n the root of the boot disk and begins executing the commands it\n contains.\n\n Note: with DOS 6.0+, You can force COMMAND.COM to execute a different\n startup batch by using SHELL=d:\\path\\command.com /K=batfile.bat\n in CONFIG.SYS.\n\n AUTOEXEC.BAT can be tailored to execute a different set of commands for\n each of the MultiConfig menu options by testing the CONFIG e-var.\n\n Finally, the command processor displays the command prompt and you may\n begin interactive computing.\n\nSee Also: CONFIG.SYS Commands\n Clean Boot\n Interactive Boot\n MultiConfig Menus\n DoubleSpace\n Predefined Environment Variables\n -♦-"
  },
  {
    "id": "264-power_on_self_test.html",
    "t": "Power-On Self-Test",
    "b": "┌─┐ ┌─┐ ┌─┐ ┌─┐\n │P│ower─│O│n │S│elf─│T│est\n └─┘ └─┘ └─┘ └─┘\n The POST is a ROM program that's executed when the computer is first\n turned ON. It performs the following functions:\n\n ■ Checks the Switch Settings (PC,XT) or the CMOS Memory (AT,PS/2) to\n determine what peripheral equipment is connected and sets the\n Equipment List bit flags.\n\n ■ Checks RAM and writes data to all addresses (required for RAM error\n detection) and tests components (DMA, interrupt, disk, keyboard, etc.).\n It beeps and/or displays error codes; see POST Error Codes.\n\n ■ Performs ROM-Scan to install add-on firmware and initialize add-on\n hardware.\n\n ■ Executes the bootstrap sequence to load DOS.\n\n ■ Checks CMOS address 0fH (and 40:0072 in the BIOS Data Area) for special\n actions.\n\nSee Also: System Startup Sequence\n ROM-Scan\n CONFIG.SYS\n MultiConfig Menus\n DoubleSpace\n -♦-"
  },
  {
    "id": "265-power_on_error_codes.html",
    "t": "Power-On Error Codes",
    "b": "When power is first applied to the system, the POST BIOS code checks the\n CPU, Keyboard, and various controllers and when it encounters an error, it\n typically beeps and displays an error code and a brief message.\n\n The earliest PCs, Xt, and ATs displayed a simple error code number and\n left you wondering what happened. Later BIOSes provide more info, but\n often use the same numbering convention as shown below.\n\n█▌Beep Codes▐█\n No beeps, no display: Power failure\n Continuous beeps: Power failure\n Repeating short beeps: Power failure\n One short beep: Display failure\n One long, two short beeps: Display failure\n One long, three short beeps: EGA display failure\n\n█▌100s: Motherboard▐█\n 101 Interrupt failure\n 102 Timer failure\n 103 Timer interrupt failure\n 104 Protected mode failure\n 107 Hot non-maskable interrupt (NMI) test\n 108 Timer bus test failure\n 109 Direct Memory Access (DMA) failure\n 110 Motherboard memory\n 111 Adapter memory\n 112,113,166 Adapter in system unit\n 121 Hardware interrupts\n 151 Defective battery\n 152 Real-time clock\n 161 Battery failure\n 162,165,199 System options not set correctly; run setup\n 163 Time and date not set correctly\n 164 Memory size error\n\n█▌200s: Memory▐█\n xxyyy yyzz 201 Bad Chip (note: code IDs chip, but differs for\n various BIOSes, makes, and models\n 201,202 Memory test failed\n 203,215 Memory address error\n 216 Motherboard memory\n\n█▌300s: Keyboard Errors▐█\n 301 Improper keyboard response or stuck key\n 302 User-indicated error from keyboard test or AT keylock locked\n 303 Keyboard or system\n 341 Replace keyboard\n 342 Replace interface cable\n 343 replace enhancement card or cable\n\n█▌400s: Monochrome Monitor▐█\n 401 MDA video memory, horizontal sync, or video test failed\n 408,416,424 User-indicated display attributes failure\n 432 Parallel port test failed\n\n█▌500s: Color Monitor▐█\n 501 Video memory, horizontal sync, or video test failed\n 408,516,424,532,540,548 User-indicated attribute or mode failure\n\n█▌600s: Diskette Drive▐█\n 601 Diskette power-on diagnostics failed\n 602 Boot record not valid\n 603 Diskette size error\n 606 Diskette verify\n 607 Write protected\n 608 Bad command diskette status\n 610 Diskette initialization\n 611 Time out\n 612 Bad controller\n 613,614 Direct memory access (DMA)\n 621 Bad seek\n 622 Bad cyclic redundancy (CRC)\n 623 Record not found\n 624 Bad address mark\n 625 Bad controller seek\n 626 Diskette data compare\n 627 Diskette change line\n 628 Diskette removed\n\n█▌600s: Math Coprocessor▐█\n 701 Coprocessor test failed\n\n█▌900s: Parallel Printer Adapter LPT1▐█\n 901 Parallel printer adapter failure\n\n█▌1000s: Parallel Printer Adapter LPT2▐█\n 1001 Alternate Parallel printer adapter failure\n\n█▌1400s: Printer▐█\n 1401 Printer test failed\n 1404 Dot Matrix printer test failed\n\n█▌1700s: Hard Disk▐█\n 1702 Time out error\n 1703 Seek error\n 1704 Disk adapter error\n 1705 No record found\n 1706 Write fault error\n 1707 Track 0 error\n 1708 Head select error\n 1709 Defective error check\n 1710 Read buffer overrun\n 1711 Bad address mark\n 1712 Undetermined error\n 1713 Data compare error\n 1714 Drive not ready\n 1780,1790 Disk 1 failure or error\n 1781,1791 Disk 2 failure or error\n 1782 Disk adapter error\n\nSee Also: POST\n DOS Error Codes\n -♦-"
  },
  {
    "id": "266-rom_scan.html",
    "t": "ROM-Scan",
    "b": "During cold-boot (power-on start-up), after the POST and installation of\n default interrupt handlers, BIOS makes a check for external ROMs found on\n feature cards (boards installed in a PC slot). This testing is informally\n called ROM-scan.\n\n Note: ROM-scan was NOT implemented in the earliest BIOS and the very\n oldest PCs (those with a maximum of 64K on the motherboard) will\n not have this feature unless a later version of the ROM-BIOS has\n been installed.\n\n External ROM modules may exist between addresses c000:0 and e000:0. Each\n 2K block in this range is checked for a signature and is in this format:\n\nRomScanHdrRec\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 2 wSignature must be aa55H (55H followed by aaH; i.e. U¬)\n +2 1 bLenPgs length of the ROM module in 512-byte pages\n +3 ? abCode variable-length code and data of the ROM. It\n usually begins with a JMP to get the\n initialization portion of the code.\n\n When BIOS finds a ROM signature, it performs a checksum on the defined\n module. Each byte is summed modulo 100H and the sum must be exactly 0.\n When a module is verified to be valid, BIOS performs a FAR CALL to offset\n 0003H of its segment and the ROM must eventually return to the BIOS via a\n FAR RET.\n\n Typically, the ROM module will perform any hardware initialization tasks\n necessary and insert its own addresses into one or more interrupt vectors.\n\n The ROM sockets U17 and U37 on the AT motherboard are addressed starting\n at e000:0000. A scan occurs in 64K blocks for a valid module. If\n present, a module will have the aa55H signature, an unused length byte,\n executable code starting at xxxx:0003 and a checksum of 0 modulo 100H at\n e000:ffff.\n\n A MRCI hardware-assist adaptor could install data-compression support\n via ROM-Scan, and thus be available immediately on power up. See\n INT 1aH b001H (query hardware-based MRCI support).\n\nSee Also: POST\n BIOS Data Area\n System Startup Sequence\n -♦-"
  },
  {
    "id": "267-the_config_sys_file.html",
    "t": "The CONFIG.SYS File",
    "b": "When DOS boots up, it looks in the root directory of the boot disk for a\n text file named CONFIG.SYS. If that file exists, it is read and processed\n as a list of configuration commands.\n\n Command Function Command Function\n BREAK= Ctrl-Break test level █ INSTALLHIGH= load TSRs into UMB\n BUFFERS= # of disk I/O buffers █ MENUITEM= menu text & action\n COUNTRY= country-dependant info █ MENUCOLOR= menu colors\n cmd?= conditional execution █ MENUDEFAULT= default and time-out\n DEVICE= install device driver █ NUMLOCK= state of NumLock\n DEVICEHIGH= install driver in UMB █ REM or ; comments in CONFIG.SYS\n DRIVPARM= parms for disk drivers █ SET e-vars in CONFIG.SYS\n FCBS= max open FCBs █ SHELL= install cmd processor\n LASTDRIVE= SUBST drive ID limit █ STACKS= hdwr int stack sizes\n FILES= max # of file handles █ SUBMENU= set up a submenu\n INCLUDE= run cmds in a block █ SWITCHAR= cmd-line switch char\n INSTALL= load TSRs █ SWITCHES= kydb, boot opts, etc.\n\n CONFIG.SYS is a standard text file▲, created by any text editor. Changes\n to CONFIG.SYS take effect only after you restart DOS.\n\nSee Also: Enhanced CONFIG.SYS Options\n MultiConfig Menus\n Device Drivers\n System Startup Sequence\n -♦-"
  },
  {
    "id": "268-enhanced_config_sys_options.html",
    "t": "Enhanced CONFIG.SYS Options",
    "b": "DOS 6 provides the following enhanced configuration options:\n\n MultiConfig Menus\n New CONFIG.SYS commands make it possible to display an interactive\n menu of configuration options. Different sets of commands can be\n executed depending upon the user input. DOS provides a way to\n specify a timed default selection and a way to continue along a\n particular boot path in the AUTOEXEC.BAT file.\n ┌──╖\n │F5║ Clean Boot\n ╘══╝ At system startup, you can press F5 (or press and hold SHIFT) to\n bypass the commands in CONFIG.SYS and AUTOEXEC.BAT. This can get\n you out of a tough situation in which a configuration problem is\n causing a system lockup. DOS 6.2: Ctrl+F5 also bypasses loading\n of DBLSPACE.BIN.\n ┌──╖\n │F8║ Interactive Boot\n ╘══╝ If you press F8 during system startup, you will get a chance to\n step through the commands in CONFIG.SYS one-by-one, skipping any\n commands that are causing a problem. This option also lets you\n bypass execution of AUTOEXEC.BAT. DOS 6.2: Ctrl+F8 lets you\n process individual commands in AUTOEXEC.BAT.\n\ncmd?= Place a question mark (e.g., DEVICE?=RAMDRIVE.SYS) in any\n CONFIG.SYS command to be prompted whether to execute that command.\n\n;(rem) Semicolon at the start of a line indicates a remark.\n\nSET With DOS 6.0+, you can create environment variables in CONFIG.SYS.\n\nSee Also: CONFIG.SYS Commands\n System Startup Sequence\n SWITCHES= (/N disables Clean Boot and Interactive Boot)\n -♦-"
  },
  {
    "id": "269-clean_boot.html",
    "t": "Clean Boot",
    "b": "┌───╖ ┌┬─────╥╖\n │F5 ║ or ││SHIFT║║\n ╘═══╝ ╘╧═════╩╝\n This feature of DOS 6.0+ lets you bypass all commands in CONFIG.SYS and\n AUTOEXEC.BAT. DOS 6.2: Ctrl+F5 bypasses loading of DoubleSpace support.\n\n During the System Startup Sequence, the message...\n\n Starting MS-DOS...\n\n ...appears and the system pauses for 2 seconds. If you press and release\n F5 at this point, OR press and hold SHIFT, DOS displays...\n\n MS-DOS is bypassing your CONFIG.SYS and AUTOEXEC.BAT files.\n\n ...and goes directly to a DOS command prompt. If the CONFIG.SYS file\n contains a MultiConfig Menu, you can press F5 at the menu prompt.\n\n█▌Skipping DBLSPACE.BIN▐█\n The DoubleSpace support driver, DBLSPACE.BIN, is automatically loaded\n before CONFIG.SYS is executed. If you need to disable DoubleSpace\n support, you would need to rename it on the host drive before booting.\n ┌────╖ ┌───╖\n However, if you are running DOS 6.2+, just press │Ctrl║+│F5 ║ at boot\n time. Of course, DOS won't be able to find your ╘════╝ ╘═══╝\n normal CONFIG.SYS and AUTOEXEC.BAT files (assuming that your drive C is a\n swapped DoubleSpace volume). So you may wish to make special \"emergency\"\n versions in the root of the host drive (often drive H or I).\n\nSee Also: Interactive Boot\n MultiConfig Menus\n SWITCHES= (/N disables Clean Boot; /F skips the 2-second delay)\n -♦-"
  },
  {
    "id": "270-interactive_boot.html",
    "t": "Interactive Boot",
    "b": "┌───╖\n │F8 ║\n ╘═══╝\n and (cmd)?= processing.\n \n These features of DOS 6.0+ provide interactive control over execution of\n individual CONFIG.SYS commands. DOS 6.2: Ctrl+F8 lets you control\n execution of individual commands in AUTOEXEC.BAT.\n\n During the System Startup Sequence, the message...\n\n Starting MS-DOS...\n\n ...appears and the system pauses for 2 seconds. If you press F8 at this\n point, DOS displays...\n\n MS-DOS will prompt you to confirm each CONFIG.SYS command.\n\n ...and then prompts with...\n\n (command) [Y,N]?\n\n ...before executing each command. Press Y to execute it or N to skip it.\n After the last command in CONFIG.SYS, DOS prompts with...\n\n Process AUTOEXEC.BAT [Y,N]?\n\n ...and you can skip AUTOEXEC.BAT by pressing Y.\n\n Note: With DOS 6.2+, if you start with Ctrl+F8, you will be prompted\n for action on each command in AUTOEXEC.BAT as well as CONFIG.SYS.\n\n This step-by-step batch processing can also be used with any\n batch file using the new COMMAND.COM syntax:\n\n Command /Y /C myBat.Bat\n\n█▌Skipping individual commands▐█\n You can place a question mark (?) after any CONFIG.SYS command to force\n DOS to verify whether you want to execute the command. For instance...\n\n DEVICE?=RAMDRIVE.SYS 512\n\n ...will cause DOS to display...\n\n DEVICE=RAMDRIVE.SYS 512 [Y,N]?\n\n ...and you can press Y to execute it or N to skip it.\n\nSee Also: Clean Boot\n MultiConfig Menus\n SWITCHES= (/N disables Clean Boot; /F skips the 2-second delay)\n -♦-"
  },
  {
    "id": "271-multiconfig_menus.html",
    "t": "MultiConfig Menus",
    "b": "A feature in DOS 6.0+ supports multiple configuration sets. You can\n display a menu of options and, depending upon the selection, execute\n different parts of CONFIG.SYS and AUTOEXEC.BAT.\n ─────────────────────────────────── Menu Definition Commands\n [MENU] Identify the beginning of the startup menu.\n\n MENUITEM= Define text to display in a menu and identify a block of\n commands to be executed when that option is selected.\n MENUDEFAULT= Set a default option and a time-out value.\n MENUCOLOR= Set text and background colors for the menu display.\n SUBMENU= Identify a menu item as a submenu.\n ─────────────────────────────────────────── Related Commands\n INCLUDE= Execute the commands in another block and resume executing\n the commands in the current block.\n NUMLOCK= Set the initial state of keyboard NumLock. This\n facilitates using the arrow keys for making a selection.\n SET Create an environment variable for possible use in\n AUTOEXEC.BAT or other batch files.\n SWITCHES= The /N switch disables F8 (Interactive Boot) and F5\n (Clean Boot). /F tells DOS to skip the normal 2-second\n delay before starting to execute CONFIG.SYS.\n ──────────────────────────────────────────── Syntax Elements\n [COMMON] Identify a series of commands that will be executed\n regardless of which configuration menu option is chosen\n (Note: Commands above the first menu are considered to be\n part of a [COMMON] block).\n [blockName] Identify the beginning of a series of CONFIG.SYS commands\n or the start of a submenu.\n\n CONFIG An environment variable that gets set to the blockName of\n the selected menu item. Use this to run specific commands\n in AUTOEXEC.BAT, depending upon the chosen configuration.\n\n REM or ; Lines beginning with a semicolon (;) or REM are ignored.\n\n cmd?= A question mark (?) before the equal sign (=) sign in any\n CONFIG.SYS command causes DOS to prompt and allow you to\n skip that command.\n\nSee Also: Clean Boot\n Interactive Boot\n CONFIG.SYS Commands\n System Startup Sequence\n -♦-"
  },
  {
    "id": "272-break___config_sys_command_.html",
    "t": "BREAK= (CONFIG.SYS Command)",
    "b": "Compatibility: 1.0+\n Purpose: Sets how often DOS checks for Ctrl+Break (Ctrl+C).\n\n A similar command can be executed in batch files or at the DOS\n command prompt (the Break command).\n\n Syntax: BREAK=ON\n or: BREAK=OFF\n\n█▌Parameters▐█\n\n OFF (default setting) DOS checks for Ctrl+Break only during console\n or printer I/O (while getting keyboard input, displaying text on\n the screen, or outputting to the printer).\n\n ON DOS checks for Ctrl+Break more often, including during disk I/O.\n\n The default setting is BREAK=OFF.\n\n█▌TECH Notes▐█\n\n ■ This is equivalent to calling DOS fn 3301H.\n\n ■ Ctrl+C or Ctrl+Break are handled by INT 23H.\n\nSee Also: CONFIG.SYS Commands\n -♦-"
  },
  {
    "id": "273-buffers___config_sys_command_.html",
    "t": "BUFFERS= (CONFIG.SYS Command)",
    "b": "Compatibility: 1.0+\n Purpose: Sets the number of disk buffers DOS will allocate. Use to make\n certain disk intensive operations perform faster.\n\n Syntax: BUFFERS= n[,m]\n\n█▌Parameters▐█\n\n n is the requested number of buffers, from 1 to 99. The default\n (when BUFFERS= is not used) is 2, 3, 10, or 15, depending on\n available memory (15 for most 640K+ systems).\n\n m sets how many 'look-ahead' buffers to allocate; they are used for\n reading upcoming sectors, before they are actually requested. It\n can range from 0 to 8. The default is 0.\n\n█▌TECH Notes▐█\n\n ■ When DOS= HIGH, and BUFFER= is less than 48, then DOS will store the\n buffers in the HMA▲.\n\n ■ With DOS 6.2, when DOS= HIGH, and BUFFER= is small (<10), then\n DBLSPACE.BIN will load part of itself into the HMA to conserve\n conventional memory.\n\n ■ It is possible to suballocate memory in the HMA (see INT 2fH 4axxH).\n However, if BUFFERS= is large, then there'll be no room in the inn.\n\n ■ When Smartdrv or other disk cache is active, you should minimize your\n BUFFERS= setting.\n\nSee Also: CONFIG.SYS Commands\n -♦-"
  },
  {
    "id": "274-country___config_sys_command_.html",
    "t": "COUNTRY= (CONFIG.SYS Command)",
    "b": "Compatibility: 3.3+\n Purpose: Sets the date and time input and display format. Also makes the\n currency symbol and decimal separator available to programs which\n use the low-level DOS function 38h.\n\n Syntax: COUNTRY=xxx[,yyy]\n or: COUNTRY=xxx[,[yyy],[d:]filename]\n\n█▌Parameters▐█\n\n xxx is the country code for desired date and time format. This code\n is the same as that used in the international telephone system.\n The default (when there is no COUNTRY= command) is the USA (001).\n\n yyy specifies a code page (display/printer character set) to be used.\n\n filename specifies the name of the file that contains the country\n information.\n\n█▌TECH Notes▐█\n\n ■ Codes used here correspond to those used in DOS fn 38H.\n\nSee Also: National Language Support\n Fn 6501H (get extended country Info)\n Fn 6601H (query global code page)\n Fn 6602H (set global code page)\n -♦-"
  },
  {
    "id": "275-country_codes.html",
    "t": "country codes",
    "b": "█▌International language support▐█\n ■ DOS defaults to US English. Use COUNTRY= if you want to use a\n character set for another supported language.\n\n ■ By default, DOS looks for a file named COUNTRY.SYS (in the root\n directory of the boot disk), but if you move the file to a different\n directory, or rename it, you must tell DOS about it with the COUNTRY=\n CONFIG.SYS command.\n\n █▌Supported languages; date and time formats▐█\n The following table lists country codes and character sets (code\n pages) supported by DOS with examples of date and time formats used\n when each country code is in use:\n ┌─────────────────────┬───────┬─────────┬────────────┬────────────┐\n │Country or language │country│character│Date format │Time format │\n │ │ code │ sets │ example │ example │\n ├─────────────────────┼───────┼─────────┼────────────┼────────────┤\n │Belgium │ 032 │ 850,437 │ 23/01/1993 │ 17:35:00 │\n │Brazil │ 055 │ 850,437 │ 23/01/1993 │ 17:35:00 │\n │Canada (French) │ 002 │ 863,850 │ 1993-01-23 │ 17:35:00 │\n │Croatia │ 038 │ 852,850 │ 1993-01-23 │ 17:35:00 │\n │Czechoslovakia │ 042 │ 852,850 │ 1993-01-23 │ 17:35:00 │\n │Denmark │ 045 │ 850,865 │ 23-01-1993 │ 17.35.00 │\n │Finland │ 358 │ 850,437 │ 23.01.1993 │ 17.35.00 │\n │France │ 033 │ 850,437 │ 23.01.1993 │ 17:35:00 │\n │Germany │ 049 │ 850,437 │ 23.01.1993 │ 17:35:00 │\n │Greece │ 030 │ 869,737 │ │ │\n │Hungary │ 036 │ 852,850 │ 1993-01-23 │ 17:35:00 │\n │International-English│ 061 │ 437,850 │ 23-01-1993 │ 5:35:00.00p│\n │Iceland │ 354 │ 861,850 │ │ │\n │Italy │ 039 │ 850,437 │ 23/01/1993 │ 17.35.00 │\n │Latin America │ 003 │ 850,437 │ 23/01/1993 │ 5:35:00.00p│\n │Netherlands │ 031 │ 850,437 │ 23-01-1993 │ 17:35:00 │\n │Norway │ 047 │ 850,865 │ 23.01.1993 │ 17:35:00 │\n │Poland │ 048 │ 852,850 │ 1993-01-23 │ 17:35:00 │\n │Portugal │ 351 │ 850,860 │ 23-01-1993 │ 17:35:00 │\n │Romania │ 040 │ 852,850 │ │ │\n │Serbia/Yugoslavia │ 038 │ 852,850 │ 1993-01-23 │ 17:35:00 │\n │Slovakia │ 042 │ 852,850 │ 1993-01-23 │ 17:35:00 │\n │Slovenia │ 038 │ 852,850 │ 1993-01-23 │ 17:35:00 │\n │Spain │ 034 │ 850,437 │ 23/01/1993 │ 17:35:00 │\n │Sweden │ 046 │ 850,437 │ 1993-01-23 │ 17.35.00 │\n │Switzerland │ 041 │ 850,437 │ 23.01.1993 │ 17,35,00 │\n │Turkish │ 090 │ 857,850 │ │ │\n │United Kingdom │ 044 │ 437,850 │ 23/01/1993 │ 17:35:00.00│\n │United States │ 001 │ 437,850 │ 01-23-1993 │ 5:35:00.00p│\n │Yugoslavia │ 038 │ 852,850 │ 1993-01-23 │ 17:35:00 │\n └─────────────────────┴───────┴─────────┴────────────┴────────────┘\n\n ■ Special versions of MS-DOS exist which provide support for Arabic\n countries, Israel, Japan, Korea, People's Republic of China, and\n Taiwan.\n\nSee Also: CONFIG.SYS Commands\n National Language Support\n -♦-"
  },
  {
    "id": "276-device___config_sys_command_.html",
    "t": "DEVICE= (CONFIG.SYS Command)",
    "b": "Compatibility: 2.0+\n Purpose: Adds DOS support for a physical (hardware) device. Use to\n install a device driver in conventional▲ memory.\n\n Use DEVICEHIGH= to install drivers into upper▲ memory.\n\n Syntax: DEVICE=[d:][path]filename.ext [drvrParms]\n\n█▌Parameters▐█\n\nd:\\path\\filename.ext is the drive, path, filename and extension of the file\n that contains the program code of the device. If you omit the\n drive and/or path, the file must be in the root of the boot disk.\n The file usually has an extension of .SYS, .BIN, or .EXE and the\n extension must be specified.\n\ndrvrParms are switches and options needed by the device driver. They vary\n from driver to driver.\n\n█▌TECH Notes▐█\n\n ■ See Device Driver Basics for background info on device drivers.\n\nSee Also: CONFIG.SYS Commands\n Device Drivers\n DEVICEHIGH=\n -♦-"
  },
  {
    "id": "277-devicehigh___config_sys_command_.html",
    "t": "DEVICEHIGH= (CONFIG.SYS Command)",
    "b": "Compatibility: 5.0+\n Purpose: Loads a device driver into upper▲ memory on 386-based and better\n computers.\n\n Uses: Use to maximize the amount of conventional▲ memory available for\n application programs.\n\n Use DEVICE= to install drivers into conventional▲ memory.\n\n Syntax: DEVICEHIGH=[d:][path]filename.ext [drvrParms]\n\n or: DEVICEHIGH [/L:loadOpts [/S]]=[d:][path]filename.ext [drvrParms]\n\n█▌Parameters▐█\n\nd:\\path\\filename.ext is the drive, path, filename and extension of the file\n that contains the device driver program code. If you omit the\n drive and/or path, the file must be in the root of the boot disk.\n The file usually has an extension of .SYS, .BIN, or .EXE and the\n extension must be specified.\n\ndrvrParms are switches and options needed by the device driver. They vary\n from driver to driver.\n\n/L:loadOpts specifies a UMB region and minimum size needs for the driver.\n /L and /S are normally used only by the Memmaker command when it\n optimizes memory use in your CONFIG.SYS file.\n\n When /L is omitted, DOS loads the driver into the largest\n available UMB▲ region and gives it access to that entire region.\n If no UMB is large enough for the driver, it is loaded into\n conventional RAM.\n\n For hand-optimizing the /L settings, the actual syntax is:\n\n /L:rgn[,minSize][;rgn[,minSize]...\n\n rgn is a UMB region number (0 to n; 0 is conventional▲ memory and\n n varies depending upon your memory configuration. Use Mem\n /F to obtain a list of free UMB regions on your system).\n\n minSize specifies the amount of memory that the driver will need.\n It is used for cases when the driver needs more memory than\n is identified by the load module.\n\n ;rgn[,minSize]... When a driver can make use of more than one\n memory block, you can specify additional regions and sizes\n on the command line.\n\n /S may be used in conjunction with /L. It is normally used only by\n Memmaker, after it analyses the driver's use of memory. It\n causes DOS to shrink the specified UMB to a smaller size,\n thereby minimizing driver memory use.\n\n█▌TECH Notes▐█\n\n ■ When this is used, DOS has set the allocation strategy to\n FIRST_FIT_HIGH as it loads the driver. See DOS fn 58H for related\n info.\n\n ■ If your device driver allocates memory and you wish to direct where\n that memory will be, use fns 5803H and 5801H.\n\nSee Also: CONFIG.SYS Commands\n DEVICE=\n Device Drivers\n -♦-"
  },
  {
    "id": "278-dos___config_sys_command_.html",
    "t": "DOS= (CONFIG.SYS Command)",
    "b": "Compatibility: 5.0+\n Purpose: On 286- and 386-based and better computers, this command provides\n a way to tell DOS to load itself in the High Memory Area▲,\n outside of the 640K of conventional▲ memory. On 386-based and\n better computers, it also provides a way to enable loading of\n device drivers and TSRs into UMBs▲.\n\n Uses: Maximize the amount of conventional memory available to\n applications.\n\n Syntax: DOS=HIGH[,UMB or NOUMB]\n or: DOS=LOW[,UMB or NOUMB]\n or: DOS=UMB or NOUMB\n\n█▌Parameters▐█\n\n HIGH sets DOS to use the 64K HMA▲ to hold most of its code and data\n areas. This option works on 286-based or better computers. LOW\n is the default.\n\n UMB lets DOS load TSRs and device drivers into UMB▲ memory via the\n DEVICEHIGH= and Loadhigh commands and makes upper memory\n available for applications which know how to use it. This option\n works on 386-based or better computers. NOUMB is the default.\n\n█▌TECH Notes▐█\n\n ■ When DOS=UMB is used, DOS uses fn 5803H (set upper-memory link state)\n to enable access to UMBs. In order to load programs into UMBs or\n allocate UMBs for your programs, you may also need to use fn 5801H (set\n memory allocation strategy).\n\n ■ See Accessing Upper Memory for info on allocating memory in UMBs.\n\n ■ It is okay to have DOS= twice in CONFIG.SYS (once or UMB and once for\n HIGH). The Memmaker command does that just to confuse you.\n\nSee Also: CONFIG.SYS Commands\n -♦-"
  },
  {
    "id": "279-drivparm___config_sys_command_.html",
    "t": "DRIVPARM= (CONFIG.SYS Command)",
    "b": "Compatibility: 2.1+\n Purpose: Modifies the settings of a DOS-internal device driver to support\n non-standard diskette drives.\n\n Uses: ■ Force DOS to treat drive B as a 720K (3½-inch) disk drive.\n ■ Fix a problem in which DOS or an application does not notice\n that you have inserted a different diskette (especially pre-\n formatted and INSTALL diskettes).\n\n Syntax: DRIVPARM= /D:drvNo [/F:n] [/H:hds][/T:trks][/S:sects][/C][/I][/N]\n\n█▌Parameters▐█\n\n /D:drvNo is required. It is the physical drive number (0=A,1=B,2=C,etc.).\n\n /F:n specifies a \"form factor\"; that is, drive type (default=2):\n 0 = 160/180K format (single-sided)\n 0 = 320/360K format (double-sided)\n 1 = 1.2M high-capacity drive\n 2 = 720K (3½-inch) format\n 5 = Hard disk\n 6 = Tape\n 7 = 1.44 MB (3½-inch) format\n 8 = read/write optical disk\n 9 = 2.88 MB (3½- inch) format\n\n /C indicates that the drive can detect when the door is closed.\n /I specifies to include internal support code to handle the drive.\n You need this if your ROM BIOS does not directly support 3½-inch\n drives.\n /N specifies that drvNo is non-removable (fixed disk).\n\n /H:hds specifies the number of read/write heads.\n /T:trks specifies the number of tracks per side.\n /S:sects specifies the number of sectors per track.\n\n The defaults for /H, /T, and /S depend on the /F setting.\n\n█▌TECH Notes▐█\n\n ■ This uses DOS fn 440dH 40H (generic IOCTL--set device parameters) to\n modify the BPB of the specified diskette driver.\n\nSee Also: CONFIG.SYS Commands\n Device Drivers\n -♦-"
  },
  {
    "id": "280-fcbs___config_sys_command_.html",
    "t": "FCBS= (CONFIG.SYS Command)",
    "b": "Compatibility: 2.0+\n Purpose: Sets the number of File Control Blocks (FCBs) that may be opened\n at the same time.\n\n Uses: You may need to increase this setting when running some very\n old programs that open a lot of files simultaneously and which\n occasionally fail when attempting to open a file.\n\n Syntax: FCBS=n\n\n█▌Parameters▐█\n\n n is the maximum number of File Control Blocks that can be open at\n one time. n can range from 1 to 255. The default is 4.\n\n█▌TECH Notes▐█\n\n ■ It's sort of interesting to note that DOS itself uses FCB calls now and\n then. In the command Dir /C (to display DoubleSpace compression\n ratios), DOS uses fn 11H to obtain file info in order to get a complete\n directory entry, so that it can trace the FAT chain, access the MDFAT,\n and thereby learn the current compression ratio.\n\n See CVF Layout for related info.\n\nSee Also: CONFIG.SYS Commands\n FILES=\n -♦-"
  },
  {
    "id": "281-files___config_sys_command_.html",
    "t": "FILES= (CONFIG.SYS Command)",
    "b": "Compatibility: 2.0+\n Purpose: Sets the maximum number of files that may be opened and accessed\n at one time.\n\n Uses: ■ Many applications run into problems when the FILES= setting is\n left at the default. Add this command to CONFIG.SYS (or\n increase its value) when an application reports there are \"not\n enough file handles\".\n\n ■ Avoid \"inexplicable\" file open errors when using word\n processors, spreadsheets, and database management programs.\n\n Syntax: FILES=n\n\n█▌Parameters▐█\n\n n specifies how many files can be open at one time. n can range\n from 8 to 255. The default value is 8 which is often too small.\n\n█▌TECH Notes▐█\n\n ■ By default, the handle table is located in a reserved portion of the\n PSP of every app.\n\n ■ Starting with DOS 3.3+, it is possible for any application program to\n increase the available handles. See DOS fn 67H (set handle count).\n\nSee Also: CONFIG.SYS Commands\n FCBS=\n -♦-"
  },
  {
    "id": "282-include___config_sys_command_.html",
    "t": "INCLUDE= (CONFIG.SYS Command)",
    "b": "Compatibility: 6.0+\n Purpose: Causes a block of CONFIG.SYS commands to be executed. This lets\n you avoid repeating a series of commands that are the same in two\n or more configurations.\n\n Syntax: INCLUDE=blockName\n\n█▌Parameters▐█\n\nblockName is the name of a block of CONFIG.SYS commands.\n\n [blockName] (the same text, enclosed in square brackets, on a\n line by itself) must appear elsewhere in the CONFIG.SYS file. If\n it cannot be found, an error message is displayed.\n\n The commands below [blockName] are executed to the next [block]\n line or the end of the CONFIG.SYS file.\n\nSee Also: CONFIG.SYS Commands\n MultiConfig Menus\n -♦-"
  },
  {
    "id": "283-install___config_sys_command_.html",
    "t": "INSTALL= (CONFIG.SYS Command)",
    "b": "Compatibility: 4.0+\n Purpose: Loads and executes a TSR▲ (before starting AUTOEXEC.BAT).\n\n Uses: ■ Avoid some memory loss due to DOS environment duplication.\n\n ■ Hide installation of system-level programs such as Share and\n Nlsfunc in the \"permanent\" CONFIG.SYS file, rather than loading\n them in the often-edited AUTOEXEC.BAT file.\n\n ■ Give your favorite TSR a chance at intercepting interrupt\n vectors before COMMAND.COM is loaded.\n\n Syntax: INSTALL=[d:][path]filename.ext [progParms]\n\n█▌Parameters▐█\n\nd:\\path\\filename.ext is the drive, path, filename and extension of the\n program to be installed. Only certain DOS external commands and\n third-party TSR▲ programs can be installed this way.\n\nprogParms specifies command-line parameters (filenames, switches, etc.) for\n the program being installed.\n\n█▌TECH Notes▐█\n\n ■ On DOS versions prior to DOS 6.0, a TSR loaded via INSTALL= does not\n have access to a valid DOS Environment block. DOS 6.0+ does provide a\n copy of the DOS environment and does follow the standards described in\n Program Startup & Exit.\n\n HOWEVER, the environment block does NOT remain in memory after\n installation. TSRs should access it only when starting up.\n\n ■ Your TSR may wish to allocate upper memory when it is available (see\n Accessing Upper Memory for info). However, you should always provide a\n command-line switch to force it to use only conventional▲ memory (or\n you'll irritate folks who are saving their UMBs for special purposes.\n\nSee Also: INSTALLHIGH=\n CONFIG.SYS Commands\n -♦-"
  },
  {
    "id": "284-installhigh___config_sys_command_.html",
    "t": "INSTALLHIGH= (CONFIG.SYS Command)",
    "b": "Compatibility: 5.0+\n Purpose: Loads a TSR into upper▲ memory (before starting AUTOEXEC.BAT).\n\n Uses: Same as INSTALL=, but attempts to load into any available UMB.\n\n Syntax: INSTALLHIGH=[d:][path]filename.ext [progParms]\n\n█▌Notes▐█\n\n This command is identical to INSTALL=, except that it attempts to load the\n program into upper memory, if any is available.\n\n Unlike DEVICEHIGH= and Loadhigh, INSTALLHIGH= does not support /L or /S,\n so there is no way to specify a particular region of memory for the TSR;\n thus, Memmaker will not be able to optimize the use of this command.\n\n Since INSTALLHIGH= commands are executed after all device drivers are\n loaded, and since Memmaker cannot optimize it, and since the command is\n undocumented, it is probably best to load TSRs via Loadhigh in your\n AUTOEXEC.BAT file.\n\nSee Also: INSTALL=\n CONFIG.SYS Commands\n -♦-"
  },
  {
    "id": "285-lastdrive___config_sys_command_.html",
    "t": "LASTDRIVE= (CONFIG.SYS Command)",
    "b": "Compatibility: 2.0+\n Purpose: Sets the limit for drive IDs usable by the Subst command and for\n use as InterLink drives.\n\n Syntax: LASTDRIVE=d\n\n█▌Parameters▐█\n\n d is a single alphabetical letter in the range A to Z.\n\n█▌TECH Notes▐█\n\n ■ DOS maintains an undocumented internal array of information on each\n drive, including the ASCIIZ name of the current directory. The size of\n this array is set via the LASTDRIVE= command.\n\n The undocumented DOS fn 52H (get DOS Vars) returns the address of a\n DOS Variables Block, one field of which contains the LASTDRIVE= setting\n and another field points to a pointer to the drive info array.\n\nSee Also: CONFIG.SYS Commands\n -♦-"
  },
  {
    "id": "286-menuitem___config_sys_command_.html",
    "t": "MENUITEM= (CONFIG.SYS Command)",
    "b": "Compatibility: 6.0+\n Purpose: Defines a selectable item in a MultiConfig Menu.\n\n Syntax: MENUITEM=blockName [,text]\n\n█▌Parameters▐█\n\n blockName is the name of a block of CONFIG.SYS commands. If the user\n selects this menu item, that block of commands will be executed\n and a CONFIG e-var will be created (CONFIG=blockName).\n\n blockName can be up to 70 characters long. It may contain most\n characters except for:\n \\ backslashes\n / slashes\n , commas\n ; semicolons\n = equal signs\n [ ] square brackets\n\n [blockName] (the same text, enclosed in square brackets, on a line\n by itself) must appear elsewhere in the CONFIG.SYS file. If\n it cannot be found, the menu item will not be shown in the\n menu.\n\n text is some text to be displayed as a menu choice. If omitted,\n blockName itself is displayed.\n\n text can be up to 70 characters long; however, ASCII characters in\n the range 0-32 can cause DOS to ignore some or all of the\n text.\n\nSee Also: MultiConfig Menus\n CONFIG.SYS Commands\n -♦-"
  },
  {
    "id": "287-menucolor___config_sys_command_.html",
    "t": "MENUCOLOR= (CONFIG.SYS Command)",
    "b": "Compatibility: 6.0+\n Purpose: Chooses screen colors for MultiConfig Menu display.\n\n Syntax: MENUCOLOR=frgnd[,bkgnd]\n\n█▌Parameters▐█\n\n frgnd specifies a foreground (text) color number (0 to 15).\n bkgnd specifies a background color number (0 to 15; default=0).\n ┌───┬─────────────┬────┬────────────────┐\n Color Codes │ 0 │ Black │ 8 │ Gray │\n │ 1 │ Blue │ 9 │ Bright Blue │\n │ 2 │ Green │ 10 │ Bright Green │\n │ 3 │ Cyan │ 11 │ Bright Cyan │\n │ 4 │ Red │ 12 │ Bright Red │\n │ 5 │ Magenta │ 13 │ Bright Magenta │\n │ 6 │ Brown │ 14 │ Bright Yellow │\n │ 7 │ White │ 15 │ Bright White │\n └───┴─────────────┴────┴────────────────┘\n\n Note: Don't put any spaces after the comma; use frgnd,bkgnd with no\n intervening spaces (it's a bug in DOS 6.0, folks).\n\n█▌TECH Notes▐█\n\n ■ Notice that the color codes correspond to Video Attributes.\n\n ■ At system startup, the video system is still in its default setting in\n which character-blink is active rather than background-bold (see\n INT 10H 1003H). Thus, if you use 8-15 as bkgnd, you will actually see\n a background with the corresponding 0-7 color and the foreground\n characters will blink.\n\n ■ Screen colors are reset when ANSI.SYS device driver is loaded. You may\n want to rearrange the order of your DEVICE= lines to minimize the\n visual impact. Or use something like...\n\n @Echo ←[nnm (nn is an ANSI color code. See ANSI Escape Sequences)\n\n ...in your AUTOEXEC.BAT file.\n\nSee Also: MultiConfig Menus\n CONFIG.SYS Commands\n -♦-"
  },
  {
    "id": "288-menudefault___config_sys_command_.html",
    "t": "MENUDEFAULT= (CONFIG.SYS Command)",
    "b": "Compatibility: 6.0+\n Purpose: Chooses a default selection in a MultiConfig Menu and sets a\n time-out value to let the boot process continue setting up a\n default configuration.\n\n Uses: ■ Set up so that a MultiConfig CONFIG.SYS file can run its course\n automatically, without user intervention.\n ■ Position the menu cursor so that one press of Enter will\n continue with the most-often used configuration.\n ■ Skip the \"MS-DOS Startup Menu\" display altogether.\n\n Syntax: MENUDEFAULT=blockName [,time-out]\n\n█▌Parameters▐█\n\nblockName is the name of a block of CONFIG.SYS commands. It must be one of\n the blocks named in a MENUITEM= or SUBMENU= command in the same\n menu block.\n\n [blockName] (the same text, enclosed in square brackets, on a\n line by itself) must appear elsewhere in the CONFIG.SYS file.\n\n time-out specifies a delay interval, in seconds. DOS will wait time-out\n seconds and if it senses no keystrokes, it exits the menu and\n executes the commands in the block identified by blockName.\n\n If time-out is omitted, DOS will display the menu and pause until\n Enter is pressed.\n\n The time-out value can range from 0 to 90 seconds. A value of 0\n causes DOS to bypass the menu and immediately execute the\n commands in the blockName block.\n\n█▌TECH Notes▐█\n\n ■ An invalid syntax such as...\n\n MENUDEFAULT no_ems No EMS, 10\n\n ...will cause DOS to try to evaluate \"NO EMS\" as a time-out number and\n it comes out as 0. The result is that execution immediately begins at\n blockName.\n\nSee Also: MultiConfig Menus\n CONFIG.SYS Commands\n -♦-"
  },
  {
    "id": "289-numlock___config_sys_command_.html",
    "t": "NUMLOCK= (CONFIG.SYS Command)",
    "b": "Compatibility: 6.0+\n Purpose: Sets the state of keyboard \"NumLock\". When NumLock is OFF, the\n numeric keypad can be used as arrow keys for cursor movement.\n\n Uses: ■ Preset the keyboard for use with screen-oriented programs which\n use the arrow keys for cursor control.\n ■ Set up so that MultiConfig Menus will work intuitively; that\n is, so the user can use the arrow keys to move the cursor bar\n (without needing to first press the NumLock key).\n\n Syntax: NUMLOCK=ON or OFF\n\n█▌Parameters▐█\n\n ON sets the keyboard into Numlock mode; keys on the numeric keyboard\n will represent numbers.\n\n OFF runs off Numlock mode; keys on the numeric keyboard represent\n cursor-control arrows.\n\n█▌TECH Notes▐█\n\n ■ This sets or clears bit 5 of 0040:0017 (see Keyboard Flags and\n BIOS Data Area).\n\nSee Also: CONFIG.SYS Commands\n -♦-"
  },
  {
    "id": "290-rem__config_sys_command_.html",
    "t": "REM (CONFIG.SYS Command)",
    "b": "Compatibility: 4.0+\n Purpose: Lets you put comments (REMarks) in your CONFIG.SYS file.\n\n Uses: ■ Leave notes to yourself or others; record your reasons for\n CONFIG.SYS lines.\n ■ \"Comment-out\" lines; for instance, for temporary testing, etc.\n\n Syntax: REM [text]\n or: ; [text]\n\n█▌Parameters▐█\n\n text is the text of the remark.\n\n█▌TECH Notes▐█\n\n ■ REM in CONFIG.SYS is supported by DOS 4.0+.\n ; as a REM in CONFIG.SYS is supported in DOS 5.0+.\n\n ■ REM is also used in batch files (but ; is not supported). You can use\n a colon (:) as a 1-character batch-file REM.\n\nSee Also: CONFIG.SYS Commands\n -♦-"
  },
  {
    "id": "291-set__config_sys_command_.html",
    "t": "SET (CONFIG.SYS Command)",
    "b": "Compatibility: 6.0+\n Purpose: Lets you create environment variables in your CONFIG.SYS file.\n\n Uses: Set flags to trigger actions in AUTOEXEC.BAT.\n\n Syntax: SET varName=value\n\n█▌Parameters▐█\n\n varName is any string of characters, unbroken by spaces. The varName is\n converted to uppercase and the entire string, including the\n value, is placed into the environment.\n\n value is any string of characters you wish to associate with varName.\n\n█▌TECH Notes▐█\n\n ■ SET in CONFIG.SYS is supported only by DOS 6.0+.\n\n This was implemented in DOS 6.0 to enable MultiConfig Menus to pass an\n e-var (CONFIG) to AUTOEXEC.BAT.\n\n ■ There is no way to examine environment variables in CONFIG.SYS;\n however, the varName=value lines will be available for testing (via If\n or the Goto %varName% technique) in AUTOEXEC.BAT or other batch files.\n\n ■ The 127-character limit of the DOS Set command is not present when SET\n is used in CONFIG.SYS. Some folks use this to create gigantic PATH=\n environment variables. I recommend against this practice since many\n programs that examine the environment assume that no line is greater\n than 128 bytes.\n\n ■ The total size of the environment during CONFIG.SYS is not documented\n (use SHELL=COMMAND.COM /E:nnnn to set it for COMMAND.COM).\n\n ■ I use SET in CONFIG.SYS to give a name to my RAM disk; for instance,\n\n SET RAMDISK=F:\n\n Then, in batch file and MAKE files, I can use commands such as:\n\n PATH %RAMDISK%\\;c:\\dos;c:\\utils;...etc...\n COPY c:\\utils\\norton\\ncd.exe %RAMDISK%\n\nSee Also: CONFIG.SYS Commands\n -♦-"
  },
  {
    "id": "292-shell___config_sys_command_.html",
    "t": "SHELL= (CONFIG.SYS Command)",
    "b": "Compatibility: 2.0+\n Purpose: Replaces the normal command processor (COMMAND.COM) with a\n different program, OR selects non-default settings for\n COMMAND.COM. Note: This command is unrelated to the Dosshell\n command.\n\n Uses: ■ Identify the location of COMMAND.COM.\n ■ Create a DOS environment that is larger than the default.\n ■ Run a batch file other than AUTOEXEC.BAT at startup.\n\n Syntax: SHELL=[d:][path]filename.ext [parms]\n\n█▌Parameters▐█\n\nd:\\path\\filename.ext is the drive, path, filename and extension of the\n program to be used as the command processor.\n\nprogParms specifies command-line parameters for the command processor.\n\n█▌TECH Notes▐█\n\n ■ The DOS 6.0 COMMAND.COM option /K= sets the name of the AUTOEXEC.BAT\n file. COMMAND.COM /K=mybat.bat is a handy way to set up a DOS session\n from Windows.\n\n ■ To increase the size of the DOS environment, use COMMAND.COM /E=nnn.\n\nSee Also: CONFIG.SYS Commands\n -♦-"
  },
  {
    "id": "293-stacks___config_sys_command_.html",
    "t": "STACKS= (CONFIG.SYS Command)",
    "b": "Compatibility: 2.0+\n Purpose: Allocates additional stack space for DOS. If you see the\n message...\n Internal Stack Failure\n System Halted\n ...then you should put a STACKS= statement in CONFIG.SYS\n\n Syntax: STACKS= n,s\n\n█▌Parameters▐█\n\n n is the number of stacks to allocate (0-64; default=9)\n\n s is the size (in bytes) of each stack (32-512; default=128)\n\n█▌TECH Notes▐█\n\n ■ DOS typically intercepts interrupts 02H, 08H-0eH, 72H-74H, and 76H-77H\n (see Interrupts and BIOS Services) which handle IRQs.\n\n When one of these interrupts occurs, DOS points SS:SP to an internal\n data area; that is, it switches stacks. This is supposed to minimize\n the chance of a hardware interrupt overflowing an application's stack.\n\n Note: DOS only performs stack switching when n is greater than 8.\n\n ■ STACKS=0,0 saves about 1K of conventional▲ memory (but it may cause\n problems when running communications software or other interrupt-\n intensive applications, or when running poorly-written software that\n supplies insufficient internal stack space for handling external\n interrupts.\n\n ■ A worst-case scenario -- such as an interrupt interrupting an\n interrupt, which itself is interrupted (etc.) -- can cause a stack\n overflow. If that happens, you should fall back to the default stack\n settings or even increase them.\n\nSee Also: CONFIG.SYS Commands\n -♦-"
  },
  {
    "id": "294-switches___config_sys_command_.html",
    "t": "SWITCHES= (CONFIG.SYS Command)",
    "b": "Compatibility: 5.0+\n Purpose: Selects some DOS low-level options.\n\n Uses: ■ Keep users from using F5 or F8 to bypass or single-step through\n the commands in CONFIG.SYS.\n ■ Lets you move WINA20.386 to a directory other than the root of\n your boot disk.\n ■ Speed up the boot sequence.\n ■ Make some older programs interpret keystrokes correctly.\n\n Syntax: SWITCHES= [/F] [/K] [/N] [/W]\n\n█▌Parameters▐█\n\n /F forces DOS to skip the normal 2-second delay seen after the\n Starting MS-DOS... message (6.0+).\n\n /K makes an enhanced keyboard behave as a conventional keyboard.\n\n /N disables the F5 Clean Boot and F8 Interactive Boot features of\n CONFIG.SYS processing (6.0+).\n\n /W lets users of Microsoft Windows place WINA20.386 in a directory\n other than the root of the boot drive (6.0+).\n\n█▌TECH Notes▐█\n\n ■ The /K option causes DOS keyboard handlers to map such scan codes as\n 0e 49 (the separate PageUp key) to 49 (the PgUp key on the numeric\n keypad, when numlock is not active). This is needed only on the oldest\n PC BIOSes and keyboards.\n\n ■ When /N is used, you can still abort AUTOEXEC.BAT by pressing\n Ctrl+Break repeatedly during startup.\n\nSee Also: Clean Boot\n Interactive Boot\n CONFIG.SYS Commands\n -♦-"
  },
  {
    "id": "295-switchar___config_sys_command_.html",
    "t": "SWITCHAR= (CONFIG.SYS Command)",
    "b": "Compatibility: 2.0 only\n Purpose: An undocumented CONFIG.SYS command supported by DOS 2.x ONLY.\n It was intended to let users choose a character other than\n slash (/) as the character to begin DOS command-line options\n (switches).\n\n Some sort of perverse compatibility with UNIX (and its -opts\n format) was no-doubt intended. It was never really supported,\n even by DOS commands (let alone third-party programs).\n\n Syntax: SWITCHES=c\n\n█▌Parameters▐█\n\n c is the desired switch character; e.g., SWITCHAR=- sets the\n character to a dash (-).\n\n█▌TECH Notes▐█\n\n ■ If you want your command-line parser to look for a character other\n than /, be my guest; but it's of no interest to DOS or me. See PSP.\n\n ■ DOS fn 3700H (query switch character) is also obsolete, but remains\n supported through DOS 6.0. It always returns 2fH (/).\n\n ■ DOS fn 3701H (set switch character) is obsolete and unsupported.\n Calling it is a NOP; it does not return an error, but has no effect.\n\nSee Also: CONFIG.SYS Commands\n DOS Versions\n -♦-"
  },
  {
    "id": "296-submenu___config_sys_command_.html",
    "t": "SUBMENU= (CONFIG.SYS Command)",
    "b": "Compatibility: 6.0+\n Purpose: Specify that a menu item in a MultiConfig Menu actually opens a\n submenu.\n\n Syntax: SUBMENU=blockName [,text]\n\n█▌Parameters▐█\n\nblockName is the name of a block of CONFIG.SYS commands which contains one\n or more MENUITEM= or SUBMENU= commands.\n\n blockName can be up to 70 characters long. It may contain most\n characters except for:\n \\ backslashes\n / slashes\n , commas\n ; semicolons\n = equal signs\n [ ] square brackets\n\n [blockName] (the same text, enclosed in square brackets, on a\n line by itself) must appear elsewhere in the CONFIG.SYS file. If\n it cannot be found, an error message is displayed, and the\n submenu will not be shown in the menu.\n\n text is some text to be displayed as a menu choice. If omitted,\n blockName is displayed as the menu item.\n\n The text can be up to 70 characters long, including displayable\n characters (ASCII 32-255).\n\n█▌TECH Notes▐█\n\n ■ Each submenu can have its own MENUDEFAULT= and time-out value, so you\n can automate even multiply-nested menus. But are you sure your really\n need this?\n\n ■ Its not documented anywhere, but you can backtrack from a submenu to a\n higher-level menu by pressing the BACKSPACE key.\n\nSee Also: MultiConfig Menus\n CONFIG.SYS Commands\n -♦-"
  },
  {
    "id": "297-verify___config_sys_command_.html",
    "t": "VERIFY= (CONFIG.SYS Command)",
    "b": "Compatibility: 2.0+\n Purpose: This causes DOS to enable or disable a low-level disk function\n which checks each disk sector after it is written.\n\n The Verify command does the same thing\n\n Syntax: VERIFY=ON\n or: VERIFY=OFF\n\n█▌Parameters▐█\n\n ON turns on write-verification (maximum safety).\n\n OFF turns it off (better speed).\n\n The default setting is VERIFY=OFF.\n\n█▌TECH Notes▐█\n\n ■ You can do this in your program via DOS fn 2eH (set/reset verify).\n\n ■ Verify ON does NOT compare written data to data in memory. It performs\n an INT 13H 04H (verify sectors) on data after it is written. That fn\n compares the ECC▲ recorded in the sector with the ECC calculated by the\n controller.\n\n ■ Internally, DOS toggles VERIFY ON when it writes FAT and directory\n information. Leaving VERIFY ON all the time will degrade disk\n performance, especially on floppy diskettes.\n\nSee Also: CONFIG.SYS Commands\n -♦-"
  },
  {
    "id": "298-installable_device_drivers.html",
    "t": "Installable Device Drivers",
    "b": "An installable device driver lets you create a standard interface between\n DOS and an otherwise unsupported hardware device. TECH Help! covers the\n following topics:\n\n Device Driver Basics ........ general introduction to device drivers\n\n Device Header Layout ........ data structure a the start of a driver\n Device Attribute ............ bit flags that define a device\n\n Device Requests ............. services a device driver must perform\n Device Request Header ....... layout of first part of a request packet\n Device Driver Errors ........ error codes a driver returns to DOS\n Device Status Word .......... device status bit flags returned to DOS\n BPB: BIOS Parameter Block ... a structure used by block devices\n\n IOCTL Functions ............. these communicate with a driver directly\n\n Mouse Support ............... INT 33H fns are installed as a driver\n Expanded Memory Specification EMM Fns are installed as a device driver\n DoubleSpace ................. disk-compression installed as a driver\n MRCI API .................... disk-compression installed as a driver\n INT 2fH ..................... DOS extensions installed as drivers\n\nSee Also: CONFIG.SYS\n DOS Functions\n -♦-"
  },
  {
    "id": "299-device_driver_basics.html",
    "t": "Device Driver Basics",
    "b": "█▌Overview▐█\n An installable device driver is a specially-formatted program that is\n loaded into memory via a DEVICE= or DEVICEHIGH= command in CONFIG.SYS.\n\n The first part of the file must be an 18-byte Device Header structure.\n The first four bytes are modified by DOS upon installation. The file is\n installed into a chain of device drivers:\n ╔══════ Device Header ════════╗\n ╓───┬───┬┬┬┬┬┬┬───────────────╥─ - - - - - - - - - - - - - ─┐\n ╔═══════nextDev│ │N U L ║ code and data of NUL device │\n ║ ╙─┴─┴─┴─┴┴┴┴┴┴┴─┴─┴─┴─┴─┴─┴─┴─╨─ - - - - - - - - - - - - - ─┘\n ║ ╔═══►╓───┬───┬┬┬┬┬┬┬───────────────╥─ - - - - - - - - - - - - - - - ─┐\n ║ ║ ╔═══nextDev│ │C O N ║ code+data of standard CON device│\n ║ ║ ║ ╙─┴─┴─┴─┴┴┴┴┴┴┴─┴─┴─┴─┴─┴─┴─┴─╨─ - - - - - - - - - - - - - - - ─┘\n ║ ║ ╚═►╓───┬───┬┬┬┬┬┬┬───────────────╖\n ║ ║ ╔═══nextDev│ │L P T 1 ║\n ║ ║ ╚═►╟─┴─┴─┴─┼┴┴┴┴┴┴─┴─┴─┴─┴─┴─┴─┴─╫─ - - - - - - - - - - - ──┐\n ║ ║ ║ ffff│ │L P T 2 ║ code+data of LPTn devices│\n ║ ║ ╙─┴─┴─┴─┴┴┴┴┴┴┴─┴─┴─┴─┴─┴─┴─┴─╨─ - - - - - - - - - - - ──┘\n ╚═════►╓───┬───┬┬┬┬┬┬┬───────────────╥─ - - - - - - - - - - - - - - - ─┐\n ╚═════nextDev│ │C O N ║ code+data of ANSI.SYS CON device│\n ╙─┴─┴─┴─┴┴┴┴┴┴┴─┴─┴─┴─┴─┴─┴─┴─╨─ - - - - - - - - - - - - - - - ─┘\n\n When installing, DOS points nextDev of the NUL device to the new driver\n (e.g., ANSI.SYS above) and stores whatever was in the NUL device's nextDev\n into ANSI.SYS's nextDev field.\n\n This process inserts the driver near the start of the chain. In the\n example, any access to the device name of CON is satisfied by the\n installed driver, rather than the original.\n\n The device driver file is a binary image file. After assembling the\n source code, use EXE2BIN to convert to a binary file (or link it as a\n \"tiny model\" program). Unlike a COM-format file, do not include an\n ORG 100H at the start of the code and do not assume that a PSP or\n environment has been prepared for you.\n\n Note: It is possible to use the EXE file format for a device driver.\n The trick it to put the device header at the very start of your\n data segment.\n\n However, some older versions of IBM's OEM version (PC-DOS) cannot\n load an EXE file via the DEVICE= command.\n\n█▌Strategy and Interrupt▐█\n Two of the fields in the device header are 16-bit pointers to within the\n device driver code segment--the Strategy routine and the Interrupt\n routine.\n\n When an application uses a DOS function (such as INT 21H services) which\n require action of a device, DOS makes two calls to the driver. First, it\n calls the Strategy routine, passing it information about the requested\n action. It then calls the Interrupt routine.\n\n ■ When DOS calls the Strategy routine, it sets ES:BX to the address of a\n Device Request information structure. The \"request packet\" always\n begins with a 13-byte DevRequestHdrRec, followed by 0 or more bytes of\n data that varies, depending upon the request command code.\n\n The device driver should simply save the address passed in ES:BX, for\n later use by the Interrupt routine.\n\n ■ Then DOS calls the Interrupt routine, passing no parameters. The\n Interrupt routine inspects the data passed to the Strategy routine and\n takes the requested action.\n\n Upon completion of a request, the driver should set the DevStatusWord\n in the request structure to indicate completion (and any errors), then\n return to DOS via a FAR return.\n\n This two-call system was designed as a way for a \"smart device\" to enqueue\n requests, with the idea of perhaps improving performance by acting on them\n in a different order than originally requested. To my knowledge, no DOS\n device driver does this. It is probably valid to assume that a call to\n the Strategy routine will be followed immediately by a call to the\n Interrupt routine.\n\nSee Also: Device Requests\n Installable Device Drivers\n -♦-"
  },
  {
    "id": "300-device_requests.html",
    "t": "Device Requests",
    "b": "DOS\n Cmd Name Ver. Usage Flags\n ▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n 00H Initialize device ◄Chr►◄Blk►\n 01H Media Check ◄Blk►\n 02H Build BPB ◄Blk►\n 03H IOCTL Input ◄Chr►◄Blk►◄IRW►\n 04H Input (read from device) ◄Chr►◄Blk►\n 05H Non-destructive Input ◄Chr►\n 06H Input status ◄Chr►\n 07H Input Flush ◄Chr►\n 08H Output (write to device) ◄Chr►◄Blk►\n 09H Output with verify ◄Chr►◄Blk►\n 0aH Output Status ◄Chr►\n 0bH Output Flush ◄Chr►\n 0cH IOCTL Output ◄Chr►◄Blk►◄IRW►\n 0dH Device Open 3.0+ ◄Chr►◄Blk► ◄OCR►\n 0eH Device Close 3.0+ ◄Chr►◄Blk► ◄OCR►\n 0fH Removable Media 3.0+ ◄Blk► ◄OCR►\n 10H Output until busy 3.0+ ◄Chr► ◄OTB►\n 13H Generic IOCTL Request 3.2 ◄Chr►◄Blk► ◄Gen►\n 17H Get Logical Device 3.2 ◄Blk► ◄Gen►\n 18H Set Logical Device 3.2 ◄Blk► ◄Gen►\n 19H IOCTL Support Query 5.0 ◄Chr►◄Blk► ◄Gen► ◄Qry►\n ▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n\n On entry to the Strategy routine (see Device Driver Basics), DOS passes\n the address of a request structure in ES:BX (see DevRequestHdrRec). The\n bCmd field of that structure (at offset 2) will contain one of the above\n command codes.\n\n The variable-length data that follows the DevRequestHdrRec varies from\n command to command. Some commands share identical request structures.\n Others have a unique structure and some use only the request header to\n communicate with DOS.\n\nSee Also: IOCTL Functions\n Device Attribute\n Device Status Word\n Installable Device Drivers\n -♦-"
  },
  {
    "id": "301-device_request_00h__initialize_device.html",
    "t": "Device Request 00H: Initialize device",
    "b": "◄Blk► ◄Chr►\n This tells the driver to initialize itself and the device and to describe\n how much memory it needs.\n\nDevReq00Rec\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 1 bLen 19H (length of this request packet)\n +1 1 bUnitNo (not used)\n +2 1 bCmd 00H (command code)\n +3 2 rStatus OUTPUT: Device Status Word must fill before exit\n +5H 8 res (reserved)\n +0dH 1 bUnits OUTPUT: number of units you support\n +0eH 4 pfEndAddr INPUT: end of available memory for driver\n OUTPUT: end of resident code\n +12H 4 pfParms INPUT: addr of DEVICE= line in CONFIG.SYS (3.0+)\n OUTPUT: addr of BPB pointer array\n +16H 1 bDrvNo INPUT: first drive number\n +17H 2 wErrMsgFlag OUTPUT: 0000H=no error message (4.0+)\n 25 size of this structure\n\n rStatus On exit, the driver must place a DevStatusWord here. Always\n set the Done bit (bit 8). On an error, set the Done bit and\n the Error bit (bit 15) and put a Device Error Code in the low\n byte.\n\n bUnits On exit, set this to the number of block devices supported by\n this driver.\n\n pfEndAddr On entry, this contains the address (segment:offset) of the\n end of memory available to the driver.\n\n On exit, you must set this to the address of the byte\n immediate after the last byte your driver wants to keep\n resident in memory.\n\n If you exit without installing, set this to your load addr.\n\n pfParms (DOS 3.0+) On entry, this is the address of the text directly\n following the \"DEVICE=\" or \"DEVICEHIGH [/L:nn,mm]=\" in the\n line of CONFIG.SYS that loads the driver. The text ends with\n a linefeed (0aH) or carriage return (0dH).\n\n On exit, block device drivers should fill this field with the\n far address of bUnits 25-byte BPBRec structures.\n\n bDrvNo On entry, this tells you the first available drive number\n (0=A, 1=B, etc.) Your block device(s) will be given bUnits of\n these drive numbers.\n\n wErrMsgFlag On exit, if your driver fails to install, place 0001H in this\n field and set bit 15 of rStatus. DOS will display:\n\n Config.Sys Error in line ##\n\n Notes: ■ It's OK to use DOS fns 01H-0cH, 25H (set int vector), 30H (get\n version) and 35H (get int vector) during initialization.\n\n ■ This command will be used only once--directly after the driver\n is loaded via CONFIG.SYS. You can free up some memory by\n placing the code that handles this request at the end of the\n driver and setting pfEndAddr to not include that code.\n\n ■ Block device drivers can use the bDrvNo field when displaying a\n message (e.g, \"TAPE drive installed as drive d:\").\n\nSee Also: Device Requests\n DevRequestHdrRec\n Installable Device Drivers\n -♦-"
  },
  {
    "id": "302-device_request_01h__media_check.html",
    "t": "Device Request 01H: Media Check",
    "b": "◄Blk►\n This asks the driver to determine whether the media in the drive has been\n changed.\n\nDevReq01Rec\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 1 bLen 13H (length of this request packet)\n +1 1 bUnitNo unit number to check\n +2 1 bCmd 01H (command code)\n +3 2 rStatus OUTPUT: Device Status Word must fill before exit\n +5H 8 res (reserved)\n +0dH 1 bMediaID INPUT: Media Descriptor DOS thinks is there\n +0eH 1 bRetFlag OUTPUT: ffH=no change\n 00H=don't know\n 01H=changed\n +0fH 4 pfVolID OUTPUT: Addr of ASCIIZ▲ volume ID (3.0+)\n 19 size of this structure\n\n rStatus On exit, the driver must place a DevStatusWord here. Always\n set the Done bit (bit 8). On an error, set the Done bit and\n the Error bit (bit 15) and put a Device Error Code in the low\n byte.\n\n bMediaID On entry, this contains the Media Descriptor byte of the disk\n that DOS thinks is in the drive.\n\n bRetFlag On exit, you must set this to indicate whether a different\n disk is in the drive. If you support Removable Media, and\n return ffH, you must set pfVolID.\n\n pfVolID With DOS 3.0+ drivers that support Removable Media (see\n Device Attribute), you should set this to the address of an\n ASCIIZ▲ string of the volume label of the drive that was\n previously in the drive. Then, when DOS issues critical error\n 0fH (see INT 24H), it can prompt the user to insert the right\n disk.\n\n If you don't know the volume label, put the address of the\n string \"NO NAME\" here.\n\n Notes: ■ Diskette performance is much faster when the device driver can\n quickly indicate a \"no change\", since DOS need not re-read the\n FAT on the disk before each disk access.\n\nSee Also: Device Requests\n DevRequestHdrRec\n Installable Device Drivers\n -♦-"
  },
  {
    "id": "303-device_request_02h__build_bpb.html",
    "t": "Device Request 02H: Build BPB",
    "b": "◄Blk►\n This tells the driver to return the BIOS Parameter Block for the medium\n that's currently in the drive.\n\nDevReq02Rec\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 1 bLen 16H (length of this request packet)\n +1 1 bUnitNo unit number of interest\n +2 1 bCmd 02H (command code)\n +3 2 rStatus OUTPUT: Device Status Word must fill before exit\n +5H 8 res (reserved)\n +0dH 1 bMediaID INPUT: Media Descriptor DOS thinks is there\n +0eH 4 pfFatSect INPUT: far addr of first sector of FAT\n +12H 4 pfBPB OUTPUT: far addr of BPBRec\n 22 size of this structure\n\n rStatus On exit, the driver must place a DevStatusWord here. Always\n set the Done bit (bit 8). On an error, set the Done bit and\n the Error bit (bit 15) and put a Device Error Code in the low\n byte.\n\n bMediaID On entry, this contains the Media Descriptor byte of the disk\n that DOS thinks is in the drive.\n\n pfFatSect When Device Attribute bit 13 is set, this will contain the\n address of a 512-byte FAT sector of the disk that DOS thinks\n is in the drive. You can use it to see if the disk has\n changed.\n\n pfBPB You must set this to a filled-in BPBRec structure that\n describes the current media.\n\n Notes: ■ If the driver supports Removable Media (see Device Attribute),\n you should save a copy of the Volume ID of the disk for use in\n later DvRq 01H requests.\n\n ■ DOS fns 440dH 40H and 440dH 60H (set/query device parameters)\n are passed to your DvRq 13H (generic IOCTL) handler and\n settings there will affect values you return here.\n\nSee Also: Device Requests\n DevRequestHdrRec\n Installable Device Drivers\n -♦-"
  },
  {
    "id": "304-device_request_03h__ioctl_input.html",
    "t": "Device Request 03H: IOCTL Input",
    "b": "◄Blk► ◄Chr► ◄IRW►\n This tells the driver to send some IOCTL data to DOS.\n\nDevReq03Rec\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 1 bLen 14H (length of this request packet)\n +1 1 bUnitNo unit number\n +2 1 bCmd 03H (command code)\n +3 2 rStatus OUTPUT: Device Status Word must fill before exit\n +5H 8 res (reserved)\n +0dH 1 bData (not used)\n +0eH 4 pfBuffer INPUT: buffer address\n +12H 2 wLen INPUT: size of data requested (in bytes)\n OUTPUT: actual size of data being returned\n 20 size of this structure\n\n rStatus On exit, the driver must place a DevStatusWord here. Always\n set the Done bit (bit 8). On an error, set the Done bit and\n the Error bit (bit 15) and put a Device Error Code in the low\n byte.\n\n pfBuffer is the address of a buffer in which the driver may place the\n requested data. You must not store more than wLen bytes here.\n\n wLen On entry, this specifies the size of the data DOS is\n requesting, in bytes.\n\n On exit, you must store the actual size of the data that you\n supplied.\n\n Notes: ■ The layout of the data in pfBuffer is entirely device-specific\n and will vary from device to device.\n\n ■ There is no way to specify just what type of data is requested.\n See DvRq 13H (generic IOCTL) for a more flexible system.\n\n ■ This is the device driver \"catch-point\" for DOS fns 4402H and\n 4404H (receive IOCTL data).\n\nSee Also: Device Requests\n DevRequestHdrRec\n Installable Device Drivers\n -♦-"
  },
  {
    "id": "305-device_request_04h__input__read_data_from_device_.html",
    "t": "Device Request 04H: Input (Read Data from Device)",
    "b": "◄Blk► ◄Chr►\n This tells the driver to read data from the device media and transfer it\n to a specified buffer.\n\nDevReq04Rec\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 1 bLen 20H or 14H (length of this request packet)\n +1 1 bUnitNo (not used)\n +2 1 bCmd 04H (command code)\n +3 2 rStatus OUTPUT: Device Status Word must fill before exit\n +5H 8 res (reserved)\n +0dH 1 bMediaID INPUT: Media Descriptor DOS thinks is there\n +0eH 4 pfBuffer INPUT: buffer address\n +12H 2 wReadSize INPUT: number of bytes or sectors to read\n OUTPUT: bytes or sectors actually read\n ────────────────────────────── Block Devices Only\n +16H 2 wStartSect INPUT: starting sector (ffffH=use lBigSect)\n +18H 4 pfVolID OUTPUT: addr of Volume ID for this unit/media\n +1cH 4 lBigSect INPUT: starting sector (when wStartSect=ffffH)\n 32 size of this structure\n\n rStatus On exit, the driver must place a DevStatusWord here. Always\n set the Done bit (bit 8). On an error, set the Done bit and\n the Error bit (bit 15) and put a Device Error Code in the low\n byte.\n\n bMediaID On entry, this contains the Media Descriptor byte of the disk\n that DOS thinks is in the drive.\n\n pfBuffer is the address of a buffer in which the driver may place the\n requested data. You must not store more than wReadSize bytes\n (or sectors of block devices) here.\n\n wReadSize on entry, specifies how much data to transfer into pfBuffer:\n Character devices: requested number of bytes\n Block devices: requested number of sectors\n\n On return, fill this with the actual amount of data you\n transferred (bytes or sectors)\n ─────────────────────────────────────────── Block Devices Only\n wStartSect Starting logical sector number to read (see INT 25H). If the\n sector number is larger than 65,535, this will contain ffffH\n and you should use lBigSect as the 32-bit starting sector\n number. Used by block devices only.\n\n pfVolID Block devices which return Device Error Code of 0fH should set\n this to the address of an ASCIIZ▲ volume ID of the disk that\n should be in the drive (so DOS can prompt to insert that\n disk). Used by block devices only.\n\n lBigSect When DOS requests a logical sector number larger than 65,535,\n it sets wStartSect to ffffH and puts the actual desired\n starting sector number in here. Used by block devices only.\n\n Notes: ■ It is up to the driver to translate the \"logical sector number\"\n to head/track/sector values actually used on the device and to\n access sequential sectors using that numbering scheme. See\n INT 25H for the standard way to do this.\n\n ■ This is the device driver \"catch-point\" for DOS read fns such\n as 3fH (read from device or file).\n\nSee Also: Device Requests\n DevRequestHdrRec\n Installable Device Drivers\n -♦-"
  },
  {
    "id": "306-device_request_05h__non_destructive_input.html",
    "t": "Device Request 05H: Non-destructive Input",
    "b": "◄Chr►\n This tells the driver to return the next character from its input buffer\n without removing that character from the buffer. The next read request\n (DvRq 04H) should return the same character.\n\nDevReq05Rec\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 1 bLen 0eH (length of this request packet)\n +1 1 bUnitNo (not used)\n +2 1 bCmd 05H (command code)\n +3 2 rStatus OUTPUT: Device Status Word must fill before exit\n +5H 8 res (reserved)\n +0dH 1 bChar OUTPUT: the character from the device\n 14 size of this structure\n\n rStatus On exit, the driver must place a DevStatusWord here. Always\n set the Done bit (bit 8).\n\n If no characters are ready, set the Busy bit (bit 9).\n\n bChar on return, put the next character of the input buffer here.\n Do not remove the character from the buffer.\n\nSee Also: Device Requests\n DevRequestHdrRec\n Installable Device Drivers\n -♦-"
  },
  {
    "id": "307-device_request_06h__input_status.html",
    "t": "Device Request 06H: Input Status",
    "b": "◄Chr►\n This tells the driver to return its input status; in particular, to\n indicate whether there are characters in the device input buffer ready for\n immediate retrieval.\n\nDevReq06Rec\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 1 bLen 0dH (length of this request packet)\n +1 1 bUnitNo (not used)\n +2 1 bCmd 06H (command code)\n +3 2 rStatus OUTPUT: Device Status Word must fill before exit\n +5H 8 res (reserved)\n 13 size of this structure\n\n rStatus On exit, the driver must place a DevStatusWord here. Always\n set the Done bit (bit 8).\n\n If no characters are ready, set the Busy bit (bit 9).\n Otherwise, clear bit 9 to indicate that a call to DvRq 04H\n will be satisfied without waiting.\n\n Notes: ■ This is the device driver \"catch-point\" for DOS fn 0bH (get\n input status).\n\n It is also called by DOS to avoid waiting in an input loop.\n\nSee Also: Device Requests\n DevRequestHdrRec\n Installable Device Drivers\n -♦-"
  },
  {
    "id": "308-device_request_07h__input_flush.html",
    "t": "Device Request 07H: Input Flush",
    "b": "◄Chr►\n This tells the driver to terminate any read operation in progress and to\n empty the device input buffer.\n\nDevReq07Rec\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 1 bLen ??H (length of this request packet)\n +1 1 bUnitNo (not used)\n +2 1 bCmd 07H (command code)\n +3 2 rStatus OUTPUT: Device Status Word must fill before exit\n +5H 8 res (reserved)\n 13 size of this structure\n\n rStatus On exit, the driver must place a DevStatusWord here. Always\n set the Done bit (bit 8). On an error, set the Done bit and\n the Error bit (bit 15) and put a Device Error Code in the low\n byte.\n\n Notes: ■ This is the device driver \"catch-point\" for DOS fn 0cH (clear\n and input).\n\nSee Also: Device Requests\n DevRequestHdrRec\n Installable Device Drivers\n -♦-"
  },
  {
    "id": "309-device_request_08h__output__write_data_to_device_.html",
    "t": "Device Request 08H: Output (Write Data to Device)",
    "b": "◄Blk► ◄Chr►\n This tells the driver to write data to the device.\n\nDevReq08Rec\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 1 bLen 20H or 14H (length of this request packet)\n +1 1 bUnitNo (not used)\n +2 1 bCmd 08H (command code)\n +3 2 rStatus OUTPUT: Device Status Word must fill before exit\n +5H 8 res (reserved)\n +0dH 1 bMediaID INPUT: Media Descriptor DOS thinks is there\n +0eH 4 pfBuffer INPUT: buffer address\n +12H 2 wWriteSize INPUT: number of bytes or sectors to write\n OUTPUT: bytes or sectors actually written\n ────────────────────────────── Block Devices Only\n +16H 2 wStartSect INPUT: starting sector (ffffH=use lBigSect)\n +18H 4 pfVolID OUTPUT: addr of Volume ID for this unit/media\n +1cH 4 lBigSect INPUT: starting sector (when wStartSect=ffffH)\n 32 size of this structure\n\n rStatus On exit, the driver must place a DevStatusWord here. Always\n set the Done bit (bit 8). On an error, set the Done bit and\n the Error bit (bit 15) and put a Device Error Code in the low\n byte.\n\n bMediaID On entry, this contains the Media Descriptor byte of the disk\n that DOS thinks is in the drive. Used by block devices only.\n\n pfBuffer is the address of a buffer in which the driver may place the\n requested data. You must not store more than wReadSize bytes\n (or sectors of block devices) here.\n\n wWriteSize on entry, specifies how much data to transfer from pfBuffer to\n the device:\n Character devices: requested number of bytes to write\n Block devices: requested number of sectors to write\n\n On return, fill this with the actual amount of data you\n transferred (bytes or sectors)\n ─────────────────────────────────────────── Block Devices Only\n wStartSect Logical sector number to start writing (see INT 26H). If the\n sector number is larger than 65,535, this will contain ffffH\n and you should use lBigSect as the 32-bit starting sector\n number. Used by block devices only.\n\n pfVolID Block devices which return Device Error Code of 0fH should set\n this to the address of an ASCIIZ▲ volume ID of the disk that\n should be in the drive (so DOS can prompt to insert that\n disk). Used by block devices only.\n\n lBigSect When DOS requests a logical sector number larger than 65,535,\n it sets wStartSect to ffffH and puts the actual desired\n starting sector number in here. Used by block devices only.\n\n Notes: ■ It is up to the driver to translate the \"logical sector number\"\n to head/track/sector values actually used on the device and to\n access sequential sectors using that numbering scheme. See\n INT 26H for the standard way to do this.\n\n ■ Driver request DvRq 09H is identical in every way, except that\n the driver is expected to verify the accuracy of the data\n written.\n\n ■ This is the device driver \"catch-point\" for DOS write fns such\n as 40H (write to file or device).\n\nSee Also: Device Requests\n DevRequestHdrRec\n Installable Device Drivers\n -♦-"
  },
  {
    "id": "310-device_request_09h__output__write_verify_data_to_device_.html",
    "t": "Device Request 09H: Output (Write/Verify Data to Device)",
    "b": "◄Blk► ◄Chr►\n This tells the driver to write data to the device and, if possible, to\n verify that the data was written accurately.\n\n The parameters for this request are identical to:\n\n Device Request 08H: Output (Write Data to Device)\n\n Notes: ■ This is the device driver \"catch-point\" for DOS write fns such\n as 40H (write to file or device) when DOS is in VERIFY mode\n (see fns 2eH and 54H).\n\nSee Also: Device Requests\n DevRequestHdrRec\n Installable Device Drivers\n -♦-"
  },
  {
    "id": "311-device_request_0ah__output_status.html",
    "t": "Device Request 0aH: Output Status",
    "b": "◄Chr►\n This tells the driver to return its output status; in particular, to\n indicate whether an output request can be satisfied without waiting.\n\nDevReq0aRec\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 1 bLen 0dH (length of this request packet)\n +1 1 bUnitNo (not used)\n +2 1 bCmd 0aH (command code)\n +3 2 rStatus OUTPUT: Device Status Word must fill before exit\n +5H 8 res (reserved)\n 13 size of this structure\n\n rStatus On exit, the driver must place a DevStatusWord here. Always\n set the Done bit (bit 8).\n\n If the driver is unable to accept any additional characters,\n set the Busy bit (bit 9). Otherwise, clear bit 9 to indicate\n that a call to DvRq 08H will be satisfied without waiting.\n\n Notes: ■ Output devices can be optimized by processing DvRq 10H (output\n until busy).\n\nSee Also: Device Requests\n DevRequestHdrRec\n Installable Device Drivers\n -♦-"
  },
  {
    "id": "312-device_request_0bh__output_flush.html",
    "t": "Device Request 0bH: Output Flush",
    "b": "◄Chr►\n This tells the driver to terminate any write operation in progress and to\n empty the device output buffer.\n\nDevReq0bRec\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 1 bLen 0dH (length of this request packet)\n +1 1 bUnitNo (not used)\n +2 1 bCmd 0bH (command code)\n +3 2 rStatus OUTPUT: Device Status Word must fill before exit\n +5H 8 res (reserved)\n 13 size of this structure\n\n rStatus On exit, the driver must place a DevStatusWord here. Always\n set the Done bit (bit 8). On an error, set the Done bit and\n the Error bit (bit 15) and put a Device Error Code in the low\n byte.\n\n Notes: ■ This is the device driver \"catch-point\" when a device file such\n as PRN is closed via fn 3eH (close file).\n\nSee Also: Device Requests\n DevRequestHdrRec\n Installable Device Drivers\n -♦-"
  },
  {
    "id": "313-device_request_0ch__ioctl_output.html",
    "t": "Device Request 0cH: IOCTL Output",
    "b": "◄Blk► ◄Chr► ◄IRW►\n This tells driver to accept and act upon IOCTL commands or data.\n\nDevReq0cRec\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 1 bLen 14H (length of this request packet)\n +1 1 bUnitNo (not used)\n +2 1 bCmd 0cH (command code)\n +3 2 rStatus OUTPUT: Device Status Word must fill before exit\n +5H 8 res (reserved)\n +0dH 1 bRes2 (not used)\n +0eH 4 pfBuffer INPUT: buffer address\n +12H 2 wSize INPUT: size of IOCTL data\n OUTPUT: number of bytes actually processed\n 20 size of this structure\n\n rStatus On exit, the driver must place a DevStatusWord here. Always\n set the Done bit (bit 8). On an error, set the Done bit and\n the Error bit (bit 15) and put a Device Error Code in the low\n byte.\n\n pfBuffer on entry, this is the address of the IOCTL data. It is the\n address passed in DS:DX from DOS fn 4403H or 4405H.\n\n wSize on entry, this is the size of the IOCTL data being passed from\n DOS. It is the value passed in CX from DOS fn 4403H or 4405H.\n\n On return, if you were unable to process all of the data, you\n should indicate an error and set this to amount of data that\n was actually processed.\n\n Notes: ■ This is the device driver \"catch point\" for:\n DOS Fn 4403H (IOCTL send control data to character device) and\n DOS Fn 4405H (IOCTL send control data to block device)\n\n ■ The layout of the data at pfBuffer is device-specific.\n\n ■ Only drivers capable of IOCTL-processing need support this\n request (see Device Attribute).\n\nSee Also: Device Requests\n DevRequestHdrRec\n Installable Device Drivers\n -♦-"
  },
  {
    "id": "314-device_request_0dh__device_open.html",
    "t": "Device Request 0dH: Device Open",
    "b": "◄Blk► ◄Chr► ◄OCR►\n This tells the driver that a block-device file or character device is\n being opened or created.\n\nDevReq0dRec\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 1 bLen 0dH (length of this request packet)\n +1 1 bUnitNo (not used)\n +2 1 bCmd 00H (command code)\n +3 2 rStatus OUTPUT: Device Status Word must fill before exit\n +5H 8 res (reserved)\n 13 size of this record\n\n rStatus On exit, the driver must place a DevStatusWord here. Always\n set the Done bit (bit 8). On an error, set the Done bit and\n the Error bit (bit 15) and put a Device Error Code in the low\n byte.\n\n Notes: ■ Only drivers capable of device Open/Close-processing need\n support this request (see Device Attribute bit 11).\n\n ■ DOS uses this request whenever an application opens or creates\n a file or opens a device (fn 3dH) and DOS issues DvRq 0eH\n (Device Close) when the device or file gets closed (fn 3eH).\n\n Drivers supporting this request can uses these fns to help with\n maintenance of internal buffers, etc.\n\n Character devices (such as PRN drivers) can watch for Open\n requests and send control data to the device (such as font\n downloads) when it is opened after being closed. In that\n scenario, the driver should also accept DvRq 03H and DvRq 0cH\n (IOCTL fns) in order to provide a means to receive download\n data from applications.\n\nSee Also: Device Requests\n DevRequestHdrRec\n Installable Device Drivers\n -♦-"
  },
  {
    "id": "315-device_request_0eh__device_close.html",
    "t": "Device Request 0eH: Device Close",
    "b": "◄Blk► ◄Chr► ◄OCR►\n This tells the driver that a block-device file or character device is\n being closed.\n\nDevReq0eRec\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 1 bLen 0dH (length of this request packet)\n +1 1 bUnitNo (not used)\n +2 1 bCmd 0eH (command code)\n +3 2 rStatus OUTPUT: Device Status Word must fill before exit\n +5H 8 res (reserved)\n 13 size of this record\n\n rStatus On exit, the driver must place a DevStatusWord here. Always\n set the Done bit (bit 8). On an error, set the Done bit and\n the Error bit (bit 15) and put a Device Error Code in the low\n byte.\n\n Notes: ■ Only drivers capable of device Open/Close-processing need\n support this request (see Device Attribute bit 11).\n\n ■ DOS uses this request whenever an application closes a file or\n device (fn 3eH). Drivers can use this in conjunction with\n DvRq 0dH (Device Open) to help manage internal buffers.\n\nSee Also: Device Requests\n DevRequestHdrRec\n Installable Device Drivers\n -♦-"
  },
  {
    "id": "316-device_request_0fh__removable_media.html",
    "t": "Device Request 0fH: Removable Media",
    "b": "◄Blk► ◄Chr► ◄OCR►\n This asks the driver whether the device contains removable media.\n\nDevReq0fRec\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 1 bLen 0dH (length of this request packet)\n +1 1 bUnitNo (not used)\n +2 1 bCmd 0fH (command code)\n +3 2 rStatus OUTPUT: Device Status Word must fill before exit\n +5H 8 res (reserved)\n 13 size of this record\n\n rStatus On exit, the driver must place a DevStatusWord here. Always\n set the Done bit (bit 8).\n\n If the disk in the drive is removable, clear the busy bit\n (bit 9). If the disk is non-removable, set bit 9.\n\n Notes: ■ Only drivers capable of device Open/Close-processing need\n support this request (see Device Attribute bit 11).\n\n ■ This is the driver \"catch point\" for DOS fn 4408H (IOCTL does\n drive use removable media?).\n\nSee Also: Device Requests\n DevRequestHdrRec\n Installable Device Drivers\n -♦-"
  },
  {
    "id": "317-device_request_10h__output_until_busy.html",
    "t": "Device Request 10H: Output Until Busy",
    "b": "◄Chr► ◄OTB►\n This tells the driver to write data to the device until the device signals\n that it cannot accept any more data.\n\nDevReq10Rec\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 1 bLen 14H (length of this request packet)\n +1 1 bUnitNo (not used)\n +2 1 bCmd 10H (command code)\n +3 2 rStatus OUTPUT: Device Status Word must fill before exit\n +5H 8 res (reserved)\n +0dH 1 bData (not used)\n +0eH 4 pfBuffer INPUT: buffer address\n +12H 2 wWriteSize INPUT: number of bytes to write\n OUTPUT: bytes actually written\n 20 size of this structure\n\n rStatus On exit, the driver must place a DevStatusWord here. Always\n set the Done bit (bit 8). On an error, set the Done bit and\n the Error bit (bit 15) and put a Device Error Code in the low\n byte.\n\n It is NOT an error to write fewer than the requested number of\n bytes. Just set the Done bit, update wWriteSize, and exit.\n\n pfBuffer is the address of a buffer containing data to write to the\n device.\n\n wWriteSize on entry, specifies how much data to transfer from pfBuffer to\n the device.\n\n On return, fill this with the actual amount of data you\n transferred, in bytes.\n\n Notes: ■ Only character device drivers capable of Output-Until-Busy need\n support this request (see Device Attribute bit 13).\n\n ■ The driver must transfer as much data as possible, update the\n wWriteSize field, set bit 8, and return immediately.\n\n ■ This fn makes it possible for DOS to optimize its device output\n activities and to take advantage of hardware features such as a\n printer's internal input buffer.\n\n For instance, DOS can pass a large buffer of data, and the\n driver can fill the printer's buffer and return. Then DOS can\n periodically check the output status (DvRq 0aH) and call this\n fn again (passing only the unprocessed data) when the device is\n not busy. This avoids tying up the system inside a driver's\n wait loop.\n\nSee Also: Device Requests\n DevRequestHdrRec\n Installable Device Drivers\n -♦-"
  },
  {
    "id": "318-device_request_13h__generic_ioctl_request.html",
    "t": "Device Request 13H: Generic IOCTL Request",
    "b": "◄Blk► ◄Chr► ◄Gen►\n This tells the driver to process an \"generic IOCTL\" request. These have a\n variety of uses, ranging from setting up code page fonts to formatting a\n hard disk.\n\nDevReq13Rec\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 1 bLen 17H (length of this request packet)\n +1 1 bUnitNo unit number (block drivers only)\n +2 1 bCmd 13H (command code)\n +3 2 rStatus OUTPUT: Device Status Word must fill before exit\n +5H 8 res (reserved)\n +0dH 1 bCategory INPUT: device category\n +0eH 1 bMinorCode INPUT: minor code\n +0fH 4 lRes (reserved)\n +13H 4 pfIoctlData addr of IOCTL data structure to process\n 23 size of this structure\n\n rStatus On exit, the driver must place a DevStatusWord here. Always\n set the Done bit (bit 8). On an error, set the Done bit and\n the Error bit (bit 15) and put a Device Error Code in the low\n byte.\n\n bCategory is the device category as passed in CH from DOS 440cH or 440dH\n (Generic IOCTL fns):\n 00H=unknown\n 01H=COMn (DOS 3.3+)\n 03H=console (screen + keyboard) (DOS 3.3+)\n 05H=parallel printer (DOS 3.2+)\n\n bMinorCode is a subfn code, as passed in CL from DOS 440cH (Generic IOCTL\n for Character Devices):\n 45H (set iteration count) 3.3+\n 4aH (select a prepared code page) 3.3+\n 4cH (begin preparing a code page) 3.3+\n 4dH (done preparing a code page) 3.3+\n 5fH (set display information) 4.0+\n 65H (query retry iteration count) 3.3+\n 6aH (query active code page) 3.3+\n 6bH (get list of prepared code pages) 3.3+\n 7fH (query display information) 4.0+\n\n or a subfn code, as passed in CL from DOS 440dH (Generic IOCTL\n for Block Devices):\n 40H (set device parameters) 3.2+\n 41H (write track) 3.2+\n 42H (format and verify track) 3.2+\n 46H (set media ID) 4.0+\n 47H (set disk access flag) 4.0 only\n 60H (get device parameters) 3.2+\n 61H (read track) 3.2+\n 62H (verify track) 3.2+\n 66H (query media ID) 4.0+\n 67H (query disk access flag) 4.0 only\n 68H (sense media type) 5.0+\n\n pfIoctlData is the address of structure containing the data you'll need to\n process the request. See:\n\n Generic IOCTL Data Packets\n\n Notes: ■ Only device drivers capable of handling generic IOCTL requests\n need support this request (see Device Attribute bit 6).\n\n ■ The driver must interpret the bCategory and bMinorCode fields\n in order to understand the request and the layout of the data\n (if any) at pfIoctlData.\n\n ■ Drivers may support a subset of the generic IOCTL services.\n See DvRq 19H and DOS fn 4410H and 4411H (query IOCTL support).\n\nSee Also: Device Requests\n DevRequestHdrRec\n Installable Device Drivers\n -♦-"
  },
  {
    "id": "319-device_request_17h__get_logical_device.html",
    "t": "Device Request 17H: Get Logical Device",
    "b": "◄Blk► ◄Gen►\n This asks the driver to identify which logical drive ID is currently is\n use for a physical drive unit. This is in support for DOS's \"phantom\n floppy\" feature.\n\nDevReq17Rec\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 1 bLen 0dH (length of this request packet)\n +1 1 bUnitNo INPUT: unit number of drive to check\n OUTPUT: active drive number (1=A, 2=B, etc)\n +2 1 bCmd 17H (command code)\n +3 2 rStatus OUTPUT: Device Status Word must fill before exit\n +5H 8 res (reserved)\n 13 size of this structure\n\n bUnitNo On entry, this is a drive unit number (or instance, 0 is the\n first drive supported by the drive, 1 is the second, etc).\n\n On return, the field must contain the drive ID number (1=A,\n 2=B, etc.) of the logical drive that is currently active on\n this unit.\n\n Use the ID passed in the most recent DvRq 18H request OR\n return 00H if you don't support logical (phantom) drives.\n\n rStatus On exit, the driver must place a DevStatusWord here. Always\n set the Done bit (bit 8). On an error, set the Done bit and\n the Error bit (bit 15) and put a Device Error Code in the low\n byte.\n\n Notes: ■ Only device drivers capable of handling Get/Set Logical drive\n requests need support this (see Device Attribute bit 6).\n\n ■ This is the device driver \"catch point\" for DOS fn 440eH (IOCTL\n query logical drive).\n\n ■ The \"phantom floppy\" concept lets DOS pretend (for instance)\n that a one-diskette-drive system actually has a drive A and a\n drive B. For instance, if the user types: Dir B:, then DOS\n prompts the user to \"Insert diskette for drive B:\" and sends\n DvRq 18H (set logical device) to the driver.\n\nSee Also: Device Requests\n DevRequestHdrRec\n Installable Device Drivers\n -♦-"
  },
  {
    "id": "320-device_request_18h__set_logical_device.html",
    "t": "Device Request 18H: Set Logical Device",
    "b": "◄Blk► ◄Gen►\n Tells the block-device driver that a particular unit number will be\n referred to by a particular drive ID number. This is in support for DOS's\n \"phantom floppy\" feature.\n\nDevReq18Rec\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 1 bLen 0dH (length of this request packet)\n +1 1 bUnitNo unit number\n +2 1 bCmd 17H (command code)\n +3 2 rStatus OUTPUT: Device Status Word must fill before exit\n +5H 8 res (reserved)\n 13 size of this structure\n\n bUnitNo On entry, this identifies how DOS will refer to this unit at\n the user-interface level.\n\n It is zero-based, relative to the number of logical drives\n supported by the driver. For instance, if the driver supports\n two diskette drives (A and B) but only one physical diskette\n drive is present, then a call with bUnitNo=1 means that the\n physical drive will be referred to as drive B.\n\n rStatus On exit, the driver must place a DevStatusWord here. Always\n set the Done bit (bit 8). On an error, set the Done bit and\n the Error bit (bit 15) and put a Device Error Code in the low\n byte.\n\n Notes: ■ Only device drivers capable of handling Get/Set Logical drive\n requests need support this (see Device Attribute bit 6).\n\n ■ The \"phantom floppy\" concept lets DOS pretend (for instance)\n that a one-diskette-drive system actually has a drive A and a\n drive B. For instance, if the user types: Dir B:, then DOS\n prompts the user to \"Insert diskette for drive B:\" and sends\n DvRq 18H (set logical device) to the driver.\n\n ■ This is the device driver \"catch point\" for DOS fn 440fH (IOCTL\n set logical drive).\n\nSee Also: Device Requests\n DevRequestHdrRec\n Installable Device Drivers\n -♦-"
  },
  {
    "id": "321-device_request_19h__ioctl_support_query.html",
    "t": "Device Request 19H: IOCTL Support Query",
    "b": "◄Blk► ◄Chr► ◄Gen► ◄Qry►\n This asks the driver to identify whether it supports a particular generic\n IOCTL function. Generic IOCTL fns have a variety of uses, ranging from\n setting up code page fonts to formatting a hard disk.\n\nDevReq19Rec\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 1 bLen ??H (length of this request packet)\n +1 1 bUnitNo unit number (block devices only)\n +2 1 bCmd 19H (command code)\n +3 2 rStatus OUTPUT: Device Status Word must fill before exit\n +5H 8 res (reserved)\n +0dH 1 bCategory INPUT: device category\n +0eH 1 bMinorCode INPUT: minor code\n +0fH 4 lRes (reserved)\n +13H 4 pfIoctlData (not used; do not modify)\n 23 size of this structure\n\n rStatus On exit, the driver must place a DevStatusWord here. Always\n set the Done bit (bit 8).\n\n If you don't support the specified category/MinorCode, set the\n Error bit (bit 15) and put Device Error Code 03H (unknown\n function) in the low byte.\n\n bCategory is the device category as passed in CH from DOS 440cH or 440dH\n (Generic IOCTL fns):\n 00H=unknown\n 01H=COMn (DOS 3.3+)\n 03H=console (screen + keyboard) (DOS 3.3+)\n 05H=parallel printer (DOS 3.2+)\n\n bMinorCode is a subfn code, as passed in CL from DOS 440cH (Generic IOCTL\n for Character Devices):\n 45H (set iteration count) 3.3+\n 4aH (select a prepared code page) 3.3+\n 4cH (begin preparing a code page) 3.3+\n 4dH (done preparing a code page) 3.3+\n 5fH (set display information) 4.0+\n 65H (query retry iteration count) 3.3+\n 6aH (query active code page) 3.3+\n 6bH (get list of prepared code pages) 3.3+\n 7fH (query display information) 4.0+\n\n or a subfn code, as passed in CL from DOS 440dH (Generic IOCTL\n for Block Devices):\n 40H (set device parameters) 3.2+\n 41H (write track) 3.2+\n 42H (format and verify track) 3.2+\n 46H (set media ID) 4.0+\n 47H (set disk access flag) 4.0 only\n 60H (get device parameters) 3.2+\n 61H (read track) 3.2+\n 62H (verify track) 3.2+\n 66H (query media ID) 4.0+\n 67H (query disk access flag) 4.0 only\n 68H (sense media type) 5.0+\n\n Notes: ■ Only device drivers capable of handling generic IOCTL requests\n need support this request (see Device Attribute bit 6).\n\n ■ The driver must interpret the bCategory and bMinorCode fields\n and if the specified combination is not supported, set rStatus\n to indicate an \"unknown fn\" Device Driver Error.\n\nSee Also: Device Requests\n DevRequestHdrRec\n Installable Device Drivers\n -♦-"
  },
  {
    "id": "322-device_header_layout.html",
    "t": "Device Header Layout",
    "b": "The binary image file of a device driver begins with this structure and\n this data remains in memory after installation of the driver.\n\nDevHdrRec\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 4 pfNextDev FAR address of next device in chain.\n (offset=ffffH if this the last/only driver)\n +4 2 rDevAttr bit fields that make up the Device Attribute\n +6 2 pnStrategy offset address of device STRATEGY routine\n +8 2 pnInterrupt offset address of device INTERRUPT routine\n +0aH 8 abDevName blank-padded device (or 10-byte block device\n sub-unit number)\n 18 size of this structure\n ───────────────────── Extra fields for CD ROM\n +12H 2 wRes (reserved)\n +14H 1 wDrvLtr CD-ROM drive letter; often 53H ('S')\n +15H 1 wUnits number of CD-ROM units\n +16H 6 abCdrSig signature \"MSCDnn\")\n 28 size of CD-ROM version of device header\n\n pfNextDev In the device driver file, this should start out as ffff:ffff.\n During installation it is updated to fit in with device chain.\n The last driver in the chain will contain ffffH in the first\n two bytes of this field.\n\n DOS actually inserts drivers into the chain just after the NUL\n device (which cannot be replaced). The address of the start\n of the device driver chain may be found via the undocumented\n DOS fn 52H (get List of Lists).\n\n rDevAttr But flags describing the device. See Device Attribute.\n\n pnStrategy Near address (in same segment as this structure) of the code\n to process Device STRATEGY calls. See Device Driver Basics.\n\n pnInterrupt Near address of the code to process Device INTERRUPT calls.\n\n abDevName Character devices: blank-padded name of the device, for\n instance, \"LPT1 \".\n Block Devices: First byte is the number of block devices\n supported by this driver; other bytes are reserved.\n\n Notes: Fields starting at offset 12H are present only in CD-ROM device\n drivers.\n\nSee Also: Device Drivers\n Device Attribute\n Device Requests\n fn 52H (get DOS vars address)\n fn 32H (get DPB; obtain addr of a DeviceHdrRec)\n -♦-"
  },
  {
    "id": "323-device_attribute.html",
    "t": "Device Attribute",
    "b": "The rDevAttr field of the DevHdrRec indicates properties of a device. DOS\n fn 32H returns a structure that contains a pointer to the DevHdrRec for a\n specified block device driver. And fn 52H obtain info that can let you\n get attributes of character devices.\n\n Bit-meanings vary depending on the driver type, so two layouts are given:\n\nDevAttrChar ─── layout for character devices\n 1 1 1 1 1 1\n╓5┬4┬3┬2┬1┬0┬9┬8╥7┬6┬5┬4┬3┬2┬1┬0╖\n║1│ │ │0│ │0 0 0║q│g│0│s│c│n│o│i║\n╙╥┴╥┴╥┴─┴╥┴─┴─┴─╨╥┴╥┴─┴╥┴╥┴╥┴╥┴╥╜ bit mask\n ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ╚═► 0: 0001H standard input device\n ║ ║ ║ ║ ║ ║ ║ ║ ║ ╚═══► 1: 0002H standard output device\n ║ ║ ║ ║ ║ ║ ║ ║ ╚═════► 2: 0004H standard NUL device\n ║ ║ ║ ║ ║ ║ ║ ╚═══════► 3: 0008H clock device\n ║ ║ ║ ║ ║ ║ ╚═════════► 4: 0010H special; fast output INT 29H\n ║ ║ ║ ║ ║ ╚═════════════► 6: 0040H supports Generic IOCTL DvRq 13H\n ║ ║ ║ ║ ╚═══════════════► 7: 0080H supports Query IOCTL DvRq 19H\n ║ ║ ║ ╚═══════════════════════►11: 0800H supports device open, DvRq 0dH\n ║ ║ ║ and device close DvRq 0eH\n ║ ║ ╚═══════════════════════════►13: 2000H sprts output till busy DvRq 10H\n ║ ╚═════════════════════════════►14: 4000H supports IOCTL Read DvRq 03H\n ║ and IOCTL Write DvRq 0cH\n ╚═══════════════════════════════►15: 8000H 1=character device\n\nDevAttrBlock ─── layout for block devices\n 1 1 1 1 1 1\n╓5┬4┬3┬2┬1┬0┬9┬8╥7┬6┬5┬4┬3┬2┬1┬0╖\n║0│ │ │0│ │0 0 0║q│g│0 0 0 0│b│0║\n╙╥┴╥┴╥┴─┴╥┴─┴─┴─╨╥┴╥┴─┴─┴─┴─┴╥┴─╜ bit mask\n ║ ║ ║ ║ ║ ║ ╚═══► 1: 0002H supports >32M partitions\n ║ ║ ║ ║ ║ ╚═════════════► 6: 0040H supports Generic IOCTL DvRq 13H\n ║ ║ ║ ║ ║ and Get Logical Device DvRq 17H\n ║ ║ ║ ║ ║ and Set Logical Device DvRq 18H\n ║ ║ ║ ║ ╚═══════════════► 7: 0080H supports Query IOCTL DvRq 19H\n ║ ║ ║ ╚═══════════════════════►11: 0800H supports device open DvRq 0dH\n ║ ║ ║ and device close DvRq 0eH\n ║ ║ ║ and Removable Media DvRq 0fH\n ║ ║ ╚═══════════════════════════►13: 2000H 0=Needs FAT with BPB DvRq 02H\n ║ ╚═════════════════════════════►14: 4000H supports IOCTL Read DvRq 03H\n ║ and IOCTL Write DvRq 0cH\n ╚═══════════════════════════════►15: 8000H 0=block device\n\n bit 15 This bit affects Device Input and Output requests and determines\n the meaning of the abDevName field of the DevHdrRec. If this bit\n is 0, the device is a block device (usually a disk drive).\n\n ─────────────────────────────────────────────── Character Devices\n bit 0 and...\n bit 1 Set the standard I/O bits when you replace the CON driver.\n\n bit 2 The standard NUL device cannot be reassigned.\n\n bit 3 The clock device indicates replacement for the CLOCK$ device\n driver. CLOCK$ is a character device which handles device\n requests to input and output exactly 6 bytes. An input request\n (DvRq 04H) should return 6 bytes indicating the current time/date\n and an output request (DvRq 08H) should accept 6 bytes to set the\n clock/calendar. See ClockIORec for the layout.\n\n bit 4 This is set if this is the CON device and it supports the INT 29H\n \"fast-output\" function.\n\n bits 7 11, and 14 indicates support for device utilities which use\n fn 440cH and other fn 44H services.\n\n ─────────────────────────────────────────────────── Block Devices\n bit 1 Indicates support for accessing the large disk partitions (4.0+).\n On DvRq 04H and DvRq 08H, the wSectorNo field in the request\n packet will be set to ffffH and the actual address will be a 32-\n bit value in the lBigSectorNo field. See INT 25H/26H for related\n information.\n\n bit 11 (DOS 3.0+) indicates support for Removable Media-related device\n requests (DvRq 0dH and DvRq 0fH) so a block device driver can\n optimize with local buffering. When set, the driver must also\n take special action on DvRq 02H.\n\n bit 13 (once called the \"non-IBM device\" bit)\n 0: DvRq 02H (Build BPB) will receive a buffer containing the\n first sector of the first FAT. You can determine the media type\n from the first byte of the FAT.\n 1: The buffer given in DvRq 02H is not important.\n\nSee Also: Device Drivers\n Device Attribute\n Device Requests\n Device Driver Basics\n -♦-"
  },
  {
    "id": "324-device_request_header.html",
    "t": "Device Request Header",
    "b": "Each request to a device driver is accompanied by a pointer to a request\n structure or \"packet\". Each packet begins with this 13-byte header. Upon\n entry into a driver, ES:BX always points to a packet in this layout.\n\nDevRequestHdrRec\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 1 bLen length of this request packet (header and data)\n +1 1 bUnitNo unit number (used for block devices only)\n +2 1 bCmd command code (Device Request number)\n +3 2 rStatus Device Status Word must be filled before return\n +5H 8 res (reserved)\n 13 length of common portion of all request packets\n +0dH ? abData variable-length data formatted according to the\n command code. See Device Requests.\n\n rStatus On exit, the driver must place a DevStatusWord here. Always\n set the Done bit (bit 8) -- even if you don't support the\n request or when there's an error.\n\n If you can't process the request because of hardware failure\n or other error, set the Error bit (bit 15) and put\n Device Error Code in the low byte.\n\n abData data beginning here varies depending upon the request.\n\nSee Also: Device Drivers\n Device Requests\n -♦-"
  },
  {
    "id": "325-device_status_word.html",
    "t": "Device Status Word",
    "b": "A driver must fill the rStatus field of the DevRequestHdrRec (offset 3)\n before returning control to DOS. This is a 16-bit field, containing an\n 8-bit error code in the low byte and other information in the high byte.\n It has the following layout:\n\nDevStatusWord\n 1 1 1 1 1 1\n╓5┬4┬3┬2┬1┬0┬9┬8╥7┬6┬5┬4┬3┬2┬1┬0╖\n║e│0 0 0 0 0│b│d║ error_code ║\n╙╥┴─┴─┴─┴─┴─┴╥┴╥╨─┴─┴─┴─┴─┴─┴─┴─╜ bit mask\n ║ ║ ║ ╚═════════════╩═► 0-7: 00ffH Device Driver Error code\n ║ ║ ╚═════════════════► 8: 0100H Done (always set on exit)\n ║ ╚═══════════════════► 9: 0200H Busy (on 06H,0AH,0fH only)\n ║ 10-14: reserved (must be 0)\n ╚═══════════════════════════════► 15: 8000H error occurred\n\n bit 1-7 specify an 8-bit Device Driver Error code, but only if bit 15 is\n set. If bit 15 is 0, then these bits are ignored.\n\n bit 8 should always be set to 1 upon exit from the driver.\n\n bit 9 The \"busy\" bit is set by device a request handler when it\n determines that it can't satisfy a request because the physical\n device is in use by a previous request.\n\n It is also used to return miscellaneous information, such as\n \"keyboard queue in not empty\" (DvRq 06H) or \"no writes pending\"\n (DvRq 0aH) or \"media is removable\" (DvRq 0fH).\n\n bit 15 indicates an error occurred processing the request. When set,\n the bits 1-7 must contain an 8-bit Device Driver Error code.\n\n Upon normal, successful completion of a request, the driver must set the\n \"done\" bit (bit 8), clear the busy bit (bit 9) and exit via a FAR RETurn.\n\nSee Also: Device Driver Errors\n Device Drivers\n Device Requests\n -♦-"
  },
  {
    "id": "326-device_driver_errors.html",
    "t": "Device Driver Errors",
    "b": "When a device driver receives an invalid request or encounters an error\n during operation, the Device Status Word error bit (bit 15) should be set\n and one of the following error codes should be placed in the low 8 bits\n of the rStatus field of the DevRequestHdrRec.\n\n Err Description █ Err Description\n ▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀ █ ▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n 00H write protect violation █ 09H printer out of paper\n 01H unknown unit █ 0aH write fault\n 02H device not ready █ 0bH read fault\n 03H unknown command █ 0cH general failure\n 04H CRC error █ 0dH (reserved)\n 05H bad request structure length █ 0eH (reserved)\n 06H seek error █ 0fH invalid disk change (DOS 3.0+)\n 07H unknown media █\n 08H sector not found █\n\n Note: These codes are propagate around the system and show up in\n INT 24H (Critical Error Handler), and as DOS Error Codes returned\n by various DOS functions and fn 59H.\n\n When returned by DOS to an application, 13H has been added to the\n code (for instance, if the driver returns 06H, DOS returns 19H to\n the application.\n\nSee Also: Device Drivers\n Device Requests\n Device Request Header\n Device Status Word\n -♦-"
  },
  {
    "id": "327-_chr_.html",
    "t": "◄Chr►",
    "b": "This request is passed to\n\n Character Device Drivers\n\ndrivers such as printers, console, COM, etc.\n\n Bit 15 is set\n\nin the Device Attribute of the Device Header\nof these drivers."
  },
  {
    "id": "328-_blk_.html",
    "t": "◄Blk►",
    "b": "This request is passed to\n\n Block Device Drivers\n\nsuch as disk, tape, and RAM drives.\n\n Bit 15 is clear\n\nin the Device Attribute of the\nDevice Header on these drivers."
  },
  {
    "id": "329-_irw_.html",
    "t": "◄IRW►",
    "b": "This request is passed to\n drivers supporting\n\n IOCTL Read/Write.\n\n Bit 14 is set\n\nin the Device Attribute of the\nDevice Header of these drivers."
  },
  {
    "id": "330-_ocr_.html",
    "t": "◄OCR►",
    "b": "This request is passed to\n drivers supporting\n\n Open/Close Removable Media.\n\n Bit 11 is set\n\nin the Device Attribute of the\nDevice Header of these drivers."
  },
  {
    "id": "331-_gen_.html",
    "t": "◄Gen►",
    "b": "This request is passed to\n drivers supporting\n\n Generic IOCTL.\n\n Bit 6 is set\n\nin the Device Attribute of the\nDevice Header of these drivers."
  },
  {
    "id": "332-_qry_.html",
    "t": "◄Qry►",
    "b": "This request is passed to\n drivers supporting\n\n IOCTL Support Query.\n\n Bit 7 is set\n\nin the Device Attribute of the\nDevice Header of these drivers."
  },
  {
    "id": "333-_otb_.html",
    "t": "◄OTB►",
    "b": "This request is passed to character\n device drivers supporting\n\n \"Output Until Busy\".\n\n Bit 13 is set\n\nin the Device Attribute of the\nDevice Header of these drivers."
  },
  {
    "id": "334-understanding_tech_help__data_structures.html",
    "t": "Understanding TECH Help! Data Structures",
    "b": "In TECH Help!, data structure layouts are described using easy-to-use\n conventions. Structure and field names in DOS and BIOS data structures\n are arbitrary, so we have used some conventions that make them more\n meaningful. The name of each field is started with a few letters which\n describe the size and type of the data it represents:\n\n b = byte\n w = word (16-bit, unsigned)\n l = long (dword)\n r = multi-byte record (structure or bit field)\n sz = ASCIIZ▲ string\n\n To indicate that a field is a pointer (an address), the field name begins\n with a p. To indicate a far pointer (a 32-bit segment:offset address),\n the field name begins with pf. For instance,:\n\n p = pointer\n pf = far pointer (32-bit, segment:offset address)\n pfr = far pointer to a structure\n pfsz = far pointer to an ASCIIZ string\n\n When an a is used as a leading qualifier, the field is an array, or list\n of identical elements. For instance:\n\n ab = multiple-element array of bytes\n aw = array of 16-bit words\n\n Finally, the field name itself is given, starting with an uppercase\n letter.\n\n█▌Sample Structure▐█\n Here's an example of a multiple-byte data area:\n\nSampleDataRec\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 1 bFieldByte an 8-bit (BYTE) field\n +1 2 wFieldWord a 16-bit (WORD) field\n +3 4 lFieldDword a 32-bit (DWORD) field\n +7 9 abTextField a 9-byte array of bytes\n +10H 4 pfrNext a 32-bit far pointer to a structure\n +14H 12 szTextField a 12-byte field containing an ASCIIZ▲ string\n 32 size of a SampleDataRec structure\n\n The offset and size are the most important; the field names are arbitrary.\n Offsets are given in hex▲, with an H suffixed where relevant.\n Sizes are given in decimal.\n\n As the last line, the total size of the structure is given in bytes.\n\n When deemed important, additional information about each field is\n described in the topic. For instance,\n\n bFieldByte a one byte field\n wFieldWord a two-byte field. As with all 16-bit values, the first byte\n is the low byte and the next is the high byte of the value.\n lFieldDword a 4-byte field, used as a 32-bit (long) value\n abTextField a multi-byte field. Words such as \"blank-padded\" mean that\n any unused part of the field contains spaces.\n pfrNext a 32-bit address of a structure. As with all 32-bit\n addresses, the first two bytes are the offset and the next two\n bytes are the segment.\n szTextField an ASCIIZ string. The string is terminated with a NUL (00H)\n and bytes following that NUL are not used.\n\n█▌Sample Bit Record▐█\n Here's an example of a one-byte record that contains bit-fields:\n\nSampleBitRec\n╓7┬6┬5┬4┬3┬2┬1┬0╖\n║c│0 0│drv│0│d│v║\n╙╥┴─┴─┴─┴─┴─┴╥┴╥╜ bit mask\n ║ ╚╦╝ ║ ╚═► 0: 01H perform verification\n ║ ║ ╚═══► 1: 02H \"dirty\" (has been modified)\n ║ ╚════════►3-4: 18H drive ID: 00=A, 01=B, 10=C, 11=D\n ╚═══════════════► 7: 80H calibration needed\n\n Notes: ■ Where a 0 appears in the diagram, that bit is reserved and has\n no (documented) meaning.\n\n ■ Other bits may contain a letter or short word in this color.\n That is simply a mnemonic to help you see at a glance what the\n bits mean.\n\n ■ The mask value is the digital value of that bit. For instance,\n assuming the above record is in AL, your program could use...\n\n AND AL,80H\n CMP AL,80H\n JE BitWasSet\n\n ...or perhaps...\n\n TEST AL,80H\n JNZ BitWasSet\n\n ...to test the \"calibration needed\" bit (bit 7). To set that\n bit, use...\n\n OR AL,80H\n\nSee Also: (fns that use the structure are listed here)\n Using TECH Help!\n Data Structures\n -♦-"
  },
  {
    "id": "335-absdiskiorec.html",
    "t": "AbsDiskIORec",
    "b": "This structure is used in DOS interrupts INT 25H and INT 26H when reading\n or writing on drives having more than 65535 sectors (usually 32M). This\n is used in DOS 4.0+.\n\nAbsDiskIORec\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 4 lStartSect logical sector number to start read/write\n +4 2 wSectCnt number of sectors to read/write\n +6 4 pBuffer FAR addr of data buffer\n 10 Length of an AbsDiskIORec structure\n\n lStartSect is a logical sector number. For instance, sector 0 is the\n Boot Sector. To convert a cluster▲ number (as obtained from\n the FAT or a Directory Entry) into a logical sector number\n use:\n\n RootDirSectors = wSecSize / (wRootEntries * 32)\n FatSectors = bFatCnt * wFatSects\n DataStart = wResSects + FatSectors + RootDirSectors\n\n where wSecSize et.al are obtained from the BootSectorRec or\n other source. An easier method is to use DOS fn 32H to obtain\n a Drive Parameter Block (DPB) and use the wFirstData field as\n an aid to the conversion.\n\n wSectCnt desired number of sectors to read/write. On INT 25H reads, be\n sure that the buffer at pBuffer is large enough to hold the\n data. Sectors are usually 512 bytes, but you should always\n use DOS fn 32H (or other fn) to check the sector size.\n\n Presumably, you could transfer up to 65535 sectors (usually\n 32M) at one time, but conventional▲ memory constraints will\n typically limit the transfer to about 1024 (400H) sectors at\n once (512K).\n\n pBuffer is the FAR address of the buffer to receive the disk data\n (INT 25H) or containing the data to write (INT 26H).\n\nSee Also: Boot Sector Layout\n Partition Table\n File Allocation Table\n Device Drivers\n -♦-"
  },
  {
    "id": "336-access_mode___open_mode.html",
    "t": "Access Mode / Open Mode",
    "b": "DOS version 3.0 added networking and file-locking capabilities to the DOS\n file system. The additional complications will normally affect only those\n programs which expect to be used in a network environment.\n\n ┌─────────────────────────────────────────┐\n │ DOS 2.x (non-networking) Access Modes │\n ├─────────────────────────────────────────┤\n │ 00H = open for reading │\n │ 01H = open for writing │\n │ 02H = open for both reading and writing │\n └─────────────────────────────────────────┘\n\n DOS 3.0+ is upwardly compatible with previous versions. The Access/Open\n Mode is treated as a set of bit-flags:\n\n OpenModeRec\n ╓7┬6┬5┬4┬3┬2┬1┬0╖\n ║i│share│0│ r/w ║\n ╙╥┴─┴─┴─┴─┴─┴─┴─╜ bits mask\n ║ ╚═╦═╝ ╚═══╩═► 0-2: 03H Network Access Rights required for access\n ║ ║ 000 = read\n ║ ║ 001 = write\n ║ ║ 010 = read and write\n ║ ╚═══════════► 4-6: 70H Sharing Mode:\n ║ 000 = compatibility mode 00H\n ║ 001 = deny read/write(exclusive) 10H\n ║ 010 = deny write 20H\n ║ 011 = deny read 30H\n ║ 100 = deny none 40H\n ╚═══════════════► 7: 80H Inheritance:\n 1 = file is private to this process 80H\n 0 = inherited by spawned processes\n\n Notes: ■ If the file attribute indicates Read-Only, then it overrides\n these flags.\n\n ■ The Network Access Rights and Sharing Mode bits have an effect\n if the DOS SHARE program has been installed or other file\n sharing support is installed.\n\n ■ The DOS 4.0+ Fn 6cH uses this mode byte as the low-byte of an\n Extended Open Mode word. It provides flags that let you avoid\n critical errors and force disk-caching write-through.\n\nSee Also: Handle-Oriented File I/O\n fn 3dH (open file)\n fn 5cH (lock)\n DOS Functions\n -♦-"
  },
  {
    "id": "337-boot_sector_layout.html",
    "t": "Boot Sector Layout",
    "b": "The DOS boot sector of a floppy disk or a hard disk partition is expected\n to be in this format. Prior to DOS 4.0, a smaller structure was used (see\n notes, below).\n\nBootSectorRec\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 3 abJmpCode JMP opcode to start of boot code\n +3 8 abOem e.g., \"MSDOS6.0\" or \"IBM 4.0\"\n +0bH 2 wSectSize bytes per sector (usually 512; 200H)\n +0dH 1 bClustSects sectors per allocation unit (cluster)\n +0eH 2 wResSects boot and reserved sectors\n +10H 1 bFatCnt number of File Allocation Tables. See FAT.\n +11H 2 wRootEntries max number of 32-byte DirEntryRecs in root\n +13H 2 wTotSects total number of sectors in media\n 0000H means >32 MB, so use lBigTotSects\n +15H 1 bMedia media descriptor (same as 1st byte in FAT)\n +16H 2 wFatSects number of sectors in one FAT\n +18H 2 wSectsPerTrk sectors per track\n +1aH 2 wHeads number of read/write heads\n +1cH 4 lHidSects hidden sectors (ignore hiword in pre-DOS 4.0)\n +20H 4 lBigTotSects 32-bit TotSects in volume (partitions > 32M)\n\n +24H 1 bDrvNo 80H=first hard disk (used internally by DOS)\n +25H 1 res1 (reserved)\n +26H 1 bExtBootSig Extended boot record signature (always 29H)\n +27H 4 lSerNo Volume Serial Number (based on when formatted)\n +2bH 11 abVolLabel Volume Label (11-character, blank padded)\n +36H 8 abFileSysID contains 'FAT12 ' or 'FAT16 ')\n 62 length of formatted portion of BootSectorRec\n\n +3eH ? abBootCode code and data that performs disk bootstrap\n+2ffH end of boot sector\n\n See BPBRec for a description of most of these fields. Fields unique to\n the BootSectorRec include:\n\n abJmpCode Since the Boot Sector is used as program code during system\n startup, the first bytes in the sector are a JMP opcode to get\n past the data area. It usually jumps to abBootCode.\n\n abOem This is an 8-character text field that is supposed to contain\n the signature of the version of DOS which formatted the disk\n (or otherwise laid down the boot sector). It is not used by\n DOS.\n\n bDrvNo On the first hard disk in a system, this field contains 80H.\n Otherwise it should be 00H. Used internally by DOS.\n\n bExtBootSig Prior to DOS 4.0, the formatted portion of the Boot Sector\n ended at offset 1eH and that variation is still supported.\n Boot Sectors which contain 29H in this field (offset 26H) are\n expected to contain the entire 3eH-byte record.\n\n lSerNo a 32-bit volume serial number. It is based on the time and\n date when formatted, making the disk unique for the system\n which formatted it. This field is used by block device\n drivers which support Removable Media and Change Line\n functions (see Device Requests and fn 44H).\n\n On disks formatted by DOS versions prior to 4.0, there is no\n lSerNo or abVolLabel fields. On pre-formatted diskettes,\n these fields are often non-unique. In either case, DOS might\n not be able to detect a disk swap.\n\n abVolLabel the 11-character, blank-padded, volume label. DOS lays this\n down when the disk is formatted AND DOS updates it (along with\n the volume label entry in the root directory) when you use the\n Label command.\n\n abFileSysID this 8-character, blank-padded text field identifies the file\n system. It can be 'FAT12 ' (12-bit FAT entries) or\n 'FAT16 ' (16-bit FAT entries). See File Allocation Table.\n\n abBootCode this is the start of the unformatted portion of the boot\n sector. It contains data and code that is executed when the\n disk is booted.\n\nVersions: ■ DOS 2.x: the formatted part of the record ended at offset 18H.\n ■ DOS 3.x: the formatted part of the record ended at offset 1eH.\n ■ DOS 4.0+: bExtBootSig contains 29H and all fields through\n offset 3eH are used.\n\n Notes: ■ Use absolute disk read INT 25H (DX=0) to read this sector OR\n • floppy disks: The boot sector is at BIOS INT 13H head 0,\n track 0, sector 1\n • hard disks: read the Partition Table to determine BIOS Head,\n Track, Sector to seek before using INT 13H.\n\n ■ To convert a cluster number (as read from the wClustNo field of\n a Directory Entry or a FAT chain) into a absolute sector number\n (as used in INT 25H/26H calls), you may use DOS Fn 32H or read\n the Boot Sector and apply the formulae:\n\n wRootSects = (wRootEntries * 32) / wSectSize\n wFirstData = wResSects + (wFatSects * bFatCnt) + wRootSects\n lAbsSector = wFirstData + ((lAnyClusterNo - 2) * bClustects)\n\n Use the calculated value (lAbsSector) in INT 25H or INT 26H\n calls.\n\n ■ Very old hard disks which require an installed device driver\n (non-bootable hard disks) may contain garbage in the boot\n sector. When possible, use DOS fns such as 32H to obtain\n information about the device.\n\nSee Also: Partition Table\n File Allocation Table\n Device Drivers\n -♦-"
  },
  {
    "id": "338-bpb__bios_parameter_block.html",
    "t": "BPB: BIOS Parameter Block",
    "b": "This is a subset of the data found in the Boot Sector Layout used by\n device drivers. The 'Build BPB' device driver command (DvRq 02H) expects\n the driver to fill a buffer in this layout.\n\n Note the DOS 4.0 extensions (Extended BPB) at the end of the block.\n\nBPBRec\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 2 wSectSize bytes per sector (usually 512; 200H)\n +2 1 bClustSects sectors per allocation unit (cluster)\n +3 2 wResSects boot and reserved sectors\n +5 1 bFatCnt number of File Allocation Tables. See FAT.\n +6 2 wRootEntries max number of 32-byte DirEntryRecs in root\n +8 2 wTotSects total number of sectors in media\n 0000H means >32 MB, so use lBigTotSects\n +0aH 1 bMedia media descriptor (same as 1st byte in FAT)\n +0bH 2 wFatSects number of sectors in one FAT\n ───────────────────────── Extended BPB additions\n +0dH 2 wSectsPerTrk sectors per track\n +0fH 2 wHeads number of read/write heads\n +11H 4 lHidSects hidden sectors (ignore hiword in pre-DOS 4.0)\n +15H 4 lBigTotSects 32-bit TotSects in volume (partitions > 32M)\n 25 Length of a BPBRec (was 13 in pre-DOS 4.0)\n\n wResSects The number of \"reserved sectors\", starting with absolute\n sector 0. This counts how many sectors come before the first\n FAT in the partition. It is usually 0001H; that is only the\n boot sector comes before the first FAT sector.\n\n bFatCnt The number of File Allocation Tables. Usually 02H; The second\n FAT is just a copy of the first.\n\nwRootEntries The size of the root directory, given in 32-byte units. The\n root directory has a fixed size, but subdirectory space is\n allocated as needed.\n\n wTotSects Total size of the media, in sectors (wSecSize bytes each).\n DOS 4.0+: This field will be 0000H to indicate a DOS partition\n that is larger than 32 MB. In that case, the total sector\n count is the 32-bit value lBigTotSects.\n\n bMedia Might identify the media. Media Descriptor.\n\n ───────────────────────────────────── Extended BPB (DOS 4.0+)\n These fields may help the driver and/or disk utility programs\n to understand the media better. Also, you may need to know\n this stuff when using BIOS Disk I/O (INT 13H).\n\nwSectsPerTrk Sectors per track (one surface of one platter)\n\n wHeads Disk read/write heads (total surfaces all platters)\n\n lHidSects Sectors before the start of the 1st FAT in the partition.\n\nlBigTotSects Dword total sectors in the partition. When a partition is\n larger than 32 MB, there are more than 65535 sectors--the\n actual count won't fit in wTotSects so it goes here.\n\nSee Also: Boot Sector Layout\n Partition Table\n File Allocation Table\n Device Drivers\n -♦-"
  },
  {
    "id": "339-clock__i_o_structure.html",
    "t": "CLOCK$ I/O Structure",
    "b": "Programs can open the CLOCK$ device (via DOS fn 3dH) and use fn 3fH (read\n file) to read the system time or fn 40H (write to file) to change it.\n\n The format of all reads and writes to this device is a 6-byte (48-bit)\n binary value indicating the number of milliseconds since January 1, 1980.\n 1000 milliseconds = 1 second; highest value is (2^48)-1 or 8915.7 years.\n\nClockIORec\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 2 wLowMs least significant word (bits 0-15)\n +2 2 wMidMs middle word (bits 16-31)\n +4 2 wHighMs most significant word (bits 32-47)\n 6 Size of ClockIORec\n\n Writing to CLOCK$ changes all parts of the structure. It is much more\n sensible to use DOS fns 2bH (set date) and 2dH (set time), which perform\n the same task, but without the headaches.\n\nSee Also: Device Drivers\n Device Attribute\n Device Requests\n -♦-"
  },
  {
    "id": "340-code_page.html",
    "t": "Code Page",
    "b": "A code page is simply a character set. Code page support was added to\n DOS 3.3 to make it possible for DOS to be translated into international\n languages. DOS also makes it possible for a program to be written in a\n \"language-independent\" manner; for instance, there are DOS functions which\n help you to sort a list of text strings that contain international\n characters such as É and Ç.\n\n Code page support provides a \"behind-the-scenes\" way to process non-\n English keystrokes and a way to reprogram EGA and VGA adapters to display\n certain characters that are not defined by standard IBM-compatible\n hardware. It also provides some limited printer font-definition support.\n\n Code pages (character sets) defined and supported in DOS include:\n\n CodePage Language\n ▀▀▀▀▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n 437 US et.al.\n 850 Multilingual (Latin I)\n 852 Slavic (Latin II)\n 860 Portuguese\n 863 Canadian French\n 866 Norwegian and Danish\n\n Here is some information relevant to code pages:\n\n ■ The CONFIG.SYS file contains a COUNTRY= directive which selects a\n default code page and country information file. See also fn 65H.\n\n ■ One or more DEVICE= directives in CONFIG.SYS install 'code page\n aware' device drivers DISPLAY.SYS or PRINTER.SYS.\n\n ■ The '.CPI' files that come with DOS contain 'Code Page Information'\n for a selected device. See Code Page Font Files.\n\n ■ The Nlsfunc command installs code page switching (optionally\n overriding the country information file set in CONFIG.SYS) and must\n be used before any code page activities take place.\n\n ■ The Mode and Chcp commands (3.3+) can prepare and select a code page.\n You can perform the same functions as Mode via fn 440cH (but it is a\n pain). And you can use fn 6602H to activate a prepared code page.\n\n ■ When you 'prepare' a code page via the Mode command, the information\n in the .CPI file is used to redefine a font. For instance, the '$'\n character can be changed into the '£' character. This takes place at\n the device driver level via Fn 44H (IOCTL) commands. For the EGA,\n the appropriate INT 10H BIOS calls are made to redefine the character\n set. For a printer, a character set can be downloaded into it and\n selected as the default.\n\n Code Page Font Files describes the layout of the font-definition files\n used by code page aware device drivers.\n\nSee Also: National Language Support\n fn 44H (IOCTL functions)\n fn 66H (code page switching)\n Code Page Font Files\n -♦-"
  },
  {
    "id": "341-code_page_font_files.html",
    "t": "Code Page Font Files",
    "b": "DOS 3.3+ device drivers which support code page switching (via Fn 44H\n IOCTL commands) read specially-formatted data files in order to prepare a\n device to handle a selected code page font. These .CPI files are in the\n following format:\n\n FontLibHdrRec\n font library name\n offset of FontInfo\n FontInfoHdrRec\n CpEntryHdrRec\n pointer to next CodePageInfo header\n device type (display or printer) and subtype (EGA, LCD, etc.)\n CodePage number. See Code Page\n offset of FontData Header for this code page\n\n FontDataHdrRec FontData Header\n number of fonts defined\n Font 1 data (ScreenFontDataRec or PrinterFontDataRec)\n Font 2 data\n .\n :\n Font n\n\n The following describes the structures used in .CPI files:\n\nFontLibHdrRec\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 8 abSig font library identifier: ffH,'FONT',20H,20H,20H\n +8 8 res 8 bytes reserved; must be 00\n +10H 2 wPtrCnt Count of pointers in hdr (0001 for DOS 3.3-6.0)\n +12H 1 bPtrType Type of info pointer (use 01 for DOS 3.3-6.0)\n +15H 4 lOffset DWORD file offset of a FontInfoRec\n 23 size of a FontLibHdrRec (designed to be longer,\n but DOS 3.3-6.0 define only one font).\n\nFontInfoHdrRec\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 2 wCpEntryCnt number of CpEntryHdrRecs to follow\n 2 size of a FontInfoHdrRec\n\nCpEntryHdrRec\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 2 wCpEntryCnt number of CpEntryHdrRecs to follow\n +2 2 wLen size of this structure, in bytes\n +4 4 lNextCpEH DWORD file offset of next CpEntryHdrRec\n (0000 0000 indicates this is the last)\n +8 2 wDevType device type (0001=display, 0002=printer)\n +0aH 8 abDevSubType device subtype and font file name;\n left-justified, blank-padded. For instance,\n 'EGA ' means EGA.CPI.\n +12H 2 wCpID code page number (e.g., 01b5H = 437 = US\n standard)\n +14H 6 res (6 bytes reserved, 0)\n +18H 4 lOffset file offset of FontDataHdrRec for this code page\n 24 length of a CpEntryHdrRec\n\nFontDataHdrRec\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 2 res (reserved: must be 0001)\n +2 2 wFontCnt number of fonts defined for this code page\n +4 2 wLen total length of all following font definitions\n 6 length of a FontDataHdrRec\n\nScreenFontDataRec\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 1 bCharHeight lines per character (e.g., 0eH=14; 350-line mode)\n +1 1 bCharWidth clms per character (usually 08)\n +2 1 bRelHeight must be 00\n +3 1 bRelWidth must be 00\n +4 2 wCharCnt number of characters defined (e.g., 100H = 256)\n +6 ? abFontData pixel data. Each character has (rows * clms)\n bits, formatted row by row. Thus, in a 14-row by\n 8-clm character, each byte defines one row so a\n set of 14 bytes define one character.\n ?+6 length of a ScreenFontDataRec\n (256 chars * 14) = 3584 = 0e00H total bytes.\n\nPrinterFontDataRec\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 2 wSelType 0001=the rCtrlSeq selects the default (hardware)\n font and the data that follows it contains codes\n to select a downloaded font followed by down-\n laodable data. See below.\n 0002=the rCtrlSeq consists of a single sequence\n of data to select a character set (for instance,\n if it is supported in the hardware).\n +2 2 wSeqLength size of the rCtrlSeq data (31 or less).\n For wSelType=0001, this is the entire length.\n For wSelType=0002, is just the length of the\n first escape sequence (that selects the default\n hardware font).\n\n +4 ? rCtrlSeq this data is in the form of a PrnSelType1Rec or a\n PrnSelType2Rec.\n ?+4 length of a PrinterFontDataRec\n\nPrnSelType1Rec\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 1 bResetLen the length of the escape sequence which selects\n the default (hardware) character set.\n +1 n abResetData the escape sequence to select the default\n character set\n +n+1 1 bSelLen the length of the escape sequence which selects\n this character set (once the download has been\n performed).\n +n+2 m abSelData escape codes to select this character set\n+m+n+2 1 bDnldLen the length of the download data that sets up this\n character set.\n+m+n+3 ? abDnldData bytes to download\n +?+m+n+3 length of a PrSelType1Rec structure\n\nPrnSelType2Rec\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 ? abSelData the escape sequence to select this character set.\n The length is in PrinterFontDataRec.wSeqLength\n\nSee Also: National Language Support\n fn 44H (IOCTL functions)\n fn 66H (code page switching)\n Code Page\n -♦-"
  },
  {
    "id": "342-country_id_codes.html",
    "t": "Country ID Codes",
    "b": "Hex Dec Country Date Time Money Format DS\n ▀▀▀▀ ▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀ ▀▀▀▀▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀ ▀▀\n 3dH 061 Australia DD-MM-YY 13:00:00 $1,000.00 ,\n 20H 032 Belgium DD/MM/YY 13:00:00 1 000,00 F ;\n 2 002 Canadian-French YY-MM-DD 13:00:00 1 000,00 $ ;\n 2dH 045 Denmark DD/MM/YY 13.00:00 1.000,00 DKR ;\n 166H 358 Finland DD-MM-YY 13:00:00 1 000,00 MK ;\n 21H 033 France DD/MM/YY 13:00:00 1 000,00 F ;\n 31H 049 Germany DD.MM.YY 13.00.00 DM1.000,00 ;\n 27H 039 Italy DD/MM/YY 13:00:00 1.000,Lit. ;\n 3ccH 972 Israel DD/MM/YY 13:00:00 Ö 1,000.00 ,\n 311H 785 Middle East DD/MM/YY 01:00:00 PM 1.000,000 $ ;\n 1fH 031 Netherlands DD-MM-YY 13:00:00 ƒ1.000,00 ;\n 2fH 047 Norway DD/MM/YY 13.00.00 KR 1.000,00 ;\n 15fH 351 Portugal DD/MM/YY 13:00:00 1.000$00 ;\n 22H 034 Spain DD/MM/YY 13:00:00 1.000,00 ₧ ;\n 2eH 046 Sweden YY-MM-DD 13.00.00 SEK 1.000,00 ;\n 29H 041 Switzerland DD.MM.YY 13.00.00 Fr 1,000.00 ,\n 2cH 044 United Kingdom DD-MM-YY 13:00:00 £1,000.00 ,\n 1 001 United States MM-DD-YY 01:00:00 PM $1,000.00 ,\n\n Notes: Country information is contained in the file COUNTRY.SYS and may\n vary in your OEM version of DOS.\n\nSee Also: National Language Support\n Code Pages\n Data Structures\n -♦-"
  },
  {
    "id": "343-country_info_block.html",
    "t": "Country Info Block",
    "b": "This topic covers the ExtCountryInfoRec returned by fn 38H (AL>0). For\n the structure obtained via the newer fn 6501H, see ExtCountryInfoRec.\n\n DOS 2.x returns an abridged country info record (see below).\n\nCountryInfoRec\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 2 wDateFormat 0=USA (m d y), 1=Europe (d m y), 2=Japan (y m d)\n +2 5 szCrncySymb currency symbol (ASCIIZ▲)\n +7 2 szThouSep thousands separator (ASCIIZ)\n +9 2 szDecSep decimal separator (ASCIIZ)\n +0bH 2 szDateSep date separator (ASCIIZ)\n +0dH 2 szTimeSep time separator (ASCIIZ)\n +0fH 1 bCrncyFlags currency format flags\n +10H 1 bCrncyDigits decimals digits in currency\n +11H 1 bTimeFormat time format\n +12H 4 pfCasemap Casemap FAR call address\n +16H 2 szDataSep data list separator (ASCIIZ)\n +18H 10 res reserved zeros\n 34 length of return buffer\n\n Notes: ■ See ExtCountryInfoRec for descriptions of these fields (the\n meanings are the same, but offsets differ).\n\n ■ When running under DOS version 2.x, DOS returns a simpler data\n structure:\n\nDOS 2.x CountryInfoRec\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 2 wDateFormat 0=USA (m d y), 1=Europe (d m y), 2=Japan (y m d)\n +2 5 szCrncySymb currency symbol (ASCIIZ▲)\n +7 2 szThouSep thousands separator (ASCIIZ)\n +9 2 szDecSep decimal separator (ASCIIZ)\n +0bH 21 res reserved)\n 32 size of this structure\n\nSee Also: National Language Support\n Data Structures\n -♦-"
  },
  {
    "id": "344-directory_entry_layout.html",
    "t": "Directory Entry Layout",
    "b": "DirEntryRec\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 8 abName left-justified, blank-padded (e.g. 'FILE '\n +8 3 abExt left-justified, blank-padded (e.g. 'EXT'\n +0bH 1 bAttr file attribute\n +0cH 10 res (reserved)\n +16H 2 rTime time created/last modified in FileTimeRec format\n +18H 2 rDate date created/last modified in FileDateRec format\n +1aH 2 wClstrNo cluster number of start of file (link into FAT)\n +1cH 4 lSize file size in bytes\n 32 size of DirEntryRec\n\n abName The name of the file or directory. If fewer than 8\n characters, it is padded to 8 with spaces (20H). The\n following bytes, when at offset 0, have special meaning:\n 00H ( ) The entry has never been used.\n 05H (♣) The first character is really 0e5H\n 2eH (.) This is an alias for a directory. .=self, ..=parent\n e5H (σ) The entry has been deleted.\n abExt File extension. If fewer than 3 characters, it is padded to 3\n with spaces (30H)\n bAttr See File Attributes\n rTime File time in special format. See FileTimeRec\n rDate File date in special format. See FileDateRec\n wClstrNo Cluster▲ number of the first cluster in the file. This is the\n link into the FAT chain that defines the location if the file.\n lSize 32-bit file length; a 4 GB capacity!\n\n Notes: ■ This layout is seen when you read a directory sector from the\n disk, for instance, via INT 25H. See Boot Sector for a way to\n calculate the sector of the root directory.\n\n ■ It is also returned by FCB-oriented fns 11H and 12H.\n\n ■ It is used in DoubleSpace compressed drives. See CVF Layout.\n\nSee Also: File Allocation Table\n Data Structures\n -♦-"
  },
  {
    "id": "345-disk_partition_table.html",
    "t": "Disk Partition Table",
    "b": "The very first sector of a hard disk (head 0, cylinder 0, sector 1)\n contains the Master Boot Record which is loaded into memory at 0:7c00 and\n executed by the ROM-BIOS during the System Startup Sequence.\n\n The last part of this sector contains the partition table--a 4-entry table\n with each entry being 16 bytes long. This table is manipulated by FDISK\n (or the equivalent utility of a non-DOS operating system).\n\n At boot time, the ROM-BIOS loads the Master Boot Record and jumps to its\n code. That code examines the Partition Table to determine which partition\n is marked as active. It then reads the correct boot sector into memory\n and executes it.\n\nMasterBootRec\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 1beH abBootCode master boot executable code\n +1beH 10H rPrtnInfo_1 partition 1 entry (see below)\n +1ceH 10H rPrtnInfo_2 partition 2 entry\n +1deH 10H rPrtnInfo_3 partition 3 entry\n +1eeH 10H rPrtnInfo_4 partition 4 entry\n +1feH 2 wPrtnTblSig partition table signature (aa55H)\n 512 size of the master boot sector\n\n abBootCode The first part of the sector (446 bytes) contains executable\n code. This code examines the partition table (starting at\n offset 1beH) and learns which partition is active. It then\n seeks to that portion of the disk and reads the first sector\n of that partition. That sector is laid out as a\n BootSectorRec.\n\n rPrtnInfo_n These four entries define the partitions allocated on the\n disk. Their layout is described below.\n\n wPrtnTblSig The final two bytes of the sector contain AA55H. This\n signature identifies the sector as a Master Boot Record.\n\nPartitionEntryRec\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 1 bBootFlag 0=not active, 80H = active (boot this partition)\n +1 1 bBeginHead partition begins at this head...\n +2 2 rBeginSecCyl ...and this sector and cylinder (see below)\n +4 1 bFileSysCode file system type\n +5 1 bEndHead partition ends at this head...\n +6 2 bEndSecCyl ...and this sector and cylinder (see below)\n +8 4 lBeginAbsSec partition begins at this absolute sector #\n +0cH 4 lTotalSects total sectors in this partition\n 16 size of a PartitonEntryRec\n +10H start of next entry or AA55H if last entry\n\n bBootFlag specifies if this partition is the active, bootable partition.\n 00H means not active (or not bootable)\n 80H means this is the partition to boot\n Only one entry can be set to 80H.\n\n bBeginHead the head number to use as the start of this partition.\nrBeginSecCyl the sector and cylinder number of the first sector in this\n partition.\n\n Sector and Cylinder values are actually 6 bits and 10 bits:\n 1 1 1 1 1 1\n ╓5┬4┬3┬2┬1┬0┬9┬8╥7┬6┬5┬4┬3┬2┬1┬0╖\n ║c c c c c c c c C c S s s s s s║\n ╙─┴─┴─┴─┴─┴─┴─┴─╨─┴─┴─┴─┴─┴─┴─┴─╜\n The high two bits of the second byte are used as the high bits\n of a 10-bit value. This allows for as many as 1024 cylinders\n and 64 sectors per cylinder.\n\n This is ordered so that when you load CX with the 16-bit\n value, it will be set up for a call to INT 13H to read the\n desired portion of the disk.\n\nbFileSysCode The following codes are recognized by DOS:\n 00H unknown file system type\n 01H DOS 12-bit FAT; partition smaller than 10 MB\n 04H DOS 16-bit FAT; partition smaller than 32 MB\n 05H Extended DOS Partition (see notes, below)\n 06H DOS 16-bit FAT; partition larger than or exactly 32 MB\n\n Other codes may exist; for instance, in non-DOS partitions.\n\n Types 1, 4, and 6, are given their own drive ID. Type 5\n provides a way to have more than 4 DOS partitions on a drive.\n\n bEndHead the head number for identifying the end of the partition\n bEndSecCyl the sector and cylinder number of the last sector in this\n partition (see rBeginSecCyl, above)\n\nlBeginAbsSec the partition starts at the absolute sector # (just another\n way to express rBeginHead and rBeginSecCyl; see notes, below).\n lTotalSects total number of sectors in this partition.\n\n Notes: ■ The absolute sector value at offset 08H of each entry is\n equivalent to the head, sector, and cylinder of the partition\n start address:\n\n Relative sector 0 is equal to cylinder 0, head 0, sector 1.\n The relative sector number increments first for each\n sector-per-track, next for each head, and finally for each\n cylinder. This formula applies:\n\n relSec = (CylNo * SecsPerTrack * Heads)\n + (HeadNo * SecsPerTrack)\n + (SecNo - 1)\n\n Use SecNo-1 since sectors are always numbered starting with 1.\n\n You can obtain low-level information such as sectors-per-track\n by using INT 13H, fn 08H.\n\n ■ Partitions begin on an even cylinder number, except for the\n first partition which may begin on cylinder 0, head 0, sector 2\n (since sector 1 is occupied by the Master Boot Record).\n\n ■ When the boot record of a partition receives control, its\n partition table entry is pointed to by DS:SI.\n\n█▌Logical Volumes and DOS Extended Partitions▐█\n Prior to DOS 3.3 DOS was incapable of accessing a drive larger than 32 MB\n (see FAT and INT 25H/26H for reasons). You could define four DOS\n partitions, but that maxed out at 128 MB. DOS 3.3 added the concept of\n \"logical volumes, so that one disk could define more than 4 partitions.\n\n Note: Starting with DOS 4.0, the 32 MB limit went away, and the\n extended DOS Partition concept is useful only of you need to\n access more than 4 DOS partitions.\n\n With DOS 6, you may find it advantageous to make the entire disk\n as one large volume and use DoubleSpace to break it up into\n several drives.\n\n When a partition table entry bFileSysCode contains a 05H, then the\n partition defined by the entry is treated as if it were the start of\n another physical drive; that is, the Master Boot code reads the table to\n learn about additional partitions. Each extended partition can define up\n to four DOS partitions.\n\n See Extended DOS Partition for a detailed discussion of this topic.\n\n█▌Logical Volumes and DOS Extended Partitions▐█\n The trans-32M support in DOS 4.0 caused no changes in the partition table\n or the 3.3 logical volume support. The significant differences are found\n in the Boot Sector Layout at the start of each DOS 4.0-formatted\n partition, in the changes to INT 25H/26H, and in the new functionality\n required in block device drivers.\n\nSee Also: INT 13H (disk I/O\n INT 19H (bootstrap)\n Boot Sector\n Extended DOS Partition\n Data Structures\n -♦-"
  },
  {
    "id": "346-dos_environment.html",
    "t": "DOS Environment",
    "b": "█▌Overview▐█\n DOS maintains an area of memory that holds a set of ASCIIZ▲ strings that\n can be used to obtain certain system-level information and to pass data to\n other programs.\n\n ■ The environment is a series of strings in the form: name=value.\n ■ The Set command is a general purpose interface to the environment. The\n Path and Prompt commands also affect its contents.\n ■ In DOS 3.0+, you can obtain the name by which your program was started\n (and therefore, your startup directory) by examining the end of the\n environment.\n ■ In DOS 3.3+ batch files, any text surrounded by percent marks is\n replaced with the environment value that matches the name. Examples:\n ┌─────────────────────────────────────────\n │ Path c:\\my_dir;%PATH%\n │ If (%USER%) == (dan) GOTO dan_label\n │ Echo %SET_CMPRS% > %CUR_LPT%\n\n ■ In DOS 6.0+, you can use SET in CONFIG.SYS.\n\n The environment is limited to an arbitrary size, but a larger DOS\n environment can be created with the SHELL= directive in the CONFIG.SYS\n file or the command 'COMMAND /e:nnnn' which starts a secondary copy of the\n command interpreter, providing nnnn bytes of environment space.\n\n Layout: Example using ASM mnemonics:\n ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n name_1=value_10 db 'COMSPEC=c:\\command.com',0\n name_2=value_20 db 'PROMPT=$p$g',0\n : db 'WP=c:\\wordproc',0\n name_N=value_N0 db 'PATH=d:\\;c:\\dos;c:\\utils',0\n 0 db 0\n ┌─ xxxx ───────────┐ DOS ┌─ dw 1 ───────────────────────┐\n │ EXEC_string_10 ╞═► 3.0+ ◄═╡ db 'C:\\ACCTNG\\AR001.EXE',0 │\n │ : │ only └─ db 0 ───────────────────────┘\n │ EXEC_string_NN0 │\n └─ 0 ──────────────┘\n\n where 0 is the ASCII NUL character (00H)\n xxxx is a 16-bit binary value (usually 0001H)\n\n█▌Using the Environment▐█\n The environment is less than 32K bytes and it starts on a paragraph\n boundary. Offset 2cH of the PSP of the current program contains the\n paragraph number of the environment for the active program.\n\n Alas, there are no DOS services to help access the environment. You can\n find a selected name by using a series of ASCIIZ string comparisons, until\n you come to a null string (zero length), indicating the end of the\n environment. Normally, the name portion of each string in the environment\n is in uppercase, but this is not enforced.\n\n One typical operation with the environment is used by shell-type programs\n which execute a secondary copy of COMMAND.COM. Shells typically search\n for the name of \"COMSPEC\" and use the value as the drive, path, and\n filespec of the DOS command interpreter--the program to EXEC via fn 4bH\n\n Some programs (including some DOS commands) request the operator to store\n application-specific information in the environment via the SET command.\n The application can use that information each time it is executed. For\n instance, a word processor may search the environment for a name of\n \"DICTIONARY\" and use the text of the value as the filespec for a\n dictionary data file.\n\n See Predefined Environment Variables for related info.\n\n█▌Locating Your Load Path▐█\n Starting with DOS 3.0, DOS stores an additional string after the end of\n the formal environment that can be used to locate the drive and directory\n from which a program was loaded. Applications can use this to help locate\n program overlays and data files.\n\n This becaem important with DOS 3.0, when DOS began allowing an operator to\n invoke a program by prefixing a pathname before the program filename.\n\n Following the final string of the environment is a byte of 0, indicating\n the end of the formal environment. The next two bytes are a 16-bit binary\n count of additional strings (this value is normally 0001H). Following\n this binary value, you can expect to find an ASCIIZ string of the filespec\n (including the drive, path, and extension) which was used by DOS Fn 4bH\n (EXEC) to load and execute the program.\n\n Even if the program file was not in the default directory and DOS or\n Windows needed to use the command search path to locate the program file,\n the correct full filespec (d:\\path\\filename.ext,0) will be stored after\n the end of the environment.\n\n█▌The \"Master\" Environment▐█\n Each program receives a static copy of the initial environment. Thus,\n any changes you make to an environment will be in effect for all your\n child processes (if any), but will be lost when control is returned to\n your parent process. See Program Startup & Exit.\n\n The DOS Set command affects the master environment of the active copy of\n COMMAND.COM, but there is no simple or documented way to do so in your own\n programs. The undocumented way to locate the \"root\" or \"master\"\n environment is:\n\n ■ Examine the word at offset 16H of your PSP; that's the PSP of your\n parent (undocumented).\n\n ■ Examine the same offset in that \"parent PSP\". Keep working backward\n up the chain until the \"parent PSP\" is the same as the PSP\n itself--that will be the PSP of COMMAND.COM.\n\n ■ The word at offset 2cH in that PSP is the segment of the environment\n for COMMAND.COM (that's the \"master\" environment).\n\n ■ The size of the master environment can be obtained by examining the\n Memory Control Block (MCB) which is in the paragraph just before the\n environment. The word at offset 03H is the size of the memory block,\n in 16-byte paragraphs.\n\n If you want to change anything in the master environment, you'll need to\n be careful to avoid overwriting the end and to leave it in good shape.\n Also remember that when running multiple DOS sessions (e.g., under\n Windows), this will affect the environment of ONLY the current session.\n\nSee Also: Predefined Environment Variables\n PSP\n Program Startup & Exit\n DOS Functions\n -♦-"
  },
  {
    "id": "347-dos_error_codes.html",
    "t": "DOS Error Codes",
    "b": "This topic lists error codes returned by DOS Functions (in AX when Carry\n Flag is set) as well as extended information returned by fn 59H. Other\n error-code listings in TECH Help!: APM API Error/Return Codes\n Device Driver Errors\n DoubleSpace API Error/Return Codes\n DPMI Error Codes\n EMM Error/Status Codes\n MRCI API Error/Return Codes\n POST Error Codes\n XMS Error Codes\n\n Error # Error #\n Hex Dec Meaning Hex Dec Meaning\n ▀▀▀ ▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀ ▀▀▀ ▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n 01H 1 Invalid function number 0aH 10 Invalid environment\n 02H 2 File not found 0bH 11 Invalid format\n 03H 3 Path not found 0cH 12 Invalid access code\n 04H 4 Too many open files 0dH 13 Invalid data\n 05H 5 Access denied 0eH 14 (not used)\n 06H 6 Invalid handle 0fH 15 Invalid drive specified\n 07H 7 Memory ctrl blocks destroyed 10H 16 Can't remove current dir\n 08H 8 Insufficient memory 11H 17 Not same device\n 09H 9 Invalid memory block address 12H 18 No more matching files\n\n█▌Extended Error Codes▐█\n These codes (and the class/location/action codes below) are returned by\n DOS fn 59H (DOS 3.0+).\n\n Error #\n Hex Dec Meaning (returned in AX by Fn 59H)\n ▀▀▀ ▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n 0 0 No error (don't expect 0 unless no error has EVER occurred)\n\n 13H 19 Write-protected disk ────────── 0 ┐\n 14H 20 Unknown unit ID 1 │\n 15H 21 Disk drive not ready 2 │\n 16H 22 Unknown command 3 │\n 17H 23 Disk data error (CRC error) 4 ╞═►These correspond to error\n 18H 24 Bad request structure length 5 │ codes 0-0cH passed in DI to\n 19H 25 Disk seek error 6 │ an INT 24H critical error\n 1aH 26 Unknown disk media type 7 │ handler and they match the\n 1bH 27 Disk sector not found 8 │ values in AL after errors\n 1cH 28 Printer out of paper 9 │ in INT 25H/26H.\n 1dH 29 Write fault error 0aH │\n 1eH 30 Read fault error 0bH │\n 1fH 31 General failure ──────────── 0cH ┘\n\n 20H 32 File sharing violation\n 21H 33 File locking violation\n 22H 34 Invalid disk change\n 23H 35 FCB unavailable (too many FCBs)\n 24H 36 Sharing buffer overflow\n 25H-31H (reserved)\n 32H 50 Network request not supported\n 33H 51 Remote computer not listening\n 34H 52 Duplicate name on network\n 35H 53 Network name not found\n 36H 54 Network busy\n 37H 55 Network device no longer exists\n 38H 56 Net BIOS command limit exceeded\n 39H 57 Network adapter hardware error\n 3aH 58 Incorrect response from network\n 3bH 59 Unexpected network error\n 3cH 60 Incompatible remote adapter\n 3dH 61 Print queue full\n 3eH 62 Not enough space for print file\n 3fH 63 Print file was deleted\n 40H 64 Network name was deleted\n 41H 65 Access denied\n 42H 66 Incorrect network device type\n 43H 67 Network name not found\n 44H 68 Network name limit exceeded\n 45H 69 Net BIOS session limit exceeded\n 46H 70 Temporarily paused\n 47H 71 Network request not accepted\n 48H 72 Print or disk redirection is paused\n 49H-4fH (reserved)\n 50H 80 File already exists\n 51H 81 (reserved)\n 52H 82 Cannot make directory entry\n 53H 83 \"fail\" error from INT 24H Critical Error handler\n 54H 84 Too many redirections\n 55H 85 Duplicate redirection\n 56H 86 Invalid password\n 57H 87 Invalid parameter\n 58H 88 Network data fault\n\n█▌Error Class▐█\n These codes provide additional information to help you determine how to\n handle the error. Fn 59H returns these informational codes in BH.\n\n Class #\n Hex Dec Meaning (returned in BH by Fn 59H)\n ▀▀▀ ▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n 01H 1 Out of resource: no more FCBs, memory, channels, handles, etc.\n 02H 2 Temporary situation: will go away in a while (e.g., locked file)\n 03H 3 Authorization problem: You need higher permission to do this\n 04H 4 Internal error: DOS is at fault\n 05H 5 Hardware failure\n 06H 6 System failure: DOS is at fault\n 07H 7 App. error: passed bad info to DOS, inconsistent request,etc.\n 08H 8 Not found: requested file/item can't be found\n 09H 9 Bad format: file/item in invalid format (EXE file bad, etc.)\n 0aH 10 Locked: file/item locked\n 0bH 11 Media error: wrong disk, disk CRC error, etc.\n 0cH 12 Already exists: collision with existing file/item\n 0dH 13 Unknown error class: classification doesn't exist\n\n█▌Suggested Action▐█\n These codes indicate appropriate action to take when an error occurs. The\n idea is to limit your coding by NOT looking for specific error numbers in\n your application. Instead, maintain upward compatibility by taking the\n suggested actions listed below. Fn 59H returns these codes in BL.\n\n Action#\n Hex Dec Meaning (returned in BL by Fn 59H)\n ▀▀▀ ▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n 01H 1 Retry: Retry the operation a few times. If the error continues\n to occur, ask the user if he wants to continue or quit.\n\n 02H 2 Delay Retry: Delay a while and retry the operation a few times.\n If the error continues to occur, ask the user if she wants to\n continue or quit.\n\n 03H 3 User Input: If data presented to DOS was entered by a user, ask\n the user to re-enter input (e.g., bad drive ID or pathname).\n\n 04H 4 Abort: Abort the application, but it's OK to perform cleanup\n operations such as closing files, updating indexes, releasing\n memory blocks, etc.\n\n 05H 5 Immediate Exit: Abort immediately without attempting cleanup.\n The system is in an unhealthy state and immediate exit is best.\n\n 06H 6 Ignore: The error doesn't make any difference.\n\n 07H 7 Retry after user action: the user needs to perform some action,\n such as inserting a diskette. Prompt the user and then retry.\n\n█▌Error Location▐█\n These codes are meant to help you figure out where the error occurred.\n Fn 59H returns these informational codes in CH.\n\n Locus #\n Hex Dec Meaning (returned in CH by Fn 59H)\n ▀▀▀ ▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n 01H 1 Unknown: No specific area to pin-point error source\n 02H 2 Block device: error occurred on disk or tape drive\n 03H 3 (reserved)\n 04H 4 Character device\n 05H 5 Memory\n\n█▌DOS Versions▐█\n Error handling is upwardly-compatible for all DOS versions. These general\n rules apply:\n\n ■ DOS 1.x: indicates some errors by placing 0ffH in AL upon return.\n\n ■ DOS 2+: New 2.0+ calls indicate errors by setting the Carry Flag\n (CF=CY=1) and putting an error code into AX.\n\n ■ DOS 3+: 2.0-6.0 calls still return error codes in AX when CF=CY.\n IBM advised us in 1985 to use DOS Fn 59H to obtain error\n information since this \"AX return code\" policy may change.\n But I don't see that happening.\n\nSee Also: DOS Fn 59H (get extended error info)\n INT 24H Critical Error Handling\n ErrorMode Flag\n APM API Error/Return Codes\n Device Driver Errors\n DoubleSpace API Error/Return Codes\n DPMI Error Codes\n EMM Error/Status Codes\n MRCI API Error/Return Codes\n XMS Error Codes\n -♦-"
  },
  {
    "id": "348-cds__current_directory_structure.html",
    "t": "CDS: Current Directory Structure",
    "b": "This is the undocumented format of a structure DOS maintains for each\n logical drive (as set via the LASTDRIVE= command in CONFIG.SYS).\n\n Use DOS fn 52H (get ListOfLists) to locate the first of these structures\n and to find how many there are. The second follows directly after the\n first, and so forth.\n\nCurDirRec\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 67 szPath ASCIIZ▲ d:\\path of current default directory\n +43H 2 rFlags bit-flags describing this drive\n +45H 4 pfDPB FAR address of the DPB for this drive\n +49H 2 wClustNo cluster number of start of default dir\n or FAR address of a network redirector record\n +4bH 4 pRes unknown; always ffffffffH\n +4dH 2 wNetUsrCode network user code as stored via fn 5f03H\n +4fH 2 wSlashOffset offset of first '\\' in abPath (to skip d:)\n +51H 1 bRes unknown\n +52H 4 pIFSDrvr points to IFS (Installable File System) driver\n +56H 2 wRes unknown\n 88 size of this structure (DOS 4.0+)\n\n szPath This is an ASCIIZ▲ string giving the entire name of the\n current default directory for this logical drive, starting\n with the drive ID (e.g., C:\\DOS\\UTILS◄0►).\n\n On Subst drives, this is the true name of the directory on the\n actual drive in which it resides.\n\n rFlags I don't have the layout of these flags but C000H is a network\n drive, 5000H is a Subst drive, and 0000H is an invalid drive.\n\n pfDPB Address of the Drive Parameter Block (DPB) for this drive.\n\n wClustNo on non-network drives, this is the cluster number of the first\n cluster of the current default directory for this drive.\n\n On network drives, this is the address of a network redirector\n record.\n\n wNetUsrCode on network drives, this is the \"user code\" that was passed in\n CX to DOS fn 5f03H (make network connection).\n\nwSlashOffset This is usually 0002H; it is the offset of the first backslash\n (\\) in the szPath field (you add this to the addr of the start\n of the record and viola, you are past the d: drive ID.\n\n pIFSDrvr For drives that are part of an \"Installable File System\", this\n is the address of the IFS driver. Sorry, I have no info on\n IFSs.\n\nSee Also: fn 52H (get DOS vars address/ListOfLists)\n fn 47H (query default directory)\n fn 3bH (set default directory -- CHDIR)\n Device Drivers\n Data Structures\n -♦-"
  },
  {
    "id": "349-dos_variables_block__list_of_lists_.html",
    "t": "DOS Variables Block (List of Lists)",
    "b": "This is the undocumented format of the structure whose address is returned\n in ES:BX by the undocumented DOS fn 52H. This data can be used to learn\n low-level information such as how many drive IDs are recognized and the\n address of the base MemBlockRec.\n\nDosVarsRec\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n -2 2 wBaseMemSeg ES:[BX-2] is seg of first Memory Control Block\n ──────────────────────────────────────────────\n +0 4 prBaseDPB address of first Drive Parameter Block (DPB)\n +4 4 pHandleTbl address of first system file table\n +8 4 prClockDev address of CLOCK device header\n +0cH 4 prConDev address of CON device header\n +10H 2 wMaxSect maximum sector size for block devices\n +12H 4 pbCache address of cache head buffer\n +16H 4 parDirs address of the CurDirRec structure array\n +1aH 4 prFcbTbl address of system FCB file table\n +1eH 2 wFcbCnt size of FCB table file table\n +20H 1 bDriveCnt number of drives in system\n +21H 1 bLastDrive corresponds to Config.sys LASTDRIVE\n 34 size of a DOSVarsRec\n ──────────────────────────────────────────────\n +22H 18 rNulDevHdr the DevHdrRec for the NUL device (the start of\n device driver chain).\n\n wBaseMemSeg The segment address of the \"base MemBlockRec\" This is the\n lowest allocation in memory. It may be owned by DOS or\n DoubleSpace.\n\n Note: This value is located two bytes before the structure\n itself; i.e., after calling fn 52H, it is at ES:[BX-2].\n\n prBaseDPB The first Drive Parameter Block. You can trace the DPB chain\n by accessing the pfrNextDPB field of each structure.\n pHandleTbl Internal info on each open file (?)\n prClockDev Address of the DevHdrRec for the CLOCK device\n prConDev Address of the DevHdrRec for the CON device\n wMaxSect Largest allowed sector size for block devices (?)\n pbCache FAR address of DOS's internal disk buffers\n parDirs FAR address of an array of 88-byte CurDirRec structures. The\n first item in each structure is an ASCIIZ▲ string that names\n the current default directory for one drive. There are\n bDriveCnt such records, placed sequentially in memory.\n prFcbTbl Address of the system FCBRec file table (?)\n wFcbCnt Number of FCBRecs in the system FCB table\n bDriveCnt Number of drives (including logical drives) known to the\n system (does not include network drives).\n bLastDrive A count of the elements in the list pointed to by pparDirs.\n For instance, if you specified LASTDRIVE=Z in your CONFIG.SYS\n file, then this value will be 24 (18H).\n\n rNulDevHdr is the actual 18-byte DevHdrRec of the NUL device. This is\n the start of the device driver chain. You can locate all\n device drivers by examining the chain of far pointers whose\n first link is at ES:[BX+22H]. It is a 4-byte pointer to the\n next driver.\n\n Notes: ■ You can use the wBaseMemSeg as the segment address to start\n tracing the memory allocation chain. You can recognize a PSP\n since it begins with an INT 20H (ie, cd 20). At offset 2cH of\n a PSP is the address of the DOS environment segment for that\n process (from which you may be able to obtain the fill filespec\n of the program which owns it).\n\n ■ This structure has apparently been intact since DOS 2.0, but\n Microsoft continues to leave it undocumented as late as 6.0.\n\nSee Also: System Information Functions\n fn 52H (get DOS vars address)\n Data Structures\n -♦-"
  },
  {
    "id": "350-dpb__drive_parameter_block.html",
    "t": "DPB: Drive Parameter Block",
    "b": "The DPB information is obtained via DOS Fns 32H and 1fH. It describes a\n drive and the medium in the drive.\n\n Virtually all this information can be obtained by reading the boot sector\n and invoking a series of other DOS function calls and performing\n calculations (see FAT), but the DPB has all the data in one place.\n\nDPBRec\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 1 bDrvNo drive number (0=A, 1=B, etc.)\n +1 1 bUnitNo sub-unit number\n +2 2 wSectSize bytes per sector\n +4 1 bClustMask sectors per cluster-1 (max sector in cluster)\n +5 1 bClustShift cluster-to-sector shift (cluster is 2ⁿ sectors)\n +6 2 wFirstFAT sector number of first start of first FAT\n +8 1 bFatCnt number of FATs\n +9 2 wRootEntries number of entries allowed in root directory\n +0bH 2 wFirstData sector number of cluster #2 (first data cluster)\n +0dH 2 wHiClust total clusters+1 (number of highest cluster)\n +0fH 1 bFatSects sectors needed by a FAT\n +10H 2 wRootSec sector # of start of root directory\n +12H 4 pfrDevHdr address of DevHdrRec for this device driver\n +16H 1 bMedia media descriptor byte\n +17H 1 bFirstAccess ffH=medium in drive has not been accessed\n +18H 4 pfrNextDPB Address of next DPBRec (0ffffH if last)\n +1CH 2 wNextFree last allocated cluster\n +1EH 2 wFreeCnt number of free clusters\n 32 size of a DPBRec\n\n Many of these fields are exactly as in BootSectorRec and BPBRec (which\n see). Notable fields are:\n\n bUnitNo identifies the drive sub-unit, for device drivers which\n support multiple drive types.\n\n wFirstFAT is the sector number of the first copy of the FAT for this\n drive. It is also the number of \"reserved\" sectors on the\n disk, since the first FAT always follows the last reserved\n sector.\n\n wFirstData saves some calculations when converting a cluster number (from\n the FAT or a DirEntryRec) into a cluster number. Data for a\n FAT entry of (0)002H starts at this sector number. In\n general, the data for cluster number n starts at sector number\n wFirstData + ((n-2)*(bClustMask+1)).\n\nbFirstAccess 00H means this DPB has been accessed.\n ffH means this DPB has NOT been accessed and must be rebuilt.\n\n pfrNextDPB is the FAR address of the next DPBRec in the chain; this\n address is FFFF:FFFF in the last DPBRec. The address of the\n first DBPRec can be found via 52H (get ListOfLists).\n\n wNextFree is used by DOS in allocating clusters. DOS will attempt to\n allocate at this cluster (and then bump wNextFree up) in the\n hopes of making contiguous allocations. This field was not\n documented before 5.0.\n\n wFreeCnt MAY contain the current number of unallocated clusters. But\n DOS is NOT required to maintain a correct calculation here.\n Use fn 36H to learn how much space is available (that fn\n triggers ram-resident Undelete Delete Sentry to purge old\n files). If this field is ffffH, it has not been calculated\n yet. This field was not documented before 5.0.\n\n Notes: The undocumented DOS fn 53H converts a BPB (as supplied by a\n device driver) into a DPB.\n\nSee Also: DOS fn 53H (translate BPB to DPB)\n Disk Drive Functions\n Device Drivers\n BPB: BIOS Parameter Block\n Boot Sector Layout\n File Allocation Table\n -♦-"
  },
  {
    "id": "351-dta__disk_transfer_address.html",
    "t": "DTA: Disk Transfer Address",
    "b": "The old FCB File I/O functions funnel all data through a program-global\n address called the DTA or Data Transfer Address.\n\n DOS fn 1aH (set DTA) sets or changes the DTA.\n DOS fn 2fH (query DTA) obtains the current address of the DTA.\n\n When a program starts, its DTA is initially set to PSP:0080. See\n Program Startup & Exit.\n\n About the only commonly-used DOS services that uses the DTA are:\n 4eH (find first matching file)\n 4fH (find next matching file)\n\n If you use these functions in a recursive search through directories,\n remember to set the DTA to an instance-local area at each level!\n\nSee Also: Directory and File Functions\n Data Structures\n -♦-"
  },
  {
    "id": "352-errorinforec.html",
    "t": "ErrorInfoRec",
    "b": "This structure is used in calls to DOS fn 5d0aH (set extended error).\n Data passed in this structure will be returned to the next program which\n uses fn 59H (get extended error info).\n\nErrorInfoRec\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 2 wAX_ErrCode see DOS Error Codes\n +2 2 wBX_ClassAct error class and suggested action code\n +4 2 wCX_Locus an error location code\n +6 2 wDX DX register when the error occurred\n +8 2 wSI SI register when the error occurred\n +0aH 2 wDI DI register when the error occurred\n +0cH 2 wDS DS register when the error occurred\n +0eH 2 wES ES register when the error occurred\n +10H 2 wRes (reserved)\n +12H 2 wUID computer ID when err is remote; 0=local\n +14H 2 wPID program ID when err is remote; 0=local\n 22 size of this structure\n\n wAX_ErrCode ...and...\nwBX_ClassAct ...and...\n wCX_Locus should contain DOS extended error information.\n See DOS Error Codes for a full listing.\n\nSee Also: DOS fn 5d0aH (set extended error info)\n DOS fn 59H (get extended error info)\n -♦-"
  },
  {
    "id": "353-errormode_flag.html",
    "t": "ErrorMode Flag",
    "b": "█▌Overview▐█\n If you have control when a critical disk error occurs you must not call\n any system functions (including INT 21H and other DOS services).\n\n This situation can arise if your program hooks INT 24H (Critical Error\n handler) or if your TSR gets control via a timer interrupt such as\n INT 08H or INT 1cH while a critical disk error is taking place.\n\n Note that a similar caution is described about the InDOS Flag, but when\n that flag is set, it is still OK to use DOS fns 01H-0cH. The ErrorMode\n Flag indicates a more dire situation, with DOS being in a very unstable\n state. When it is set, you must avoid all DOS fns.\n\n█▌ErrorMode Detection▐█\n Your program can check the state of the ErrorMode Flag as follows:\n\n ■ Early on (before you need it!) use DOS fn 34H (get InDOS addr). The\n address of the ErrorMode Flag is one byte before the address returned\n by fn 34H. Save it.\n\n ■ Before popping up, check the byte at the ErrorMode Flag address.\n A non-zero value means beware!. When ErrorMode is non-zero, DOS is\n processing a critical disk error and you must NOT use any DOS\n services.\n\n█▌INT 28H: Toggling ErrorMode▐█\n It is common for a pop-up TSR to take control by hooking INT 28H (DOS Idle\n Handler).\n\n When INT 28H is called, it is OK to use most DOS services (including disk\n I/O and all higher-level fns. But you must avoid fns 01H-0cH. If you\n simply must use fns 01H-0cH, the DOS tech ref suggests that you first set\n ErrorMode to 01H.\n\n In general, it is pretty easy to avoid fns 01H-0cH by accessing CON or\n PRN, etc. via Handle-Oriented File I/O or by dropping down to BIOS-level\n services such as INT 16H (keyboard services).\n\nSee Also: DOS fn 34H (get InDOS and ErrorMode address)\n DOS fns 01H-0CH (low-level character I/O)\n InDOS Flag\n INT 24H (Critical Error Handler)\n Process Control Functions\n TSR Functions\n -♦-"
  },
  {
    "id": "354-exe_file_header_layout.html",
    "t": "EXE File Header Layout",
    "b": "ExeHeaderRec\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 2 wSignature 5a4dH .EXE file signature ('MZ')\n +2 2 wPartPage length of partial page at end (generally ignored)\n +4 2 wPageCnt length of image in 512-byte pages, incl. header\n +6 2 wReloCnt number of items in relocation table\n +8 2 wHdrSize size of header in 16-byte paragraphs\n +0aH 2 wMinAlloc minimum RAM needed above end of prog (paragraphs)\n +0cH 2 wMaxAlloc maximum RAM needed above end of prog (paragraphs)\n +0eH 2 wInitSS segment offset of stack segment (for setting SS)\n +10H 2 wInitSP value for SP register when started\n +12H 2 wChkSum file checksum (negative sum of all words in file)\n +14H 2 wInitIP value for IP register when started\n +16H 2 wInitCS segment offset of code segment (for setting CS)\n +18H 2 wTablOff file-offset of first relo item (often 001cH)\n +1aH 2 wOverlayNo overlay number (0 for base module)\n 28 size of formatted portion of EXE header\n\n +? 4*? alReloTbl variable-length relocation table\n +? ? abFiller filler to paragraph boundary\n +? ? abImage start of program image\n\n Since an EXE file may be loaded on any segment, all absolute segment\n references (such as FAR CALLs, long address pointers, and references such\n as MOV AX,data_seg) must be adjusted to work for the memory location in\n which they are loaded. Here are the steps used by the DOS program loader\n (fn 4bH ) to load an EXE file:\n\n 1. Create a PSP via DOS Fn 26H.\n\n 2. Read 1cH bytes of the EXE file (the formatted portion of the EXE\n header) into a local memory area.\n\n 3. Determine the load module size:\n size=((wPageCnt*512)-(wHdrSize*16))-wPartPage\n\n 4. Determine file offset of load module = (wHdrSize * 16)\n\n 5. Select a segment addr, START_SEG, for loading (usually PSP+10H)\n\n 6. Allocate enough memory to hold the load module, honoring the\n settings in wMaxMem and wMinMem.\n\n 7. Read the load module into memory starting at START_SEG:0000\n\n 8. LSEEK to the start of the relocation table (wTablOff)\n\n 9. For each relocation item (wReloCnt):\n a. read the item as two 16-bit words (I_OFF,I_SEG)\n b. add RELO_SEG=START_SEG+I_SEG (find the address of\n relocation ref)\n c. fetch the word at RELO_SEG:I_OFF (read current value)\n d. add START_SEG to that word (perform the segment fixup)\n e. store the sum back at its original address (RELO_SEG:I_OFF)\n\n 10. Allocate memory for the program according to wMaxMem and wMinMem\n\n 11. Initialize registers and execute the program:\n a. ES = DS = PSP\n b. Set AX to indicate the validity of drive IDs in command line\n c. SS = START_SEG+ReloSS, SP = ExeSP\n d. CS = START_SEG+ReloCS, IP = ExeIP\n\n Note: Recent additions to the EXE format, specifically the CodeView,\n OS/2, and Windows versions of the EXE file contain additional\n information embedded in the executable file. Sorry, but these\n additions are not covered here.\n\nSee Also: Program Startup & Exit\n Process Control Functions\n PSP: Program Segment Prefix\n DOS Environment\n -♦-"
  },
  {
    "id": "355-exec_parameter_block__execparamrec_.html",
    "t": "Exec Parameter Block (ExecParamRec)",
    "b": "This structure is used in fn 4b00H (load and execute program).\n\nExecParamRec\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 2 wEnvSeg segment of environment for child (0000=current)\n +2 4 pfCmdTail address of command line text to place at PSP:0080\n +6 4 pfrFCB_1 address of an FCB to be placed at PSP:005c\n +0ah 4 pfrFCB_2 address of an FCB to be placed at PSP:006c\n 14 length of an ExecParamRec\n\n wEnvSeg Segment address of the environment to be provided for the\n child process OR 0000H to have DOS create and allocate a\n duplicate of the current environment for the child.\n\n If this is non-zero, you must prepare the required series of\n ASCIIZ strings. DOS will allocate memory and copy the data,\n appending the child program's filename (see DOS Environment).\n DOS will free the memory upon termination of the child.\n\n pfCmdTail Text to be passed to the child as it command-line arguments.\n It must be in the same format as described in the PSP (126-\n character maximum Lstring▲); it will be copied to the child's\n PSP at offset 80H.\n\n pfrFCB_1 and...\n pfrFCB_2 are unopened FCBs to be copied to the child's PSP.\n\n Notes: ■ Prepare an environment and set wEnvSeg to its paragraph (or set\n wEnvSeg to 0000 to have the child inherit a copy of the current\n environment).\n\n Some programs put their own PROMPT= string into the child's\n environment, e.g., PROMPT=Type EXIT to return to MyProg$G\n\n ■ Prepare an Lstring command line to pass to the child. If no\n command line is needed, it should contain: 00H 0dH. See PSP\n offset 80H for the format.\n\n Note that fn 4b00H does NOT process redirection symbols.\n\n ■ Set pfCmdTail to the offset and segment of this command line.\n\n If no FCBs are needed (as when EXECing Command.Com) you can\n ignore the following steps. If EXECing a program that expects\n FCBs (as with FORMAT.COM):\n\n ■ prepare two unopened FCBs to pass to the child\n ■ set pfrFCB_1 to the offset and segment of the first FCB\n ■ set pfrFCB_2 to the offset and segment of the second FCB\n\nSee Also: Process Control Functions\n PSP: Program Segment Prefix\n DOS Environment\n -♦-"
  },
  {
    "id": "356-exec_state_record.html",
    "t": "Exec State Record",
    "b": "This structure is used in fn 4b05H (set execution state).\n\nExecStateRec\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 2 res reserved\n +2 2 wTypeFlags 0=COM, 1=EXE, 2=COM overlay, 3=EXE overlay\n +4 4 pfszProgName Address of ASCIIZ▲ program name\n +6 2 wPspSeg Segment of the program's PSP\n +8 4 lStartAddr 32-bit address of entry point (CS:IP)\n +0aH 2 lProgSize 32-bit size of program, including PSP.\n 12 length of an ExecStateRec\n\nSee Also: Process Control Functions\n PSP: Program Segment Prefix\n DOS Environment\n -♦-"
  },
  {
    "id": "357-extended_country_info_block.html",
    "t": "Extended Country Info Block",
    "b": "This topic covers the ExtCountryInfoRec returned by fn 6501H. See\n CountryInfoRec for the subset of this structure obtained via the older\n fn 38H.\n\nExtCountryInfoRec\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 1 bRecID Information ID (01H on calls to fn 6501H)\n +1 2 wRecLen size of information\n +3 2 wCountryID Country Code\n +5 2 wCodePgID Code Page\n +7 2 wDateFormat date format\n +9 5 szCrncySymb currency symbol (ASCIIZ▲)\n +0eH 2 szThouSep thousands separator (ASCIIZ)\n +10H 2 szDecSep decimal separator (ASCIIZ)\n +12H 2 szDateSep date separator (ASCIIZ)\n +14H 2 szTimeSep time separator (ASCIIZ)\n +16H 1 bCrncyFlags currency format flags\n +17H 1 bCrncyDigits decimals digits in currency\n +18H 1 bTimeFormat time format\n +19H 4 pfCasemap Casemap FAR call address\n +1dH 2 szDataSep data list separator (ASCIIZ)\n +1fH 10 res reserved zeros\n 41 length of return buffer\n\n bRecID The record ID, as used in all 3.3+ NLS fns.\n wRecLen The size of the following information. Be suer to check this,\n to avoid the chance that DOS returns a truncated record.\n wCountryID Country ID\n wCodePgID Code Page ID\n wDateFormat How to print a date: 0000H = MM/DD/YY (as in USA)\n 0001H = DD/MM/YY (as in Europe)\n 0002H = YY/MM/DD (as in Japan)\n szCrncySymb ASCIIZ▲ char(s) used for printing currency amounts\n szThouSep ASCIIZ char used to separate 1000 place (e.g., comma)\n szDecSep ASCIIZ char used to separate number from decimal (e.g.,\n period)\n szDateSep ASCIIZ char used to separate elements of a date\n szTimeSep ASCIIZ char used to separate elements hours from minutes\n bCrncyFlags currency format code, e.g.: 0=\"$123.00\"; 1=\"123.00$\";\n 2=\"$ 123.00\"; 3=\"123.00 $\"\nbCrncyDigits The number of places that appear to the right of the decimal\n point when printing currency amounts.\n bTimeFormat time format: 0=12-hour clock, 1=24-hour clock\n pfCasemap CaseMap FAR Call address (see note)\n szDataSep ASCIIZ char used to separate elements of a list (e.g., comma)\n\n Notes: ■ The CaseMap call can be used to assign ASCII weights to\n characters above 80H. For instance, the DOS SORT command uses\n the CaseMap to assign â,ä,à,å,Ä,Å,æ,and á the same ASCII weight\n as 'A' and 'a' for sorting purposes. Different CaseMaps exist\n for countries with different alphabets.\n\n To use the CaseMap address:\n 1. Place a byte to 'weigh' into AL\n 2. Make a FAR CALL to the indicated address\n 3. The weight value is returned in AL\n All register values (except AL) are preserved\n\n Note: DOS 3.3+ provides easy-to-use case-mapping via fn 65H.\n\n ■ When running under DOS version 2.0 through 3.2, DOS returns a\n structure containing some of this information, but in a\n different layout. See CountryInfoRec. Be sure you know which\n version of DOS is active (see fn 30H).\n\nSee Also: National Language Support\n Data Structures\n -♦-"
  },
  {
    "id": "358-extended_dos_partition.html",
    "t": "Extended DOS Partition",
    "b": "Starting with DOS 3.3, DOS supports a system that makes it possible for a\n hard disk to contain additional DOS partitions beyond the maximum of four\n that was available in previous versions.\n\n Originally, this was a work-around for the 32 MB-per-partition limit (that\n went away with DOS 4.0), but it can still be used to create additional\n logical disk volumes. For instance, a hard disk can contain, say 3 non-\n DOS partitions and 20 DOS partitions.\n\n The basic idea is this:\n\n ■ When an entry in the Disk Partition Table contains 05H in the\n bFileSysCode field, that entry actually defines the location of a\n secondary Master Boot Sector which contains its own variation of a\n partition table, called an extended partiton record.\n\n ■ Each extended partition record has at most two entries. One will\n contain a PartitionEntryRec that identifies the location and size of\n the DOS partition. It will have a bFileSysCode of 1, 4, or 6. The\n second (if any) will have a bFileSysCode of 5, indicating the\n location of another extended partition record.\n\n An extended partition record sector is like a partition table except that:\n\n ■ These logical drives are not bootable, so the sector does not need to\n contain any Master Boot Record-style boot code. It just needs the\n data starting at offset 1beH in the sector (see MasterBootRec).\n\n ■ Entries cannot identify non-DOS partitions. bFileSysCode values must\n be one of: 00 table entry is empty\n 01 defines 12-bit DOS logical drive\n 04 defines 16-bit DOS logical drive < 32 MB\n 05 defines another extension table\n 06 defines 16-bit DOS logical drive > 32 MB\n\n ■ The table will have either one or two entries. One entry defines a\n type-1, 4, or 6 DOS drive. The second (optional) entry may be a\n type-5 extension table indicator. You can define only one drive per\n table.\n\n ■ When bFileSysCode is 1, 4, or 6, the start/end Hd/Sec/Cyl values are\n relative to the extension boot sector.\n\n ■ When bFileSysCode is 5, the start/end Hd/Sec/Cyl values are absolute\n (relative to the beginning of the physical disk).\n\nSee Also: INT 13H (disk I/O\n Partition Table\n Boot Sector\n Data Structures\n -♦-"
  },
  {
    "id": "359-fat__dos_file_allocation_table.html",
    "t": "FAT: DOS File Allocation Table",
    "b": "The FAT is a linked-list table that DOS uses to keep track of the physical\n position of data on a disk and for locating free space for storing new\n files.\n\n The word at offset 1aH in a directory entry is a cluster number of the\n first cluster in an allocation chain. If you locate that cell in the FAT,\n it will either indicate the end of the chain or the next cell, etc.\n Observe:\n starting cluster number ══╗\nDirectory ╓───────────────────┬─┬───────────────────┬───┬───┬─▼─┬───────╖\nEntry ══► ║M Y F I L E T X T│a│ │tim│dat│08 │ size ║\n ╙─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─║─┴─┴─┴─┴─╜\n ╔═════════════════════════╝\n 00 01 02 03 04 05 06 07 ║8 09 0a 0b 0c 0d 0e 0f\n ┌──┐┌──┐┌──┐┌──┐┌──┐┌──┐┌──┐┌──┐┌▼─┐┌──┐┌──┐┌──┐┌──┐┌──┐┌──┐┌──┐\n0x │ID││ff││03═►04═►05═►ff││00││00││09═►0a═►0b═►15││00││00││00││00│\n └──┘└──┘└──┘└──┘└──┘└──┘└──┘└──┘└──┘└──┘└──┘└║─┘└──┘└──┘└──┘└──┘\n ╔═══════════════════════╝\n ┌──┐┌──┐┌──┐┌──┐┌──┐┌▼─┐┌──┐┌──┐┌──┐┌──┐┌──┐┌──┐┌──┐┌──┐┌──┐┌──┐\n1x │00││00││00││00││00││16═►17═►19││f7││1a═►1b═►ff││00││00││00││00│\n └──┘└──┘└──┘└──┘└──┘└──┘└──┘└║─┘└──┘└▲─┘└──┘└──┘└──┘└──┘└──┘└──┘\n ╚═══════╝\n This diagram illustrates the main concepts of reading the FAT. In it:\n\n ■ The file, MYFILE.TXT, is 10 clusters long. The first byte is in\n cluster 08 and the last is in cluster 1bH. The chain is\n 8,9,0a,0b,15,16,17,19,1a,1b. Each entry indicates the next entry in\n the chain, with a special code in the last entry.\n\n ■ Cluster 18H is marked bad and is not part of any allocation chain.\n\n ■ Clusters 6,7, 0cH-14H, and 1cH-1fH are empty and available for\n allocation.\n\n ■ Another chain starts at cluster 2 and ends at cluster 5.\n\n Notes: The diagram is simplified in that it shows the FAT as if it held\n 8-bit values (00-nn). A FAT actually contains 12-bit or 16-bit\n entries (see below).\n\n To read the data associated with a FAT cluster number, you must do some\n math and use INT 25H. See Converting a Cluster Number, below.\n\n█▌FAT Facts▐█\n The FAT normally starts at DOS logical sector 0001H in the DOS partition\n (i.e., you can read it with INT 25H with DX=0001H). One way to locate the\n FAT is to read the boot sector (DX=0000H), and examine the wResSects field\n of the BootSectorRec (offset 0eH). This tells how many boot and reserved\n sectors come before the FAT. Use that number (usually 1) in DX to read\n the FAT via INT 25H. You may also use DOS fn 32H or 1fH (get drive\n parameter block) and examine the word at offset 6 of the DPBRec.\n\n There are usually two complete copies of the FAT. If so, they are always\n adjacent (the second FAT directly follows the first). The number of FATs\n is in wFatCnt and the size, in sectors, of one FAT is in wFatSects of the\n BootSectorRec or DPBRec.\n\n You have the following services available to help you obtain information\n about the FAT:\n\n ■ Use DOS Fn 36H or 1cH to determine total disk sectors and clusters\n ■ Use INT 25H to read the Boot Sector and examine the data therein\n ■ Use DOS Fn 44H (if the device driver supports Generic IOCTL)\n ■ Use DOS Fn 32H to get all kinds of useful information\n\n Notes: ■ The boot sector of non-booting disks (such as network block\n devices and very old hard disks) may contain nothing but\n garbage. Use DOS fn 32H to get info on these devices.\n\n ■ DoubleSpace simulates all disk data structures and all of the\n above-mentioned services work transparently for a mounted,\n compressed volume. See Compressed Volume File Layout and\n Mapping DOS FAT to MDFAT for details on how it manages this.\n\n█▌12-bit/16-bit▐█\n The FAT can contain 12-bit or 16-bit entries.\n\n 12-bit entries are efficient for media less than 384K--the entire FAT can\n fit in a single 512-byte disk sector. A 12-bit fat can map only 4086\n clusters (2^12=4096 and ff7H-fffH have special meaning--see below).\n\n The DOS Format command creates a 12-bit FAT when the partition is less\n than 10 MB. It could actually handle larger disks, but the clusters would\n need to be very large and wasteful. For instance, on a 32 MB disk, the\n clusters would need to be 8K (averaging 4K of cluster slack▲ per file).\n\n 16-bit entries were introduced with DOS 3.0 with the necessity of\n efficient handling the AT's \"whopping\" 20-Megabyte hard disk. A 16-bit\n FAT can track 65530 data clusters. Assuming a 16-sector cluster, that\n maxes out at 512 MB of storage. DoubleSpace's \"virtual clusters\" hit this\n FAT max.\n\n To determine if the FAT is 12-bit or 16-bit: The correct way (according to\n Microsoft) is to check the total clusters (e.g., via fn 32H). If there\n are 4086 or more, then it is a 16-bit fat.\n\n This should always work for partitions created/formatted after DOS 3.3.\n As a sanity check, you should consider looking at the abFileSysID field of\n the BootSectorRec and/or validating by seeing how big a FAT is (wFatSects)\n compared to the number of entries it contains (wTotSects/bClustSects) and\n you might look at the bFileSysCode field of the PartitionEntryRec.\n\n Note: It's a common misconception that it was that creation of the\n 16-bit FAT that first let DOS work with disks larger than 32\n Megabytes. In fact, the limiting factor is that INT 25H/26H\n (through which DOS performs its disk I/O) is unable to access\n a SECTOR number higher than 65535. Normally, sectors are 512\n bytes (½-K), so that sets the 32M limit.\n\n In DOS 4.0+, INT 25H/26H supports a technique for accessing\n sector numbers higher than 65535, and thus supports trans-32MB\n partitions. This has no effect on the layout of the FAT itself.\n Using 16-bit FAT entries and 16-sector clusters, DOS supports\n partitions up to 512 MB (twice that for 32-sector clusters,\n etc.).\n\n█▌Reading the FAT▐█\n To read the value of any entry in a FAT (as when following a FAT chain),\n first read the entire FAT into memory and obtain a starting cluster number\n from a directory.\n\n Then, for 12-bit entries:\n ■ Multiply the cluster number by 3 ═╗\n ■ Divide the result by 2 ═════════╩═► (each entry is 1.5 (3/2) bytes)\n ■ Read the WORD at the resulting address (offset from start of the FAT)\n ■ If the cluster number was even, mask the value by 0fffH (keep the low\n 12 bits). If the cluster number was odd, shift the value right by 4\n bits (keep the upper 12 bits)\n ■ The result is the entry for the next cluster in the chain (0fffH=the\n end).\n\n Note: A 12-bit entry can cross over a sector boundary, so be careful\n with 1-sector FAT-buffering schemes.\n\n For 16-bit entries, the action is simpler--each entry contains the 16-bit\n offset (from the start of the FAT) of the next entry in the chain (ffffH\n indicates the end of the chain).\n\n█▌FAT Entries▐█\n The first byte of the FAT is called the Media Descriptor (AKA the FAT ID\n byte). The next 2 bytes (12-bit FATs) or 3 bytes (16-bit FATs) are 0ffH.\n The rest of the FAT is composed of 12-bit or 16-bit cells that each\n represent one disk cluster. These cells will contain one of the following\n values:\n\n ■ 0000H ................. an available cluster\n ■ fff0H through fff7H ... a reserved cluster\n ■ fff7H ................. a bad cluster\n ■ fff8H through ffffH ... the end of an allocation chain\n ■ 0002H through ffefH ... the number of the next cluster in a chain\n\n Notes: ■ The high nibble of the value is used only in 16-bit FATs; for\n instance, a bad cluster is marked with ff7H in 12-bit FATs,\n and fff7H with 16-bit FATs.\n ■ Cluster numbers 0001H and 0002H should never appear in a FAT\n chain. You can think of the first two FAT entries as being\n \"symbolic representations\" of the FAT and root directory.\n\n█▌Converting a Cluster Number to a Sector Number▐█\n After you obtain a file's starting cluster number from a directory entry\n you will want to locate to actual disk sector that holds the file (or\n subdirectory) data.\n\n A diskette (or a DOS partition of a hard disk) is laid out like so:\n\n ■ Boot and reserved sector(s)\n ■ FAT #1\n ■ FAT #2 (optional -- not used on RAM disks; simulated by Dblspace)\n ■ root directory\n ■ data area (all file data reside here, including files for directories)\n\n Every section of this layout is variable and the sizes of each section\n must be known in order to perform a correct cluster-to-sector conversion.\n The following formulae represent all of the steps:\n\n RootDirSectors = wSecSize / (wRootEntries * 32)\n FatSectors = bFatCnt * wFatSects\n DataStart = wResSects + FatSectors + RootDirSectors\n\n INT 25h/26h Sector = DataStart + ((AnyClusterNo-2) * bClustSects)\n\n Where the variables in thisColor are obtained from the Boot Sector or\n from a BPB or DPBRec. The resulting sector number can be used in DX for\n INT 25H/26H DOS absolute disk access.\n\n Easier method: DOS fn 32H (first documented with DOS 5.0, but available\n with 2.0+) returns a DPBRec containing a field named wFirstData at offset\n 0bH. It is simply a pre-calculation of \"DataStart\" in the above formulae.\n\n█▌So What???▐█\n All this information about the FAT is irrelevant to most applications.\n However, writers of disk utilities must know this stuff in order to\n recover deleted files and lost data.\n\n Also, a DoubleSpace-aware program must look through the FAT and compare it\n to the MDFAT in order to report the actual compression ratio obtained for\n a file (that's how COMMAND.COM does it).\n\n Finally, a high-speed file management program may find use for this\n information. For instance, to create a list all files on a disk, it is\n roughly twice as fast to read the directory sectors yourself (compared to\n using DOS fns to find files via 4eH).\n\nSee Also: INT 25H/26H (direct disk read/write)\n Mapping DOS FAT to MDFAT\n Boot Sector Layout\n BPB: BIOS Parameter Block\n DPB: Drive Parameter Block\n Directory Entry\n Device Drivers\n Disk Drive Functions\n -♦-"
  },
  {
    "id": "360-fcb__file_control_block.html",
    "t": "FCB: File Control Block",
    "b": "FcbRec\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 1 bDrvID drive ID (see below)\n +1 8 abName left-justified, blank-padded (e.g. 'FILE '\n +9 3 abExt left-justified, blank-padded (e.g. 'EXT'\n +0cH 2 wCurBlock current block number\n +0eH 2 wRecSize logical record size\n +10H 4 lFileSize length of file\n +14H 2 rDate Date created/last modified in FileTimeRec format\n +14H 2 rTime Time created/last modified in FileDateRec format\n +16H 8 res (reserved, undocumented)\n +20H 2 wCurRecNo current position in current block (0-7fH)\n +21H 4 lRndmRecNo current record number in entire file\n 37 size of an FcbRec\n\n bDrvID Drive number. Before open: 0=default, 1=A, 2=B, etc.\n After open: 0=A, 1=B, etc.)\n abName Filename. If fewer than 8 characters, it is padded to 8 with\n spaces (20H)\n abExt File extension. If fewer than 3 characters, it is padded to 3\n with spaces (30H)\n wCurBlock Current block number (a block is 128 records). DOS sets to 0\n when the file is opened\n wRecSize Size of a record, in bytes. DOS sets to 128 on open.\n lFileSize Total size of the file, in bytes\n rDate File date in special format. See FileDateRec\n rTime File time in special format. See FileTimeRec\n wCurRecNo position within the current record (wCurRec)\n lRndmRecNo file position, specified as a number of records from the start\n of the file.\n\n Notes: ■ FCBs are obsolete, but still supported by DOS. There is no\n need to use this structure at all.\n\n ■ Unopened FCB: Before opening a file, you need only supply\n bDrvID, abName, and abExt (e.g.: 0,'MYFILE TXT') and leave\n room for DOS to fill in the other fields.\n\n ■ Opened FCB: After successfully opening an FCB, the bDrvID\n contains a non-zero drive number (A=1, B=3, etc), other fields\n have been set up for access to the start of the file.\n\n ■ I won't bother covering the arcane system of block-and-record\n bookkeeping used to position the file pointer. R.I.P.\n\n ■ In order to open files that have a particular file attribute,\n you must use an Extended FCB...\n\nFcbExtendedRec\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n -7 1 bSig ffH (signature indicates Extended FCB)\n -6 5 res reserved\n -1 1 bAttr file attribute\n +0 1 bDrvID drive ID (see below)\n .\n . (other fields as above)\n .\n ...that is simply an FcbRec, preceded by 7 bytes, with [FCB-7]\n being 0ffH and [FCB-1] being the file attribute. Weird, huh?\n\nSee Also: FCB File I/O\n Data Structures\n -♦-"
  },
  {
    "id": "361-file_attribute.html",
    "t": "File Attribute",
    "b": "The file attribute is a 1-byte bit-flag associated with each file, found\n in the file's directory entry and used in several DOS functions.\n\nFileAttrRec\n╓7┬6┬5┬4┬3┬2┬1┬0╖\n║ │a│d│v│s│h│r║\n╙─┴─┴╥┴╥┴╥┴╥┴╥┴╥╜ bit mask\n ║ ║ ║ ║ ║ ╚═► 0: 01H 1=Read-only (file can't be written/deleted)\n ║ ║ ║ ║ ╚═══► 1: 02H 1=Hidden\n ║ ║ ║ ╚═════► 2: 04H 1=System\n ║ ║ ╚═══════► 3: 08H 1=Volume label entry\n ║ ╚═════════► 4: 10H 1=subDirectory entry\n ╚═══════════► 5: 20H Archive bit. 1=file has NOT been backed up\n\n Some Commonly-Seen File Attributes\n Attr Meaning\n ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n 0 a normal file\n 3 read-only, hidden, and system (used in system files)\n 8 the volume label entry (should be found only in the root directory)\n 10H a directory\n 20H a normal file which has not been backed up by BACKUP or XCOPY\n ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n\n DOS Fn 11H and 4eH directory searches are inclusive. You can set one or\n more of the file attribute bits for Hidden, System, Directory, and\n Archive if you want to search for files with one or more of these\n attributes. When a bit is clear, files that have that attribute will NOT\n be found.\n\n For instance, if you want to locate directory entries only, you can use an\n attribute of 10H to obtain a set of all files including directories, then\n ignore all the entries that are not directories (having bit 4=0).\n\n If you specify an attribute with the Volume bit, the search will be\n exclusive, returning only the entry of the volume label (if any).\n\n DOS Fn 43H (set file attribute) will let you set or clear the Read-only,\n Hidden, System, and Archive bits. You cannot alter the Directory\n attribute bit, but you can add or remove other bits of the directory's\n attribute by specifying an attribute having all the desired bits for the\n directory EXCEPT bit 4.\n\nSee Also: Directory and File Functions\n Data Structures\n -♦-"
  },
  {
    "id": "362-file_handle.html",
    "t": "File Handle",
    "b": "Starting with DOS 2.0, a set of UNIX-like file functions were added to the\n DOS repertoire. When you open a file, DOS passes back a 16-bit value\n called a file handle. Thereafter, when you read, write, seek a position,\n or close the file, you refer to it by its handle.\n\n One nice feature is that you can refer to certain devices as if they were\n disk files by using one of the reserved DOS handles:\n\n Pre-defined DOS handles\n Handle Description\n▀▀▀▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n 0000H Standard Input Device (usually the keyboard)\n 0001H Standard Output Device (usually the screen)\n 0002H Standard Error Device (always CON--the screen. Use for messages)\n 0003H Standard AUX Device (AUX first serial port--COM1)\n 0004H Standard Printer (PRN first parallel printer port--LPT1)\n\n Notes: ■ Standard handles are automatically opened when your program\n starts:\n • Use fn 3fH and 40H to read and write.\n • Close one or more standard handles if an open fails due to\n lack of handles (or use fn 67H to increase the available\n number of handles).\n • One quick sanity check during debugging: The first file you\n open should generally be assigned handle # 5.\n\n ■ You can redirect Standard Input and Standard Output handles to\n a text file or another device. See I/O Redirection for\n details.\n\n ■ You can flush a standard handle via fn 68H (commit file)\n\nSee Also: Handle-Oriented File I/O\n Standard I/O\n Config.Sys (FILES= setting)\n -♦-"
  },
  {
    "id": "363-file_time_date_format.html",
    "t": "File Time/Date Format",
    "b": "FileTimeRec\n 1 1 1 1 1 1\n╓5┬4┬3┬2┬1┬0┬9┬8╥7┬6┬5┬4┬3┬2┬1┬0╖\n║ hour │ minute │ sec/2 ║\n╙─┴─┴─┴─┴─┴─┴─┴─╨─┴─┴─┴─┴─┴─┴─┴─╜ bits mask\n ╚═══╦═══╝ ╚════╦════╝ ╚═══════╩═► 0-4: 001fH 2-second units (0-30 valid)\n ║ ╚════════════════► 5-10: 07e0H minute (0-59 valid)\n ╚═══════════════════════════►11-15: f800H hour (0-23 valid)\n\nFileDateRec\n 1 1 1 1 1 1\n╓5┬4┬3┬2┬1┬0┬9┬8╥7┬6┬5┬4┬3┬2┬1┬0╖\n║ year │ month │ day ║\n╙─┴─┴─┴─┴─┴─┴─┴─╨─┴─┴─┴─┴─┴─┴─┴─╜ bits mask\n ╚═════╦═════╝ ╚══╦══╝ ╚═══════╩═► 0-4: 001fH day (0-31)\n ║ ╚══════════════► 5-8: 01e0H month (1-12 valid)\n ╚═════════════════════════► 9-15: e000H years since 1980 (0-119 valid)\n\n Notes: ■ These layouts are seen in directory entries (as when performing\n absolute disk reads; see DirEntryRec), FCBs, and in the\n FileInfoRec returned by DOS fns 4eH and 4fH (find file) and\n 57H (query/set file time/date).\n\n ■ DOS uses a different format for fns 2aH-2dH (system clock\n functions).\n\n ■ Remember that the date value is relative to 1980 (the\n approximate beginning of the IBM-PC era).\n\nSee Also: 5700H (query file time/date)\n 5701H (set file time/date)\n DirEntryRec\n -♦-"
  },
  {
    "id": "364-fileinforec.html",
    "t": "FileInfoRec",
    "b": "This structure is used in DOS fns 4eH and 4fH (find file) and\n fn 57H (query/set file time/date).\n\nFileInfoRec\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 21 reserved used by DOS in subsequent fn 4fH (find next)\n +15H 1 bAttr file attribute of file that was found\n +16H 2 rTime time created/modified in FileTimeRec format\n +18H 2 rDate date created/modified in FileDateRec format\n +1aH 4 lSize DWORD file size, in bytes\n +1eH 13 szFilespec 13-byte max ASCIIZ▲ filespec: \"filename.ext\",0\n (not blank-padded; e.g., MYFILE.BAT0____)\n 43 size of a FileInfoRec structure\n\nSee Also: File Attribute\n File Time/Date Format\n Data Structures\n -♦-"
  },
  {
    "id": "365-indos_flag.html",
    "t": "InDOS Flag",
    "b": "█▌Overview▐█\n When your program gets control via a timer interrupt INT 08H or INT 1cH\n or the keyboard interrupt INT 09H or any asynchronously-generated event,\n you must be very careful about using DOS functions.\n\n The reason is that DOS is not reentrant. DOS might be processing a\n service call at the time of the interrupt. If you then issue another\n INT 21H, you risk disaster.\n\n In general, when InDOS is set, you may use only DOS fns 01H-0cH (low-level\n character I/O). When it is clear, you can use all DOS fns. An exception\n occurs during INT 28H (see below).\n\n█▌InDOS Detection▐█\n Your program can check the state of the InDOS Flag as follows:\n ■ Early on (before you need it!) use DOS fn 34H (Get InDOS addr). Save\n the value returned in ES:BX.\n\n ■ Before popping up, check the byte at the InDOS address. A non-zero\n value means beware!. When InDOS is non-zero, DOS is processing an\n INT 21H service call and you must NOT use any DOS services except the\n low-level character I/O fns 01H-0cH.\n\n█▌INT 28H: OK to ignore InDOS▐█\n DOS invokes INT 28H (DOS Idle) when it is waiting for keyboard input and\n it takes special precautions before making the call. It switches stacks,\n making available all DOS functions except fns 01H-0cH.\n\n Thus, your TSR can hook INT 28H and popup with almost full availability of\n DOS services regardless of the InDOS setting -- you can open/read/close\n files, etc.\n\n But when taking control under INT 28H, do remember to avoid DOS fns\n 01H-0cH. For instance, to display text, use fn 40H or drop down to BIOS\n fn INT 10H 0eH. If you simply must use fns 01H-0cH, you must set the\n ErrorMode Flag to 1 beforehand (and use only fns 01H-0cH while it is set).\n\nSee Also: DOS fn 34H (get InDOS and ErrorMode address)\n DOS fn 01H-0CH (low-level character I/O)\n ErrorMode Flag\n INT 24H (Critical Error Handler)\n Process Control Functions\n TSR Functions\n -♦-"
  },
  {
    "id": "366-load_overlay_record__execoverlayrec_.html",
    "t": "Load Overlay Record (ExecOverlayRec)",
    "b": "This structure is used in fn 4b03H (load an overlay).\n\nExecParamRec\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 2 wStartSeg segment to load the overlay (at offset 0)\n +2 2 wReloFactor Relocation factor\n 4 length of an ExecOverlayRec\n\n wStartSeg The segment address at which to load the overlay. This memory\n must be owned by the caller.\n\n wReloFactor The factor to be added to each segment reference on the load\n module during segment fixup. For .EXE-format overlays, this\n is normally the same as wStartSeg. For .COM files (binary\n images that need no fixups), this should be 0.\n\nSee Also: Process Control Functions\n PSP: Program Segment Prefix\n DOS Environment\n -♦-"
  },
  {
    "id": "367-load_program_record__execloadrec_.html",
    "t": "Load Program Record (ExecLoadRec)",
    "b": "This structure is used in fn 4b01H (load a program without executing).\n\nExecParamRec\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 2 wEnvSeg segment of environment for child (0000=current)\n +2 4 pfCmdTail address of command line text to place at PSP:0080\n +6 4 pfrFCB_1 address of an FCB to be placed at PSP:005c\n +0ah 4 pfrFCB_2 address of an FCB to be placed at PSP:006c\n +0eh 4 lCsIp Dword to receive program entry address\n +12h 4 lSsSp Dword to receive program stack pointer address\n 22 length of an ExecLoadRec\n\n wEnvSeg and...\n pfCmdTail and...\n pfrFCB_1 and...\n pfrFCB_2 are as described for ExecParamRec.\n\n lCsIp is filled with the 32-bit address that should be used as the\n entry point for the program. DOS calculates this as it loads\n the program. Use a FAR JMP to this address to begin executing\n the child.\n lSsSp is filled with the 32-bit address that should be used for the\n stack segment and stack pointer for the program (as calculated\n by DOS).\n\nSee Also: Process Control Functions\n PSP: Program Segment Prefix\n DOS Environment\n -♦-"
  },
  {
    "id": "368-mcb__memory_control_block.html",
    "t": "MCB: Memory Control Block",
    "b": "This structure is used internally by DOS when it allocates memory.\n\nMemBlockRec\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 1 bSignature 'M' (4dH)=valid; 'Z'(5aH)=last block in list\n +1 2 wOwnerID segment address of PSP of owner (0=owns self)\n +3 2 wSizeParas allocation size in 16-byte paragraphs\n +5 3 res (reserved)\n +8 8 szOwnerName ASCIIZ▲ name of owner (DOS 4.0+)\n 16 size of a MemBlockRec\n +10H ? abBlockData allocation starts here and extends for\n wSizeParas*16 bytes. Another MemBlockRec will be\n at that address.\n\n Notes: ■ Memory blocks always start and end on a paragraph boundary.\n\n ■ After fn 4bH Exec, a Z block begins at (PSP-1):0 of the new\n process (16 bytes before the PSP).\n\n ■ sZOwnerName is 7 or fewer bytes, followed by 00H. When DOS\n loads a program, this field is filled-in with (part of)\n filename of the program. Subsequent allocations are not\n labeled by name (but the wBlockID is valid, so the owner name\n can be tracked down with a little effort).\n\n Note: Prior to DOS 4.0, this field contained garbage.\n\n ■ It can be entertaining to trace the MCBs and figure out how\n much memory is used by TSRs and so forth. An undocumented way\n to find the first or 'base' MemBlockRec to use DOS Fn 52H.\n See DosVarsRec (aka List Of Lists) for related info.\n\nSee Also: Memory Control Functions\n DosVarsRec\n Data Structures\n -♦-"
  },
  {
    "id": "369-predefined_environment_variables.html",
    "t": "Predefined Environment Variables",
    "b": "These environment variables are created by parts of DOS or can be set to\n custom values to modify how DOS acts:\n\n APPEND Data search path visible in the environment after Append /E.\n\n COMSPEC The name and location of the command processor.\n\n CONFIG The item chosen from a MultiConfig Menu in CONFIG.SYS.\n Typical usage is to test this value in AUTOEXEC.BAT. For\n instance:\n IF (%CONFIG%)==(DAN) Echo Hi Dan!\n or\n Goto %CONFIG%\n .\n .\n .\n :NO_EMS\n\n COPYCMD Option settings for the Copy command (DOS 6.2+).\n\n DIRCMD Option settings for the Dir command.\n\n DOSSHELL The directory for DOSSHELL.INI.\n\n MSDOSDATA The directory for some configuration and setup files used by\n DOS 6.0+ Msbackup, MSAV, Undelete.\n\n PATH The command search path.\n\n PROMPT The command prompt as set via the Prompt command.\n\n TEMP The location for I/O Redirection piping files. Also used for\n temporary files by Dosshell, Windows and other programs.\n Setting this to a large RAM disk can speed up Windows printing\n dramatically.\n\n Note: A few older programs look for TMP rather than TEMP.\n\n WINPMT The command prompt for DOS sessions under Windows. When a DOS\n session starts, Windows swaps PROMPT and WINPMT.\n\n windir In a DOS session under Windows, this identifies the drive and\n directory where Windows is stored.\n\nSee Also: DOS Environment\n CONFIG.SYS\n Data Structures\n -♦-"
  },
  {
    "id": "370-media_descriptor.html",
    "t": "Media Descriptor",
    "b": "DOS defines a 1-byte code that (sometimes) can be used to identify the\n type of media that is being used by a disk device. The Media Descriptor\n (also called the FAT ID byte) will be seen:\n\n ■ as a value obtained from DOS Fns 1bH, 1cH, and 32H\n ■ as the first byte of the FAT (DOS logical sector 1)\n ■ at offset 0aH of a BPBRec\n ■ at offset 15H of a BootSectorRec (in DOS logical sector 0)\n ■ in the data block used by DOS Fn 440dH (Generic IOCTL)\n\n Value Media Types Defined as of DOS 5.0\n ▀▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n f0H 3½\" (1.44 MB) 2 sides, 18 sectors\n 3½\" (2.88 MB 2 sides, 36 sectors\n 5¼\" (1.2 MB) 2 sides, 15 sectors\n (also used for other media types)\n\n f8H fixed disk, any capacity\n\n f9H 3½\" (720K) 2 sides, 9 sectors, 80 tracks\n 5¼\" (1.2 MB) 2 sides, 15 sectors, 80 tracks\n faH 5¼\" (320K) 1 side, 8 sectors, 80 tracks\n fbH 3½\" (640K) 2 sides, 8 sectors, 80 tracks\n\n fcH 5¼\" (180K) 1 side, 9 sectors, 40 tracks\n fdH 5¼\" (360K) 2 sides, 9 sectors, 40 tracks; also used on 8\" disks\n feH 5¼\" (160K) 1 side, 8 sectors, 40 tracks; also used on 8\" disks\n ffH 5¼\" (320K) 2 sides, 8 sectors, 40 tracks\n\n The media descriptor byte is not a particularly reliable way to ascertain\n media type. Refer to other fields of the BPBRec or BootSectorRec to\n obtain track, sector, and head information.\n\n For instance, the boot sector of a RAM disk may show it to be a hard disk\n (f8H) or even some other value.\n\nSee Also: fn 1bH and fn 1cH (get FAT info)\n fn 32H (get drive parameter block)\n BPBRec\n Device Drivers (see DvRq 01H and DvRq 02H)\n -♦-"
  },
  {
    "id": "371-psp__program_segment_prefix.html",
    "t": "PSP: Program Segment Prefix",
    "b": "This structure is created for each program that DOS executes.\n\nPspRec\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 2 wInt20 INT 20H instruction (cd 20) (old way to exit)\n +2 2 wNextSeg Segment addr just beyond end of program image\n +4 1 res1 (reserved)\n +5 5 abDispatch FAR CALL to DOS function dispatcher (obs)\n +0aH 4 pfTerminate terminate address. See INT 22H\n +0eH 4 pfCtlBrk Ctrl-Break handler address INT 23H\n +12H 4 pfCritErr Critical Error handler addr INT 24H\n +16H 22 res2 DOS reserved area\n 2 wParentPsp ◄undoc► segment of parent's PSP\n +2cH 2 wEnvSeg segment address of DOS environment\n +2eH 46 res3 DOS reserved area (handle table, et al.)\n +5cH 16 rFCB_1 an unopened FCB for 1st cmd parameter\n +6cH 20 rFCB_2 an unopened FCB for 2nd cmd parameter\n +80H 1 bCmdTailLen count of characters in command tail at 81H (also\n default setting for the DTA)\n +81H 127 abCmdTail characters from DOS command line\n 256 size of a PspRec structure\n\n wInt20 An obsolete way to terminate a program is to JMP here.\n wNextSeg Segment address of the paragraph just above the end of the\n program. This can be used to calculate the size of the load\n block (by subtracting the segment of the PSP itself). Memory\n at this address is NOT free for use.\n abDispatch An obsolete way to call DOS fns was to JMP here.\n\n pfTerminate On exit, DOS copies this to INT 22H vector\n pfCtrlBrk On exit, DOS copies this to INT 23H vector\n pfCritErr On exit, DOS copies this to INT 24H vector\n\n wParentPsp This undocumented 2-byte field at (offset 16H) contains the\n segment of the parent process's PSP (usually COMMAND.COM). By\n tracing backward along this chain, you can locate a wParentPsp\n which is the same as the PSP in which it resides. The wEnvSeg\n in that PSP points to the master environment, and careful\n manipulation of that data area will make changes to the\n DOS Environment that are remembered after your program exits\n (just changing your own copy of the environment will only\n affect you and your own spawns).\n\n wEnvSeg At program startup, DOS creates a copy of the DOS Environment\n area and places its segment address in this field.\n\n rFCB_1 The first filename in the command tail is formatted into an\n unopened FCB and placed here.\n rFCB_1 The second filename (note: no path info, so rarely used)\n\n bCmdTailLen The length of the command-line text tail.\n Also: The default address of the DTA is here (PSP:0080)\n abCmdTail The text of command-line parameters, not including the command\n name (except I/O redirection info has been removed). A CR\n (0dH) is appended, but not included in aCmdTailLen.\n\n Notes: ■ When a program starts running, DS and ES point to the start of\n that program's PSP. You may also obtain the PSP address via\n fn 51H.\n\n ■ The PSP segment address is used as the \"process ID\" in fns 50H,\n 51H, and 62H; it is used as the wOwnerID in an MemBlockRec.\n\n ■ Use the PSP information to parse filenames and options from the\n command line tail, learn how much RAM is available, find the\n environment etc. See Program Startup & Exit.\n\nSee Also: Program Startup & Exit\n Process Control Functions\n TSR Functions\n Data Structures\n -♦-"
  },
  {
    "id": "372-dos_fn_00h__terminate_a_program.html",
    "t": "DOS Fn 00H: Terminate a Program",
    "b": "Compatibility: 1.0+\n Expects: AH 00H\n CS segment of Program Segment Prefix of terminating process\n ──────────────────────────────────────────────────────────────────\n Returns: none\n ──────────────────────────────────────────────────────────────────\n Info: Exits to the parent process; passes control to the Terminate\n Vector in the PSP. Identical to the INT 20H Terminate. The CS\n segment register must be set to the PSP.\n\n Resets vectors for DOS interrupts 22H-24H (Terminate, Ctrl-Break,\n and Critical Error) to values saved from the parent's PSP.\n Flushes file buffers, but files should be closed if their length\n has changed.\n\n Notes: ■ It's easier and cleaner to use DOS fn 4cH (exit).\n\nSee Also: Process Control Functions\n DOS Functions\n -♦-"
  },
  {
    "id": "373-dos_fns_01h_0ch__low_level_i_o.html",
    "t": "DOS Fns 01H-0cH: Low-level I/O",
    "b": "Compatibility: 1.0+\n These low-level I/O functions are given special treatment. DOS switches\n to a special stack when calling these fns. The idea is to allow higher-\n level fns to call these without reentrancy problems. In particular, it is\n OK for device drivers to use fn 01H-0cH during initialization. And popup\n TSR programs must pay special attention to when these fns are available\n and when not.\n\n See TSR and InDOS Flag and ErrorMode Flag and INT 24H for related details.\n\n See: 01H Keyboard Input\n 02H Display Output\n 03H Auxiliary Input\n 04H Auxiliary Output\n 05H Printer Output\n 06H Console I/O\n 07H No Echo Unfiltered Console Input\n 08H No Echo Console Input\n 09H Display String\n 0aH Buffered String Input\n 0bH Check Input Status\n 0cH Clear & Input\n\nSee Also: Character I/O Functions\n DOS Functions\n -♦-"
  },
  {
    "id": "374-dos_fn_01h__keyboard_input.html",
    "t": "DOS Fn 01H: Keyboard Input",
    "b": "Compatibility: 1.0+\n Expects: AH 01H\n ──────────────────────────────────────────────────────────────────\n Returns: AL character fetched from the Standard Input\n ──────────────────────────────────────────────────────────────────\n Info: Reads (waits for) a character from the Standard Input Device.\n Echoes that character to the Standard Output Device. If\n Ctrl-Break is detected, INT 23H is executed.\n\n Notes: ■ Extended ASCII keystrokes (i.e., F1-F12, PgUp, cursor, etc)\n will require two calls to this function. The first call will\n return AL=0. The second will return AL with the extended ASCII\n code.\n\nSee Also: Character I/O Functions\n DOS Functions\n -♦-"
  },
  {
    "id": "375-dos_fn_02h__display_output.html",
    "t": "DOS Fn 02H: Display Output",
    "b": "Compatibility: 1.0+\n Expects: AH 02H\n DL character to send to the Standard Output\n ──────────────────────────────────────────────────────────────────\n Returns: none\n ──────────────────────────────────────────────────────────────────\n Info: Sends the character in DL to the Standard Output. Handles\n backspace (ASCII 8) by moving the cursor left and leaving the\n cursor there.\n\n If Ctrl-Break is detected, INT 23H is executed.\n\nSee Also: Character I/O Functions\n DOS Functions\n -♦-"
  },
  {
    "id": "376-dos_fn_03h__auxiliary_input.html",
    "t": "DOS Fn 03H: Auxiliary Input",
    "b": "Compatibility: 1.0+\n Expects: AH 03H\n ──────────────────────────────────────────────────────────────────\n Returns: AL character fetched from the Standard Auxiliary Device\n ──────────────────────────────────────────────────────────────────\n Info: Reads (waits for) a character from the Standard Auxiliary Device,\n COM1 or AUX, returning that character in AL.\n\n Notes: ■ Input is not buffered and must be polled (not interrupt\n driven).\n\n ■ When DOS starts up, the AUX port (COM1) is initialized to:\n 2400 baud\n no parity\n 1 stop bit\n 8-bit word\n\n ■ The DOS MODE command can be used to initialize various\n settings.\n\nSee Also: INT 14H\n COM Ports\n Character I/O Functions\n DOS Functions\n -♦-"
  },
  {
    "id": "377-dos_fn_04h__auxiliary_output.html",
    "t": "DOS Fn 04H: Auxiliary Output",
    "b": "Compatibility: 1.0+\n Expects: AH 04H\n DL character to send to the Standard Auxiliary Device\n ──────────────────────────────────────────────────────────────────\n Returns: none\n ──────────────────────────────────────────────────────────────────\n Info: Sends the character in DL to the Standard Auxiliary Device, COM1\n or AUX.\n\nSee Also: DOS Fn 03H Auxiliary Input\n INT 14H\n COM Ports\n Character I/O Functions\n DOS Functions\n -♦-"
  },
  {
    "id": "378-dos_fn_05h__printer_output.html",
    "t": "DOS Fn 05H: Printer Output",
    "b": "Compatibility: 1.0+\n Expects: AH 05H\n DL character to send to the Standard Printer Device\n ──────────────────────────────────────────────────────────────────\n Returns: none\n ──────────────────────────────────────────────────────────────────\n Info: Sends the character in DL to the Standard Printer Device\n (normally LPT1).\n\n Notes: ■ The DOS MODE command can redirect this output to a serial port.\n\nSee Also: INT 17H\n Printer Ports\n Character I/O Functions\n DOS Functions\n -♦-"
  },
  {
    "id": "379-dos_fn_06h__console_i_o.html",
    "t": "DOS Fn 06H: Console I/O",
    "b": "Compatibility: 1.0+\n Expects: AH 06H\n DL 0 to 0feH character to send to the Standard Output\n 0ffH request for input from the Standard Input\n ──────────────────────────────────────────────────────────────────\n Returns: ZF clear (NZ) if character is ready ══╦═► on input requests\n AL character read, if ZF is clear ════╝ (when DL=0ffH)\n ──────────────────────────────────────────────────────────────────\n Info: If DL is 0ffH, this performs a \"no wait\" console input, returning\n the Zero Flag (ZF) set (ZR) if there is no character ready. If a\n character is ready, returns ZF cleared (NZ) with the character\n that was read in AL.\n\n If DL is anything but 0ffH, DL is sent to the Standard Output.\n\n Notes: ■ Does not check for Ctrl-Break.\n ■ Call twice for Extended ASCII.\n\nSee Also: Character I/O Functions\n DOS Functions\n -♦-"
  },
  {
    "id": "380-dos_fn_07h__no_echo_unfiltered_console_input.html",
    "t": "DOS Fn 07H: No Echo Unfiltered Console Input",
    "b": "Compatibility: 1.0+\n Expects: AH 07H\n ──────────────────────────────────────────────────────────────────\n Returns: AL character fetched from the Standard Input\n ──────────────────────────────────────────────────────────────────\n Info: Reads (waits for) a character from the Standard Input Device,\n returning that character in AL. The character is not displayed.\n\n Notes: ■ Does not check for Ctrl-Break.\n ■ Call twice for Extended ASCII.\n ■ Use Fn 0bH to check status before calling (if you don't want to\n wait for a key).\n\nSee Also: Character I/O Functions\n DOS Functions\n -♦-"
  },
  {
    "id": "381-dos_fn_08h__no_echo_console_input.html",
    "t": "DOS Fn 08H: No Echo Console Input",
    "b": "Compatibility: 1.0+\n Expects: AH 08H\n ──────────────────────────────────────────────────────────────────\n Returns: AL character fetched from the Standard Input\n ──────────────────────────────────────────────────────────────────\n Info: Reads (waits for) a character from the Standard Input Device,\n returning that character in AL.\n\n If Ctrl-Break is detected, INT 23H is executed.\n\n Notes: ■ Call twice for Extended ASCII character input.\n\nSee Also: Character I/O Functions\n DOS Functions\n -♦-"
  },
  {
    "id": "382-dos_fn_09h__display_string.html",
    "t": "DOS Fn 09H: Display String",
    "b": "Compatibility: 1.0+\n Expects: AH 09H\n DS:DX address of a string terminated with a '$' (ASCII 24H)\n ──────────────────────────────────────────────────────────────────\n Returns: none\n ──────────────────────────────────────────────────────────────────\n Info: The string, up to the terminating character '$' is sent to the\n Standard Output.\n\n Backspaces are handled as in the 02H Display Char function.\n\n The Normal procedure for displaying a 'newline' is to embed a\n CR/LF pair (ASCII 0dH followed by ASCII 0aH) in the string.\n\n Strings containing '$' may be printed via 40H Write File (BX=0).\n\nSee Also: Character I/O Functions\n DOS Functions\n -♦-"
  },
  {
    "id": "383-dos_fn_0ah__buffered_string_input.html",
    "t": "DOS Fn 0aH: Buffered String Input",
    "b": "Compatibility: 1.0+\n Expects: AH 0aH\n DS:DX address of a length-prefixed input buffer (see below)\n ──────────────────────────────────────────────────────────────────\n Returns: DS:DX the buffer contains input terminated with CR (ASCII 13H) and\n identifies the length of the actual input\n ──────────────────────────────────────────────────────────────────\n Info: Reads a line of text (up to 254 bytes) from the Standard Input\n into a caller-supplied buffer. You must specify the maximum\n input length.\n\n On entry, the buffer at DS:DX must be set up as:\n ┌───┬───┬───┬───┬───┬───┬─ -\n │max│ ? │ ? ? ? ? ? max is maximum acceptable input\n └───┴───┴───┴───┴───┴───┴ - (range: 1 to 254)\n On exit, the buffer is filled:\n ┌───┬───┬───┬───┬───┬───┬─ -\n │max│len│ H I 0dH len is actual length of input,\n └───┴───┴───┴───┴───┴───┴ - less the terminating CR (e.g.,\n 02H)\n\n Characters are read from the Standard Input up to a CR\n (ASCII 0dH) or up to the value of max-1. If max-1 is reached,\n the console bell rings (beeps) for each character until Enter\n (CR) is read.\n\n The second byte of the buffer is filled with the actual length of\n the input, less the terminating CR. The final character in the\n buffer is always CR (which is not counted in the length byte).\n\n Notes: The DOS \"template\" editing keystrokes are in effect:\n ■ The initial contents of the buffer (up to len) are used as the\n \"current template string\". Special keys are handled as they\n are at a standard DOS prompt, for instance:\n [Esc] displays \"\\\" and restarts the edit;\n [F3] displays to the end of the template;\n [F5] displays \"@\" and stores the line as the template; etc.\n [Ins] toggles insert mode, [←] backs up and deletes, etc.\n\n ■ If len is set to 0 when called, then no template exists.\n\n ■ If Ctrl-Break is detected, INT 23H is executed and the buffer\n is left unchanged. The default Ctrl+Break handler displays ^C.\n\n ■ You may also obtain a \"cooked\" string of standard input using\n DOS Fn 3fH (with BX set to 00H).\n\nSee Also: Character I/O Functions\n DOS Functions\n -♦-"
  },
  {
    "id": "384-dos_fn_0bh__check_input_status.html",
    "t": "DOS Fn 0bH: Check Input Status",
    "b": "Compatibility: 1.0+\n Expects: AH 0bH\n ──────────────────────────────────────────────────────────────────\n Returns: AL 0ffH if a character is available from the Standard Input\n 0 if no character is available\n ──────────────────────────────────────────────────────────────────\n Info: Checks the status of the Standard Input.\n\n If Ctrl-Break is detected, INT 23H is executed.\n\n Notes: ■ Use before Fns 01H, 07H, and 08H to avoid having DOS wait for a\n key.\n\n ■ This is a simple, non-destructive way to check for Ctrl-Break\n during long calculations or other processing that does not\n normally look for input. It lets the user abort from such a\n sequence.\n\nSee Also: INT 16H\n Character I/O Functions\n DOS Functions\n -♦-"
  },
  {
    "id": "385-dos_fn_0ch__clear___input.html",
    "t": "DOS Fn 0cH: Clear & Input",
    "b": "Compatibility: 1.0+\n Expects: AH 0cH\n AL DOS input function number (01H, 06H, 07H, 08H, or 0aH)\n ──────────────────────────────────────────────────────────────────\n Returns: none\n ──────────────────────────────────────────────────────────────────\n Info: Clears the Standard Input type-ahead buffer then invokes the DOS\n input function specified by AL. This forces the system to wait\n for a character to be typed.\n\n These values are allowed for AL: 01H Kybd Input\n 06H Console I/O\n 07H NoEcho Unfiltered Input\n 08H NoEcho Input\n 0aH Buffered Input\n\n Notes: ■ This is normally used in cases when you want to ignore any\n keystrokes in the type-ahead buffer; for instance when\n prompting for an OK before formatting a disk.\n\nSee Also: Character I/O Functions\n DOS Functions\n -♦-"
  },
  {
    "id": "386-dos_fn_0dh__reset_disk.html",
    "t": "DOS Fn 0dH: Reset Disk",
    "b": "Compatibility: 1.0+\n Expects: AH 0DH\n ──────────────────────────────────────────────────────────────────\n Returns: none\n ──────────────────────────────────────────────────────────────────\n Info: Flushes all file buffers.\n\n This does NOT update file length in a directory. To ensure a\n file's length is correctly recorded, close the file via Fn 10H or\n 3eH.\n\n Notes: ■ All MS-DOS tools that buffer I/O data will honor this function,\n including the SmartDrv disk cache and caching performed by\n DoubleSpace. For instance, if you want to avoid having\n Smartdrv perform its periodic disk output during a time-\n critical program function, use Fn 0dH before starting that\n function.\n\n ■ Control does not return until all buffers have been flushed.\n\n ■ The default INT 23H Ctrl+Break handler calls this function when\n DOS detects Ctrl+Break or Ctrl+C.\n\nSee Also: Disk Drive Functions\n DOS Functions\n -♦-"
  },
  {
    "id": "387-dos_fn_0eh__select_dos_default_disk.html",
    "t": "DOS Fn 0eH: Select DOS Default Disk",
    "b": "Compatibility: 1.0+\n Expects: AH 0eH\n DL drive number (0=A, 1=B, etc.) to become the default disk\n ──────────────────────────────────────────────────────────────────\n Returns: AL total number of system drives\n ──────────────────────────────────────────────────────────────────\n Info: The drive identified in DL becomes the current DOS default drive\n (if it is a valid drive number).\n\n Error test; use DOS Fn 19H (Get CurDisk) to make sure it worked.\n\n Notes: ■ The return value in AL is number of drives of any type,\n including hard disks and 'logical' and phantom drives (such as\n drive B: in a 1-floppy system).\n\n ■ The return value is simply a count of valid drive IDs--not an\n indication of which drive IDs are valid.\n\n ■ This call triggers a critical error (INT 24H) when you select a\n drive that does not contain a diskette.\n\nVersions: DOS 3.0+ AL is the same as the value of LASTDRIVE=, as specified\n in CONFIG.SYS. The a typical default LASTDRIVE is 5.\n\nSee Also: 3bH (set default directory\n INT 11H (equipment check)\n INT 24H (critical error handler)\n Directory and File Functions\n DOS Functions\n -♦-"
  },
  {
    "id": "388-dos_fn_0fh__open_file_via_fcb.html",
    "t": "DOS Fn 0fH: Open File via FCB",
    "b": "Compatibility: 1.0+\n Expects: AH 0fH\n DS:DX address of an unopened FCB\n ──────────────────────────────────────────────────────────────────\n Returns: AL 0 if file opened without error (and FCB is updated)\n 0ffH if error occurred and file could not be opened\n ──────────────────────────────────────────────────────────────────\n Info: The file specified by the unopened FCB must already exist in the\n default directory on the drive specified in the FCB (0=default,\n 1=A, 2=B, etc). If not found, AL=0ffH upon return.\n\n The file is opened in compatibility Access Mode.\n\n In the FCB, if the bDrvID field is 0 before the call, it is\n filled with the drive number of the default disk (1=A, 2=B,\n etc.).\n\n The FCB curBlk field is set to 0.\n The FCB recSize field is set to 80H.\n The FCB file size and date are set from info in the directory\n\n Notes: ■ As with all FCB functions, this works only for files in the\n current directory.\n ■ The handle-oriented functions are MUCH easier to use.\n\nSee Also: DOS fn 3dh (open file via handle)\n FCB File I/O\n Handle-Oriented File I/O\n Directory and File Functions\n DOS Functions\n -♦-"
  },
  {
    "id": "389-dos_fn_10h__close_file_via_fcb.html",
    "t": "DOS Fn 10H: Close File via FCB",
    "b": "Compatibility: 1.0+\n Expects: AH 10H\n DS:DX address of an open FCB\n ──────────────────────────────────────────────────────────────────\n Returns: AL 0 if file closed without error\n 0ffH if file was not found where it was upon fn 0fH (open)\n ──────────────────────────────────────────────────────────────────\n Info: Closes a file that was opened using an FCB.\n\n The file entry must be in its original place in the current\n default directory of the disk from which it was opened.\n\n If the file IS found, the directory is updated, the file buffers\n are flushed, and AL=00H upon return.\n\n If the file IS NOT found, the directory is not updated, a variety\n of unsavory things happen, and AL=0ffH upon return.\n\nSee Also: Fn 3eh (close file via handle)\n FCB File I/O\n Handle-Oriented File I/O\n Directory and File Functions\n DOS Functions\n -♦-"
  },
  {
    "id": "390-dos_fn_11h__find_1st_matching_file_via_fcb.html",
    "t": "DOS Fn 11H: Find 1st Matching File via FCB",
    "b": "Compatibility: 1.0+\n Expects: AH 11H\n DS:DX address of an unopened FCB (filespec may contain '?'s)\n ──────────────────────────────────────────────────────────────────\n Returns: AL 00H if a matching filename found (and DTA is filled)\n ffH if no match was found\n ──────────────────────────────────────────────────────────────────\n Info: The DOS default directory is searched for a file that matches\n that in the FCB pointed to by DS:DX. AL returns 0ffH if no match\n is found.\n\n If a match is found, AL returns 00h, the DTA is filled with the\n first byte as the drive (A=1, B=2, etc.) and the DirEntryRec of\n the file is stored in the next 32 bytes.\n\n You can use an Extended FCB in the call to select specific files\n with specific file attributes. In this case, the DTA is filled\n with 0ffH, 7 bytes of 00s, the drive number, and the dir entry.\n\n In either case, the DTA is filled with a valid, unopened FCB.\n\n Use DOS Fn 12H Find Next FCB to search for additional matches.\n\n Notes: ■ If you intend to search for more files, don't perform any I/O\n operations on a \"found\" file. Copy the FCB somewhere else\n before opening it.\n\n ■ The DOS 2.0+ function 4eh Find 1st File is easier to use and\n employs normal d:\\path\\filespec format.\n\n ■ Although this fn has been superseded, it is still useful for\n programs that play around in DoubleSpace CVFs (see CVF Layout)\n since it returns the \"starting cluster number\" for a file.\n COMMAND.COM itself uses this in processing Dir /C.\n\nSee Also: Fn 1aH (set DTA)\n Fn 4eh (find first file)\n Directory and File Functions\n DOS Functions\n -♦-"
  },
  {
    "id": "391-dos_fn_12h__find_next_matching_file_via_fcb.html",
    "t": "DOS Fn 12H: Find Next Matching File via FCB",
    "b": "Compatibility: 1.0+\n Expects: AH 12H\n DS:DX address of an unopened FCB (filespec may contain '?'s)\n ──────────────────────────────────────────────────────────────────\n Returns: AL 0 if a matching filename found (and DTA is filled)\n 0ffH if no match was found\n ──────────────────────────────────────────────────────────────────\n Info: Use this after calling DOS Fn 11H Find 1st FCB with a wildcard▲\n filespec. Each subsequent call fills the DTA with the next\n matching filespec's directory entry and returns AL=00H if a match\n is found or AL=0ffH if no match was found.\n\n The reserved area of the FCB carries information used in\n continuing the search, so don't open or alter the FCB between\n calls to Fns 11H and 12H.\n\nSee Also: Fn 4fh (find next file)\n Directory and File Functions\n DOS Functions\n -♦-"
  },
  {
    "id": "392-dos_fn_13h__delete_file_via_fcb.html",
    "t": "DOS Fn 13H: Delete File via FCB",
    "b": "Compatibility: 1.0+\n Expects: AH 13H\n DS:DX address of an unopened FCB (filespec may contain '?'s)\n ──────────────────────────────────────────────────────────────────\n Returns: AL 0 if the file was deleted successfully\n 0ffH if file not found or access denied\n ──────────────────────────────────────────────────────────────────\n Info: All matching filespecs in the current default directory on the\n drive specified in the FCB are deleted.\n\n If no matching filespecs are found, or if access is denied (as\n when attempting to delete a file with a file attribute of\n Read-Only), AL returns 0ffH.\n\nSee Also: Fn 41h (delete file)\n Directory and File Functions\n DOS Functions\n -♦-"
  },
  {
    "id": "393-dos_fn_14h__read_sequential_file_via_fcb.html",
    "t": "DOS Fn 14H: Read Sequential File via FCB",
    "b": "Compatibility: 1.0+\n Expects: AH 14H\n DS:DX address of an opened FCB\n ──────────────────────────────────────────────────────────────────\n Returns: AL 0 if the read was successful and the DTA contains data\n 1 if EOF was reached and no data was read\n 2 if DTA+ FCB recSiz would overrun a segment (no read)\n 3 if EOF and a partial record was read (padded with 0s)\n ──────────────────────────────────────────────────────────────────\n Info: Reads recSize bytes from the file address specified by curBlk and\n curRec (as specified in the FCB) into the DTA. Then increments\n the block-and-record file address.\n\n Be sure to set curRec to 0 before starting sequential file\n operations, since Fn 0fH Open FCB does not initialize it.\n\nSee Also: Fn 1aH (set DTA)\n Fn 3fh (read from handle)\n FCB File I/O\n Handle-Oriented File I/O\n DOS Functions\n -♦-"
  },
  {
    "id": "394-dos_fn_15h__write_sequential_file_via_fcb.html",
    "t": "DOS Fn 15H: Write Sequential File via FCB",
    "b": "Compatibility: 1.0+\n Expects: AH 15H\n DS:DX address of an opened FCB\n ──────────────────────────────────────────────────────────────────\n Returns: AL 0 if the write was successful\n 1 if \"disk full\" error and no data was written\n 2 if DTA+ FCB recSize would overrun a segment (no write)\n ──────────────────────────────────────────────────────────────────\n Info: Writes recSize bytes from the DTA to the file address specified\n by curBlk and curRec (as specified in the FCB). Then increments\n the block-and-record file address.\n\n Be sure to set CurRec to 0 before starting sequential file\n operations, since DOS Fn 0fH Open FCB does not initialize it.\n\n Notes: ■ DOS buffers data until a full sector can be written at one time\n (or until the file is closed).\n\nSee Also: Fn 1aH (set DTA)\n Fn 40h (write to handle)\n FCB File I/O\n Handle-Oriented File I/O\n DOS Functions\n -♦-"
  },
  {
    "id": "395-dos_fn_16h__create_file_via_fcb.html",
    "t": "DOS Fn 16H: Create File via FCB",
    "b": "Compatibility: 1.0+\n Expects: AH 16H\n DS:DX address of an unopened FCB\n ──────────────────────────────────────────────────────────────────\n Returns: AL 0 if file created without error (and FCB is filled)\n 0ffH if error (file could not be created/opened)\n ──────────────────────────────────────────────────────────────────\n Info: The file specified by the unopened FCB is created on the drive\n specified in the FCB (0=default, 1=A, etc.) It is opened in the\n current DOS default directory for that drive.\n\n The FCB is filled as with DOS Fn 0fH Open FCB.\n\n If the file existed before this call, its directory entry is\n reused and the file length is set to 0.\n\n Notes: ■ Handle-oriented functions of DOS 2.0+ are MUCH easier to use.\n\nSee Also: Fn 3ch (create file)\n FCB File I/O\n Handle-Oriented File I/O\n DOS Functions\n -♦-"
  },
  {
    "id": "396-dos_fn_17h__rename_file_via_fcb.html",
    "t": "DOS Fn 17H: Rename File via FCB",
    "b": "Compatibility: 1.0+\n Expects: AH 17H\n DS:DX address of a special-format FCB\n ──────────────────────────────────────────────────────────────────\n Returns: AL 0 if the file was renamed successfully\n 0ffH file not found, new name already exists, other error\n ──────────────────────────────────────────────────────────────────\n Info: Renames a file in the current default directory. Use the\n following layout for renaming files with this function:\n\n ╔══► 0=default, 1=A, 2=B, etc.\noffset len ┌─╨─┬───────────────────────────────┬───────────┐\n +0 0cH │drv│ F I L E N A M E │ E X T │ ◄════ oldname\n ├───┴───┴───┴───┴───┴───┼───┴───┴───┴───┴───┴───┘\n +0cH 6 │ reserved │\n ├───┴───┴───┴───┴───┴───┴───────┬────────────┐\n +11H 0bH │ F I L E N A M E │ E X T │ ◄══════ newname\n └───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴────┘\n\n Either name may contain ? wildcard▲ characters:\n ■ In the oldname a wildcard causes a search for all matches in\n the default directory and renames each matching filespec.\n ■ In the newname it means: use the same character as found in\n that position in the oldname.\n\n Notes: ■ This function allows you to rename a directory by using an\n Extended FCB with the proper file attribute for the oldname.\n\nSee Also: Fn 56H (rename/move file)\n Directory and File Functions\n DOS Functions\n -♦-"
  },
  {
    "id": "397-dos_fn_19h__query_dos_default_disk.html",
    "t": "DOS Fn 19H: Query DOS Default Disk",
    "b": "Compatibility: 1.0+\n Expects: AH 19H\n ──────────────────────────────────────────────────────────────────\n Returns: AL DOS current default drive number (0=A, 1=B, etc.)\n ──────────────────────────────────────────────────────────────────\n Info: Returns the drive number of the current DOS default disk.\n\n Notes: ■ Add 'A' (65H) to AL to obtain a drive letter suitable for use\n in handle-oriented file operations.\n\nSee Also: Fn 0eH (set default disk)\n Directory and File Functions\n DOS Functions\n -♦-"
  },
  {
    "id": "398-dos_fn_1ah__set_disk_transfer_address__dta_.html",
    "t": "DOS Fn 1aH: Set Disk Transfer Address (DTA)",
    "b": "Compatibility: 1.0+\n Expects: AH 1aH\n DS:DX address for the DTA\n ──────────────────────────────────────────────────────────────────\n Returns: none\n ──────────────────────────────────────────────────────────────────\n Info: This sets the Disk Transfer Address for use in subsequent DOS\n function calls.\n\n Notes: ■ All FCB-type file accesses take place at the DTA\n\n ■ File-finding fns 11H, 12H, 4eH and 4fH place data into the DTA\n\n ■ The DTA is global, so be careful when setting it in a recursive\n or re-entrant procedure or when acting as a TSR\n\n ■ When a program is started, its DTA is at offset 80H in the PSP.\n Be wary of operations which will put more than 128 bytes in the\n DTA since that would transfer data over top of whatever follows\n the PSP in memory.\n\nSee Also: Fn 2Fh Get DTA\n Program Startup & Exit\n DOS Functions\n -♦-"
  },
  {
    "id": "399-dos_fn_1bh__get_drive_info__current_disk_.html",
    "t": "DOS Fn 1bH: Get Drive Info (current disk)",
    "b": "Compatibility: 2.0+\n Expects: AH 1bH\n ──────────────────────────────────────────────────────────────────\n Returns: DS:BX address of a FAT ID byte (might indicate disk type)\n DX total clusters (allocation units) on the disk\n AL sectors per cluster\n CX bytes per sector\n ──────────────────────────────────────────────────────────────────\n Info: Returns information on the size and type of the default disk.\n\n Disk size in bytes = (DX * AL * CX)\n\n Find free space with DOS Fn 36h Disk Free or 32h Disk Info\n\n Warning: Notice that this changes the value of DS segment register.\n\nVersions: DOS 1.x held the FAT in memory and returned DS:BX => FAT\n DOS 2.0+ may retain only a portion of the FAT in memory.\n\nSee Also: Fns 1cH 36H 32H\n File Allocation Table\n DOS Functions\n -♦-"
  },
  {
    "id": "400-dos_fn_1ch__get_drive_info__any_disk_.html",
    "t": "DOS Fn 1cH: Get Drive Info (any disk)",
    "b": "Compatibility: 2.0+\n Expects: AH 1cH\n DL drive number (0=default, 1=A, etc).\n ──────────────────────────────────────────────────────────────────\n Returns: DS:BX address of a FAT ID byte (might indicate disk type)\n DX total clusters (allocation units) on the disk\n AL sectors per cluster\n CX bytes per sector\n ─────────────────────────────────────────────────────────────────\n Info: Returns information on the size and type of the default disk.\n Same as DOS Fn 1bH (get FAT current drive) except that DL\n specifies the drive for which you want the information.\n\n Disk size in bytes = (DX * AL * CX).\n\n Find free space with DOS Fn 36h Disk Free or 32h Disk Info.\n\n Warning: Notice that this changes the value of DS segment register.\n\nVersions: Not documented for DOS 1.x\n\nSee Also: Fns 1bH 36H 32H\n File Allocation Table\n DOS Functions\n -♦-"
  },
  {
    "id": "401-dos_fn_1fh__get_drive_parameter_block__current_disk_.html",
    "t": "DOS Fn 1fH: Get Drive Parameter Block (current disk)",
    "b": "Compatibility: 5.0+\n Expects: AH 1fH\n ──────────────────────────────────────────────────────────────────\n Returns: AL 0ffh on error, else...\n 0 no error and...\n DS:BX address of a Drive Parameter Block for the default drive\n ──────────────────────────────────────────────────────────────────\n Info: Returns a block of information that is useful for applications\n and utilities which perform sector-level access of disk drives\n supported by device drivers.\n\n This returns the pointer for the current default drive. A more\n flexible version is DOS Fn 32H (which see for related details).\n\n Warning: ■ Alters DS.\n\nVersions: ■ This known to work starting with 3.0, but has only been\n documented since 5.0.\n\nSee Also: Fn 32H (get drive parameter block)\n INT 25H/26H\n Drive Parameter Block\n Disk Drive Functions\n DOS Functions\n -♦-"
  },
  {
    "id": "402-dos_fn_21h__read_random_file_record.html",
    "t": "DOS Fn 21H: Read Random File Record",
    "b": "Compatibility: 1.0+\n Expects: AH 21H\n DS:DX address of an opened FCB\n ──────────────────────────────────────────────────────────────────\n Returns: AL 0 if read was successful (and DTA is filled with data)\n 1 if EOF was reached and no data was read\n 2 if DTA + FCB RecSize would overrun a segment (no read)\n 3 if EOF and a partial record was read (padded with 0s)\n ──────────────────────────────────────────────────────────────────\n Info: Sets FCB curBlk and curRec to the agree with randomRec then reads\n recSize bytes from the specified file address, placing the data\n into memory starting at the DTA.\n\n Notes: ■ Be sure to set recSize to the record length and randomRec in\n the FCB to the desired record number.\n\nSee Also: Fn 3fH (read file via handle)\n FCB File I/O\n Handle-Oriented File I/O\n DOS Functions\n -♦-"
  },
  {
    "id": "403-dos_fn_22h__write_random_file_record.html",
    "t": "DOS Fn 22H: Write Random File Record",
    "b": "Compatibility: 1.0+\n Expects: AH 22H\n DS:DX address of an opened FCB\n ──────────────────────────────────────────────────────────────────\n Returns: AL 0 if write was successful\n 1 if disk full error\n 2 if DTA + FCB recSize would overrun a segment (no write)\n ──────────────────────────────────────────────────────────────────\n Info: Sets FCB curBlk and curRec to the agree with randomRec then\n writes recSize bytes from the DTA to disk at the specified file\n address.\n\n Notes: ■ Be sure to set recSize to the record length and randomRec in\n the FCB to the desired record number.\n\nSee Also: Fn 40H (write file via handle)\n FCB File I/O\n Handle-Oriented File I/O\n DOS Functions\n -♦-"
  },
  {
    "id": "404-dos_fn_23h__query_file_size_via_fcb.html",
    "t": "DOS Fn 23H: Query File Size via FCB",
    "b": "Compatibility: 1.0+\n Expects: AH 23H\n DS:DX address of an opened FCB\n ──────────────────────────────────────────────────────────────────\n Returns: AL 0 if file was found\n 0ffH if file was not in current directory\n ──────────────────────────────────────────────────────────────────\n Info: Sets the randomRec field of the FCB to indicate how many records\n of recSize bytes are contained in the file.\n\n Be sure to set recSize before calling. If you set recSize to 1,\n then RandomRec will hold a 4-byte value of file size in bytes.\n\n Notes: ■ You may find it easier to determine the file size by using 3dH\n Open Handle followed by 42H Lseek Handle (with AL=2).\n\n ■ A faster way is to use fn 4eH (find file).\n\n ■ The fastest way may be to read the directory. See INT 25H.\n\nSee Also: Directory and File Functions\n FCB File I/O\n DOS Functions\n -♦-"
  },
  {
    "id": "405-dos_fn_24h__set_random_file_block_address.html",
    "t": "DOS Fn 24H: Set Random File Block Address",
    "b": "Compatibility: 1.0+\n Expects: AH 24H\n DS:DX address of an opened FCB\n ──────────────────────────────────────────────────────────────────\n Returns: none\n ──────────────────────────────────────────────────────────────────\n Info: Sets the randomRec field of the FCB to the file address that\n corresponds to the values of curBlk and curRec.\n\nSee Also: Directory and File Functions\n FCB File I/O\n 42H (Lseek handle)\n DOS Functions\n -♦-"
  },
  {
    "id": "406-dos_fn_25h__set_interrupt_vector.html",
    "t": "DOS Fn 25H: Set Interrupt Vector",
    "b": "Compatibility: 1.0+\n Expects: AH 25H\n AL interrupt number\n DS:DX interrupt vector: address of code to handle an interrupt\n ──────────────────────────────────────────────────────────────────\n Returns: none\n ──────────────────────────────────────────────────────────────────\n Info: Sets the interrupt vector table entry for interrupt number AL to\n DS:DX.\n\n Same as storing a 4-byte address into 0000:(AL*4), but lets DOS\n know what you're doing, and ensures that no hardware interrupt\n occurs while the vector change is taking place.\n\n See Interrupts and BIOS Services for a list of interrupt numbers.\n\nSee Also: Fn 35H (get interrupt vector)\n TSR/Popup Functions\n DOS Functions\n -♦-"
  },
  {
    "id": "407-dos_fn_26h__create_program_segment_prefix.html",
    "t": "DOS Fn 26H: Create Program Segment Prefix",
    "b": "Compatibility: 1.0+\n Expects: AH 26H\n DX segment address (paragraph) for new PSP\n CS segment of a PSP to use as a template for the new PSP\n ──────────────────────────────────────────────────────────────────\n Returns: none\n ──────────────────────────────────────────────────────────────────\n Info: Sets up a PSP for a child process at DX:0000.\n\n ■ the current PSP (100H bytes starting at CS:0) is copied to DX:0\n\n ■ the MemTop field is adjusted\n\n ■ Terminate, Ctrl-Break, and Critical Error vectors are copied\n into the PSP from the vectors for INT 22H, INT 23H and INT 24H.\n\n You may then load a program from disk and run it with a FAR JMP.\n See EXE Header for information on manually loading an EXE-format\n file. See Program Startup & Exit for related information.\n\n Notes: ■ Avoid this call; use DOS Fn 4b00H (exec) or 4b01H (load\n overlay) instead.\n\n ■ If you intercept INT 21H be sure to leave the correct CS:IP on\n the stack.\n\nSee Also: PSP: Program Segment Prefix\n DOS Functions\n -♦-"
  },
  {
    "id": "408-dos_fn_27h__read_random_file_block.html",
    "t": "DOS Fn 27H: Read Random File Block",
    "b": "Compatibility: 1.0+\n Expects: AH 27H\n DS:DX address of an opened FCB\n CX number of records to read\n ──────────────────────────────────────────────────────────────────\n Returns: AL 0 if read was successful and DTA is filled with data\n 1 if EOF was reached and no data was read\n 2 if DTA + FCB (RecSize * CX) would overrun a segment\n 3 if EOF and a partial record was read (padded with 0s)\n CX actual number of records read\n ──────────────────────────────────────────────────────────────────\n Info: Reads multiple records from the file starting at the file address\n specified by the randomRec field of the FCB. Stores the data\n into memory starting at the DTA. Reads (FCB recSize*CX) bytes\n from the file.\n\n The randomRec and curBlk and curRec fields are adjusted to point\n to the next record (the first record that wasn't read).\n\nSee Also: Fn 3fH (read file via handle)\n FCB File I/O\n Handle-Oriented File I/O\n DOS Functions\n -♦-"
  },
  {
    "id": "409-dos_fn_28h__write_random_file_block.html",
    "t": "DOS Fn 28H: Write Random File Block",
    "b": "Compatibility: 1.0+\n Expects: AH 28H\n CX number of records to write (if CX=0, set file's size)\n DS:DX address of an opened FCB\n ──────────────────────────────────────────────────────────────────\n Returns: AL 0 if write was successful\n 1 if disk full error\n 2 if DTA + FCB (RecSize * CX) would overrun a segment\n CX actual number of records written\n ──────────────────────────────────────────────────────────────────\n Info: Writes multiple records to the file starting at the file address\n specified by the randomRec field of the FCB. Data is taken from\n memory starting at the DTA.\n\n Actual bytes written is (recSize * CX).\n\n If CX = 0 on entry, the file's size is shrunk or expanded to\n randomRec*recSize and no data is written.\n\nSee Also: Fn 40H (write file via handle)\n FCB File I/O\n Handle-Oriented File I/O\n DOS Functions\n -♦-"
  },
  {
    "id": "410-dos_fn_29h__parse_filename.html",
    "t": "DOS Fn 29H: Parse Filename",
    "b": "Compatibility: 1.0+\n Expects: AH 29H\n AL bit-flags to select parsing options (see below)\n DS:SI address of source text line to parse\n ES:DI address of buffer to hold resulting unopened FCB\n ──────────────────────────────────────────────────────────────────\n Returns: AL 0 if result FCB has no wildcard characters \n 1 if result FCB does contain wildcards▲\n 0ffH if invalid drive ID in filespec\n DS:SI updated: points to the character just past the filename\n ES:DI preserved: points to the unopened FCB\n ──────────────────────────────────────────────────────────────────\n Info: Creates an unopened FCB from a text line or command parameter.\n The text starting at DS:SI is parsed for a filespec in the format\n D:FILENAME.EXT and the buffer at ES:DI is filled in as a\n properly-formatted, unopened FCB.\n\n ═══► This Fn is NOT useful for a text line containing a pathname.\n Basically, this is a quick way to skip leading spaces, upshift\n and remove the dot (.) from a filename input from the keyboard.\n It converts * into a series of ?s and it allows you to pre-set a\n default in the destination FCB (e.g., extension = \"WKS\").\n\n The parsing action depends upon these bit flags in AL:\n ╓7┬6┬5┬4┬3┬2┬1┬0╖\n ║0 0 0 0│ │ │ │ ║\n ╙─┴─┴─┴─┴╥┴╥┴╥┴╥╜ bit mask value\n ║ ║ ║ ╚═► 0: 1=scan off leading separators (a | 01H)\n ║ ║ ╚═══► 1: 1=use FCB drive byte as a default (a | 02H)\n ║ ╚═════► 2: 1=use FCB filename as a default (a | 04H)\n ╚═══════► 3: 1=use FCB extension as a default (a | 08H)\n\nSee Also: Fn 60H (Get Truename)\n FCB File I/O\n DOS Functions\n -♦-"
  },
  {
    "id": "411-dos_fn_2ah__query_dos_date.html",
    "t": "DOS Fn 2aH: Query DOS Date",
    "b": "Compatibility: 1.0+\n Expects: AH 2aH\n ──────────────────────────────────────────────────────────────────\n Returns: CX year (1980 to 2099)\n DH month (1 to 12)\n DL day (1 to 31)\n\n AL day of the week (0=Sun, 1=Mon,...6=Sat) DOS 1.1+\n ──────────────────────────────────────────────────────────────────\n Info: Returns the current date as known to the system.\n\nVersions: ■ DOS 2.x technical manuals do not guarantee the return of the\n day value in AL; however, all DOS versions after (1.0) do so.\n ■ DOS Versions prior to 2.1 had problems rolling-over the date.\n\nSee Also: Fn 2cH (get time)\n Fn 2bH (set date)\n DOS Functions\n -♦-"
  },
  {
    "id": "412-dos_fn_2bh__set_dos_date.html",
    "t": "DOS Fn 2bH: Set DOS Date",
    "b": "Compatibility: 1.0+\n Expects: AH 2bH\n CX year (1980 to 2099)\n DH month (1 to 12)\n DL day (1 to 31)\n ──────────────────────────────────────────────────────────────────\n Returns: AL 0 if date was valid\n 0ffH if date was invalid (30 day values hath September...)\n ──────────────────────────────────────────────────────────────────\n Info: Sets the DOS system date. The system time is not changed.\n\nVersions: ■ DOS 3.3+ On AT and PS/2 systems, this also sets the date in\n the battery-backed CMOS memory.\n\nSee Also: Fn 2cH (set time)\n Fn 2aH (set date)\n DOS Functions\n -♦-"
  },
  {
    "id": "413-dos_fn_2ch__query_dos_time.html",
    "t": "DOS Fn 2cH: Query DOS Time",
    "b": "Compatibility: 1.0+\n Expects: AH 2cH\n ──────────────────────────────────────────────────────────────────\n Returns: CH hour (0 to 23)\n CL minutes (0 to 59)\n DH seconds (0 to 59)\n DL hundredths of a second (0 to 99)\n ──────────────────────────────────────────────────────────────────\n Info: Returns the current time as known to the system.\n\n Notes: ■ Since the system clock ticks at 18.2 ticks per second (55ms)\n intervals, DL is accurate to about ±4/100ths of a second.\n\n ■ See INT 08H and INT 15H for other timer-related information.\n\nSee Also: Fn 2dH (set time)\n Fn 2aH (get date)\n DOS Functions\n -♦-"
  },
  {
    "id": "414-dos_fn_2dh__set_dos_time.html",
    "t": "DOS Fn 2dH: Set DOS Time",
    "b": "Compatibility: 1.0+\n Expects: AH 2dH\n CH hour (0 to 23)\n CL minutes (0 to 59)\n DH seconds (0 to 59)\n DL hundredths of a second (0 to 99)\n ──────────────────────────────────────────────────────────────────\n Returns: AL 0 if time was valid\n 0ffH if time was not valid\n ──────────────────────────────────────────────────────────────────\n Info: Sets the DOS system time.\n\nVersions: ■ DOS 3.3+ On AT and PS/2 systems, this also sets the time in\n the battery-backed CMOS memory.\n\nSee Also: Fn 2cH (get time)\n Fn 2bH (set date)\n DOS Functions\n -♦-"
  },
  {
    "id": "415-dos_fn_2eh__set_reset_verify_switch.html",
    "t": "DOS Fn 2eH: Set/Reset Verify Switch",
    "b": "Compatibility: 1.0+\n Expects: AH 2eH\n AL 0 to turn verify OFF\n 1 to turn verify ON\n DL 0 (need for DOS 1.x and 2.x only)\n ──────────────────────────────────────────────────────────────────\n Returns: none\n ──────────────────────────────────────────────────────────────────\n Info: Selects whether DOS should verify (check the CRC▲ on) each sector\n after it is written to disk.\n\n This slows down disk write operations, but it ensures maximum\n data integrity.\n\n DOS Fn 54H returns the current DOS verify status.\n\n Notes: ■ The Verify flag is a system-global setting. If you change it,\n you should restore the original value before exiting.\n\nSee Also: Fn 54H (get verify\n Disk Drive Functions\n DOS Functions\n -♦-"
  },
  {
    "id": "416-dos_fn_2fh__query_disk_transfer_address__dta_.html",
    "t": "DOS Fn 2fH: Query Disk Transfer Address (DTA)",
    "b": "Compatibility: 2.0+\n Expects: AH 2fH\n ──────────────────────────────────────────────────────────────────\n Returns: ES:BX address of the start of the current DTA\n ──────────────────────────────────────────────────────────────────\n Info: Returns the address of the start of the Disk Transfer Address.\n\n Since the DTA is a global value for any process, in recursive\n procedures (as when traversing a directory tree), you may need\n to use this procedure to save the DTA, then set it back via fn\n 1aH (set DTA).\n\n You should also use this when saving the state of the system\n before popping up as a TSR.\n\nSee Also: Fn 1aH (set DTA)\n TSR/Popup Functions\n DOS Functions\n -♦-"
  },
  {
    "id": "417-dos_fn_30h__get_dos_version_number.html",
    "t": "DOS Fn 30H: Get DOS Version Number",
    "b": "Compatibility: 2.0+\n Expects: AH 30H\n ──────────────────────────────────────────────────────────────────\n Returns: AL major version number\n AH minor version number (note: binary value -- x.20 is 14H)\n BX,CX (OEM info, see below) DOS 2.0+\n ──────────────────────────────────────────────────────────────────\n Info: Returns AX with the value of the current DOS version. For\n instance, if DOS 3.20 is active, AL returns 3 and AH returns 14H\n (20 decimal).\n\n Use this function early in your program to find out what\n capabilities are present.\n\nVersions: ■ 5.0+\n Setver intercepts this call and may return a cooked value if\n the caller is on its hit list. Use Fn 3306H to obtain the\n actual DOS version number.\n ■ 1.x\n Since this function does not exist with DOS 1.x, you should set\n AL to 0 before calling it. If AL then returns with 0, then you\n can assume that you are running DOS 1.x.\n ■ 2.0+\n Values returned in BX and CX may vary from OEM to OEM. BH may\n return holding an OEM ID number and BL:CX may be set to a\n 24-bit value used by the OEM to identify sub-versions.\n\nSee Also: Fn 3306H (get DOS version info)\n DOS Function Index - by DOS Version\n DOS Versions (overview and history)\n System Information Functions\n DOS Functions\n -♦-"
  },
  {
    "id": "418-dos_fn_31h__terminate___stay_resident.html",
    "t": "DOS Fn 31H: Terminate & Stay Resident",
    "b": "Compatibility: 2.0+\n Expects: AH 31H\n AL exit code▲ to be made available to fn 4dH\n DX memory size to keep resident, in 16-byte paragraphs\n ──────────────────────────────────────────────────────────────────\n Returns: none (not applicable)\n ──────────────────────────────────────────────────────────────────\n Info: Exits to the parent process, leaving code and data in memory and\n setting the exit code in AL. See TSR for related topics.\n\n DOS sets the initial memory allocation (at your PSP segment\n address) to the size specified by DX and returns control to the\n parent process, keeping that much memory resident (bytes\n remaining resident = DX * 16).\n\n This function also performs the following actions:\n ■ Flushes file buffers and closes all open files.\n ■ Sets the INT 22H vector to the value at PSP:000AH.\n ■ Sets the INT 23H vector to the value at PSP:000EH.\n ■ Sets the INT 24H vector to the value at PSP:0012H (2.0+).\n\n Notes: ■ This DOES NOT free up any other blocks allocated via Fn 48H.\n\n It's wise to free your environment block beforehand (call\n Fn 49H with ES= the WORD at PSP offset 2cH).\n\n ■ This function supersedes INT 27H which does not return an exit\n code and can't install resident programs larger than 64K.\n\nSee Also: TSR\n Process Control\n Program Startup & Exit\n DOS Functions\n -♦-"
  },
  {
    "id": "419-dos_fn_32h__get_dpb__drive_parameter_block_.html",
    "t": "DOS Fn 32H: Get DPB (Drive Parameter Block)",
    "b": "Compatibility: 2.0+\n Expects: AH 32H\n DL drive number (0=default, 1=A, etc.)\n ──────────────────────────────────────────────────────────────────\n Returns: AL 0 if DL was a valid drive\n 0ffH if invalid drive\n DS:BX address of Drive Parameter Block (DPB) for requested drive\n ──────────────────────────────────────────────────────────────────\n Info: Returns a block of information that is useful for utilities which\n perform sector-level access of disk drives supported by device\n drivers.\n\n Some disk drives (especially non-bootable drives) work via their\n device driver interface only. These drives might not contain\n valid information in the Boot Sector and Partition Table, making\n it very hard to locate, for instance, the size of the root\n directory or the number of FATs, etc. The DPBRec contains all\n this information in a nicely-formatted structure.\n\n This may be the only way to find the address of a device driver.\n\n Warning: ■ Alters the value of the DS segment register.\n\nSee Also: Fn 1fH (get DPB, default disk)\n Drive Parameter Block\n INT 25H/26H (absolute disk I/O)\n Disk Drive Functions\n DOS Functions\n -♦-"
  },
  {
    "id": "420-dos_fn_33h__set_query_break_check__query_dos_info.html",
    "t": "DOS Fn 33H: Set/Query Break-check; Query DOS Info",
    "b": "See: Fn 3300H (query break-check level)\n Fn 3301H (set break-check level)\n\n Fn 3305H (query boot drive)\n Fn 3306H (query DOS version info)\n\nSee Also: System Information Functions\n INT 23H\n DOS Functions\n -♦-"
  },
  {
    "id": "421-dos_fn_3300h__query_break_check_flag.html",
    "t": "DOS Fn 3300H: Query Break-Check Flag",
    "b": "Compatibility: 2.0+\n Expects: AX 3300H\n ──────────────────────────────────────────────────────────────────\n Returns: DL current break level (0=OFF, 1=ON)\n ──────────────────────────────────────────────────────────────────\n Info: DL is returned with the current Ctrl-Break checking state.\n\n When Break is ON, DOS checks for Ctrl-Break (or Ctrl+C) from the\n console during most functions (except 06H and 07H). When\n detected, INT 23H is executed (if INT 23H has not been\n intercepted, this will abort the process).\n\n When Break is OFF, DOS checks for Ctrl-Break during standard I/O,\n standard printer, and standard AUX operations\n only.\n\nSee Also: Fn 3301H (set break-checking state)\n Fn 0bH (get input status)\n INT 23H\n DOS Functions\n -♦-"
  },
  {
    "id": "422-dos_fn_3301h__set_break_check_level.html",
    "t": "DOS Fn 3301H: Set Break-check Level",
    "b": "Compatibility: 2.0+\n Expects: AX 3301H\n DL desired break level (0=OFF, 1=ON)\n ──────────────────────────────────────────────────────────────────\n Returns: none\n ──────────────────────────────────────────────────────────────────\n Info: Sets the DOS break-checking level to the value in DL.\n\n When Break is ON (DL=1), DOS checks for Ctrl-Break (or Ctrl+C)\n from the console during most functions (except 06H and 07H).\n When detected, INT 23H is executed (if INT 23H has not been\n intercepted, this will abort the process).\n\n When Break is OFF, DOS checks for Ctrl-Break during standard I/O,\n standard printer, and standard AUX operations\n only.\n\n Notes: ■ The Break flag is a system-global setting. If you change it,\n you should restore the original value before exiting.\n\nSee Also: Fn 3300H (query break-checking state)\n Fn 0bH (get input status)\n INT 23H\n DOS Functions\n -♦-"
  },
  {
    "id": "423-dos_fn_3305h__get_boot_drive.html",
    "t": "DOS Fn 3305H: Get Boot Drive",
    "b": "Compatibility: 4.0+\n Expects: AX 3305H\n ──────────────────────────────────────────────────────────────────\n Returns: DL boot drive (1=A, 2=B, etc.)\n ──────────────────────────────────────────────────────────────────\n Info: Returns with DL containing the number of the drive which was used\n to boot the system.\n\n You can use this to help locate CONFIG.SYS or AUTOEXEC.BAT or\n DBLSPACE.BIN, etc. (files that live in the root of the boot\n disk).\n\nSee Also: System Information Functions\n DOS Functions\n -♦-"
  },
  {
    "id": "424-dos_fn_3306h__get_dos_version_info.html",
    "t": "DOS Fn 3306H: Get DOS Version Info",
    "b": "Compatibility: 5.0+\n Expects: AX 3306H\n ──────────────────────────────────────────────────────────────────\n Returns: BL major version number\n BH minor version number (note: binary value -- x.20 is 14H)\n DL revision number in low two bits (i.e., 00H to 03H)\n DH version flags: bit 3 (08H) DOS runs in ROM\n bit 4 (10H) DOS is in the HMA\n ──────────────────────────────────────────────────────────────────\n Info: Returns information about the active version of DOS. The return\n value is not modified by Setver.\n\nSee Also: Fn 30H (get DOS version)\n DOS Function Index - by DOS Version\n DOS Versions (overview and history)\n System Information Functions\n DOS Functions\n -♦-"
  },
  {
    "id": "425-dos_fn_34h__get_indos_address__dos_reentrancy_status_.html",
    "t": "DOS Fn 34H: Get InDOS Address (DOS Reentrancy Status)",
    "b": "Compatibility: 2.0+\n Expects: AH 34H\n ──────────────────────────────────────────────────────────────────\n Returns: ES:BX addr of the 1-byte InDOS flag (if ES:[BX]=0, OK to pop up)\n addr+1 of the ErrorMode flag (if ES:[BX-1]!=0, use no fns)\n ──────────────────────────────────────────────────────────────────\n Info: Returns the address of a DOS status flag that indicates the\n current state of INT 21H processing.\n\n DOS is not built to be re-enterable. For instance, if DOS is\n performing an INT 21H function and a program gains control via a\n timer or other interrupt, then that program should refrain from\n making DOS calls (otherwise, DOS static internal variables and\n stack data will become scrambled).\n\n However, there are times when DOS is prepared for possible\n reentrancy (it has switched to a secondary stack). When that's\n the case, DOS clears the InDOS flag, thereby signalling that it\n is OK for programs to make DOS calls.\n\n When ES:[BX] is non-zero, a background program (TSR, or popup)\n MUST NOT use any INT 21H functions.\n\nVersions: Undocumented until DOS 5.0, but functional since DOS 2.0.\n\n Notes: ■ You may ignore this flag if you are running as an INT 28H\n handler. When INT 28H is called, DOS is in a stable state and\n it's OK to do disk I/O and use other DOS fns (though you must\n avoid Fns 01h-0cH unless you set the ErrorMode Flag to 1).\n\nSee Also: InDOS Flag\n ErrorMode Flag\n INT 08H\n TSR/Popup Functions\n Process Control Functions\n DOS Functions\n -♦-"
  },
  {
    "id": "426-dos_fn_35h__get_interrupt_vector.html",
    "t": "DOS Fn 35H: Get Interrupt Vector",
    "b": "Compatibility: 2.0+\n Expects: AH 35H\n AL interrupt number (00H to 0ffH)\n ──────────────────────────────────────────────────────────────────\n Returns: ES:BX address of the interrupt handler\n ──────────────────────────────────────────────────────────────────\n Info: Returns the value of the interrupt vector for INT (AL). It loads\n BX with 0000:[AL*4], and ES with 0000:[(AL*4)+2].\n\nSee Also: Fn 25H (set INT Vector)\n DOS Functions\n -♦-"
  },
  {
    "id": "427-dos_fn_36h__get_disk_free_space.html",
    "t": "DOS Fn 36H: Get Disk Free Space",
    "b": "Compatibility: 2.0+\n Expects: AH 36H\n DL drive number (0=default, 1=A, etc.)\n ──────────────────────────────────────────────────────────────────\n Returns: AX ffffH if DL was an invalid drive number\n else sectors per cluster if no error\n BX available clusters (allocation units)\n CX bytes per sector (usually 512)\n DX total clusters on the disk\n ──────────────────────────────────────────────────────────────────\n Info: Returns information useful for calculating total and available\n disk space.\n\n If AX returns ffffH, you sent a bad drive number in DL.\n\n Otherwise, free space in bytes = (AX * CX * BX)\n total space in bytes = (AX * CX * DX)\n\n When sectors are 512 bytes, the calculation for Ks is simpler:\n free space in K-bytes = (AX * BX) / 2\n total space in K-bytes = (AX * DX) / 2\n\nNotes: ■ A common error in the use of this fn is to disregard arithmetic\n overflow on the multiplications. The product of three 16-bit\n values can be very large indeed.\n\nVersions: DOS 6.0\n ■ This call is intercepted by the resident portion of Undelete\n (when Delete Sentry is active). The free-space value is\n increased to reflect the disk space that will be made available\n if Undelete needs to physically delete files in the \\SENTRY\n directory.\n\n Once per day, this call may take several seconds before\n returning -- when it triggers Undelete's daily purge.\n\n ■ In DoubleSpace compressed volumes, the available and free space\n values are estimates, based on the average compression ratio\n obtained for data currently on the drive.\n\nSee Also: Fn 32H (get disk info)\n Fn 1bH (get FAT info)\n DOS Functions\n -♦-"
  },
  {
    "id": "428-dos_fn_37h__set_or_query_switch_character.html",
    "t": "DOS Fn 37H: Set or Query Switch Character",
    "b": "See: Fn 3700H (query switch character)\n\n Fn 3701H (set switch character)\n\n These two functions are ◄Undocumented► and ◄Obsolete►.\n\n They were intended as part of a system that would enable DOS users to\n select a character other than slash (/) as the lead character for command\n options. See the obsolete SWITCHAR= CONFIG.SYS command.\n\nSee Also: Handle-Oriented File I/O\n DOS Functions\n -♦-"
  },
  {
    "id": "429-dos_fn_3700h__query_switchar.html",
    "t": "DOS Fn 3700H: Query Switchar",
    "b": "Compatibility: 2.0+ ◄Undoc►\n Expects: AX 3700H\n ──────────────────────────────────────────────────────────────────\n Returns: DL current DOS switch character (always 2fH in DOS 5.0+)\n ──────────────────────────────────────────────────────────────────\n Info: Obtains the character that DOS and applications may interpret as\n the lead character in command-line switches.\n\n This concept never really caught on; most programs do not bother\n to check this value. Nowadays, all programs just assume that\n slash (/), ASCII 2fH, is the switch character.\n\nVersions: 2.0+ This is an undocumented, though valid function.\n 5.0+ The corresponding function, 3701H, is now ◄Obsolete► (so\n now there is no DOS-blessed way to set a non-standard switch\n character).\n\nSee Also: Fn 3701H (set switchar; obsolete)\n DOS Functions\n -♦-"
  },
  {
    "id": "430-dos_fn_3701h__set_switchar.html",
    "t": "DOS Fn 3701H: Set Switchar",
    "b": "Compatibility: ◄Undoc► ◄Obs► 2.0-4.x\n Expects: AX 3701H\n DL desired DOS switch character\n ──────────────────────────────────────────────────────────────────\n Returns: none\n ──────────────────────────────────────────────────────────────────\n Info: This ◄Obsolete► function previously set a global \"switch\n character\" and was even supported by the undocumented CONFIG.SYS\n command SWITCHAR=.\n\n The idea was to provide a way to use a character other than slash\n (/) as the lead-character in command-line switches (perhaps\n freeing / for use in pathnames or allowing the UNIX-like dash (-)\n as the switch character.\n\n The concept never really caught on; most programs do not bother\n to use Fn 3700H to check for changes.\n\nVersions: 2.0-4.x This is an undocumented, though valid function.\n 5.0+ This function is ◄Obsolete► and no longer supported\n by DOS. It does not return an error, but is ignored.\n\nSee Also: Fn 3700H (query switchar)\n CONFIG.SYS\n DOS Functions\n -♦-"
  },
  {
    "id": "431-dos_fn_38h__get_set_country_dependent_info.html",
    "t": "DOS Fn 38H: Get/Set Country-dependent Info",
    "b": "Compatibility: 2.0+\n Expects: AH 38H\n DX 0ffffH select country code in AL (or BX) as current country\n AL = Country Code (if code < 254)\n = 0ffH and BX is a Country Code\n BX=code of country you want to make current\n\n (else) get CountryInfoRec for country number in AL (or BX)\n AL = 00H: Get info for current country\n 0ffH: Get info for country whose code is in BX\n BX=code of country whose info you want\n else: Get info for country whose code is in AL\n (else)\n\n BX (if AL=0ffH) 16-bit country code\n\n DS:DX address of local buffer to receive a CountryInfoRec\n ──────────────────────────────────────────────────────────────────\n Returns: AX error code if CF is set to CY\n BX country code\n DS:DX buffer holds country info (if DX was not 0ffffH on entry)\n ──────────────────────────────────────────────────────────────────\n Info: In 2.0+, gets localization information about a country.\n In 3.0+, gets country info or activates a different country as\n the current country.\n\n DOS's support of international localization includes information\n on the time-and-date format, currency layout, and collation\n (string sorting) tools. See CountryInfoRec for related info.\n\n To get country info:\n ■ Set DS:DX to a buffer large enough for a CountryInfoRec.\n ■ Set AL to a Country Code (if the country code > 254, then set\n AL to 0ffH, and set BX to the country code).\n To get info on the current country, set AL to 0.\n ■ Set AH to 38H and perform INT 21H.\n\n To select a different country as the \"current\" country:\n ■ DX to a 0ffffH.\n ■ Set AL to desired Country Code (if the country code > 254, then\n set AL to 0ffH, and set BX to the country code).\n ■ Set AH to 38H and perform INT 21H.\n\nVersions: 2.x\n You cannot select a different current country. The calling\n sequence is simpler:\n Expects: AL = 0\n DS:DX = address of 20H-byte local buffer\n Returns: fills memory at DS:DX with DOS 2.x CountryInfoRec\n\nSee Also: Fn 6501H (get extended country Info)\n Fn 6601H (query global code page)\n Fn 6602H (set global code page)\n CONFIG.SYS\n National Language Support\n DOS Functions\n -♦-"
  },
  {
    "id": "432-dos_fn_39h__create_a_new_directory____mkdir.html",
    "t": "DOS Fn 39H: Create a New Directory -- MKDIR",
    "b": "Compatibility: 2.0+\n Expects: AH 39H\n DS:DX address of an ASCIIZ▲ string of a directory name\n ──────────────────────────────────────────────────────────────────\n Returns: AX error code if CF is set to CY\n ──────────────────────────────────────────────────────────────────\n Info: Creates a new, empty directory.\n\n DS:DX points to an ASCIIZ string in the form...\n d:\\path\\dirname◄0►\n ...which identifies the directory to create.\n\n Notes: ■ A new directory can be created ONLY in an existing directory\n (this fn will NOT create several directory levels at once).\n\n ■ If drive and/or leading path are omitted, defaults are assumed.\n\n ■ The maximum length of the ASCIIZ string is 64 bytes.\n\nSee Also: Directory and File Functions\n DOS Functions\n -♦-"
  },
  {
    "id": "433-dos_fn_3ah__delete_a_directory____rmdir.html",
    "t": "DOS Fn 3aH: Delete a Directory -- RMDIR",
    "b": "Compatibility: 2.0+\n Expects: AH 3aH\n DS:DX address of an ASCIIZ▲ string of a directory name\n ──────────────────────────────────────────────────────────────────\n Returns: AX error code if CF is set to CY\n ──────────────────────────────────────────────────────────────────\n Info: Removes an existing directory, but only if it is empty.\n\n DS:DX points to an ASCIIZ string in the form...\n d:\\path\\dirname◄0►\n ...which identifies the directory to remove. It must not contain\n wildcards▲.\n\n If CF is set on return, and error code is in AX and the directory\n was not deleted.\n\n Notes: ■ The directory must be empty of files and directories, must not\n be the current directory, and must be free of other constraints\n (no DOS Join or Subst in effect, etc.)\n ■ If drive and/or leading path are omitted, defaults are assumed.\n ■ The maximum length of the ASCIIZ string is 64 bytes.\n\nSee Also: Directory and File Functions\n DOS Functions\n -♦-"
  },
  {
    "id": "434-dos_fn_3bh__set_dos_default_directory____chdir.html",
    "t": "DOS Fn 3bH: Set DOS Default Directory -- CHDIR",
    "b": "Compatibility: 2.0+\n Expects: AH 3bH\n DS:DX address of an ASCIIZ▲ string of a directory name\n ──────────────────────────────────────────────────────────────────\n Returns: AX error code if CF is set to CY\n ──────────────────────────────────────────────────────────────────\n Info: Selects a default directory for a drive.\n\n DS:DX points to an ASCIIZ string in the form...\n d:\\path\\dirname◄0►\n ...which identifies the directory to become the default. If the\n d: portion is missing, the \\path\\dirname is assumed to be on the\n current default drive; see Fn 0EH (set default drive).\n\n If CF is set on return, an error code is in AX and no action was\n taken.\n\n Notes: ■ This selects the default directory for the specified or current\n drive. it DOES NOT select a default drive.\n ■ If drive and/or leading path are omitted, defaults are assumed.\n ■ The maximum length of the ASCIIZ string is 64 bytes.\n\nSee Also: Directory and File Functions\n DOS Functions\n -♦-"
  },
  {
    "id": "435-dos_fn_3ch__create_a_file_via_handle.html",
    "t": "DOS Fn 3cH: Create a File via Handle",
    "b": "Compatibility: 2.0+\n Expects: AH 3cH\n DS:DX address of an ASCIIZ▲ string of a filespec▲\n CX file attribute (can't be a volume label)\n ──────────────────────────────────────────────────────────────────\n Returns: AX error code if CF is set to CY\n file handle if no error\n ──────────────────────────────────────────────────────────────────\n Info: Creates an empty file, or deletes all data from an existing file.\n The file is open for read/write operations.\n\n DS:DX points to an ASCIIZ string in the form...\n d:\\path\\filename.ext◄0►\n ...which identifies the location and name of the file to create.\n If drive and/or path are omitted, defaults are assumed.\n\n If CF is set on return, an error code is in AX and no action was\n taken.\n\n Notes: ■ The file is opened with an Access Mode of read/write.\n\n ■ if the file already exists:\n • When opened, it is truncated to a length of 0.\n • If its file attribute is read-only, the open fails\n (its attribute may be changed via Fn 4301H).\n\n ■ Fn 5bH (create new file) is similar, but fails if the file\n already exists.\n\n ■ Fn 6cH has additional options, such as disabling critical\n errors and forcing automatic write-through to disk.\n\nSee Also: Handle-Oriented File I/O\n DOS Functions\n -♦-"
  },
  {
    "id": "436-dos_fn_3dh__open_a_file_via_handle.html",
    "t": "DOS Fn 3dH: Open a File via Handle",
    "b": "Compatibility: 2.0+\n Expects: AH 3dH\n AL Access Mode (0=read, 1=write, 2=both, etc.)\n DS:DX address of an ASCIIZ▲ string of a filespec▲\n ──────────────────────────────────────────────────────────────────\n Returns: AX error code if CF is set to CY\n file handle if no error\n ──────────────────────────────────────────────────────────────────\n Info: Opens an existing file for read and/or write operations.\n\n DS:DX points to an ASCIIZ string in the form...\n d:\\path\\filename.ext◄0►\n ...which identifies the location and name of the file to open.\n If drive and/or path are omitted, defaults are assumed.\n\n If CF is set on return, an error code is in AX and no action was\n taken.\n\n Notes: ■ The file must exist. See Fn 3cH (create file).\n\n ■ The file is opened in the selected Access Mode / Open Mode.\n For compatibility with DOS 2.x and no network involvement, use:\n • AL = 0 to open for reading\n • AL = 1 to open for writing\n • AL = 2 to open for reading and writing\n\n ■ The read/write pointer is set to 0. See DOS Fn 42H (Lseek).\n\n ■ CONFIG.SYS specifies how many handles are available or you may\n use Fn 67H (set handle count) to increase available handles.\n ■ Fn 6cH has additional options, such as disabling critical\n errors and forcing automatic write-through to disk.\n\nSee Also: Handle-Oriented File I/O\n DOS Functions\n -♦-"
  },
  {
    "id": "437-dos_fn_3eh__close_a_file_handle.html",
    "t": "DOS Fn 3eH: Close a File Handle",
    "b": "Compatibility: 2.0+\n Expects: AH 3eH\n BX file handle\n ──────────────────────────────────────────────────────────────────\n Returns: AX error code if CF is set to CY\n ──────────────────────────────────────────────────────────────────\n Info: Closes an open file.\n\n BX contains a file handle returned from an Open operation. The file\n represented by that handle is closed, its buffers are flushed,\n and the directory is updated with the correct size, time, and\n date.\n\n Because of the potential shortage of file handles (default=8,\n max=20 with DOS < 3.3), you may want to close one or more of the\n default handles, such as handle 3 (Standard AUX).\n\n Notes: ■ Smartdrv may decide not to flush its cache for up to several\n seconds. To force \"commit\" to disk, use Fn 0dH (reset disk)\n after closing the file.\n\n ■ With DOS 3.3+, you can force a \"commit to disk\" without closing\n the file. See Fn 68H (commit file).\n\nSee Also: Handle-Oriented File I/O\n DOS Functions\n -♦-"
  },
  {
    "id": "438-dos_fn_3fh__read_from_file_via_handle.html",
    "t": "DOS Fn 3fH: Read from File via Handle",
    "b": "Compatibility: 2.0+\n Expects: AH 3fH\n BX file handle\n CX number of bytes to read\n DS:DX address of buffer to receive data\n ──────────────────────────────────────────────────────────────────\n Returns: AX error code if CF is set to CY\n if no error, AX=number of bytes actually read\n ──────────────────────────────────────────────────────────────────\n Info: Reads CX bytes of data (or fewer) from the file or device with\n handle number BX. The data is read from the current position of\n the file's read/write pointer and is placed into the caller's\n buffer pointed to by DS:DX.\n\n This updates the file's read/write pointer to set up for a\n subsequent sequential-access read or write. To access a specific\n part of a file, use Fn 42H (Lseek) before this call.\n\n Notes: ■ You should always compare the return value of AX (number of\n bytes read) to CX (number of bytes requested):\n\n • if AX = CX, (and CF=NC) the read was correct with no error\n • if AX = 0, the end of the file (EOF) was reached\n • if AX < CX (but not zero):\n if reading from a device, the input line is AX bytes long\n if reading from a file, the call has read up to the EOF\n\n ■ It is handy to use this function for reading default handles\n such as the Standard I/O handles, instead of the buffered input\n or character-by-character input functions.\n\n ■ When you read from a device, AX returns the length of the line\n up to and including the terminating CR (ASCII 13H).\n\nSee Also: Handle-Oriented File I/O\n DOS Functions\n -♦-"
  },
  {
    "id": "439-dos_fn_40h__write_to_file_via_handle.html",
    "t": "DOS Fn 40H: Write to File via Handle",
    "b": "Compatibility: 2.0+\n Expects: AH 40H\n BX file handle\n CX number of bytes to write (Note: 0 means truncate the file)\n DS:DX address of a buffer containing the data to write\n ──────────────────────────────────────────────────────────────────\n Returns: AX error code if CF is set to CY\n number of bytes actually written ◄════ use for error test\n ──────────────────────────────────────────────────────────────────\n Info: Writes CX bytes of data to the file or device with handle number\n in BX. The data is taken starting from the caller's buffer\n pointed to by DS:DX. The data is written to the current position\n of the file's read/write pointer.\n\n This updates the file's read/write pointer to set up for a\n subsequent sequential-access read or write. To write to a\n specific part of a file, use Fn 42H (Lseek) before this call.\n\nVersions: 3.0+ If CX is 0000H on entry, the file is truncated at the\n current file position -- or the file is padded to that position.\n\n 6.0+ (on Doublespace compressed drive) when you seek some large\n distance past the end of the file and then write some data,\n DoubleSpace may not allocate disk space for the unwritten bytes.\n The compression ratio for such data is considered \"infinite\".\n See MDFAT.\n\n Notes: ■ You should always compare the return value of AX (number of\n bytes written) to CX (requested write size):\n\n • if AX = CX, the write was successful\n • if AX < CX, an error occurred (most likely a full disk).\n Note that Carry is not set for this \"error\".\n\n ■ It is handy to use this function for writing to default handles\n such as the Standard Output instead of using the various text\n output functions.\n\nSee Also: Handle-Oriented File I/O\n DOS Functions\n -♦-"
  },
  {
    "id": "440-dos_fn_41h__delete_file.html",
    "t": "DOS Fn 41H: Delete File",
    "b": "Compatibility: 2.0+\n Expects: AH 41H\n DS:DX address of an ASCIIZ▲ string of a filespec▲\n ──────────────────────────────────────────────────────────────────\n Returns: AX error code if CF is set to CY\n ──────────────────────────────────────────────────────────────────\n Info: Deletes an existing file.\n\n DS:DX points to an ASCIIZ string in the form...\n d:\\path\\filename.ext◄0►\n ...which identifies the location and name of the file to delete.\n It cannot contain wildcards▲. If drive and/or path are omitted,\n defaults are assumed.\n\n If CF is set on return, an error code is in AX and no action was\n taken.\n\n Notes: ■ This function removes the file's directory entry from the\n directory (actually, it overwrites the first byte of the file\n name with 0e5H) and updates the FAT to deallocate its disk\n space. It does not physically erase the file's data.\n\n ■ If Undelete's Delete Sentry is active, it will intercept this\n call and move the file's directory entry into the \\SENTRY\n directory, giving it a unique name and recording the\n transaction in CONTROL.FIL. The file will actually be deleted\n when the disk space is needed.\n\n ■ This function will not delete files having the read-only\n file attribute. You may use fn 4301H (change file attribute)\n to clear this attribute.\n\nSee Also: Directory and File Functions\n DOS Functions\n -♦-"
  },
  {
    "id": "441-dos_fn_42h__set_file_pointer.html",
    "t": "DOS Fn 42H: Set File Pointer",
    "b": "Compatibility: 2.0+\n Expects: AH 42H\n BX file handle\n CX:DX distance to move file pointer: offset is (CX * 65536) + DX\n AL subfn: 0 = move pointer to start of file + CX:DX\n 1 = move pointer to current position + CX:DX\n 2 = move pointer to end of file + CX:DX\n ──────────────────────────────────────────────────────────────────\n Returns: AX error code if CF is set to CY\n DX:AX new position of file read/write pointer (if no error)\n ──────────────────────────────────────────────────────────────────\n Info: This moves the logical read/write pointer to the desired address.\n All file reads and writes will start from the new address.\n\n Notes: ■ One way to obtain the size of a file is to call with AL=2,\n CX=0, DX=0 (the length is returned in DX:AX --DX is the most\n significant word--actual length is (DX * 65536) + AX.\n\n A faster way is to use fn 4eH (find file).\n\n ■ To truncate a file, use LSEEK to move to the desired position,\n and use Fn 40H with CX=0.\n\n ■ To pre-allocate disk space to a file, use LSEEK to move to the\n desired file length, then use Fn 40H with CX=0. Then close the\n file (Fn 3eH).\n\n (!) When you use this technique on a DoubleSpace compressed\n drive, DoubleSpace does not actually allocate disk storage from\n the physical medium. It considers these bytes to be\n \"infinitely compressible\". See MDFAT.\n\nSee Also: Handle-Oriented File I/O\n DOS Functions\n -♦-"
  },
  {
    "id": "442-dos_fn_43h__set_or_query_file_attributes.html",
    "t": "DOS Fn 43H: Set or Query File Attributes",
    "b": "See: Fn 4300H (query file attributes)\n\n Fn 4301H (set file attributes)\n\nSee Also: Handle-Oriented File I/O\n DOS Functions\n -♦-"
  },
  {
    "id": "443-dos_fn_4300h__query_file_attribute.html",
    "t": "DOS Fn 4300H: Query File Attribute",
    "b": "Compatibility: 2.0+\n Expects: AX 4300H\n DS:DX address of an ASCIIZ▲ string of a filespec▲\n ──────────────────────────────────────────────────────────────────\n Returns: AX error code if CF is set to CY\n CX file attribute of specified file (if no error)\n ──────────────────────────────────────────────────────────────────\n Info: Obtains the file attribute of a file.\n\n DS:DX points to an ASCIIZ string in the form...\n d:\\path\\filename.ext◄0►\n ...which identifies the location and name of the file. It must\n not contain wildcards▲, but it may identify a directory name or\n volume label.\n\n If CF is set on return, an error code is in AX and no action was\n taken.\n\nSee Also: Fn 4301H (set file attributes)\n File Attribute\n Directory and File Functions\n DOS Functions\n -♦-"
  },
  {
    "id": "444-dos_fn_4301h__set_file_attribute.html",
    "t": "DOS Fn 4301H: Set File Attribute",
    "b": "Compatibility: 2.0+\n Expects: AX 4301H\n CX file attribute to assign to the file\n DS:DX address of an ASCIIZ▲ string of a filespec▲\n ──────────────────────────────────────────────────────────────────\n Returns: AX error code if CF is set to CY\n ──────────────────────────────────────────────────────────────────\n Info: Sets the file attribute of a file or directory.\n\n DS:DX points to an ASCIIZ string in the form...\n d:\\path\\filename.ext◄0►\n ...which identifies the location and name of the file. It must\n not contain wildcards▲, but it may identify a directory name.\n\n If CF is set on return, an error code is in AX and no action was\n taken.\n\n Notes: ■ To add an attribute to an existing value, use fn 4300H to\n obtain the current setting, OR the desired new attribute bit,\n then call this function.\n\n ■ Bits 3 and 4 of CX (volume label and directory) must be clear\n when calling this function. If you wish to hide a directory,\n use CX=02H (not 12H as you might expect).\n\nSee Also: Fn 4300H (query file attributes)\n File Attribute\n Directory and File Functions\n DOS Functions\n -♦-"
  },
  {
    "id": "445-dos_fn_44h__device_i_o_control____ioctl.html",
    "t": "DOS Fn 44H: Device I/O Control -- IOCTL",
    "b": "See: Fn 4400H (query device/file type) 2.0+\n Fn 4401H (set file/device flags) 2.0+\n Fn 4402H (get control data from char device) 2.0+\n Fn 4403H (send control data to char device) 2.0+\n Fn 4404H (get control data from block device) 2.0+\n Fn 4405H (send control data to block device) 2.0+\n Fn 4406H (get input status) 2.0+\n Fn 4407H (get output status) 2.0+\n Fn 4408H (removable media query) 3.0+\n Fn 4409H (remote device or SUBST drive query) 3.1+\n Fn 440aH (remote handle query) 3.1+\n Fn 440bH (sharing retry count) 3.0+\n\n Fn 440cH (Generic IOCTL: character devices)\n Fn 440cH 45H (set iteration count) 3.3+\n Fn 440cH 4aH (select a prepared code page) 3.3+\n Fn 440cH 4cH (begin preparing a code page) 3.3+\n Fn 440cH 4dH (done preparing a code page) 3.3+\n Fn 440cH 5fH (set display information) 4.0+\n Fn 440cH 65H (query retry iteration count) 3.3+\n Fn 440cH 6aH (query active code page) 3.3+\n Fn 440cH 6bH (get list of prepared code pages) 3.3+\n Fn 440cH 7fH (query display information) 4.0+\n\n Fn 440dH (generic IOCTL: block devices)\n Fn 440dH 40H (set device parameters) 3.2+\n Fn 440dH 41H (write track) 3.2+\n Fn 440dH 42H (format and verify track) 3.2+\n Fn 440dH 46H (set media ID) 4.0+\n Fn 440dH 47H (set disk access flag) 4.0 only\n Fn 440dH 60H (get device parameters) 3.2+\n Fn 440dH 61H (read track) 3.2+\n Fn 440dH 62H (verify track) 3.2+\n Fn 440dH 66H (query media ID) 4.0+\n Fn 440dH 67H (query disk access flag) 4.0 only\n Fn 440dH 68H (sense media type) 5.0+\n\n Fn 440eH (get logical drive) 3.2+\n Fn 440fH (set logical drive) 3.2+\n Fn 4410H (query IOCTL handle) 5.0+\n Fn 4411H (query IOCTL device) 5.0+\n\n Note: IOCTL is handled by device drivers and therefore the level of\n support is controlled by the version of the driver as opposed to\n the version of DOS.\n\nSee Also: IOCTL device info\n Device Drivers\n DOS Functions\n -♦-"
  },
  {
    "id": "446-dos_fn_4400h__ioctl_query_device_file_flags.html",
    "t": "DOS Fn 4400H: IOCTL Query Device/File Flags",
    "b": "Compatibility: 2.0+\n Expects: AX 4400H\n BX file handle (device or disk file)\n ──────────────────────────────────────────────────────────────────\n Returns: AX error code if CF is set to CY\n DX IOCTL device info (if no error)\n ──────────────────────────────────────────────────────────────────\n Info: Checks to see if a handle represents a device or a disk file and\n obtains information about that device or file.\n\n See IOCTL device info for a layout of the 16-bit return value.\n\n If the handle is a disk file:\n DX bit 7 is clear (0)\n DX bit 6 is set if the file is \"dirty\" (has been written to)\n DX bits 0-5 represent a drive number (0=A, 1=B, etc.)\n\n If the handle is a device:\n DX bit 7 is set (1)\n DX bits 0-6 are device information flags\n DX bits 8-15 are the same as bits 8-15 of the Device Attribute\n (the rDevAttr field of the driver's DevHdrRec structure).\n\n Notes: ■ This is often used to see if Standard I/O has been redirected.\n For instance, if handle 01H (standard output) represents a disk\n file rather than the CON device, you may wish to output\n different information and perhaps send some extra messages to\n handle 02H (Standard Error device).\n\nSee Also: Fn 44H (IOCTL)\n Fn 4401H (Set Device/File Flags)\n DOS Functions\n -♦-"
  },
  {
    "id": "447-dos_fn_4401h__ioctl_set_device_file_flags.html",
    "t": "DOS Fn 4401H: IOCTL Set Device/File Flags",
    "b": "Compatibility: 2.0+\n Expects: AX 4401H\n BX file handle (device only)\n DX IOCTL device info\n ──────────────────────────────────────────────────────────────────\n Returns: AX error code if CF is set to CY\n ──────────────────────────────────────────────────────────────────\n Info: This can change certain aspects of how DOS handles I/O with some\n devices. It cannot be used to affect disk file handles.\n\n Bits 8-15 (i.e. DH) must be 0\n Bit 7 must be set (1) to indicate a device\n Bit 5 selects \"raw\" or \"cooked\" mode for character devices\n Other bits specify special devices. See IOCTL device info.\n\nSee Also: Fn 44H (IOCTL)\n Fn 4400H (Query Device/File Flags)\n DOS Functions\n -♦-"
  },
  {
    "id": "448-dos_fn_4402h__ioctl_receive_control_data_from_char_device.html",
    "t": "DOS Fn 4402H: IOCTL Receive Control Data from Char Device",
    "b": "Compatibility: 2.0+\n Expects: AX 4402H\n BX file handle (device only)\n CX buffer size (maximum number of bytes to receive)\n DS:DX Address of buffer to receive data\n ──────────────────────────────────────────────────────────────────\n Returns: AX error code if CF is set to CY\n Number of bytes actually received (if no error)\n ──────────────────────────────────────────────────────────────────\n Info: Some character device drivers support this method of providing\n device-specific information to programs. The layout and contents\n of the returned data varies from device to device.\n\n Notes: ■ This fn is supported only if bit 14 of the rDevAttr field of\n the device driver's DevHdrRec structure is set. Use Fn 4400H\n to check this bit.\n\nSee Also: Fn 44H (IOCTL)\n Fn 4403H (Send Control Data to Character Device)\n Fn 4404H (Receive Control Data from Block Device)\n DOS Functions\n -♦-"
  },
  {
    "id": "449-dos_fn_4403h__ioctl_send_control_data_to_character_device.html",
    "t": "DOS Fn 4403H: IOCTL Send Control Data to Character Device",
    "b": "Compatibility: 2.0+\n Expects: AX 4403H\n BX file handle (device only)\n CX byte count (amount of data to send)\n DS:DX Address of buffer containing data to send\n ──────────────────────────────────────────────────────────────────\n Returns: AX error code if CF is set to CY\n Number of bytes actually sent (if no error)\n ──────────────────────────────────────────────────────────────────\n Info: Some character device drivers support this method of\n communicating with a device driver to select special features\n (such as setting the baud rate of a COM port). The layout and\n contents of the control data varies from device to device.\n\n Notes: ■ This fn is supported only if bit 14 of the Device Attribute\n (the rDevAttr field of the driver's DevHdrRec structure) is\n set. Use Fn 4400H to check this bit.\n\nSee Also: Fn 44H (IOCTL)\n Fn 4402H (Receive Control Data from Character Device)\n Fn 4405H (Send Control Data to Block Device)\n DOS Functions\n -♦-"
  },
  {
    "id": "450-dos_fn_4404h__ioctl_receive_control_data_from_block_device.html",
    "t": "DOS Fn 4404H: IOCTL Receive Control Data from Block Device",
    "b": "Compatibility: 2.0+\n Expects: AX 4404H\n BL drive number (0=default, 1=A, 2=B, etc.)\n CX buffer size (maximum number of bytes to receive)\n DS:DX Address of buffer to receive data\n ──────────────────────────────────────────────────────────────────\n Returns: AX error code if CF is set to CY\n Number of bytes actually received (if no error)\n ──────────────────────────────────────────────────────────────────\n Info: Some block device drivers support this method of providing\n device-specific information to programs; for instance, it is used\n to tell DoubleSpace to flush its cache. The layout and contents\n of the returned data varies from device to device.\n\n Notes: ■ This fn is supported only if bit 14 of the Device Attribute\n (the rDevAttr field of the driver's DevHdrRec structure) is\n set. Use Fn 4400H to check this bit.\n\n ■ DoubleSpace API supports IOCTL strings for some fns.\n\nSee Also: Fn 44H (IOCTL)\n Fn 4402H (Receive Control Data from Character Device)\n Fn 4405H (Send Control Data to Block Device)\n DoubleSpace API\n DOS Functions\n -♦-"
  },
  {
    "id": "451-dos_fn_4405h__ioctl_send_control_data_to_block_device.html",
    "t": "DOS Fn 4405H: IOCTL Send Control Data to Block Device",
    "b": "Compatibility: 2.0+\n Expects: AX 4405H\n BL drive number (0=default, 1=A, 2=B, etc.)\n CX byte count (amount of data to send)\n DS:DX Address of buffer containing data to send\n ──────────────────────────────────────────────────────────────────\n Returns: AX error code if CF is set to CY\n Number of bytes actually sent (if no error)\n ──────────────────────────────────────────────────────────────────\n Info: Some block device drivers support this method of communicating\n with a device driver to select special features. The layout and\n contents of the control data varies from device to device.\n\n Notes: ■ This fn is supported only if bit 14 of the Device Attribute\n (the rDevAttr field of the driver's DevHdrRec structure) is\n set. Use Fn 4400H to check this bit.\n\nSee Also: Fn 44H (IOCTL)\n Fn 4403H (Send Control Data to Character Device)\n Fn 4404H (Receive Control Data from Block Device)\n DOS Functions\n -♦-"
  },
  {
    "id": "452-dos_fn_4406h__ioctl_query_handle_input_status.html",
    "t": "DOS Fn 4406H: IOCTL Query Handle Input Status",
    "b": "Compatibility: 2.0+\n Expects: AX 4406H\n BX file handle (device or disk file)\n ──────────────────────────────────────────────────────────────────\n Returns: AX error code if CF is set to CY\n AL input status code (if no error)\n 00H: End of file or device not ready\n ffH: not EOF or device ready\n ──────────────────────────────────────────────────────────────────\n Info: This function checks to see if a device or file is ready for\n input; i.e, has data waiting to be read.\n\n If the handle is a disk file:\n AL=00H file pointer has reached the end of file\n AL=ffH file pointer is at EOF (next read will return 0 bytes)\n\n If the handle is a device:\n AL=00H the device is not ready (no input available)\n AL=ffH the device is ready (input is available)\n\n Notes: ■ This fn makes for a simple way to determine EOF or to see if a\n device, such as a COM port, has any input to be read.\n\nSee Also: Fn 44H (IOCTL)\n Fn 4407H (Query Handle Output Status)\n Handle-Oriented File I/O\n DOS Functions\n -♦-"
  },
  {
    "id": "453-dos_fn_4407h__ioctl_query_handle_output_status.html",
    "t": "DOS Fn 4407H: IOCTL Query Handle Output Status",
    "b": "Compatibility: 2.0+\n Expects: AX 4407H\n BX file handle (device or disk file)\n ──────────────────────────────────────────────────────────────────\n Returns: AX error code if CF is set to CY\n AL output status code (if no error)\n 00H: not ready\n ffH: ready\n ──────────────────────────────────────────────────────────────────\n Info: This function checks to see if a device is ready to receive\n output.\n\n If the handle is a disk file:\n AL always returns with ffH (ready) even if the disk is full or\n no diskette is present etc.\n\n If the handle is a device:\n AL=00H the device is not ready\n AL=ffH the device is ready (output will be accepted)\n\n Notes: ■ This fn makes for a simple way to determine if an output\n device, such as a COM port, is ready to accept output. It is\n not useful for disk files.\n\nSee Also: Fn 44H (IOCTL)\n Fn 4406H (Query Handle Input Status)\n DOS Functions\n -♦-"
  },
  {
    "id": "454-dos_fn_4408h__ioctl_does_drive_use_removable_media.html",
    "t": "DOS Fn 4408H: IOCTL Does Drive Use Removable Media",
    "b": "Compatibility: 3.0+\n Expects: AX 4408H\n BL drive number (0=default, 1=A, 2=B, etc.)\n ──────────────────────────────────────────────────────────────────\n Returns: AX error code if CF is set to CY\n 0000H if drive contains removable media\n 0001H if drive does NOT contain removable media\n ──────────────────────────────────────────────────────────────────\n Info: Determines whether a device uses removable media; for instance,\n to see if a drive is a hard disk or a floppy diskette).\n\n Notes: ■ This fn cannot be used to query a network drive.\n\n ■ Block device drivers need not support this function. In that\n case, on return CY is set and AX contains an error code of\n 0001H (invalid function).\n\nSee Also: Fn 44H (IOCTL)\n DOS Functions\n -♦-"
  },
  {
    "id": "455-dos_fn_4409h__ioctl_is_drive_remote_or_subst.html",
    "t": "DOS Fn 4409H: IOCTL Is Drive Remote or SUBST",
    "b": "Compatibility: 3.1+\n Expects: AX 4409H\n BL drive number (0=default, 1=A, 2=B, etc.)\n ──────────────────────────────────────────────────────────────────\n Returns: AX error code if CF is set to CY\n DX Bit 12 is 1: Drive is remote (if no error)\n Bit 12 is 0: Drive is local and DX=IoctlDriveInfoRec\n ──────────────────────────────────────────────────────────────────\n Info: Obtains information about a drive, including whether or not it is\n remote (on the network). For local drives, this returns\n additional information including, which IOCTL fns it supports,\n and whether the drive is a logical drive created by the Subst\n command.\n\n On return, DX bit 12 (DX & 1000H) is 1 if the drive is remote\n (i.e., on a network server) and all other bits are 0.\n\n See IoctlDriveInfoRec for a layout of the flags returned in DX\n when bit 12 is 0 (i.e., not a remote drive).\n\n Notes: ■ This is the only way to see if a logical drive ID represents a\n Subst drive. It also lets you see if a local drive is shared\n by others on the network.\n\nSee Also: Fn 44H (IOCTL)\n Fn 440AH (Is File/Device Remote)\n DOS Functions\n -♦-"
  },
  {
    "id": "456-dos_fn_440ah__ioctl_is_file_device_remote.html",
    "t": "DOS Fn 440aH: IOCTL Is File/Device Remote",
    "b": "Compatibility: 3.1+\n Expects: AX 440AH\n BX file handle (device or disk file)\n ──────────────────────────────────────────────────────────────────\n Returns: AX error code if CF is set to CY\n DX IoctlHandleInfoRec (Bit 15 is 1 if file/device is remote)\n ──────────────────────────────────────────────────────────────────\n Info: Obtains information about a file or device represented by a\n file handle, including whether or not it is local (on this\n computer) or remote (on a network server). It also tells whether\n the handle represents a file or a device.\n\n On return, DX bit 15 (DX & 8000H) is 1 if the file or device is\n remote (i.e., on a network server). See IoctlHandleInfoRec for a\n full layout of the rest of the returned information.\n\n Notes: ■ In general, you should treat local and remote files the same.\n One exception might be if you want to avoid overwriting\n configuration files when they are shared on the network.\n\n ■ If the network is not started, CF is set and AX contains and\n error code of 0001H (invalid function).\n\nSee Also: Fn 44H (IOCTL)\n Fn 4409H (Is Drive Remote)\n DOS Functions\n -♦-"
  },
  {
    "id": "457-dos_fn_440bh__ioctl_set_sharing_retry_count.html",
    "t": "DOS Fn 440bH: IOCTL Set Sharing Retry Count",
    "b": "Compatibility: 3.0+\n Expects: AX 440bH\n CX delays per retry (default=1)\n DX retries before declaring INT 24H critical error (default=3)\n ──────────────────────────────────────────────────────────────────\n Returns: AX error code if CF is set to CY\n ──────────────────────────────────────────────────────────────────\n Info: This fn sets how many times DOS should retry a file I/O attempt\n on any shared file or device.\n\n When a file is locked, an attempt to write to it will cause an\n INT 24H critical error. Before declaring the error, DOS will\n retry the I/O 3 times, waiting for 1 \"delay unit\" between\n retries.\n\n Notes: ■ The count in CX specifies a number of arbitrary \"delay units\",\n which depend on the speed of the CPU. A \"delay unit\" is the\n time it takes the CPU to LOOP 65536 times. On 4.77 MHz PCs,\n this equates to about 0.2 seconds. On faster PCs, it can\n represent less than 0.001 seconds.\n\n ■ This is a global setting. If you change it, you should restore\n the defaults (CX=1, DX=3) before terminating your program.\n\nSee Also: Fn 44H (IOCTL)\n Fn 56H (Lock/Unlock File)\n INT 2FH 1000H (Is SHARE.EXE Installed)\n DOS Functions\n -♦-"
  },
  {
    "id": "458-dos_fn_440ch__generic_i_o_control____character_devices.html",
    "t": "DOS Fn 440cH: Generic I/O Control -- Character Devices",
    "b": "See: Fn 440cH 45H (set iteration count) 3.3+\n\n Fn 440cH 4aH (select a prepared code page) 3.3+\n Fn 440cH 4cH (begin preparing a code page) 3.3+\n Fn 440cH 4dH (done preparing a code page) 3.3+\n\n Fn 440cH 5fH (set display information) 4.0+\n Fn 440cH 65H (query retry iteration count) 3.3+\n\n Fn 440cH 6aH (query active code page) 3.3+\n Fn 440cH 6bH (get list of prepared code pages) 3.3+\n\n Fn 440cH 7fH (query display information) 4.0+\n\n Info: These functions require a \"minor code\" value in the CL register\n as well as the 440cH in AX.\n\nSee Also: Fn 44H (IOCTL)\n Fn 440dH (generic IOCTL for block devices)\n Generic IOCTL Data Packets\n Device Drivers\n DOS Functions\n -♦-"
  },
  {
    "id": "459-dos_fn_440ch_cl_45h__ioctl_set_retry_iteration_count.html",
    "t": "DOS Fn 440cH CL=45H: IOCTL Set Retry Iteration Count",
    "b": "Compatibility: 3.3+\n Expects: AX 440cH\n BX file handle (device or disk file)\n CL 45H\n CH device category: 00H=unknown\n 01H=COMn (DOS 3.3+)\n 03H=console (screen + keyboard) (DOS 3.3+)\n 05H=parallel printer (DOS 3.2+)\n DS:DX addr of a 16-bit word containing the desired number of\n retries\n ──────────────────────────────────────────────────────────────────\n Returns: AX error code if CF is set to CY\n ──────────────────────────────────────────────────────────────────\n Info: Sets the number of times the device driver is to try to send\n output to the device before assuming that the device is busy.\n\n DS:DX points to a 2-byte buffer that contains a 16-bit value\n specifying the desired number of retries.\n\n Notes: ■ This is used only for printer drivers that support\n \"Output Until Busy\". See Device Requests and DvRq 10H.\n\n ■ This setting is system/global. Before changing it, you should\n use fn 440CH 65H to obtain the current value. Change it back\n before exiting.\n\nSee Also: Fn 44H (IOCTL)\n Fn 440cH (generic IOCTL for character devices)\n Fn 440cH 65H (query retry iteration count)\n Generic IOCTL Data Packets\n Device Drivers\n DOS Functions\n -♦-"
  },
  {
    "id": "460-dos_fn_440ch_cl_4ah__ioctl_select_code_page.html",
    "t": "DOS Fn 440cH CL=4AH: IOCTL Select Code Page",
    "b": "Compatibility: 3.3+\n Expects: AX 440cH\n BX file handle (device or disk file)\n CL 4aH\n CH device category: 00H=unknown\n 01H=COMn (DOS 3.3+)\n 03H=console (screen + keyboard) (DOS 3.3+)\n 05H=parallel printer (DOS 3.2+)\n DS:DX addr of an IoctlCpIdRec that selects the code page\n ──────────────────────────────────────────────────────────────────\n Returns: AX error code if CF is set to CY\n ──────────────────────────────────────────────────────────────────\n Info: Selects a desired code page to be used by the specified device.\n The code page must by among those that have already been\n prepared; see 440cH 6bH (cp prepare) and 440cH 6bH (cp list).\n\nSee Also: Fn 44H (IOCTL)\n Fn 440cH (generic IOCTL for character devices)\n Fn 440cH 6aH (query current code page)\n Generic IOCTL Data Packets\n National Language Support\n DOS Functions\n -♦-"
  },
  {
    "id": "461-dos_fn_440ch_cl_4ch__ioctl_start_code_page_prepare.html",
    "t": "DOS Fn 440cH CL=4CH: IOCTL Start Code Page Prepare",
    "b": "Compatibility: 3.3+\n Expects: AX 440cH\n BX file handle (device or disk file)\n CL 4cH\n CH device category: 00H=unknown\n 01H=COMn (DOS 3.3+)\n 03H=console (screen + keyboard) (DOS 3.3+)\n 05H=parallel printer (DOS 3.2+)\n DS:DX addr of an IoctlCpPrepRec that contains information for the\n new code page list.\n ──────────────────────────────────────────────────────────────────\n Returns: AX error code if CF is set to CY\n ──────────────────────────────────────────────────────────────────\n Info: Instructs a device driver to begin preparing a new code-page\n list. It can also be used to select the hardware character set\n or \"refresh\" the device with the most recently-prepared character\n set.\n\n Notes: ■ To set up a new code page list:\n ■ Prepare the IoctlCpPrepRec and call this fn\n ■ Call fn 4403h (send control data) to pass the code-page\n character set remapping information to the driver.\n ■ Call fn 440cH 4dH (end cp prepare).\n\n ■ To reset to the hardware code page:\n ■ Prepare the IoctlCpPrepRec and call this fn\n ■ Immediately call fn 440cH 4dH (end cp prepare) without\n sending any control data to the driver.\n\n ■ To \"refresh\" the most recently selected code page:\n ■ Prepare the IoctlCpPrepRec, filling all of the ccpIDs fields\n with -1 (ffffH) and then call this function.\n ■ Immediately call fn 440cH 4dH (end cp prepare) without\n sending any control data to the driver.\n\nSee Also: Fn 44H (IOCTL)\n Fn 440cH (generic IOCTL for character devices)\n Generic IOCTL Data Packets\n National Language Support\n DOS Functions\n -♦-"
  },
  {
    "id": "462-dos_fn_440ch_cl_4dh__ioctl_end_code_page_prepare.html",
    "t": "DOS Fn 440cH CL=4DH: IOCTL End Code Page Prepare",
    "b": "Compatibility: 3.3+\n Expects: AX 440cH\n BX file handle (device or disk file)\n CL 4dH\n CH device category: 00H=unknown\n 01H=COMn (DOS 3.3+)\n 03H=console (screen + keyboard) (DOS 3.3+)\n 05H=parallel printer (DOS 3.2+)\n ──────────────────────────────────────────────────────────────────\n Returns: AX error code if CF is set to CY\n ──────────────────────────────────────────────────────────────────\n Info: Completes the sequence that prepares a device for preparing a\n code page list.\n\n See Fn 440cH 4cH (start cp prepare) and 4403H (send IOCTL data)\n for related information.\n\nSee Also: Fn 44H (IOCTL)\n Fn 440cH (generic IOCTL for character devices)\n National Language Support\n DOS Functions\n -♦-"
  },
  {
    "id": "463-dos_fn_440ch_cl_5fh__ioctl_set_display_mode.html",
    "t": "DOS Fn 440cH CL=5Fh: IOCTL Set Display Mode",
    "b": "Compatibility: 4.0+\n Expects: AX 440cH\n BX file handle (device or disk file; 0001H=std output)\n CL 5fH\n CH 03H (device category: console)\n DS:DX Addr of an IoctlDisplayModeRec describing desired mode\n ──────────────────────────────────────────────────────────────────\n Returns: AX error code if CF is set to CY\n ──────────────────────────────────────────────────────────────────\n Info: Sets the console screen display mode (including selecting the\n width in columns and height in lines)\n\n Before calling, you must preset the IoctlDisplayModeRec\n bInfoLevel field to 00H and the wDataLen field to 0eH (14).\n\n This fn works only if the ANSI.SYS (or equivalent) device driver\n is loaded.\n\n When an unsupported mode is requested, AX returns with 0005H\n (access denied).\n\nSee Also: Fn 44H (IOCTL)\n Fn 440cH (generic IOCTL for character devices)\n INT 2FH 1a00H (query ANSI.SYS installed state)\n DOS Functions\n -♦-"
  },
  {
    "id": "464-dos_fn_440ch_cl_65h__ioctl_query_retry_iteration_count.html",
    "t": "DOS Fn 440cH CL=65H: IOCTL Query Retry Iteration Count",
    "b": "Compatibility: 3.3+\n Expects: AX 440cH\n BX file handle (device or disk file)\n CL 65H\n CH device category: 00H=unknown\n 01H=COMn (DOS 3.3+)\n 03H=console (screen + keyboard) (DOS 3.3+)\n 05H=parallel printer (DOS 3.2+)\n DS:DX Addr of a 16-bit word to receive the current retry count.\n ──────────────────────────────────────────────────────────────────\n Returns: AX error code if CF is set to CY\n DS:DX buffer contains the retry count (if no error)\n ──────────────────────────────────────────────────────────────────\n Info: Sets the number of times the device driver should try to send\n output to the device before assuming that the device is busy.\n\n DS:DX points to a 2-byte buffer. Upon return, the buffer\n contains the current 16-bit retry count.\n\n Notes: ■ This is used only for printer drivers that support \"Output\n until Busy\". See Device Requests.\n\n ■ This setting is global. Before changing it (via, 440CH 65H),\n you should use this fn to obtain the current value. Change it\n back before exiting.\n\nSee Also: Fn 44H (IOCTL)\n Fn 440cH (generic IOCTL for character devices)\n Fn 440cH 45H (set retry iteration count)\n Generic IOCTL Data Packets\n Device Drivers\n DOS Functions\n -♦-"
  },
  {
    "id": "465-dos_fn_440ch_cl_6ah__ioctl_query_current_code_page.html",
    "t": "DOS Fn 440cH CL=6AH: IOCTL Query Current Code Page",
    "b": "Compatibility: 3.3+\n Expects: AX 440cH\n BX file handle (device or disk file)\n CL 6aH\n CH device category: 00H=unknown\n 01H=COMn (DOS 3.3+)\n 03H=console (screen + keyboard) (DOS 3.3+)\n 05H=parallel printer (DOS 3.2+)\n DS:DX Addr of buffer to hold an IoctlCpIdRec structure.\n ──────────────────────────────────────────────────────────────────\n Returns: AX error code if CF is set to CY\n DS:DX buffer is filled with IoctlCpIdRec identifying current cp\n ──────────────────────────────────────────────────────────────────\n Info: Query a driver to see what code page is currently active for that\n device.\n\nSee Also: Fn 44H (IOCTL)\n Fn 440cH (generic IOCTL for character devices)\n Fn 440cH 4aH (select code page)\n Generic IOCTL Data Packets\n National Language Support\n DOS Functions\n -♦-"
  },
  {
    "id": "466-dos_fn_440ch_cl_6bh__ioctl_query_code_page_list.html",
    "t": "DOS Fn 440cH CL=6BH: IOCTL Query Code Page List",
    "b": "Compatibility: 3.3+\n Expects: AX 440cH\n BX file handle (device or disk file)\n CL 6BH\n CH device category: 00H=unknown\n 01H=COMn (DOS 3.3+)\n 03H=console (screen + keyboard) (DOS 3.3+)\n 05H=parallel printer (DOS 3.2+)\n DS:DX addr of a buffer to hold an IoctlCpListRec structure\n ──────────────────────────────────────────────────────────────────\n Returns: AX error code if CF is set to CY\n DS:DX buffer is filled with IoctlCpListRec data (if no error)\n ──────────────────────────────────────────────────────────────────\n Info: Obtains the list of currently-prepared code pages for the\n specified device.\n\n Code pages in this list may be activated via fn 440CH 4aH.\n\n Notes: ■ See fn 440CH 4cH and National Language Support for related\n information.\n\n ■ Use fn 440CH 6aH to obtain the ID of the current active code\n page for a device.\n\nSee Also: Fn 44H (IOCTL)\n Fn 440cH (generic IOCTL for character devices)\n Generic IOCTL Data Packets\n National Language Support\n DOS Functions\n -♦-"
  },
  {
    "id": "467-dos_fn_440ch_cl_7fh__ioctl_query_display_mode.html",
    "t": "DOS Fn 440cH CL=7Fh: IOCTL Query Display Mode",
    "b": "Compatibility: 4.0+\n Expects: AX 440cH\n BX file handle (device or disk file; 0001H=std output)\n CL 7fH\n CH 03H (device category: console)\n DS:DX addr of an IoctlDisplayModeRec to receive data\n ──────────────────────────────────────────────────────────────────\n Returns: AX error code if CF is set to CY\n ──────────────────────────────────────────────────────────────────\n Info: Obtains information about the current screen mode (including the\n width in columns and height in lines).\n\n Before calling, you must preset the IoctlDisplayModeRec\n bInfoLevel field to 00H and the wDataLen field to 0eH (14).\n\n This fn works only if the ANSI.SYS (or equivalent) device driver\n is loaded.\n\nSee Also: Fn 44H (IOCTL)\n Fn 440cH (generic IOCTL for character devices)\n Fn 440cH 5FH (set display mode)\n INT 2FH 1a00H (query ANSI.SYS installed state)\n Generic IOCTL Data Packets\n DOS Functions\n -♦-"
  },
  {
    "id": "468-dos_fn_440dh__generic_i_o_control____block_devices.html",
    "t": "DOS Fn 440dH: Generic I/O Control -- Block Devices",
    "b": "See: Fn 440dH 40H (set device parameters) 3.2+\n\n Fn 440dH 41H (write track) 3.2+\n Fn 440dH 42H (format and verify track) 3.2+\n\n Fn 440dH 46H (set media ID) 4.0+\n Fn 440dH 47H (set disk access flag) 4.0 only\n Fn 440dH 60H (get device parameters) 3.2+\n\n Fn 440dH 61H (read track) 3.2+\n Fn 440dH 62H (verify track) 3.2+\n\n Fn 440dH 66H (query media ID) 4.0+\n Fn 440dH 67H (query disk access flag) 4.0 only\n Fn 440dH 68H (sense media type) 5.0+\n\n Info: These functions require a \"minor code\" value in the CL register\n as well as the 440dH in AX.\n\nSee Also: Fn 44H (IOCTL)\n Fn 440cH (generic IOCTL for character devices)\n Generic IOCTL Data Packets\n Device Drivers\n DOS Functions\n -♦-"
  },
  {
    "id": "469-dos_fn_440dh_cl_40h__ioctl_set_device_parameters.html",
    "t": "DOS Fn 440dH CL=40H: IOCTL Set Device Parameters",
    "b": "Compatibility: 3.2+\n Expects: AX 440dH\n BX drive (0=default, 1=A, 2=B, etc.)\n CL 40H\n CH 08H (device category: block device)\n DS:DX addr of an IoctlDeviceParmsRec containing desired settings\n ──────────────────────────────────────────────────────────────────\n Returns: AX error code if CF is set to CY\n ──────────────────────────────────────────────────────────────────\n Info: Sets block device parameters (such as number of cylinders, bytes-\n per-track, etc.) for the specified block device.\n\n Notes: ■ Use 440dH 60H to obtain the current settings, then make\n changes, then when done, restore the original settings.\n\nSee Also: Fn 44H (IOCTL)\n Fn 440dH (generic IOCTL for block devices)\n Fn 440dH 60H (query device parameters)\n Generic IOCTL Data Packets\n Device Requests\n DOS Functions\n -♦-"
  },
  {
    "id": "470-dos_fn_440dh_cl_41h__ioctl_write_track_on_logical_drive.html",
    "t": "DOS Fn 440dH CL=41H: IOCTL Write Track on Logical Drive",
    "b": "Compatibility: 3.2+\n Expects: AX 440dH\n BX drive (0=default, 1=A, 2=B, etc.)\n CL 41H\n CH 08H (device category: block device)\n DS:DX addr of an IoctlRdWrtTrackRec identifying the size and\n memory address of the block to write and disk location.\n ──────────────────────────────────────────────────────────────────\n Returns: AX error code if CF is set to CY\n ──────────────────────────────────────────────────────────────────\n Info: Writes an entire trackful of data to a disk. This could be used\n as part of a system to duplicate the entire contents of a disk.\n\n Carefully fill the IoctlRdWrtTrackRec with all the information\n needed before calling. You may use Fn 440dH 60H (query device\n parameters) to obtain information about a track on the specified\n disk.\n\nSee Also: Fn 44H (IOCTL)\n Fn 440dH (generic IOCTL for block devices)\n Fn 440dH 60H (query device parameters)\n Fn 440dH 61H (read disk track)\n Fn 440dH 62H (verify disk track)\n Generic IOCTL Data Packets\n DOS Functions\n -♦-"
  },
  {
    "id": "471-dos_fn_440dh_cl_42h__ioctl_format_track_on_logical_drive.html",
    "t": "DOS Fn 440dH CL=42H: IOCTL Format Track on Logical Drive",
    "b": "Compatibility: 3.2+\n Expects: AX 440dH\n BX drive (0=default, 1=A, 2=B, etc.)\n CL 42H\n CH 08H (device category: block device)\n DS:DX addr of an IoctlFmtVrfyTrackRec identifying the head and\n cylinder number to format.\n ──────────────────────────────────────────────────────────────────\n Returns: AX error code if CF is set to CY\n ──────────────────────────────────────────────────────────────────\n Info: Formats and verifies the specified track on a disk. Use\n fn 440dH 40H (set device parms), if necessary to coerce the\n driver into accepting a non-default track layout.\n\nSee Also: Fn 44H (IOCTL)\n Fn 440dH (generic IOCTL for block devices)\n Fn 440dH 41H (write disk track)\n Fn 440dH 61H (read disk track)\n Fn 440dH 62H (verify disk track)\n Generic IOCTL Data Packets\n DOS Functions\n -♦-"
  },
  {
    "id": "472-dos_fn_440dh_cl_46h__ioctl_set_media_id.html",
    "t": "DOS Fn 440dH CL=46H: IOCTL Set Media ID",
    "b": "Compatibility: 4.0+\n Expects: AX 440dH\n BX drive (0=default, 1=A, 2=B, etc.)\n CL 46H\n CH 08H (device category: block device)\n DS:DX addr of an IoctlMediaIdRec containing desired settings\n ──────────────────────────────────────────────────────────────────\n Returns: AX error code if CF is set to CY\n ──────────────────────────────────────────────────────────────────\n Info: Sets the volume label, serial number, and file system ID for the\n specified drive.\n\n This writes directly to the boot sector of the disk.\n\n You may wish to use Fn 440dH 66H (query Media ID) to pre-fill the\n IoctlMediaIdRec, then just change one or two settings before\n calling this fn.\n\nSee Also: Fn 44H (IOCTL)\n Fn 440dH (generic IOCTL for block devices)\n Fn 440dH 66H (query media ID)\n Generic IOCTL Data Packets\n DOS Functions\n -♦-"
  },
  {
    "id": "473-dos_fn_440dh_cl_47h__ioctl_set_access_flag.html",
    "t": "DOS Fn 440dH CL=47H: IOCTL Set Access Flag",
    "b": "Compatibility: 4.0 only ◄Undoc►\n Expects: AX 440dH\n BX drive (0=default, 1=A, 2=B, etc.)\n CL 47H\n CH 08H (device category: block device)\n DS:DX addr of a two-byte structure:\n DS:[DX+0] 0\n DS:[DX+1] 00H=lock the drive\n 01H=unlock the drive; deny future access\n ──────────────────────────────────────────────────────────────────\n Returns: AX error code if CF is set to CY\n ──────────────────────────────────────────────────────────────────\n Info: Locks or unlocks all read/write access to the specified drive.\n The driver may disable all disk access, for instance, when it\n detects unformatted media or an invalid boot record.\n\n Note: This function is not documented in official MS-DOS references.\n\nSee Also: Fn 44H (IOCTL)\n Fn 440dH (generic IOCTL for block devices)\n Fn 440dH 67H (query access flag)\n DOS Functions\n -♦-"
  },
  {
    "id": "474-dos_fn_440dh_cl_60h__ioctl_query_device_parameters.html",
    "t": "DOS Fn 440dH CL=60H: IOCTL Query Device Parameters",
    "b": "Compatibility: 3.2+\n Expects: AX 440dH\n BX drive (0=default, 1=A, 2=B, etc.)\n CL 60H\n CH 08H (device category: block device)\n DS:DX addr of a buffer to hold an IoctlDeviceParmsRec\n The rSpclFns field specifies to get info for the current or\n the default medium (i.e., for removable media devices)\n ──────────────────────────────────────────────────────────────────\n Returns: AX error code if CF is set to CY\n DS:DX buffer is filled with current settings\n ──────────────────────────────────────────────────────────────────\n Info: Obtains the block device parameters (such as number of cylinders,\n bytes-per-track, etc.) for the specified block device. It can\n obtain info for the default media or the current active media.\n\n To get info for the current media:\n Put 01H in the rSpclFns field (at offset 0) before calling\n\n To get info for the default media:\n Put 02H in the rSpclFns field before calling\n\nSee Also: Fn 44H (IOCTL)\n Fn 440dH (generic IOCTL for block devices)\n Fn 440dH 40H (set device parameters)\n Generic IOCTL Data Packets\n Device Requests\n DOS Functions\n -♦-"
  },
  {
    "id": "475-dos_fn_440dh_cl_61h__ioctl_read_track_on_logical_drive.html",
    "t": "DOS Fn 440dH CL=61H: IOCTL Read Track on Logical Drive",
    "b": "Compatibility: 3.2+\n Expects: AX 440dH\n BX drive (0=default, 1=A, 2=B, etc.)\n CL 61H\n CH 08H (device category: block device)\n DS:DX addr of an IoctlRdWrtTrackRec identifying the size and disk\n location of the block to read and the memory address to\n store the data.\n ──────────────────────────────────────────────────────────────────\n Returns: AX error code if CF is set to CY\n DS:DX the buffer at IoctlRdWrtTrackRec.rwBuffer is filled with the\n requested data\n ──────────────────────────────────────────────────────────────────\n Info: Read an entire trackful of data from a block device to memory.\n This could be used as part of a system to duplicate the entire\n contents of a disk.\n\n Carefully fill the IoctlRdWrtTrackRec with all the information\n needed before calling. You may use Fn 440dH 60H (query device\n parameters) to obtain information about a track on the specified\n disk.\n\nSee Also: Fn 44H (IOCTL)\n Fn 440dH (generic IOCTL for block devices)\n Fn 440dH 41H (write disk track)\n Fn 440dH 60H (query device parameters)\n Fn 440dH 62H (verify disk track)\n Generic IOCTL Data Packets\n DOS Functions\n -♦-"
  },
  {
    "id": "476-dos_fn_440dh_cl_62h__ioctl_verify_track_on_logical_drive.html",
    "t": "DOS Fn 440dH CL=62H: IOCTL Verify Track on Logical Drive",
    "b": "Compatibility: 3.2+\n Expects: AX 440dH\n BX drive (0=default, 1=A, 2=B, etc.)\n CL 62H\n CH 08H (device category: block device)\n DS:DX addr of an IoctlFmtVrfyTrackRec identifying the head and\n cylinder number to verify.\n ──────────────────────────────────────────────────────────────────\n Returns: AX error code if CF is set to CY\n ──────────────────────────────────────────────────────────────────\n Info: Verifies that the CRC code of a track on a disk matches the CRC\n of the data on that track.\n\nSee Also: Fn 44H (IOCTL)\n Fn 440dH (generic IOCTL for block devices)\n Fn 440dH 41H (write disk track)\n Fn 440dH 61H (read disk track)\n Fn 440dH 42H (format disk track)\n Generic IOCTL Data Packets\n DOS Functions\n -♦-"
  },
  {
    "id": "477-dos_fn_440dh_cl_66h__ioctl_query_media_id.html",
    "t": "DOS Fn 440dH CL=66H: IOCTL Query Media ID",
    "b": "Compatibility: 4.0+\n Expects: AX 440dH\n BX drive (0=default, 1=A, 2=B, etc.)\n CL 66H\n CH 08H (device category: block device)\n DS:DX addr of an IoctlMediaIdRec to receive the data\n ──────────────────────────────────────────────────────────────────\n Returns: AX error code if CF is set to CY\n DS:DX buffer is filled with requested info\n ──────────────────────────────────────────────────────────────────\n Info: Obtains the current volume label, serial number, and file system\n ID for the specified drive.\n\nSee Also: Fn 44H (IOCTL)\n Fn 440dH (generic IOCTL for block devices)\n Fn 440dH 46H (set media ID)\n DOS Functions\n -♦-"
  },
  {
    "id": "478-dos_fn_440dh_cl_67h__ioctl_query_access_flag.html",
    "t": "DOS Fn 440dH CL=67H: IOCTL Query Access Flag",
    "b": "Compatibility: 4.0 only ◄Undoc►\n Expects: AX 440dH\n BX drive (0=default, 1=A, 2=B, etc.)\n CL 67H\n CH 08H (device category: block device)\n DS:DX addr of a 16-bit buffer to receive information\n ──────────────────────────────────────────────────────────────────\n Returns: AX error code if CF is set to CY\n DS:DX buffer contains returned data:\n DS:[DX+0] always 0\n DS:[DX+1] 00H=drive is NOT locked\n 01H=drive is locked; access is denied\n ──────────────────────────────────────────────────────────────────\n Info: Obtains the current setting of the disk access flag. The driver\n may disable all disk access, for instance, when it detects\n unformatted media or an invalid boot record.\n\n Note: This function is not documented in official MS-DOS references.\n\nSee Also: Fn 44H (IOCTL)\n Fn 440dH (generic IOCTL for block devices)\n Fn 440dH 47H (set access flag)\n Generic IOCTL Data Packets\n DOS Functions\n -♦-"
  },
  {
    "id": "479-dos_fn_440dh_cl_68h__ioctl_sense_media_type.html",
    "t": "DOS Fn 440dH CL=68H: IOCTL Sense Media Type",
    "b": "Compatibility: 5.0+\n Expects: AX 440dH\n BX drive (0=default, 1=A, 2=B, etc.)\n CL 68H\n CH 08H (device category: block device)\n DS:DX addr of a 16-bit word to receive the current media type\n ──────────────────────────────────────────────────────────────────\n Returns: AX error code if CF is set to CY\n DS:DX buffer contains two 8-bit values identifying the media type\n in the specified drive\n DS:[DX+0] 01H=it is the default media type\n 00H=it is NOT the default media type\n DS:[DX+1] 02H=720K media is in the drive\n 07H=1.44 MB media\n 09H=2.88 MB media\n ──────────────────────────────────────────────────────────────────\n Info: Obtains information on what type of media is currently in the\n specified drive.\n\n This function is not supported by all device drivers for all\n media types.\n\nSee Also: Fn 44H (IOCTL)\n Fn 440dH (generic IOCTL for block devices)\n Fn 440dH 66H (query media ID)\n Generic IOCTL Data Packets\n DOS Functions\n -♦-"
  },
  {
    "id": "480-dos_fn_440eh__ioctl_query_logical_drive_map.html",
    "t": "DOS Fn 440eH: IOCTL Query Logical Drive Map",
    "b": "Compatibility: 3.2+\n Expects: AX 440eH\n BL drive number to be used (0=default, 1=A, 2=B, etc.)\n ──────────────────────────────────────────────────────────────────\n Returns: AX error code if CF is set to CY\n AL 00H: the drive has only one drive number (if no error)\n 01H-1aH: the drive number currently being used to refer to\n this physical drive.\n ──────────────────────────────────────────────────────────────────\n Info: This checks to see of a physical drive is currently acting as a\n phantom floppy (or \"logical drive\") and if the alternate drive ID\n is currently being used.\n\n If CY is clear on return, then AL contains either 0 (no logical\n mappings) or AL contains the alternative drive number that can\n refer to this drive (1=A, 2=B. etc.).\n\n Notes: ■ If fn 440fH (set logical drive map) has not been called, all\n logical drive numbers will match the physical numbers.\n\n ■ The phantom floppy concept is used by DOS on systems which have\n a single diskette drive. In that case, when you attempt to\n access drive B, DOS prompts with:\n\n Insert diskette for drive B.\n Press any key when ready.\n\n Programs may use this function to avoid using a logical ID and\n thus, avoid having DOS issue this prompt.\n\n ■ Phantom floppies are also created by the Driver.Sys installable\n device driver.\n\nSee Also: Fn 44H (IOCTL)\n Fn 440fH (set logical drive map)\n DOS Functions\n -♦-"
  },
  {
    "id": "481-dos_fn_440fh__ioctl_set_logical_drive_map.html",
    "t": "DOS Fn 440fH: IOCTL Set Logical Drive Map",
    "b": "Compatibility: 3.2+\n Expects: AX 440eH\n BL drive in question (0=default, 1=A, 2=B, etc.)\n ──────────────────────────────────────────────────────────────────\n Returns: AX error code if CF is set to CY\n AL 00H: the drive has only one drive number (if no error)\n else: drive number currently being used to refer to this\n physical drive.\n ──────────────────────────────────────────────────────────────────\n Info: This tells the device driver that its \"drive alias\" will be used\n in subsequent read/write access.\n\n Notes: ■ The phantom floppy concept is used by DOS on systems which have\n a single diskette drive. In that case, when you attempt to\n access drive B, DOS prompts with:\n\n Insert diskette for drive B.\n Press any key when ready.\n\n Programs may use this function to ell that driver that the\n \"disk for drive B\" is already in place--and thus avoid having\n DOS issue this prompt.\n\n ■ Phantom floppies are also created by the Driver.Sys installable\n device driver.\n\nSee Also: Fn 44H (IOCTL)\n Fn 440eH (query logical drive map)\n DOS Functions\n -♦-"
  },
  {
    "id": "482-dos_fn_4410h__ioctl_query_ioctl_support_for_handle.html",
    "t": "DOS Fn 4410H: IOCTL Query IOCTL Support for Handle",
    "b": "Compatibility: 5.0+\n Expects: AX 4410H\n BX file handle (device or disk file)\n CH device category: 00H=unknown\n 01H=COMn (DOS 3.3+)\n 03H=console (screen + keyboard) (DOS 3.3+)\n 05H=parallel printer (DOS 3.2+)\n CL subfn number to query:\n 45H = set retry iteration count --see fn 440CH 45H\n 65H = query retry iteration count--see fn 440CH 65H\n ──────────────────────────────────────────────────────────────────\n Returns: AX error code if CF is set to CY\n ──────────────────────────────────────────────────────────────────\n Info: This checks to see if certain IOCTL functions are supported for a\n particular file handle.\n\n On return, if CF=NC=0, then the specified function IS supported.\n\n On return, if CF=CY=1, then the error code in AX indicates why\n the function is not supported:\n AX=0001 (invalid function): no support for IOCTL fns at all.\n AX=0005 (access denied): that fn (in CL) is not supported.\n\nSee Also: Fn 44H (IOCTL)\n Fn 440cH (generic IOCTL for character devices)\n DOS Functions\n -♦-"
  },
  {
    "id": "483-dos_fn_4411h__ioctl_query_ioctl_support_for_device.html",
    "t": "DOS Fn 4411H: IOCTL Query IOCTL Support for Device",
    "b": "Compatibility: 5.0+\n Expects: AX 4411H\n BL drive number of device (0=default, 1=A, 2=B, etc.)\n CH 08H (device category: drive)\n CL subfn number to query:\n 40H set device parameters -- See 440dH 40H\n 41H write track -- See 440dH 41H\n 42H format and verify track -- See 440dH 42H\n 46H set media ID -- See 440dH 46H\n 60H get device parameters -- See 440dH 60H\n 61H read track -- See 440dH 61H\n 62H verify track -- See 440dH 62H\n 66H query media ID -- See 440dH 66H\n 68H sense media type -- See 440dH 68H\n ──────────────────────────────────────────────────────────────────\n Returns: AX error code if CF is set to CY\n ──────────────────────────────────────────────────────────────────\n Info: This checks to see if certain IOCTL functions are supported for a\n particular block device.\n\n On return, if CF=NC=0, then the specified function IS supported.\n\n On return, if CF=CY=1, then the error code in AX indicates why\n the function is not supported:\n AX=0001 (invalid function): no support for IOCTL fns at all.\n AX=0005 (access denied): that fn (in CL) is not supported.\n\nSee Also: Fn 44H (IOCTL)\n Fn 440dH (generic IOCTL for block devices)\n DOS Functions\n -♦-"
  },
  {
    "id": "484-ioctl_device_or_file_info.html",
    "t": "IOCTL Device or File Info",
    "b": "DOS Fn 4400H and 4401H use this for values passed in DX. The bit flags\n have different meanings, depending upon bit 7 (device or file).\n\n Note: The upper 8 bits are the same as those in the Device Attribute\n for the device.\n\nIoctlDevInfoRec ─── layout when describing a device\n 1 1 1 1 1 1\n╓5┬4┬3┬2┬1┬0┬9┬8╥7┬6┬5┬4┬3┬2┬1┬0╖\n║1│ │ │0│ │0 0 0║1│e│b│f│c│n│o│i║\n╙╥┴╥┴╥┴─┴╥┴─┴─┴─╨╥┴╥┴╥┴╥┴╥┴╥┴╥┴╥╜ bit mask\n ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ╚═► 0: 0001H Console Input device\n ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ╚═══► 1: 0002H Console Output device\n ║ ║ ║ ║ ║ ║ ║ ║ ║ ╚═════► 2: 0004H Null device\n ║ ║ ║ ║ ║ ║ ║ ║ ╚═══════► 3: 0008H Clock device\n ║ ║ ║ ║ ║ ║ ║ ╚═════════► 4: 0010H special device; fast output\n ║ ║ ║ ║ ║ ║ ╚═══════════► 5: 0020H binary mode; 0=ASCII\n ║ ║ ║ ║ ║ ╚═════════════► 6: 0040H not EOF; 0=EOF on input\n ║ ║ ║ ║ ╚═══════════════► 7: 0080H 1=device\n ║ ║ ║ ╚═══════════════════════►11: 0800H supports device open DvRq 0DH\n ║ ║ ║ and device close DvRq 0EH\n ║ ║ ╚═══════════════════════════►13: 2000H spts output-till-busy DvRq 10H\n ║ ╚═════════════════════════════►14: 4000H supports IOCTL Read DvRq 03H\n ║ and IOCTL Write DvRq 0CH\n ╚═══════════════════════════════►15: 8000H 0=block device; 1=char device\n\nIoctlFileInfoRec ─── layout when describing a file\n 1 1 1 1 1 1\n╓5┬4┬3┬2┬1┬0┬9┬8╥7┬6┬5┬4┬3┬2┬1┬0╖\n║0│ │ │0│ │0 0 0║0│ │ drive ID ║\n╙╥┴╥┴╥┴─┴╥┴─┴─┴─╨╥┴╥┴╥┴─┴─┴─┴─┴╥╜ bit mask\n ║ ║ ║ ║ ║ ║ ╚═════════╩═►0-5: 003fH drive ID (0=A, 1=B, etc.)\n ║ ║ ║ ║ ║ ╚═════════════► 6: 0040H not EOF; 0=EOF on input\n ║ ║ ║ ║ ╚═══════════════► 7: 0080H 0=file\n ║ ║ ║ ╚═══════════════════════► 11: 0800H supports device open DvRq 0DH\n ║ ║ ║ and device close DvRq 0EH\n ║ ║ ║ and Removable Media DvRq 0FH\n ║ ║ ╚═══════════════════════════► 13: 2000H 0=Needs FAT with BPB DvRq 02H\n ║ ╚═════════════════════════════► 14: 4000H supports IOCTL Read DvRq 03H\n ║ and IOCTL Write DvRq 0CH\n ╚═══════════════════════════════►15: 8000H 0=block device; 1=char device\n\nSee Also: fn 4400H (IOCTL query device/file flags)\n fn 4401H (IOCTL set device/file flags)\n Device Attribute\n DOS Functions\n -♦-"
  },
  {
    "id": "485-ioctldriveinforec.html",
    "t": "IoctlDriveInfoRec",
    "b": "DOS Fn 4409H (is drive remote) returns this layout in DX.\n\nIoctlDriveInfoRec ─── layout when describing a local drive\n 1 1 1 1 1 1\n╓5┬4┬3┬2┬1┬0┬9┬8╥7┬6┬5┬4┬3┬2┬1┬0╖\n║s│i│f│0│r│0│l│0║q│g│0 0 0 0 0│a║\n╙╥┴╥┴╥┴─┴╥┴─┴╥┴─╨╥┴╥┴─┴─┴─┴─┴─┴╥╜ bit mask\n ║ ║ ║ ║ ║ ║ ║ ╚═► 0: 0001H uses 32-bit addressing\n ║ ║ ║ ║ ║ ║ ╚═════════════► 6: 0040H suprts generic Blk IOCTL 440dH\n ║ ║ ║ ║ ║ ║ and get logical drive map 440eH\n ║ ║ ║ ║ ║ ║ and set logical drive map 440fH\n ║ ║ ║ ║ ║ ╚═══════════════► 7: 0080H suprts query IOCTL suprt 4411H\n ║ ║ ║ ║ ╚═══════════════════► 9: 0100H this local drive is shared\n ║ ║ ║ ╚═══════════════════════►11: 0800H supports Is Media Rmvbl 4408H\n ║ ║ ╚═══════════════════════════►13: 2000H Needs FAT with BPB DvRq 02H\n ║ ╚═════════════════════════════►14: 4000H supports IOCTL Read 4404H\n ║ and IOCTL Write 4405H\n ╚═══════════════════════════════►15: 8000H 1=this is a Subst drive\n\nSee Also: fn 4409H (IOCTL is drive remote)\n Device Attribute\n Device Drivers\n DOS Functions\n -♦-"
  },
  {
    "id": "486-ioctlhandleinforec.html",
    "t": "IoctlHandleInfoRec",
    "b": "DOS Fn 440aH (is file or device remote) returns this layout in DX. The\n meanings of the bits vary depending upon the value in bit 7 (file/device).\n\nIoctlHandleInfoFileRec ─── layout when describing a disk file\n 1 1 1 1 1 1\n╓5┬4┬3┬2┬1┬0┬9┬8╥7┬6┬5┬4┬3┬2┬1┬0╖\n║r│t│0│i│0 0 0 0║0│o│ drive id ║\n╙╥┴╥┴─┴╥┴─┴─┴─┴─╨╥┴╥┴╥┴─┴─┴─┴─┴╥╜ bit mask\n ║ ║ ║ ║ ║ ╚═════════╩═►0-5: 003fH drive ID (0=A, 1=B, etc.)\n ║ ║ ║ ║ ╚═════════════► 6: 0040H file has not been written to\n ║ ║ ║ ╚═══════════════► 7: 0080H 0=file\n ║ ║ ╚═════════════════════════► 12: 1000H 1=no inherit\n ║ ╚═════════════════════════════► 14: 4000H 1=date/time not set on close\n ╚═══════════════════════════════► 15: 8000H 1=remote file; 0=local file\n\nIoctlHandleInfoDevRec ─── layout when describing a device\n 1 1 1 1 1 1\n╓5┬4┬3┬2┬1┬0┬9┬8╥7┬6┬5┬4┬3┬2┬1┬0╖\n║r│0│p│i│s│0 0 0║1│e│b│f│c│n│o│i║\n╙╥┴─┴╥┴╥┴╥┴─┴─┴─╨╥┴╥┴╥┴╥┴╥┴╥┴╥┴╥╜ bit mask\n ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ╚═► 0: 0001H Console Input device\n ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ╚═══► 1: 0002H Console Output device\n ║ ║ ║ ║ ║ ║ ║ ║ ║ ╚═════► 2: 0004H Null device\n ║ ║ ║ ║ ║ ║ ║ ║ ╚═══════► 3: 0008H Clock device\n ║ ║ ║ ║ ║ ║ ║ ╚═════════► 4: 0010H special device; fast output\n ║ ║ ║ ║ ║ ║ ╚═══════════► 5: 0020H binary mode; 0=ASCII\n ║ ║ ║ ║ ║ ╚═════════════► 6: 0040H not EOF; 0=EOF on input\n ║ ║ ║ ║ ╚═══════════════► 7: 0080H 1=device\n ║ ║ ║ ╚═══════════════════════► 11: 0800H network spooler\n ║ ║ ╚═════════════════════════► 12: 1000H no inherit\n ║ ╚═══════════════════════════► 13: 2000H named pipe\n ╚═══════════════════════════════► 15: 8000H 1=remote device; 0=local\n\nSee Also: fn 440aH (IOCTL is file/device remote)\n Device Attribute\n Device Drivers\n DOS Functions\n -♦-"
  },
  {
    "id": "487-generic_ioctl_data_packets.html",
    "t": "Generic IOCTL Data Packets",
    "b": "The following structures are used in DOS Generic IOCTL calls and related\n device driver requests:\n\n 440cH Data Packets 440dH Data Packets\n Character Device IOCTL Block Device IOCTL\n ────────────────────── ─────────────────────\n IoctlCpListRec IoctlDeviceParmsRec\n IoctlCpPrepRec IoctlFmtVrfyTrackRec\n IoctlCpIdRec IoctlMediaIdRec\n IoctlDisplayModeRec IoctlRdWrtTrackRec\n TrackLayoutRec\n\nSee Also: fn 440cH (Generic IOCTL for character devices)\n fn 440dH (Generic IOCTL for block devices)\n National Language Support\n Device Drivers\n DOS Functions\n -♦-"
  },
  {
    "id": "488-ioctlcpidrec.html",
    "t": "IoctlCpIdRec",
    "b": "This structure is used in the following IOCTL fns:\n 440cH 4aH (select code page)\n 440cH 6aH (query current code page)\n DvRq 13H (generic IOCTL for character devices)\n\nIoctlCpIdRec\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 2 wLength length of the rest of this structure (0002)\n +2 2 wCpId the code page number\n 4 length of an IoctlCpIdRec structure\n\nSee Also: fn 440cH (Generic IOCTL for character devices)\n National Language Support\n Device Drivers\n DOS Functions\n -♦-"
  },
  {
    "id": "489-ioctlcplistrec.html",
    "t": "IoctlCpListRec",
    "b": "This structure is used in the following IOCTL fns:\n 440cH 6bH (query code page prepared list)\n DvRq 13H (generic IOCTL for character devices)\n\nIoctlCpListRec\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +2 2 wLength length of the rest of this structure;\n (wHdwrIdCnt*2)+2 + (wPrpdIdCnt*2)+2\n +4 2 wHdwrIdCnt the number of items in awHdwrIdList array\n +6 2*n awHdwrIdList variable-length series of code page IDs which are\n defined internally by the hardware\n 6+(2*n) 2 wPrpdIdCnt the number of items in awPrpdIdList array\n 8+(2*n) 2*m awPrpdIdList variable-length series if code page IDs which\n have been prepared (e.g., downloaded)\n 8+(2*m)+(2*n) length of an IoctlCpListRec structure\n\n The return packet may be up to 56 bytes long.\n\n There may be up to 12 items in the awCpIdList field in the structure,\n depending on the parameters specified when the driver was installed.\n\nSee Also: fn 440cH (Generic IOCTL for character devices)\n National Language Support\n Device Drivers\n DOS Functions\n -♦-"
  },
  {
    "id": "490-ioctlcppreprec.html",
    "t": "IoctlCpPrepRec",
    "b": "This structure is used in the following IOCTL fns:\n 440cH 4cH (start code page prepare)\n DvRq 13H (generic IOCTL for character devices)\n\nIoctlCpPrepRec\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 2 rDevFlags device-specific bit flags\n +2 2 wLength length of the rest of this structure;\n ( (wCpIdCnt * 2) + 2)\n +4 2 wCpIdCnt the number of items in awCpIds array\n +6 n*2 awCpIdList variable-length series of code page numbers\n (n*2)+6 length of an IoctlCpPrepRec structure\n\n There may be up to 12 items in the awCpIdList field in the structure,\n depending on parameter values specified when the driver was installed.\n\n If any of the elements in awCpIdList is ffffH, it tells the device driver\n to NOT modify the code page at that position in its own list.\n\nSee Also: fn 440cH (Generic IOCTL for character devices)\n National Language Support\n Device Drivers\n DOS Functions\n -♦-"
  },
  {
    "id": "491-ioctldisplaymoderec.html",
    "t": "IoctlDisplayModeRec",
    "b": "This structure is used in the following IOCTL fns:\n 440cH 5fH (set display mode)\n 440cH 7fH (query display mode)\n DvRq 13H (generic IOCTL for character devices)\n\n The ANSI.SYS device driver uses this structure.\n\nIoctlDisplayModeRec\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 1 bInfoLevel must be 0\n +1 1 res1 (reserved)\n +2 2 wDataLen 14; Length of the following data, in bytes\n +4 2 wFlags flags: 0001H=bold background enabled\n +6 1 bTxtGfx mode: 01H = text mode\n 02H = graphics mode\n +7 1 res2 (reserved--16-bit SVGA modes?)\n +8 2 wColors number of colors supported\n +0aH 2 wWidth screen width, in pixels (graphics modes)\n +0cH 2 wHeight screen height, in pixels (graphics modes)\n +0eH 2 wClms screen columns (width, in character columns)\n +10H 2 wRows screen lines (height, in character rows)\n 18 length of an IoctlDisplayModeRec structure\n\n bInfoLevel must be set to 00H before invoking the fn\n wDataLen must be set to 0eH (14) before invoking the fn\n wFlags currently only one flag is defined:\n 0000H=normal treatment of Video Attribute bit 7 (makes the\n foreground color blink; only seven background colors).\n 0001H=enable bold background; attribute bit 7 is part of\n the 4-bit background color.\n bTxtGfx 00H=text mode; 01H=graphics mode\n wColors number of colors supported; usually 16 for text modes\n\n wWidth and...\n wHeight define graphics mode screen resolution, in pixels. These are\n ignored when bTxtGfx is 01H.\n wClms and...\n wRows define texts mode screen resolution, in characters. When\n bTxtGfx is 01H (graphics), this is also valid; it's the number\n of character cells displayable by BIOS and DOS display fns.\n\nSee Also: fn 440cH (Generic IOCTL for character devices)\n INT 2FH 1a00H (query ANSI.SYS installed state)\n ANSI Console Escape Sequences\n DOS Functions\n -♦-"
  },
  {
    "id": "492-ioctldeviceparmsrec.html",
    "t": "IoctlDeviceParmsRec",
    "b": "This structure is used in the following IOCTL fns:\n 440dH 40H (set device parameters)\n 440dH 60H (query device parameter)\n DvRq 13H (generic IOCTL for block devices)\n\nIoctlDeviceParmsRec\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 1 rSpclFns bit flags select options\n +1 1 bDevType device type code (returned from driver)\n +2 2 rDevAttr bit 0: 0=removable; 1=non-removable\n bit 1: 0=change-line not supported; 1=is\n +4 2 wCylCnt number of cylinders (returned from driver)\n +6 1 bDevMedia bit 0: 0=accepts high density (1.2MB) media\n 1=accepts low-density (320K/360K) media\n +7 19H rDevBPB Same as a BPBRec (25 bytes)\n +20H ? rTrkLayout variable-length TrackLayoutRec\n ?+20H size of an IoctlDeviceParmsRec\n\n rSpclFns contain bit flags that specify options for fn 440dH 40H:\n bit 0: 0=use rDevBPB to set new defaults\n 1=use current BPB\n bit 1: 0=use all fields of this record\n 1=use just the rTrkLayout data\n bit 2: 0=(never use)\n 1=sectors are all the same size and sector numbers\n begin with 0 (always set this bit)\n\n bDevType identifies the device and medium. It is one of:\n\n 00H = 320/360K 5-¼ inch drive\n 01H = 1.2M 5-¼ inch drive\n 02H = 720K 3-½ inch drive\n 03H = 8 inch single density drive\n 04H = 8 inch double density drive\n 05H = hard disk\n 06H = tape drive\n 07H = 1.44 MB\n 08H = 2.88 MB\n 09H = other\n\n rDevAttr some more device info flags:\n bit 0: 0=removable\n 1=non-removable\n bit 1: 0=change-line not supported\n 1=is supported (can sense when drive door opened)\n\n wCylCnt maximum cylinder supported (e.g., for 440dH 41H Write Track)\n\n bMedia one bit of media info:\n bit 0: 0=accepts high density (1.2MB) media\n 1=accepts low-density (320K/360K) media\n\n rDevBPB an entire BPBRec structure (all 25 bytes).\n If rSpclFns bit 0 is clear, then this data is taken as the new\n default settings for the drive.\n If rSpclFns bit 1 is set, then this data is to be used by the\n driver when it gets a DvRq 02H (Build BPB) request.\n\n rTrkLayout an entire TrackLayoutRec structure (variable length).\n If rSpclFns bit 1 is set, then only this track layout\n information is used.\n\nSee Also: fn 440dH (Generic IOCTL for block devices)\n Device Drivers\n DOS Functions\n -♦-"
  },
  {
    "id": "493-ioctlfmtvrfytrackrec.html",
    "t": "IoctlFmtVrfyTrackRec",
    "b": "This structure is used in the following IOCTL fns:\n 440dH 42H (format track on logical drive)\n 440dH 62H (verify track on logical drive)\n\n DvRq 13H (generic IOCTL for block devices)\n\nIoctlFmtVrfyTrackRec\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 1 rSpclFns must be 0\n +1 2 wHead head to read/write\n +3 2 wTrack track (cylinder) to read/write\n 5 size of an IoctlFmtVrfyTrackRec\n\n Notes: DOS device drivers do not keep a track layout table for each\n logical device. Before formatting a track, use a generic IOCTL\n Set Parameters (440dH 40H) call to set the interleave etc. for\n the media in the drive.\n\nSee Also: fn 440dH (Generic IOCTL for block devices)\n Device Drivers\n DOS Functions\n -♦-"
  },
  {
    "id": "494-ioctlmediaidrec.html",
    "t": "IoctlMediaIdRec",
    "b": "This structure is used to uniquely identify the medium in a drive. It is\n used in the following IOCTL fns:\n 440dH 46H (set media ID)\n 440dH 66H (query media ID)\n\n DvRq 13H (generic IOCTL for block devices)\n\nIoctlMediaIdRec\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 2 wInfoLevel always 00\n +2 4 lSerNo 32-bit volume serial number\n +6 0bH abVolLabel 11-character text volume label, blank-padded\n +11H 8 abFileSysID contains 'FAT12 ' or 'FAT16 ')\n 19H (25) size of an IoctlMediaIdRec\n\nSee Also: fn 440dH (Generic IOCTL for block devices)\n Device Drivers\n DOS Functions\n -♦-"
  },
  {
    "id": "495-ioctlrdwrttrackrec.html",
    "t": "IoctlRdWrtTrackRec",
    "b": "This structure is used in the following IOCTL fns:\n 440dH 41H (write track on logical drive)\n 440dH 61H (read track on logical drive)\n\n DvRq 13H (generic IOCTL for block devices)\n\nIoctlRdWrtTrackRec\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 1 rSpclFns (always 00)\n +1 2 wHead head to read/write\n +3 2 wTrack track (cylinder) to read/write\n +5 2 wStartSect starting sector (0-based; sector 1=0, 2=1...)\n +7 2 wSectCnt sector count (0-based; use 8 for 9-sector track)\n +9 4 fpBuff 32-bit addr of buffer containing data to write\n (440dH 41H) or addr to hold data read (440dH 41H)\n 0dH (13) size of an IoctlRdWrtTrackRec\n\n Notes: The wStartSect field is relative to the start of the track (for\n instance, to write an entire track on a 9-sector/track diskette,\n set wStartSect to 0 and set wSectCnt to 9.\n\n This is the only place I've seen where tracks are not specified\n with their \"hardware code\" numbers (e.g. 1-9).\n\nSee Also: fn 440dH (Generic IOCTL for block devices)\n Device Drivers\n DOS Functions\n -♦-"
  },
  {
    "id": "496-tracklayoutrec.html",
    "t": "TrackLayoutRec",
    "b": "This structure is used (at the end of an IoctlDeviceParmsRec in the\n following IOCTL fns:\n\n 440dH 40H (set device parameters)\n 440dH 60H (query device parameter)\n DvRq 13H (generic IOCTL for block devices)\n\nTrackLayoutRec\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 2 rSectCnt sectors per track\n +2 n*4 arLayout variable-length array of 2-word sector\n descriptors.\n Each element is: WORD: sector number\n WORD: sector size\n 2+(n*4) size of a TrackLayoutRec structure\n\n Notes: This structure is needed to create \"sector interleave\" in which\n the sectors are not numbered sequentially on the physical medium.\n The idea is to let the disk spin for a partial rotation while the\n hardware is processing the data, with the ultimate goal being to\n access an entire track without wasting time waiting for the data\n to come under the head.\n\n Example layout:\n\n DW 9 ; nine sectors per track\n DW 1,512 ; first sector is #1 (size is 512 bytes)\n DW 5,512 ; next sector is #5\n DW 2,512 ; next sector\n DW 6,512 ; next sector\n DW 3,512 ; next sector\n DW 7,512 ; next sector\n DW 4,512 ; next sector\n DW 8,512 ; next sector\n DW 9,512 ; next sector\n\n DOS device drivers do not keep a track layout table for each\n logical device. A generic IOCTL Set Parameters (440dH 40H) call\n must be made when the attributes of the media change.\n\nSee Also: fn 440dH (Generic IOCTL for block devices)\n INT 13H 05H (format track)\n Device Drivers\n DOS Functions\n -♦-"
  },
  {
    "id": "497-dos_fn_45h__duplicate_a_file_handle.html",
    "t": "DOS Fn 45H: Duplicate a File Handle",
    "b": "Compatibility: 2.0+\n Expects: AH 45H\n BX existing file handle\n ──────────────────────────────────────────────────────────────────\n Returns: AX new file handle that duplicates the original\n error code if CF is set to CY\n ──────────────────────────────────────────────────────────────────\n Info: Creates an additional file handle that refers to the same I/O\n stream as an existing file handle.\n\n Any motion of the file read/write pointer for one handle will\n also affect that of the duplicate -- including any file read,\n write, or file pointer motion via Fn 42H (Lseek).\n\n The new handle inherits the Open Mode of the original.\n\n Notes: ■ This function has one main use in a single-tasking system: You\n can close the duplicate handle, forcing DOS to FLUSH THE FILE\n BUFFERS. This dup/close sequence is faster than closing and\n re-opening a disk file. DOS 3.3+ offers a better method with\n Fn 68H (Commit).\n\nSee Also: Handle-Oriented File I/O\n Fn 46H (redirect a handle to a different file/device)\n Standard I/O\n DOS Functions\n -♦-"
  },
  {
    "id": "498-dos_fn_46h__redirect_a_handle.html",
    "t": "DOS Fn 46H: Redirect a Handle",
    "b": "Compatibility: 2.0+\n Expects: AH 46H\n BX destination file handle (must already exist)\n CX source file handle (must already exist)\n ──────────────────────────────────────────────────────────────────\n Returns: AX error code if CF is set to CY\n ──────────────────────────────────────────────────────────────────\n Info: Forces a file handle to refer to a different file or device. The\n file handle in CX (the source) is closed (if currently open) and\n then made to become a duplicate of the handle in BX (the\n destination).\n\n In other words, both CX and BX will refer to the same physical\n file or device. All accesses of the CX-handle file will go to or\n come from the BX-handle file.\n\n Use this function to redirect Standard I/O. For example:\n\n ■ Open a text file for output and obtain its handle (e.g.,\n 0005H).\n\n ■ Set BX=0005H, CX=0001H and call Fn 46H. Note: Handle 0001H\n is the pre-defined handle of the \"standard output device\".\n\n ■ Use Fn 3eH Close File to close handle 05H if you wish.\n\n ■ All subsequent output to the \"standard output\" by any process\n (the current process or any spawns), including outputs via\n any DOS Character I/O function and any writes to file handle\n 0001H via DOS Fn 40H, will go to the text file.\n\n ■ When you exit, the pre-defined file handles are reset to the\n normal devices (e.g., handle 0001H is reset to \"CON\").\n\nSee Also: Handle-Oriented File I/O\n Standard I/O\n DOS Functions\n -♦-"
  },
  {
    "id": "499-dos_fn_47h__query_default_directory.html",
    "t": "DOS Fn 47H: Query Default Directory",
    "b": "Compatibility: 2.0+\n Expects: AH 47H\n DL drive number (0=default, 1=A, etc.)\n DS:SI address of a local buffer to hold a pathname (64 bytes)\n ──────────────────────────────────────────────────────────────────\n Returns: AX error code if CF is set to CY\n ──────────────────────────────────────────────────────────────────\n Info: The buffer starting at DS:SI is filled with an ASCIIZ▲ pathname\n of the current default directory for the drive specified by DL.\n\n The pathname is returned in the form...\n d:\\path\\filename.ext◄0►\n\n There is no leading drive letter or leading or trailing\n backslash; for instance, if the current default directory is the\n root, all you'll get is a null string (DS:[SI] = 0).\n\n After calling this function, you can be certain that the media in\n drive DL is known to the system. Use this to ensure that the\n device driver's BPB is correct before making a INT 25H/26H call.\n\nSee Also: Fn 19H (query default drive)\n Fn 3BH (set default directory)\n Directory and File Functions\n DOS Functions\n -♦-"
  },
  {
    "id": "500-dos_fn_48h__allocate_memory___query_free_memory.html",
    "t": "DOS Fn 48H: Allocate Memory / Query Free Memory",
    "b": "Compatibility: 2.0+\n Expects: AH 48H\n BX requested amount of memory in paragraphs (16-byte chunks)\n ──────────────────────────────────────────────────────────────────\n Returns: AX error code if CF is set to CY\n segment address of allocated block (if no error)\n BX size of available RAM, in paragraphs (if allocation fails)\n ──────────────────────────────────────────────────────────────────\n Info: Allocates a block of memory BX paragraphs long, returning the\n segment address of that block in AX (block starts at AX:0000).\n\n If the allocation fails, the Carry Flag is set, an error code is\n returned in AX, and BX contains the maximum size allowable (in\n paragraphs) for an allocation.\n\n To determine the largest block available, it is a common practice\n to set BX=ffffH before the call. The allocation will fail,\n returning the available allocation size in BX.\n\n To allocate from upper▲ memory, the upper memory link must be\n active and the memory allocation strategy must be set to one of\n the options which allocate high memory. For instance:\n\n ■ Use fns 5800H and 5802H to obtain the current allocation\n settings. Save them.\n ■ Use fn 5803H (set UMB link) with BX=0001H\n ■ Use fn 5801H (set strategy) with BX=40H-42H or 80H-82H.\n ■ Use fn 48H (alloc mem) to allocate the memory. If NC, and\n AX >= A000H, then the high allocation worked. Otherwise, you\n just got some conventional memory.\n ■ Use fns 5801H and 5803H to restore the saved allocation\n settings before terminating.\n\n See Accessing Upper Memory for related info.\n\n Notes: ■ When a process receives control via Fn 4bH EXEC, the largest\n available memory block has been allocated to it already.\n\n It is usually necessary to shrink the allocation that starts at\n your PSP (via fn 4aH) in order to make conventional memory\n available for allocation.\n\n ■ When a program is loaded high via loadhigh, its code will be in\n upper memory, but additional allocations will be made according\n to the current allocation strategy (see fn 5801H).\n\nSee Also: Memory Control Functions\n Memory Control Block\n DOS Functions\n -♦-"
  },
  {
    "id": "501-dos_fn_49h__free_allocated_memory_block.html",
    "t": "DOS Fn 49H: Free Allocated Memory Block",
    "b": "Compatibility: 2.0+\n Expects: AH 49H\n ES segment address (paragraph) of allocated memory to release\n ──────────────────────────────────────────────────────────────────\n Returns: AX error code if CF is set to CY\n ──────────────────────────────────────────────────────────────────\n Info: Deallocates (frees) the block of memory starting at ES:0000.\n This block will become available for other system resources.\n\n DOS prevents a process from freeing blocks of memory that were\n allocated by another process (the PID▲ of the owner is saved\n in the MCB). The undocumented DOS Fn 50H lets you become the\n \"current process\" and thus free blocks you don't really own.\n\n It is recommended that a TSR program free its environment block\n during installation (that is, if it won't need it again!). This\n allows the next program to reuse that block.\n\nSee Also: Memory Control Functions\n Memory Control Block\n DOS Functions\n -♦-"
  },
  {
    "id": "502-dos_fn_4ah__shrink_or_expand_a_memory_block.html",
    "t": "DOS Fn 4aH: Shrink or Expand a Memory Block",
    "b": "Compatibility: 2.0+\n Expects: AH 4aH\n ES segment of an allocated memory block\n BX desired size for the block, in paragraphs (16-byte chunks)\n ──────────────────────────────────────────────────────────────────\n Returns: AX error code if CF is set to CY\n BX largest block available (if a \"grow\" request fails)\n ──────────────────────────────────────────────────────────────────\n Info: Changes the size of an existing memory block.\n\n When a program receives control, the 4bH EXEC function has\n allocated a memory block starting at the PSP that contains all of\n available memory. To make memory available to EXEC a child\n process, shrink the block starting at your PSP paragraph.\n\n Notes: ■ DOS Fn 31H and INT 27H shrink the block at the PSP.\n\n ■ .COM programs: Move your stack down BEFORE shrinking your\n block!\n\nSee Also: Memory Control Functions\n Memory Control Block\n DOS Functions\n -♦-"
  },
  {
    "id": "503-dos_fn_4bh__load_or_execute_a_program.html",
    "t": "DOS Fn 4bH: Load or Execute a program",
    "b": "See: Fn 4b00H (load and execute a program)\n\n Fn 4b01H (load a program, but don't execute)\n\n Fn 4b03H (load an overlay)\n\n Fn 4b05H (set execution state) DOS 5.0+\n\nSee Also: Process Control Functions\n Program Startup & Exit\n DOS Functions\n -♦-"
  },
  {
    "id": "504-dos_fn_4b00h__execute_a_program.html",
    "t": "DOS Fn 4b00H: Execute a Program",
    "b": "Compatibility: 2.0+\n Expects: AX 4b00H\n DS:DX address of an ASCIIZ▲ filespec of the program to execute\n ES:BX address of an ExecParamRec\n ──────────────────────────────────────────────────────────────────\n Returns: AX error code if CF is set to CY\n else All registers are destroyed, including SS and SP\n ──────────────────────────────────────────────────────────────────\n Info: Provides a means for a program (the parent) to execute another\n program (the child). When the child exits, control will return\n to the parent. It prepares a PSP for the child, loads its code,\n performs any needed segment fixup, est the registers as expected,\n then begins executing the child program.\n\n DS:DX points to an ASCIIZ string in the form...\n d:\\path\\filename.ext◄0►\n If the drive or path is omitted, defaults are assumed.\n\n ES:BX points to a block of memory prepared as an ExecParamRec that has\n been filled with the information needed.\n\n Since the parent program initially receives all of available\n memory for its own processing, you must free some memory via\n Fn 4aH before performing using this fn.\n\n To EXEC a program:\n\n ■ Call Fn 4aH with ES=your PSP and the minimum amount of memory\n that your program requires (in paragraphs).\n ■ Prepare an ASCIIZ▲ string of the program file to EXEC and set\n DS:DX to point to its first character.\n ■ Prepare an ExecParamRec containing all required fields\n ■ Save the current values of SS, SP, DS, ES, and the DTA in\n variables that are relative to CS (CS is the only point of\n reference after EXEC returns from the child).\n ■ Issue the EXEC call with AL=0\n ■ Restore SS and SP to local values\n ■ Check CF (the carry flag) to see if EXEC failed with an error\n ■ Restore DS, ES and the local DTA if necessary\n ■ Check the exit code▲ via Fn 4dH WAIT (if desired)\n\n All open files are duplicated, so the child can process data via\n file handle and/or use the standard I/O for input and output.\n Each handle's Access Mode is duplicated, but any \"file locks\"\n that are in effect will not belong to the child. See Fn 5cH.\n\n Upon return from the child, the INT 22H (Terminate), INT 23H\n (Ctrl-Break), and INT 24H (Critical Error) vectors are restored\n to their previous values.\n\n Notes: ■ This function uses the loader portion of Command.Com which is\n transient in DOS 2.0+ (a program may have overwritten it).\n Thus, this call could fail if DOS can't locate the Command.Com\n file. You should make sure that COMSPEC= in the environment is\n valid before the call.\n\n ■ Rather than parse the FCBs (as needed in the ExecParamRec), you\n may find it convenient to load and execute a secondary copy of\n Command.Com, using the /C option. For instance, to execute the\n FORMAT.COM program, set DS:DX to the address of an ASCIIZ\n string:\n\n \"c:\\dos\\command.com\",0\n\n and set EPB+2 to the segment and offset of the command line:\n\n 12H,\" /c format a: /s/4\",0dH\n\n This secondary command interpreter uses a very small amount of\n memory (around 4K). You can locate the drive and directory\n that contains COMMAND.COM by searching the DOS Environment for\n the COMSPEC string.\n\nSee Also: Fn 4b01H (load program)\n Fn 4b03H (load overlay)\n Process Control Functions\n Program Startup & Exit\n DOS Functions\n -♦-"
  },
  {
    "id": "505-dos_fn_4b01h__load_program.html",
    "t": "DOS Fn 4b01H: Load Program",
    "b": "Compatibility: 2.0+\n Expects: AX 4b01H\n DS:DX address of an ASCIIZ▲ filespec of the program to load\n ES:BX address of an ExecLoadRec\n ──────────────────────────────────────────────────────────────────\n Returns: AX error code if CF is set to CY\n ES:BX some information is returned in the ExecLoadRec\n ──────────────────────────────────────────────────────────────────\n Info: This allocates memory and loads a program. It builds a PSP and\n performs all needed segment fixups in preparation for executing\n the code, but does not actually begin execution.\n\n DS:DX points to an ASCIIZ string in the form...\n d:\\path\\filename.ext◄0►\n If the drive or path is omitted, defaults are assumed.\n\n ES:BX points to a block of memory prepared as an ExecLoadRec that has\n been filled with the information needed, similar to the needs of\n fn 4b00H (exec).\n\n On return the ExecLoadRec contains the required entry point\n (lCsIp) and stack address (lSsSp) to use when starting the\n program.\n\n Notes: ■ There must be enough free memory for DOS to load the program.\n\nSee Also: Fn 4b00H (execute program)\n Fn 4b03H (load overlay)\n Fn 4b05H (set execution state)\n Process Control Functions\n Program Startup & Exit\n DOS Functions\n -♦-"
  },
  {
    "id": "506-dos_fn_4b03h__load_overlay.html",
    "t": "DOS Fn 4b03H: Load Overlay",
    "b": "Compatibility: 2.0+\n Expects: AX 4b03H\n DS:DX address of an ASCIIZ▲ filespec of the program file to load\n ES:BX address of an ExecOverlayRec\n ──────────────────────────────────────────────────────────────────\n Returns: AX error code if CF is set to CY\n ──────────────────────────────────────────────────────────────────\n Info: This function loads a program into memory at a desired location.\n It performs all needed segment fixups in preparation for\n executing the code, but does not actually begin execution.\n\n DS:DX points to an ASCIIZ string in the form...\n d:\\path\\filename.ext◄0►\n If the drive or path is omitted, defaults are assumed.\n\n ES:BX points to a block of memory prepared as an ExecOverlayRec\n that has been filled with the information needed, including the\n address to load the overlay.\n\n Notes: ■ This variation of the EXEC function is used to load program\n fragments, such a code overlays. It does not prepare a PSP nor\n does it set registers as they would be expected by a stand-\n alone program.\n\n ■ There must be enough free memory for DOS to load the program.\n\nSee Also: Fn 4b01H (load program)\n Fn 4b05H (set execution state)\n Process Control Functions\n Program Startup & Exit\n DOS Functions\n -♦-"
  },
  {
    "id": "507-dos_fn_4b05h__set_execution_state.html",
    "t": "DOS Fn 4b05H: Set Execution State",
    "b": "Compatibility: 5.0+\n Expects: AX 4b05H\n DS:DX address of an ExecStateRec containing execution state info\n ──────────────────────────────────────────────────────────────────\n Returns: none\n ──────────────────────────────────────────────────────────────────\n Info: This function sets up DOS for executing a loaded program.\n Specifically, it prepares DOS to correctly handle calls to Fn 30H\n (get DOS version), as set up by the DOS Setver program.\n\n DS:DX points to a block of memory prepared as an ExecStateRec that has\n been filled with the information needed.\n\n Notes: ■ This function is required by programs which intercept (and\n replace) fn 4B00H (exec).\n\n ■ After return, the caller should immediately begin executing the\n program, specifically avoiding any DOS or BIOS fn calls.\n\n ■ When DOS is installed in the HMA▲, this function turns off the\n A20 line (making the HMA inaccessible). DOS normally turns A20\n on and leaves it on while executing other system functions.\n\nSee Also: Fn 4b00H (execute program)\n Fn 4b01H (load program)\n Fn 4b03H (load overlay)\n Process Control Functions\n Program Startup & Exit\n DOS Functions\n -♦-"
  },
  {
    "id": "508-dos_fn_4ch__terminate_program.html",
    "t": "DOS Fn 4cH: Terminate Program",
    "b": "Compatibility: 2.0+\n Expects: AH 4cH\n AL exit code▲ to return to parent (or for ERRORLEVEL)\n ──────────────────────────────────────────────────────────────────\n Returns: none (not applicable)\n ──────────────────────────────────────────────────────────────────\n Info: Returns control of a child process to its parent, setting an exit\n code value that may be queried by DOS Fn 4dH.\n\n Control is passed to the Terminate Address of PSP of the exiting\n program. Ctrl-Break and Critical Error handler vectors are\n restored to the addresses from the parent's PSP.\n\n Notes: ■ The ERRORLEVEL value (used in DOS batch files) can be used to\n check the exit code of the most recent program.\n\nSee Also: Process Control Functions\n Program Startup & Exit\n DOS Functions\n -♦-"
  },
  {
    "id": "509-dos_fn_4dh__get_program_exit_code.html",
    "t": "DOS Fn 4dH: Get Program Exit Code",
    "b": "Compatibility: 2.0+\n Expects: AH 4dH\n ──────────────────────────────────────────────────────────────────\n Returns: AL exit code▲ of last process to terminate\n AH Exit method: 0 = normal termination\n 1 = Ctrl-Break termination INT 23H\n 2 = termination via critical error INT 24H\n 3 = termination via Fn 31H KEEP\n ──────────────────────────────────────────────────────────────────\n Info: Returns the exit code of the most-recently terminated process.\n The exit code is set when a program calls DOS Fn 4cH or 31H.\n\n This function returns valid information only once for each\n terminating process.\n\nSee Also: Process Control Functions\n Program Startup & Exit\n DOS Functions\n -♦-"
  },
  {
    "id": "510-dos_fn_4eh__find_1st_matching_file.html",
    "t": "DOS Fn 4eH: Find 1st Matching File",
    "b": "Compatibility: 2.0+\n Expects: AH 4eH\n DS:DX address of ASCIIZ▲ filespec to find (wildcards▲ OK)\n CX file attribute to match\n ──────────────────────────────────────────────────────────────────\n Returns: AX error code if CF is set to CY\n DTA is filled with a FileInfoRec (if no error)\n ──────────────────────────────────────────────────────────────────\n Info: Searches a single directory for a file matching a specific\n wildcard▲ filespec with a given file attribute and returns file\n information into the current DTA.\n\n You may use this to obtain a file's size, time, date, etc.\n without needing to open the file.\n\n DS:DX points to an ASCIIZ string in the form...\n d:\\path\\filename.ext0\n If the drive or path is omitted, defaults are assumed.\n\n DOS finds the name of the first file on the drive and directory\n that matches the filespec and attribute, and places that name and\n other information into the DTA, in the form of a FileInfoRec.\n\n Notes: The file attribute is generally used in an inclusive search.\n For instance, if you want to look for directories as well as\n filenames, attribute bit 4 should be set (attr | 10H). See\n File Attributes for full information.\n\n A typical sequence used to find all matching files in a\n directory:\n\n ■ Use Fn 1aH to set the DTA to a local buffer (or use the\n default DTA at PSP offset 80H)\n ■ Set CX=attribute, DS:DX => ASCIIZ wildcard d:\\path\\filespec\n ■ Invoke Fn 4eH (Find First)\n ■ If CF indicates error, you're all done (no matches)\n ■ Set DS:DX => DTA (or to data you've copied from the DTA after\n using Fn 4eH)\n ■ Repeat:\n Process the filespec and data at DS:DX\n Invoke Fn 4fH (Find Next)\n Until error return indicates no match (Carry Flag is set)\n\nSee Also: Fn 4fH (find next file)\n Fn 1aH (set DTA)\n Directory and File Functions\n DOS Functions\n -♦-"
  },
  {
    "id": "511-dos_fn_4fh__find_next_matching_file.html",
    "t": "DOS Fn 4fH: Find Next Matching File",
    "b": "Compatibility: 2.0+\n Expects: AH 4fH\n DS:DX address of data from a previous Fn 4eH Find 1st File\n ──────────────────────────────────────────────────────────────────\n Returns: AX error code if CF is set to CY (i.e., if no more matches)\n DTA is filled with a FileInfoRec (if no error)\n ──────────────────────────────────────────────────────────────────\n Info: Continues a file search begun by a previous call to fn 4eH (find\n first file).\n\n DS:DX points to a 43-byte buffer containing information returned by Fn\n 4eH (find first file) -- either the DTA or a buffer copied from\n the DTA.\n\n Use this after a call to Fn 4eH. The next filename matching the\n selected wildcard filespec and file attribute will be copied into\n the buffer at DS:DX, along with other information (see\n FileInfoRec the layout of the return information and see Fn 4eH\n for related details.\n\n Notes: The DS:DX parameter is required for DOS 3.0+. It enables you to\n use recursive searching techniques more easily (for instance to\n search an entire directory tree).\n\nSee Also: Fn 43H (find first file)\n Directory and File Functions\n DOS Functions\n -♦-"
  },
  {
    "id": "512-dos_fn_50h__set_psp.html",
    "t": "DOS Fn 50H: Set PSP",
    "b": "Compatibility: 2.0+ (doc'd: 5.0)\n Expects: AH 50H\n BX Process ID (i.e, PSP segment) to make current\n ──────────────────────────────────────────────────────────────────\n Returns: none \n ──────────────────────────────────────────────────────────────────\n Info: This function tells DOS that the PID▲ in BX identifies the\n current active process. It is used in TSR programs to inform DOS\n which process is running; i.e., after popping up.\n\n Several DOS fns (including file handle operations and memory\n allocation functions), refer to and make changes to the PSP of\n the current process.\n\n A TSR should call Fn 51H and save its PSP during initialization.\n Before popping up, the TSR should use fn 51H to get the ID of the\n interrupted program, then use fn 50H to set the PID to the saved\n value. Be sure to change the PID back before popping down.\n\nSee Also: PSP (Program Segment Prefix)\n Process Control Functions\n Program Startup & Exit\n DOS Environment\n DOS Functions\n -♦-"
  },
  {
    "id": "513-dos_fn_51h__query_current_psp.html",
    "t": "DOS Fn 51H: Query Current PSP",
    "b": "Compatibility: 2.0+ (doc'd: 5.0)\n Expects: AH 51H\n ──────────────────────────────────────────────────────────────────\n Returns: BX Process ID (i.e, PSP segment) of current process\n ──────────────────────────────────────────────────────────────────\n Info: This function obtains the segment address of the PSP (a.k.a, the\n Process ID) of the calling program.\n\n A TSR should save its PSP during initialization. Before popping\n up, the TSR should use fn 51H to get the ID of the interrupted\n program, then use fn 50H to set the PID to the saved value. Be\n sure to change the PID back before popping down.\n\n Notes: ■ On program startup, DS and ES both contain the PSP segment.\n\n ■ Undocumented fn 62H performs this same function. You may use\n either one (62H is more commonly used, perhaps because it was\n uncovered earlier).\n\nSee Also: PSP (Program Segment Prefix)\n Process Control Functions\n Program Startup & Exit\n DOS Environment\n DOS Functions\n -♦-"
  },
  {
    "id": "514-dos_fn_52h__get_dos_variables.html",
    "t": "DOS Fn 52H: Get DOS Variables",
    "b": "Compatibility: 2.0+? ◄undoc►\n Expects: AH 52H\n ──────────────────────────────────────────────────────────────────\n Returns: ES:BX address of DosVarsRec; addr+2 of segment of root MCB\n ──────────────────────────────────────────────────────────────────\n Info: Also called the List of Lists function. This returns the address\n of an undocumented package of DOS internal variables; some of the\n values in this packet may be handy for use in utility programs.\n\n See DosVarsRec for a layout of the data.\n\n At ES:[BX-2], you will find a 2-byte value which is the segment\n of the fabled \"root Memory Control Block\". The root MCB can be\n used to traverse the chain of MCBs and accumulate information\n about all of the memory blocks that are currently allocated.\n Each MCB contains its owner's PID so when a recognizable PSP is\n found, you may be able to trace down its environment segment and\n therefore obtain the programs filename as well the DOS command-\n line parameters used when it was started.\n\n Warning: ■ Alters the value of the ES segment register.\n\n ■ This undocumented fn may change in future versions of DOS. It\n was conspicuously not documented in DOS 5.0 (which did document\n most of DOS's secrets).\n\nSee Also: DosVarsRec\n MemBlockRec\n DOS Functions\n -♦-"
  },
  {
    "id": "515-dos_fn_53h__convert_bpb_to_dpb.html",
    "t": "DOS Fn 53H: Convert BPB to DPB",
    "b": "Compatibility: 2.0+? ◄undoc►\n Expects: AH 53H\n DS:BX addr of a BIOS Parameter Block (as used by device drivers)\n ES:BP addr of buffer to receive a Drive Parameter Block (DPB)\n ──────────────────────────────────────────────────────────────────\n Returns: ES:BX buffer contains a filled-in DPB\n ──────────────────────────────────────────────────────────────────\n Info: This undocumented function is used by DOS during startup to\n prepare its chain of DPBs.\n\n DOS issues a DvRq 02H (Build BPB) request to a device driver and\n then calls this to put the data into a more useful form. It then\n installs the DPB into a chain of DPBs (see DosVarsRec).\n\n It has no practical use for application programs, but it might be\n used by a disk utility or a block device driver which installs\n itself from the DOS command line.\n\nSee Also: Device Drivers\n Disk Drive Functions\n -♦-"
  },
  {
    "id": "516-dos_fn_54h__get_dos_verify_state.html",
    "t": "DOS Fn 54H: Get DOS Verify State",
    "b": "Compatibility: 2.0+\n Expects: AH 54H\n ──────────────────────────────────────────────────────────────────\n Returns: AL current state: 00H is OFF\n 01H is ON\n ──────────────────────────────────────────────────────────────────\n Info: Returns the current DOS disk write verification state. If AL\n returns as 01H, then DOS will check the CRC of each sector that\n it writes, verifying that data was written correctly.\n\n Notes: ■ Programs can use Fn 2eH to set or reset the verification state.\n ■ The DOS Verify command can be used to change the state.\n\nSee Also: System Information Functions\n DOS Functions\n -♦-"
  },
  {
    "id": "517-dos_fn_56h__rename_move_a_file.html",
    "t": "DOS Fn 56H: Rename/Move a File",
    "b": "Compatibility: 2.0+\n Expects: AH 56H\n DS:DX address of ASCIIZ▲ string szOldName (existing file)\n ES:DI address of ASCIIZ string szNewName (desired path\\filespec)\n ──────────────────────────────────────────────────────────────────\n Returns: AX error code if CF is set to CY\n ──────────────────────────────────────────────────────────────────\n Info: Renames a file or moves a file or directory to a different\n directory on the same disk.\n\n DS:DX and ES:DI point to an ASCIIZ strings in the form...\n d:\\path\\filename.ext0\n If the drive or path is omitted, defaults are assumed.\n\n The szOldName must exist and must not contain wildcards▲. The\n drive and path are optional; if omitted, defaults are used.\n\n The szNewName must NOT exist. If a drive ID is used, then it\n must match that of the szOldName. If drive or path are omitted,\n current defaults will be assumed.\n\n If szOldName and szNewName contain different paths (explicitly or\n as assumed by defaults) then the file entry will be MOVED to the\n directory named in the szNewName.\n\n Notes: ■ You can use this function to rename, but not move, a directory;\n that is, the path part of szNewName must be explicitly the same\n as the path part of szOldName.\n\n ■ You cannot use this to move between drives (that's a copy\n operation which must be performed in multiple steps).\n\n ■ You can rename files and directories on a network drive only if\n you have write permission on the network drive.\n\n ■ For files, the szOldName must not be open by any process.\n\nSee Also: Directory and File Functions\n DOS Functions\n -♦-"
  },
  {
    "id": "518-dos_fn_57h__set_or_query_file_time_date.html",
    "t": "DOS Fn 57H: Set or Query File Time/Date",
    "b": "See: Fn 5700H (query file time/date)\n\n Fn 5701H (set file time/date)\n\nSee Also: File time/date format (bit-field format of return info)\n Directory and File Functions\n DOS Functions\n -♦-"
  },
  {
    "id": "519-dos_fn_5700h__query_file_time_date.html",
    "t": "DOS Fn 5700H: Query File Time/Date",
    "b": "Compatibility: 2.0+\n Expects: AX 5700H\n BX file handle of an open file\n ──────────────────────────────────────────────────────────────────\n Returns: AX error code if CF is set to CY\n CX file's time, in FileTimeRec format (if no error)\n DX file's date, in FileDateRec format\n ──────────────────────────────────────────────────────────────────\n Info: Obtains the time and date at which the specified file was created\n or most-recently modified (the last time its directory entry was\n updated).\n\n Notes: ■ This is useful only for currently-open files. To avoid the\n file open/close overhead, use fn 4eH (find first file).\n\nSee Also: Fn 5701H (set file time/date)\n File time/date format (bit-field format of return info)\n Directory and File Functions\n DOS Functions\n -♦-"
  },
  {
    "id": "520-dos_fn_5701h__set_file_time_date.html",
    "t": "DOS Fn 5701H: Set File Time/Date",
    "b": "Compatibility: 2.0+\n Expects: AX 5701H\n BX file handle of an open file\n CX file time, in FileTimeRec format (if no error)\n DX file date, in FileDateRec format\n ──────────────────────────────────────────────────────────────────\n Returns: AX error code if CF is set to CY\n ──────────────────────────────────────────────────────────────────\n Info: Changes a file's directory entry to indicate the specified time\n and date.\n\n Notes: ■ Remember that if you modify the file in any way before closing\n it, the directory entry will end up specifying the time and\n date that the file was closed.\n\nSee Also: Fn 5700H (query file time/date)\n File time/date format (bit-field format of info)\n Directory and File Functions\n DOS Functions\n -♦-"
  },
  {
    "id": "521-dos_fn_58h__set_or_query_memory_allocation_options.html",
    "t": "DOS Fn 58H: Set or Query Memory Allocation Options",
    "b": "See: Fn 5800H (query allocation strategy) 3.0+\n\n Fn 5801H (set allocation strategy) 3.0+\n\n Fn 5802H (query upper-memory link state) 5.0+\n\n Fn 5803H (set upper-memory link state) 5.0+\n\nSee Also: Accessing Upper Memory\n Fn 48H (allocate memory)\n Memory Control Functions\n DOS Functions\n -♦-"
  },
  {
    "id": "522-dos_fn_5800h__query_memory_allocation_strategy.html",
    "t": "DOS Fn 5800H: Query Memory Allocation Strategy",
    "b": "Compatibility: 3.0+\n Expects: AX 5800H\n ──────────────────────────────────────────────────────────────────\n Returns: AX allocation strategy code. See fn 5801H (set alloc strategy)\n CF always clear (CF=NC=0)\n ──────────────────────────────────────────────────────────────────\n Info: Obtains a code indicating the method DOS will use in satisfying\n subsequent memory allocations (via fn 48H).\n\n Programs which change the allocation strategy should use this\n function and save the current setting and be sure to change it\n back (via fn 5801H) before terminating.\n\n See Accessing Upper Memory for info on allocating from UMBs▲.\n\nSee Also: Fn 48H (allocate memory)\n Memory Control Functions\n DOS Functions\n -♦-"
  },
  {
    "id": "523-dos_fn_5801h__set_memory_allocation_strategy.html",
    "t": "DOS Fn 5801H: Set Memory Allocation Strategy",
    "b": "Compatibility: 3.0+\n Expects: AX 5801H\n BX desired allocation strategy code (see below).\n ──────────────────────────────────────────────────────────────────\n Returns: AX error code if CF is set to CY\n ──────────────────────────────────────────────────────────────────\n Info: Selects the method for DOS to use in satisfying subsequent memory\n allocations (via fn 48H). BX must be one of:\n\n Value Description\n ▀▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n 0000h FIRST_FIT_LOW Search conventional▲ memory for the available\n block having the lowest address. This is the\n default strategy.\n 0001h BEST_FIT_LOW Search conventional RAM for the available block\n that most closely matches the requested size.\n 0002h LAST_FIT_LOW Search conventional RAM for the available block\n having the highest address.\n ─────────────────────────────────────── DOS 5.0+\n 0080h FIRST_FIT_HIGH Search UMB▲ memory for the available block that\n most closely matches the requested size. If\n none, search conventional memory.\n 0081h BEST_FIT_HIGH Search UMB memory for the available block that\n most closely matches the requested size. If\n none, search conventional memory.\n 0082h LAST_FIT_HIGH Search UMB memory for the available block having\n the highest address. If none, search\n conventional memory.\n\n 0040h FIRST_FIT_HIGHONLY Search UMB memory for the available block having\n the lowest address.\n 0041h BEST_FIT_HIGHONLY Search UMB memory for the available block that\n most closely matches the requested size.\n 0042h LAST_FIT_HIGHONLY Search UMB memory for the available block having\n the highest address.\n\nVersions: ■ Unavailable before DOS 3.0. In 3.x-4.x, only valid codes are\n 0000h, 0001h, and 0002H. Other code valid only with DOS 5.0+.\n\n Notes: ■ Programs which change the allocation strategy should use fn\n 5800H and save the current setting and be sure to change it\n back (via this fn) before terminating.\n\n ■ If the upper memory link has not been set (see fn 5803H), then\n all allocations will be in conventional▲ memory.\n\n ■ When a program is loaded high via loadhigh, its code will be in\n upper memory, but additional allocations will be made according\n to the current allocation strategy (you must set it yourself).\n\nSee Also: Accessing Upper Memory\n Memory Control Functions\n DOS Functions\n -♦-"
  },
  {
    "id": "524-dos_fn_5802h__query_upper_memory_link_state.html",
    "t": "DOS Fn 5802H: Query Upper-Memory Link State",
    "b": "Compatibility: 5.0+\n Expects: AX 5802H\n ──────────────────────────────────────────────────────────────────\n Returns: AL 01H = upper▲ memory is currently linked\n 00H = not linked (all allocations go to conventional▲ mem)\n CF always clear (CF=NC=0)\n ──────────────────────────────────────────────────────────────────\n Info: Obtains a code indicating whether programs can allocate memory\n from UMBs▲.\n\n See Accessing Upper Memory for info on allocating from UMBs.\n\nSee Also: Fn 48H (allocate memory)\n Memory Control Functions\n DOS Functions\n -♦-"
  },
  {
    "id": "525-dos_fn_5803h__set_upper_memory_link_state.html",
    "t": "DOS Fn 5803H: Set Upper-Memory Link State",
    "b": "Compatibility: 5.0+\n Expects: AX 5803H\n BX 01H = link upper▲ memory for allocations\n 00H = unlink (all allocations go to conventional▲ mem)\n ──────────────────────────────────────────────────────────────────\n Returns: AX error code if CF is set to CY\n ──────────────────────────────────────────────────────────────────\n Info: Enables or disables access to upper memory.\n\n See Accessing Upper Memory for info on allocating from UMBs.\n\n The command dos=umb must be executed in CONFIG.SYS before is it\n possible to link and allocate upper memory.\n\n This call fails with error code 0001h (invalid function) on 8088\n and 286 CPUs and on 386+ CPUs in which a 386 memory manager such\n as Emm386.exe was not installed and/or dos=umb was not executed.\n\n Programs which set the link state should use fn 5802H and save\n the current setting and be sure to change it back before\n terminating.\n\nSee Also: Fn 48H (allocate memory)\n Memory Control Functions\n DOS Functions\n -♦-"
  },
  {
    "id": "526-dos_fn_59h__get_extended_error_info.html",
    "t": "DOS Fn 59H: Get Extended Error Info",
    "b": "Compatibility: 3.0+\n Expects: AH 59H\n BX 0000H (need for 3.x and 4.x)\n ──────────────────────────────────────────────────────────────────\n Returns: AX extended error code (0 if no error has occurred)\n BH error class\n BL suggested action\n CH location (where the error occurred)\n ──────────────────────────────────────────────────────────────────\n Info: Use this function to figure out what to do after a DOS function\n failed because of an error. You can use this:\n\n ■ Inside an INT 24H Critical Error handler\n ■ After any INT 21H DOS function which signals an error with CF\n ■ After FCB-style functions which return AL=ffH means an error\n\n See DOS Error Codes for a full listing of possible error codes,\n classes, suggested actions, and loci that may be returned by this\n function.\n\n Notes: ■ After an error, you get only on chance to call this fn. After\n one call, the error condition is unflagged and subsequent calls\n won't return meaningful data.\n\n ■ You can use fn 5D0aH to simulate an error or set your own\n internal error codes.\n\nVersions: This function is not available before 3.00.\n\n With 2.x, when CF returns indicating an error, use your own\n program logic to decide what action to take.\n\n With 3.0+, when a function returns CF=1, Microsoft advises to\n ignore the error code returned in AX, call this function, and\n take the action suggested in BL.\n\nSee Also: Fn 5d0aH (set extended error)\n System Information Functions\n DOS Error Codes\n DOS Functions\n -♦-"
  },
  {
    "id": "527-dos_fn_5ah__create_unique_temporary_file.html",
    "t": "DOS Fn 5aH: Create Unique Temporary File",
    "b": "Compatibility: 3.0+\n Expects: AH 5aH\n DS:DX address of ASCIIZ▲ path (i.e., d:\\path\\0)\n CX file attribute\n ──────────────────────────────────────────────────────────────────\n Returns: AX error code if CF is set to CY\n file handle (if no error)\n DS:DX (+n) filename has been appended to path\n ──────────────────────────────────────────────────────────────────\n Info: Creates (opens) a file with a unique filename in a specified\n directory and returns a handle to that file and its full name.\n The DOS command processor uses this function to create the\n temporary \"piping\" files used in I/O redirection.\n\n The pathspec must be ready to receive a filename at its end; that\n is, the last character must be a backslash (\\) and you must\n provide at least 12 bytes at the end of the string. In summary,\n it must be in the form:\n\n \"d:\\path\\\",0 (specify drive and path) ...OR...\n \"d:\",0 (default directory of a drive) ...OR...\n \"d:\\\",0 (root directory of a drive) ...OR...\n \"\",0 (default drive and directory)\n\n Upon return, the string at DS:DX has a unique filename appended\n to it and the file is open for read/write Access Mode.\n\n Notes: ■ DOS builds a filename of hex digits obtained from the current\n system date/time. If the filename already exists, DOS keeps\n trying new names until a file can be created.\n\n ■ The files created ARE NOT really TEMPORARY, and must be deleted\n via Fn 41H if you don't want them to clutter up your\n directories.\n\n ■ It is good practice to check the environment for a variable\n named TEMP and use its value as the directory for the file.\n\nSee Also: Handle-Oriented File I/O\n DOS Functions\n -♦-"
  },
  {
    "id": "528-dos_fn_5bh__create_new_file.html",
    "t": "DOS Fn 5bH: Create New File",
    "b": "Compatibility: 3.0+\n Expects: AH 5bH\n DS:DX address of an ASCIIZ▲ string of a filespec\n CX file attribute\n ──────────────────────────────────────────────────────────────────\n Returns: AX error code if CF is set to CY\n file handle (if no error)\n ──────────────────────────────────────────────────────────────────\n Info: This call is identical to DOS Fn 3cH (create file), except that\n it will fail if the file already exits on the named drive and\n directory.\n\n DS:DX points to an ASCIIZ string in the form...\n d:\\path\\filename.ext0\n If the drive or path is omitted, defaults are assumed.\n\n The file is opened for read/write in compatibility Access Mode.\n\n Fn 6cH has a options which include this capability.\n\nSee Also: Handle-Oriented File I/O\n DOS Functions\n -♦-"
  },
  {
    "id": "529-dos_fn_5ch__lock_unlock_file_access.html",
    "t": "DOS Fn 5cH: Lock/Unlock File Access",
    "b": "Compatibility: 3.0+\n See: Fn 5c00H (lock a region of a file)\n\n Fn 5c01H (unlock a region of a file)\n\n Note: Both functions use the same parameters. The exact same offset\n and length must be used when unlocking as were used when locking.\n\nSee Also: Network Functions\n Directory and File Functions\n DOS Functions\n -♦-"
  },
  {
    "id": "530-dos_fn_5c00h__lock_file_access.html",
    "t": "DOS Fn 5c00H: Lock File Access",
    "b": "Compatibility: 3.0+\n Expects: AX 5c00H\n BX file handle\n CX:DX file offset from start of file (CX * 65536)+DX\n SI:DI length in bytes of region to lock (SI * 65536)+DI\n ──────────────────────────────────────────────────────────────────\n Returns: AX error code if CF is set to CY\n ──────────────────────────────────────────────────────────────────\n Info: This function locks access to a region of the file identified by\n the file handle in BX. The region of the file that begins at\n file logical offset CX:DX extending for a length of SI:DI is\n locked.\n\n File sharing support must be present (usually installed by your\n network software, or Windows, or by using the DOS Share command).\n If not installed, the call returns an error code of \"invalid\n function number.\"\n\n Locks apply to reads, writes, and opens of a file by a child or\n concurrent process. When another process attempts such an access\n (and the Access Mode defined during the file OPEN is a sharing\n mode which disallows such access), then DOS will fail the\n operation via an INT 24H Critical Error handler.\n\n The correct way to avoid a lock violation is to attempt to lock\n the region yourself and examine the returned error code. By\n default, any attempt to violate a lock causes DOS to display the\n \"Abort, Retry, Ignore\" message after three tries. You can change\n the retry count via fn 440bH. And you can intercept INT 24H to\n cause a less ghastly response.\n\n To lock an entire file: It is legal to lock beyond the end of the\n file. You can lock an entire file by setting CX=0, DX=0,\n SI=0ffffH, and DI=0ffffH.\n\n Notes: ■ When you unlock (via fn 5c01H), the offset and length must\n match exactly with the offset and length that was locked.\n\n ■ DUPing a file handle via Fn 45H or 46H will duplicate any\n locks.\n\n ■ Even if an Access Mode of \"Inherit\" is used when opened, the\n locking mechanism does not give access privileges to child\n processes created via 4bH EXEC.\n\n ■ It is important that all locks be removed from a file before a\n program is terminated. You should intercept INT 23H\n (Ctrl-Break) and INT 24H (Critical Error) to ensure that locks\n are removed before you terminate.\n\n ■ It is recommended that you unlock as soon as possible. Always\n try to lock, access the file, and unlock in one operation.\n\nSee Also: Network Functions\n Directory and File Functions\n DOS Functions\n -♦-"
  },
  {
    "id": "531-dos_fn_5c01h__unlock_file_access.html",
    "t": "DOS Fn 5c01H: Unlock File Access",
    "b": "Compatibility: 3.0+\n Expects: AX 5c01H\n BX file handle\n CX:DX file offset from start of file (CX * 65536)+DX\n SI:DI length in bytes of region to lock (SI * 65536)+DI\n ──────────────────────────────────────────────────────────────────\n Returns: AX error code if CF is set to CY\n ──────────────────────────────────────────────────────────────────\n Info: This function unlocks access to a region of the file which was\n previously locked.\n\n See fn 5c00H for more details on file locking.\n\n Notes: ■ The offset and length must match exactly with the parameters\n used when the lock was applied.\n\n ■ It is important that all locks be removed from a file before a\n program is terminated.\n\n ■ It is recommended that you unlock as soon as possible. Always\n try to lock, access the file, and unlock in one operation.\n\nSee Also: Network Functions\n Directory and File Functions\n DOS Functions\n -♦-"
  },
  {
    "id": "532-dos_fn_5d0ah__set_extended_error.html",
    "t": "DOS Fn 5d0aH: Set Extended Error",
    "b": "Compatibility: 5.0+\n Expects: AX 5d0aH\n DS:SI address of an ErrorInfoRec containing error info for fn 59H\n ──────────────────────────────────────────────────────────────────\n Returns: none\n ──────────────────────────────────────────────────────────────────\n Info: Sets the error class, location, suggested action, and other\n information that will be returned by the next call to fn 59H (get\n extended error info).\n\nSee Also: Fn 59H (get extended error)\n ErrorInfoRec (data layout for DS:DI)\n System Information Functions\n DOS Error Codes\n DOS Functions\n -♦-"
  },
  {
    "id": "533-dos_fn_5eh__network_miscellaneous.html",
    "t": "DOS Fn 5eH: Network Miscellaneous",
    "b": "Compatibility: 3.1+\n See: Fn 5e00H (query network node name)\n\n Fn 5e02H (set network printer setup)\n\n Fn 5e03H (query network printer setup)\n\n Note: These functions are available when the IBM PC Local Area Network\n Program or other NETBIOS-compatible system is loaded.\n\nSee Also: Network Functions\n Printer Functions\n DOS Functions\n -♦-"
  },
  {
    "id": "534-dos_fn_5e00h__query_network_node_name.html",
    "t": "DOS Fn 5e00H: Query Network Node Name",
    "b": "Compatibility: 3.1+\n Expects: AX 5e00H\n DS:DX address of 16-byte buffer to receive ASCIIZ▲ node name\n ──────────────────────────────────────────────────────────────────\n Returns: AX error code if CF is set to CY\n CH 00H = network name not valid\n else = upper byte of network ID\n CL (if CH not 0) network ID number of local computer\n ──────────────────────────────────────────────────────────────────\n Info: Obtains the network name and NETBIOS ID number of the local\n computer.\n\n The buffer at DS:DX is filled with a 15-character, space-padded\n string, followed by a terminating byte of 00H.\n\nSee Also: Network Functions\n DOS Functions\n -♦-"
  },
  {
    "id": "535-dos_fn_5e02h__set_network_printer_setup.html",
    "t": "DOS Fn 5e02H: Set Network Printer Setup",
    "b": "Compatibility: 3.1+\n Expects: AX 5e02H\n BX network assign-list index (as obtained via fn 5f02H)\n CX length of printer setup data, in bytes\n DS:DX address of printer setup data (max 64 bytes)\n ──────────────────────────────────────────────────────────────────\n Returns: AX error code if CF is set to CY\n ──────────────────────────────────────────────────────────────────\n Info: This function defines a series of bytes that will be sent to a\n particular network printer each time DOS prints a file.\n\n The value for BX is obtained by calling fn 5f02H one or more\n times until the network name of the desired printer is found.\n This index value can change at any time, so be sure to get it\n directly before calling this fn.\n\nSee Also: Network Functions\n Printer Functions\n DOS Functions\n -♦-"
  },
  {
    "id": "536-dos_fn_5e03h__query_network_printer_setup.html",
    "t": "DOS Fn 5e03H: Query Network Printer Setup",
    "b": "Compatibility: 3.1+\n Expects: AX 5e03H\n BX network assign-list index (as obtained via fn 5f02H)\n ES:DI address of 64-byte buffer to receive printer setup data\n ──────────────────────────────────────────────────────────────────\n Returns: AX error code if CF is set to CY\n CX length of printer setup data, in bytes\n ──────────────────────────────────────────────────────────────────\n Info: This function obtains the setup data to be used for a particular\n network printer (as set by a previous call to fn 5e02H). DOS\n will send this data to the printer each time it prints a file.\n\n The value for BX is obtained by calling fn 5f02H one or more\n times until the network name of the desired printer is found.\n This index value can change at any time, so be sure to get it\n directly before calling this fn.\n\nSee Also: fn 5f02H (get network assign-list entry)\n Network Functions\n Printer Functions\n DOS Functions\n -♦-"
  },
  {
    "id": "537-dos_fn_5fh__network_device_redirection.html",
    "t": "DOS Fn 5fH: Network Device Redirection",
    "b": "Compatibility: 3.1+\n See: Fn 5f02H (get assign-list entry)\n\n Fn 5f03H (make network connection)\n\n Fn 5f04H (delete network connection)\n\n Note: These functions are available when the IBM PC Local Area Network\n Program or other NETBIOS-compatible system is loaded.\n\nSee Also: Network Functions\n DOS Functions\n -♦-"
  },
  {
    "id": "538-dos_fn_5f02h__network_query_assign_list_entry.html",
    "t": "DOS Fn 5f02H: Network Query Assign-List Entry",
    "b": "Compatibility: 3.1+\n Expects: AX 5f02H\n BX index number requested\n DS:SI addr of 16-byte buffer to receive ASCIIZ▲ device name\n ES:DI addr of 128-byte buffer to receive ASCIIZ network name\n ──────────────────────────────────────────────────────────────────\n Returns: AX error code if CF is set to CY\n BH 01H = device available\n 00H = device temporarily unavailable\n BL 03H = it's a printer\n 04H = it's a drive\n CX user value--code stored by fn 5f03H (make net connection)\n DS:SI buffer contains device name (e.g., LPT10)\n ES:DI buffer contains network device name (e.g., \\\\DAN\\HP0)\n DX,BP destroyed by some versions of network support\n ──────────────────────────────────────────────────────────────────\n Info: Fetches one element of the network redirection list (also called\n the \"assign list\").\n\n Use this fn to obtain the index number needed by network\n functions such as 5e02H and 5e03H. For instance, to obtain the\n setup string for a redirected \"LPT1\", you would call this fn\n multiple times, starting with BX=0 and incrementing on each call.\n Upon return, check the DS:SI buffer to see if it contains \"LPT1\".\n You could then use the index number used in that call as input\n into fn 5e03H (query network printer setup).\n\n Notes: ■ Index numbers can change at any time. When a device is deleted\n from the list (via fn 5f04H), DOS reorders the index numbers to\n remove the gap.\n\n Therefore, you should not save an index number for later use.\n Instead, use this function each time you need one.\n\n ■ Items are added to the assign list via fn 5F03H (make network\n connection).\n\n ■ The value in CX can also be found in the CurDirRec for a drive.\n\nSee Also: Network Functions\n DOS Functions\n -♦-"
  },
  {
    "id": "539-dos_fn_5f03h__make_network_connection.html",
    "t": "DOS Fn 5f03H: Make Network Connection",
    "b": "Compatibility: 3.1+\n Expects: AX 5f03H\n BL 03H = it's a printer (DS:SI name is \"PRN\", \"LPT1\", etc.)\n 04H = it's a drive (DS:SI name is \"A:\", \"B:\", etc.)\n CX user value--arbitrary code returned by fn 5f02H\n DS:SI addr of ASCIIZ▲ device name\n ES:DI addr of two ASCIIZ strings (network name and password)\n ──────────────────────────────────────────────────────────────────\n Returns: AX error code if CF is set to CY\n ──────────────────────────────────────────────────────────────────\n Info: Creates a connection to a network device or drive by associating\n a local drive ID or device name with a network device.\n\n The value of CX is arbitrary and is not used by DOS. It may be\n used by applications as a way to mark the device for internal\n processing. Its value is returned by fn 5f02H.\n\n BL=03H connects a network printer\n ■ Set DS:SI to point to a printer name such as \"LPT1\",0\n ■ Set ES:DI to point to the name of a printer on the network\n followed by a password. For instance,\n\n \"\\\\SERVER\\HP4\",0,\"MYPASSWORD\",0\n\n If no password is needed, you must append a null string to the\n end of the network device name; e.g., \"\\\\SERVER\\HP4\",0,0\n\n BL=04H connects a network drive\n ■ Set DS:SI to point to a local drive name such as \"E:\",0 or a\n null string (beginning with a 0). In that case, DOS attempts\n to provide access to the network without usurping a drive ID.\n ■ Set ES:DI to point to the name of a network drive name,\n followed by a password. For instance,\n\n \"\\\\SERVER\\FILES\",0,\"MYPASSWORD\",0\n\n If no password is needed, you must append a null string to the\n end of the network device name; e.g., \"\\\\SERVER\\FILES\",0,0\n\n Notes: ■ Network redirection is normally handled by system-level\n utilities rather than application programs.\n\n ■ The value in CX is stored in the CurDirRec for a drive.\n\nSee Also: Network Functions\n DOS Functions\n -♦-"
  },
  {
    "id": "540-dos_fn_5f04h__delete_network_connection.html",
    "t": "DOS Fn 5f04H: Delete Network Connection",
    "b": "Compatibility: 3.1+\n Expects: AX 5f04H\n DS:SI addr of ASCIIZ▲ device name to disconnect\n ──────────────────────────────────────────────────────────────────\n Returns: AX error code if CF is set to CY\n ──────────────────────────────────────────────────────────────────\n Info: Deletes the connection between a local drive ID or device name\n and the network. The specified device reverts to its original\n (local) meaning.\n\n The string at DS:SI can be one of:\n\n ■ The drive letter of a redirected drive, followed by a colon\n (e.g., \"D:\",0). This discontinues local access to that network\n drive and the drive ID reverts to it local meaning.\n\n ■ The name of a printer (e.g., \"LPT1\",0). This discontinues\n local access to that network printer and that device name\n reverts to its local meaning as a physical device.\n\n ■ A string starting with 2 backslashes (e.g.,\n \"\\\\SERVER\\FILES\",0). This would be used when a null drive ID\n was used when the connection was made (see fn 5f03H).\n\n Notes: ■ Network redirection is normally handled by system-level\n utilities rather than application programs.\n\nSee Also: Network Functions\n DOS Functions\n -♦-"
  },
  {
    "id": "541-dos_fn_60h__query_truename.html",
    "t": "DOS Fn 60H: Query TrueName",
    "b": "Compatibility: ◄Undoc► 2.0+\n Expects: AH 60H\n DS:SI ASCIIZ▲ string of a partial filespec\n ES:DI buffer to receive ASCIIZ▲ fully-qualified \"true name\"\n ──────────────────────────────────────────────────────────────────\n Returns: (none ??)\n ──────────────────────────────────────────────────────────────────\n Info: This undocumented function converts a partial filespec into a\n fully-qualified filespec. If the filename or ext portion\n contains an asterisk (*) wildcard▲, it is replaced with a series\n of question marks (?).\n\n This is a quick way to convert an ambiguous filespec such as\n MYFILE.TXT or D:MYFILE or even ..\\DEC\\ABC.DAT into a fully-\n qualified ASCIIZ▲ filespec, suitable for use with many DOS fns.\n\n The main idea is that if you change default drives or\n directories, a name such as MYFILE.TXT will become invalid but a\n name such as C:\\OLD\\OCT94\\MYFILE.TXT will be correct.\n\n Notes: ■ Though officially undocumented, this is so handy that it has\n been widely discussed, even by Microsoft publications such as\n MSJ. It should be OK to use this one.\n\n ■ The buffer at ES:DI must be large enough to handle the largest\n possible path and filename (about 80 bytes).\n\n ■ This function does NOT confirm that the input value (at DS:SI)\n is valid or if such a file exists. It simply parses the text\n and creates a name that looks good. It saves you the need of\n obtaining the current default drive and directory and\n prepending them to the name, etc.\n\nSee Also: Directory and File Functions\n DOS Functions\n -♦-"
  },
  {
    "id": "542-dos_fn_62h__query_current_psp.html",
    "t": "DOS Fn 62H: Query Current PSP",
    "b": "Compatibility: 3.0+ (doc'd: 5.0)\n Expects: AH 52H\n ──────────────────────────────────────────────────────────────────\n Returns: BX PID▲ (Process ID) of current process\n ──────────────────────────────────────────────────────────────────\n Info: This function obtains the segment address of the PSP (a.k.a, the\n Process ID) of the currently-executing (most-recently started)\n program.\n\n A TSR should save its own PSP during initialization. Then,\n before popping up, the TSR should use this fn to get the ID of\n the interrupted program, then use fn 50H to set the PID to its\n own (saved) value. Be sure to change the PID back before popping\n down.\n\n Notes: ■ On program startup, DS and ES both contain the PSP segment.\n\n ■ MS-DOS documents claim you can use this fn interchangeably with\n fn 51H.\n\nSee Also: PSP (Program Segment Prefix)\n Process Control Functions\n Program Startup & Exit\n DOS Environment\n DOS Functions\n -♦-"
  },
  {
    "id": "543-dos_fn_65h__extended_country_information_functions.html",
    "t": "DOS Fn 65H: Extended Country Information Functions",
    "b": "Compatibility: 3.3+\n\n See: Fn 6501H (get extended country info)\n\n Fn 6504H (get uppercase table)\n\n Fn 6505H (get filename character table)\n\n Fn 6506H (get collate sequence table)\n\n Fn 6507H (get double-byte character set)\n\n Fn 6520H (convert character)\n\n Fn 6521H (convert string)\n\n Fn 6522H (convert ASCIIZ string)\n\nSee Also: National Language Support\n DOS Functions\n -♦-"
  },
  {
    "id": "544-dos_fn_6501h__get_extended_country_information.html",
    "t": "DOS Fn 6501H: Get Extended Country Information",
    "b": "Compatibility: 3.3+\n Expects: AX 6501H\n BX Code Page (0ffffH = current code page for console)\n CX size of data to return (>=29H to get all of the data)\n DX Country ID\n ES:DI address of buffer to receive an ExtCountryInfoRec\n ──────────────────────────────────────────────────────────────────\n Returns: AX error code if CF is set to CY\n ES:DI buffer is filled with return information\n ──────────────────────────────────────────────────────────────────\n Info: Returns country-dependant information, including time and date\n format, currency symbol, etc.\n\n See ExtCountryInfoRec for a layout of the returned information.\n\n Notes: ■ The buffer size value in CX must be at least 5. If it's less\n than the size of an ExtCountryInfoRec, then only part of the\n structure is filled.\n\n ■ Fn 38H also returns country-specific information in a somewhat\n different format.\n\nSee Also: National Language Support\n DOS Functions\n -♦-"
  },
  {
    "id": "545-dos_fn_6504h__get_uppercase_table.html",
    "t": "DOS Fn 6504H: Get Uppercase Table",
    "b": "Compatibility: 3.3+\n Expects: AX 6504H\n BX Code Page (0ffffH = current code page for console)\n CX size of data to return (must be >= 5)\n DX Country ID\n ES:DI address of buffer to receive the table address\n ──────────────────────────────────────────────────────────────────\n Returns: AX error code if CF is set to CY\n ES:DI buffer is filled with 5 bytes of return information\n ──────────────────────────────────────────────────────────────────\n Info: Returns the address of a table of ASCII characters that can be\n used in converting international characters into uppercase.\n\n Upon return ES:DI points to a 5-byte structure. The first byte\n is a table identifier (04H) and the next 4 bytes are a 32-bit\n address in standard address format (offset, then segment).\n\n At that address is up to 130 bytes of data. The first two bytes\n describe the length of the table in bytes. The rest of the data\n is a series of bytes, each representing the uppercase equivalent\n of a character between 80H and ffH.\n\n The main purpose of this table is to map accented or other\n oddball characters to their plain ASCII equivalents. Text\n translated through this table can be sent, for instance, to\n printers which do not support international character sets.\n\n Notes: ■ In some cases, translation tables provided by DOS are\n truncated. Programs should always check the length of the\n table before starting to translate text.\n\n ■ Rather than bit-twiddle, just use fns 6520H, 6521H, and 6522H,\n for upshifting characters and strings.\n\nSee Also: National Language Support\n DOS Functions\n -♦-"
  },
  {
    "id": "546-dos_fn_6505h__get_filename_character_table.html",
    "t": "DOS Fn 6505H: Get Filename Character Table",
    "b": "Compatibility: 3.3+\n Expects: AX 6505H\n BX Code Page (0ffffH = current code page for console)\n CX size of data to return (must be >= 5)\n DX Country ID\n ES:DI address of buffer to receive the table address\n ──────────────────────────────────────────────────────────────────\n Returns: AX error code if CF is set to CY\n ES:DI buffer is filled with 5 bytes of return information\n ──────────────────────────────────────────────────────────────────\n Info: Returns the address of a table of ASCII characters that can be\n used in converting international characters into uppercase for\n use in filenames.\n\n Upon return ES:DI points to a 5-byte structure. The first byte\n is a table identifier (05H) and the next 4 bytes are a 32-bit\n address in standard address format (offset, then segment).\n\n At that address is up to 130 bytes of data. The first two bytes\n describe the length of the table in bytes. The rest of the data\n is a series of bytes, each representing the uppercase equivalent\n of a character between 80H and ffH.\n\n The purpose of this table is to map accented or other oddball\n characters to their plain ASCII equivalents -- for use in\n comparing or sorting filenames.\n\n Notes: ■ In some cases, translation tables provided by DOS are\n truncated. Programs should always check the length of the\n table before starting to translate text.\n\nSee Also: National Language Support\n DOS Functions\n -♦-"
  },
  {
    "id": "547-dos_fn_6506h__get_collating_sequence_table.html",
    "t": "DOS Fn 6506H: Get Collating Sequence Table",
    "b": "Compatibility: 3.3+\n Expects: AX 6506H\n BX Code Page (0ffffH = current code page for console)\n CX size of data to return (must be >= 5)\n DX Country ID\n ES:DI address of buffer to receive the table address\n ──────────────────────────────────────────────────────────────────\n Returns: AX error code if CF is set to CY\n ES:DI buffer is filled with 5 bytes of return information\n ──────────────────────────────────────────────────────────────────\n Info: Returns the address of a table containing the collating weights\n of all characters for the specified country and code page. This\n is used in sorting strings of text that contain international\n characters.\n\n Upon return ES:DI points to a 5-byte structure. The first byte\n is a table identifier (06H) and the next 4 bytes are a 32-bit\n address in standard address format (offset, then segment).\n\n At that address is up to 258 bytes of data. The first two bytes\n describe the length of the table in bytes. That is followed by a\n character array containing 256 elements. Each element is the\n collating weight of the corresponding character code. For\n instance, characters such as â,ä,à,Ä, and Å all have the same\n weight as 'A' and 'a'.\n\nSee Also: National Language Support\n DOS Functions\n -♦-"
  },
  {
    "id": "548-dos_fn_6507h__get_double_byte_character_set.html",
    "t": "DOS Fn 6507H: Get Double-Byte Character Set",
    "b": "Compatibility: 3.3+\n Expects: AX 6507H\n BX Code Page (0ffffH = current code page for console)\n CX size of data to return (must be at least 5)\n DX Country ID\n ES:DI address of buffer to receive the table address\n ──────────────────────────────────────────────────────────────────\n Returns: AX error code if CF is set to CY\n ES:DI buffer is filled with 5 bytes of return information\n ──────────────────────────────────────────────────────────────────\n Info: Returns the address of some information used in working with\n double-byte character sets (DBCS). The return information tells\n which bytes are lead characters of two-byte sequences. Such\n two-byte sequences must be treated as an unbreakable unit in\n DBCS-aware programs.\n\n Upon return ES:DI points to a 5-byte structure. The first byte\n is a table identifier (07H) and the next 4 bytes are a 32-bit\n address in standard address format (offset, then segment).\n\n At that address is a variable-length table. The first two bytes\n describe the length of the table in bytes. That is followed by a\n series of byte-pairs which each describe a run of lead\n characters. The table is terminated by two bytes of 00H. For\n instance...\n\n 06,00, dc,df, f1,ff,00,00\n\n ...indicates the table is 6 bytes long and that characters dcH,\n deH, dfH and deH and f1H through ffH are lead characters in DBCS\n byte-pairs.\n\nSee Also: National Language Support\n DOS Functions\n -♦-"
  },
  {
    "id": "549-dos_fn_6520h__upshift_character.html",
    "t": "DOS Fn 6520H: Upshift Character",
    "b": "Compatibility: 3.3+\n Expects: AX 6520H\n DL character to convert\n ──────────────────────────────────────────────────────────────────\n Returns: AX error code if CF is set to CY\n DL converted character (if no error)\n ──────────────────────────────────────────────────────────────────\n Info: Converts the specified character to uppercase, using the\n currently-active uppercase table for the active country and code\n page.\n\nSee Also: National Language Support\n DOS Functions\n -♦-"
  },
  {
    "id": "550-dos_fn_6521h__upshift_string.html",
    "t": "DOS Fn 6521H: Upshift String",
    "b": "Compatibility: 3.3+\n Expects: AX 6521H\n CX length of text, in bytes\n DS:DX address of text to convert\n ──────────────────────────────────────────────────────────────────\n Returns: AX error code if CF is set to CY\n DS:DX the text is converted in place\n ──────────────────────────────────────────────────────────────────\n Info: Converts the specified number of characters starting at the\n address at DS:DX into uppercase, using the currently-active\n uppercase table for the active country and code page.\n\nSee Also: National Language Support\n DOS Functions\n -♦-"
  },
  {
    "id": "551-dos_fn_6522h__upshift_asciiz_string.html",
    "t": "DOS Fn 6522H: Upshift ASCIIZ String",
    "b": "Compatibility: 3.3+\n Expects: AX 6522H\n DS:DX address of ASCIIZ▲ string to upshift\n ──────────────────────────────────────────────────────────────────\n Returns: AX error code if CF is set to CY\n DS:DX the string is converted in place\n ──────────────────────────────────────────────────────────────────\n Info: Converts all of the characters of the ASCIIZ string starting at\n DS:DX into uppercase, using the currently-active uppercase table\n for the active country and code page.\n\nSee Also: National Language Support\n DOS Functions\n -♦-"
  },
  {
    "id": "552-dos_fn_66h__set_or_query_active_code_page.html",
    "t": "DOS Fn 66H: Set or Query Active Code Page",
    "b": "Compatibility: 3.3+\n\n See: Fn 6601H (query active code page)\n\n Fn 6602H (activate code page)\n\nSee Also: National Language Support\n DOS Functions\n -♦-"
  },
  {
    "id": "553-dos_fn_6601h__query_active_code_page.html",
    "t": "DOS Fn 6601H: Query Active Code Page",
    "b": "Compatibility: 3.3+\n Expects: AX 6601H\n ──────────────────────────────────────────────────────────────────\n Returns: AX error code if CF is set to CY\n BX current active code page (as set by the user)\n DX system code page (a setup at boot time)\n ──────────────────────────────────────────────────────────────────\n Info: Obtains the code page ID for the current active code page and the\n default system code page, as set during system startup.\n\n Notes: ■ The system code page is set via the COUNTRY= command in\n CONFIG.SYS.\n\nSee Also: fn 6602H (activate code page)\n National Language Support\n DOS Functions\n -♦-"
  },
  {
    "id": "554-dos_fn_6602h__activate_code_page.html",
    "t": "DOS Fn 6602H: Activate Code Page",
    "b": "Compatibility: 3.3+\n Expects: AX 6602H\n BX code page to activate\n ──────────────────────────────────────────────────────────────────\n Returns: AX error code if CF is set to CY\n ──────────────────────────────────────────────────────────────────\n Info: Activates a specified global code page (character set).\n\n Before a code page can be selected for a device, the device must\n be prepared for code page switching, including:\n\n ■ DEVICE= in CONFIG.SYS to install a code-page aware device\n driver.\n\n ■ The Nlsfunc DOS command must be memory resident.\n\n ■ The Mode CP Prep command used to prepare the device (or a\n series of IOCTL fn calls that prepare the driver).\n\n The requested code page must be compatible with the country code\n specified in COUNTRY= command in CONFIG.SYS.\n\n DOS must be able to locate COUNTRY.SYS (a file that contains all\n kinds of NLS info). It will look in the root of the boot drive\n and perhaps elsewhere.\n\nSee Also: fn 6601H (query active code page)\n National Language Support\n DOS Functions\n -♦-"
  },
  {
    "id": "555-dos_fn_67h__set_file_handle_count.html",
    "t": "DOS Fn 67H: Set File Handle Count",
    "b": "Compatibility: 3.3+\n Expects: AH 67H\n BX desired maximum number of file handles\n ──────────────────────────────────────────────────────────────────\n Returns: AX error code if CF is set to CY\n ──────────────────────────────────────────────────────────────────\n Info: This function sets the maximum number of file handles that can be\n open concurrently by the calling program.\n\n BX can range from 20 to 65535. If less than 20, 20 is used.\n\n If BX is less than the current maximum (that is, if you want to\n shrink the number of handles) and more than BX files are\n currently open, then the change will be delayed until there are\n no more than the desired number of handles open.\n\n If BX is greater than the current maximum (you want to increase\n the number of handles), then DOS must have memory available to\n allocate space for the new handles. Use DOS Fn 4aH (SetBlock) to\n shrink the current memory usage. See Accessing Upper Memory for\n a way to put handles in UMB▲ space.\n\n Notes: ■ By default, the file handle table is contained in a reserved\n portion of each program's PSP. This call tells DOS to allocate\n some memory for an enlarged table.\n\n ■ This affects only the current application. The number of\n handles available to the system itself is set by the FILES=\n command in CONFIG.SYS. It does not affect child processes.\n\n ■ Remember that by default, 5 handles are used for standard I/O\n devices.\n\nSee Also: Handle-Oriented File I/O\n CONFIG.SYS\n DOS Functions\n -♦-"
  },
  {
    "id": "556-dos_fn_68h__commit_file.html",
    "t": "DOS Fn 68H: Commit File",
    "b": "Compatibility: 3.3+\n Expects: AH 68H\n BX file handle of file to flush\n ──────────────────────────────────────────────────────────────────\n Returns: AX error code if CF is set to CY\n ──────────────────────────────────────────────────────────────────\n Info: This function forces DOS to flush its RAM buffers of file data\n for the selected file handle.\n\n DOS normally avoids disk I/O by writing data to RAM buffers until\n a sector is full or the file is closed. This provides a way to\n force DOS to write the buffered data to disk.\n\nVersions: ■ Prior to DOS 3.3, you can force a file flush by closing, then\n reopening the file. But by using fn 45H to duplicate the\n handle and then close the duplicate.\n\n ■ Starting with DOS 4.0, you can force a flush on each write by\n opening the file via fn 6cH (extended file open/create).\n\n Notes: ■ This does NOT flush the Smartdrv cache buffers (the data may\n sit in memory for a few seconds). You can force Smartdrv to\n write all data by using fn 0dH (reset disk).\n\nSee Also: Handle-Oriented File I/O\n DOS Functions\n -♦-"
  },
  {
    "id": "557-dos_fn_6ch__extended_open_create.html",
    "t": "DOS Fn 6cH: Extended Open/Create",
    "b": "Compatibility: 4.0+\n Expects: AH 6cH\n BX extended open mode flags (see below)\n CX file attribute (used only if file gets created)\n DX action: 00-0h = if file exists, fail the call\n 00-1h = if file exists, open it\n 00-2h = if file exists, replace and open it\n 000-h = if doesn't exist, fail the call\n 001-h = if doesn't exist, create and open it\n DS:SI address of an ASCIIZ▲ string of a filespec to open\n ──────────────────────────────────────────────────────────────────\n Returns: AX error code if CF is set to CY\n file handle if no error\n CX action taken: 0 file was opened\n 1 file was created and opened\n 2 file was replaced and opened\n ──────────────────────────────────────────────────────────────────\n Info: This function opens (or creates and opens) a file. Think of it\n as a smart 3dH Open which can optionally 3cH Create the file if\n it doesn't exist.\n\n Additionally, this call can disable normal INT 24h critical error\n handling and can force all writes to go direct to the disk.\n\n DS:DX points to an ASCIIZ string in the form...\n d:\\path\\filename.ext0\n If the drive or path is omitted, defaults are assumed.\n\n BX On entry, BX contains extended mode flags as follows:\n\n 1 1 1 1 1 1\n ╓5┬4┬3┬2┬1┬0┬9┬8╥7┬6┬5┬4┬3┬2┬1┬0╖ See Open Mode for more\n ║0│d│f│0 0 0 0 0║i│ shr │0│ r/w ║ info on bits 0-7\n ╙─┴╥┴╥┴─┴─┴─┴─┴─╨╥┴─┴─┴─┴─┴─┴─┴─╜ bits\n ║ ║ ║ ╚═╦═╝ ╚═══╩═► 0-2: read/write access mode\n ║ ║ ║ ╚═══════════► 4-6: sharing mode\n ║ ║ ╚═══════════════► 7: inheritance\n ║ ╚═══════════════════════════► 13: 0=normal INT 24H use\n ║ 1=fail critical errors\n ║ on open and all I/O\n ╚═════════════════════════════► 14: 0=normal file buffering\n 1=directly to disk\n\n If bit 13 is set (2000H), then I/O through this handle will never\n cause an INT 24H critical error. If a drive door is open (etc.),\n then the function which caused the error will fail with a regular\n DOS error. Use Fn 59H to find out what happened.\n\n If bit 14 is set (4000H), then the normal DOS output buffering is\n bypassed and all output goes directly to the disk (as if you had\n called Fn 68H after each write). This can hurt I/O performance,\n but it maximizes safety.\n\n CX When creating a new file, set CX to the desired file attribute\n (read-only, hidden, etc.). Use 0000H for normal files. If the\n file exists, CX is ignored.\n\n DX This controls the open/create action, depending upon whether the\n file exists at the time of the call. Common combinations are:\n 0001H = open the file if it exists; otherwise fail the call\n 0011H = open the file if it exists; otherwise create it\n 0012H = if the file exists open and truncate it to length 0;\n otherwise create it and open it\n\n Notes: ■ Perhaps the most useful feature here is the ability to avoid\n special handling for INT 24H critical errors. Of course, you\n can only discard your INT 24H handler if you are sure that the\n application is used only under DOS 4.0+.\n\nSee Also: Handle-Oriented File I/O\n INT 24H\n DOS Functions\n -♦-"
  },
  {
    "id": "558-dos_interrupts.html",
    "t": "DOS Interrupts",
    "b": "INT 20H Terminate a program ◄superseded►\n INT 21H DOS Services\n\n INT 22H Terminate address ──────────────┐\n INT 23H Control-Break address ├ Address Vectors Only\n INT 24H Critical Error Handler address ─┘\n\n INT 25H/26H Absolute Disk Read/Write\n\n INT 27H Terminate but Stay Resident ◄superseded►\n INT 28H DOS Idle (safe to pop up) ◄wasUndoc►\n INT 29H DOS Internal Fast Screen Write ◄undocumented►\n INT 2eH Perform DOS Command ◄undocumented►\n\n INT 2fH Multiplex (DoubleSpace, spooler, TSR control, other APIs)\n\n INT 31H DPMI DOS Protected Mode Interface Services\n INT 33H Mouse Support\n INT 67H EMS Expanded Memory Manager (HIMEM.SYS)\n -♦-"
  },
  {
    "id": "559-int_20h__program_terminate.html",
    "t": "INT 20H: Program Terminate",
    "b": "This interrupt is a superseded fn. When running under DOS 2.0+, you\n should use fn 4cH instead. It is still supported and may be used to exit\n from a program and return control to its parent (usually COMMAND.COM).\n\n Note: The CS register must contain the value of the PSP for the\n terminating process.\n\n COM-format programs usually run with CS=PSP, so they may issue\n INT 20H at any time. EXE programs may perform a FAR JMP or a FAR\n RET to pass control to PSP:0000 which contains an INT 20H\n instruction.\n\n As with other program termination services:\n\n ■ It restores the values of DOS vectors: INT 22H INT 23H INT 24H.\n ■ It flushes all file buffers and closes all open files.\n ■ If you are using file-sharing, you must unlock all locked files and\n records.\n\n It is advisable to use DOS Fn 4cH (terminate) to avoid difficulties that\n occur when CS is not the same as the PSP. Fn 4cH also lets you set an\n exit code, checkable by the IF ERRORLEVEL batch command.\n\nSee Also: Program Startup & Exit\n Process Control Functions\n DOS Functions\n -♦-"
  },
  {
    "id": "560-int_21h__dos_functions.html",
    "t": "INT 21H: DOS Functions",
    "b": "INT 21H is the portal to most DOS functions.\n\n See DOS Function Index for a complete list.\n See DOS Fns QuickRef for an often-used subset list.\n See DOS Fns by Version for DOS version compatibility.\n See DOS Fns by Category for functional groupings.\n\n See About DOS Functions for related information.\n\n Programs requesting a DOS service must prepare all registers and set\n AH (or AX) to the desired DOS function number, then issue an INT 21H.\n ──────────────────────────────────────────────────────────────────────────\n The following are some DOS services that are NOT called via INT 21H:\n\n INT 25H Absolute Disk Read\n INT 26H Absolute Disk Write\n\n INT 28H DOS Idle\n INT 29H DOS Internal Fast Screen Write ◄undocumented►\n\n INT 2fH Multiplex Interrupt is the portal to:\n ANSI.SYS installed state\n Append Command API\n Doskey Services\n Dosshell Task-Switcher API\n DoubleSpace API\n HIMEM.SYS / XMS API\n National Language Support services\n Network services\n Print Command API\n Other Microsoft and after-market services\n\n INT 15H APM Advanced Power Management (APM)\n INT 31H DPMI Services\n INT 33H Mouse Services\n INT 67H EMS Services\n\nSee Also: API Index\n Interrupts and BIOS Services\n -♦-"
  },
  {
    "id": "561-about_dos_functions.html",
    "t": "About DOS Functions",
    "b": "The DOS functions are a haphazard set of file, device, memory, and process\n control services that are available to any program which is capable of\n setting registers and invoking software interrupts.\n\n To access DOS functions:\n ■ Place a DOS Function Number in the AH register (if one or more\n sub-functions exist, its value usually goes in AL)\n ■ Load up the other registers as described in the function summary\n ■ Prepare any buffers, ASCIIZ strings, and control blocks needed\n ■ Be aware of (or set) the location of the DTA if necessary\n ■ Invoke INT 21H\n ■ Look for error indicators returned by DOS (examine the Carry Flag)\n\n DOS preserves the entry values of all registers except when information is\n returned in a register.\n\n As DOS evolved, later version have remained mostly compatible with earlier\n versions. See DOS Versions for a discussion of incompatibilities.\n\nSee Also: DOS Functions\n DOS Interrupts\n DOS Fns by Category\n -♦-"
  },
  {
    "id": "562-int_22h__terminate_address.html",
    "t": "INT 22H: Terminate Address",
    "b": "The INT 22H vector (0000:0088) contains the address that will receive\n control when the executing program terminates via any of:\n\n Standard program exits: INT 20H ◄superseded►\n DOS fn 00H ◄superseded►\n DOS fn 4cH (normal termination)\n\n TSR (stay resident) exits: INT 27H ◄superseded►\n DOS fn 31H (normal KEEP termination)\n\n Do not invoke INT 22H or call its address directly.\n\n In addition to normal program termination, the default INT 24H (Critical\n Error) handler uses this vector when the user pressed A (to Abort) and the\n default action of the INT 23H (Ctrl-Break) handler is to terminate the\n program via this vector.\n\n On program startup, the address at this vector is copied into the\n pfTerminate field of the PSP. This PSP-local copy of the address is used\n to terminate the program and is restored into the interrupt table;\n therefore, changing the INT 22H vector has no effect on your program, but\n will affect any child programs you EXEC.\n\n Normal termination causes DOS to free all resources, including open files\n and memory allocations. A lot of DOS internal stuff can get messed up if\n you modify the pfTerminate field of the PSP or if you invoke INT 22H\n directly.\n\nSee Also: Program Startup & Exit\n DOS Functions\n -♦-"
  },
  {
    "id": "563-int_23h__ctrl_break_exit_address.html",
    "t": "INT 23H: Ctrl-Break Exit Address",
    "b": "The INT 23H vector (0000:008c) points to the code that will receive\n control when DOS senses that the user has pressed Ctrl-Break.\n\n The address at the INT 23H vector is copied into the pfCtlBrk field of the\n PSP by DOS fn 26H (create PSP) and fn 4bH (EXEC). The original address of\n the Ctrl-Break handler is restored from the PSP when a program exits.\n Thus, the parent's Ctrl-Break handler will be restored upon exit from the\n child process.\n\n█▌Break Sensing▐█\n DOS invokes INT 23H when it senses that the user has pressed Ctrl+C\n (ASCII 03H) Ctrl-Break. The level of DOS Ctrl-Break sensing can be\n checked or set via fn 33H as follows:\n\n ■ If Break sensing is OFF, DOS senses Ctrl-Break only during console,\n printer, and serial device I/O.\n\n ■ If Break sensing is ON, DOS senses Ctrl-Break during all fns except 06H\n and 07H.\n\n█▌Custom Break Handling▐█\n Normal DOS break-handling is handled by COMMAND.COM. It causes a program\n to terminate immediately. If you use network file-locking or want avoid\n the ugly DOS ^C display, you should intercept INT 23H and handle\n Ctrl+Break in your own program. Please note:\n\n ■ Use Fn 25H to set the INT 23H vector to point to your own code.\n\n ■ Upon entry to your Ctrl-Break handler:\n • All registers are set as they were upon entry to the DOS function\n that sensed Ctrl-Break.\n • SS:SP is set to a DOS internal stack. The top of stack will contain\n the CS:IP/Flags for an IRET to get back to DOS; below that is the\n CS:IP/Flags for an IRET to get back to your program (you might use\n this to figure out what part of your code was active when the user\n pressed Break).\n • DOS clears internal variables InDOS and ErrorMode, so that your\n program can use DOS fns in the Break handler.\n \n ■ If you want to ignore Ctrl-Break, just issue an IRET. DOS restarts the\n DOS fn that was interrupted, and eventually returns to your program.\n\n ■ If you want to do something (e.g., halt a repeat action), then be sure\n to save all registers before taking action and restore all registers\n afterwards.\n\n Exit via an IRET. There are no restrictions on what your break handler\n may do -- all DOS functions are allowed. However, if the break handler\n itself performs character I/O, and the user presses Ctrl-Break again,\n DOS crashes and burns.\n\n ■ If you want to abort (exit to the parent process), then set the carry\n flag and return via a FAR RET. This causes DOS to perform normal\n cleanup and exit to the parent.\n\n ■ An easy way to ensure that a process notices an occurrence of\n Ctrl-Break is to perform DOS Fn 0bH every once in a while.\n\nSee Also: Program Startup & Exit\n fn 33H (query/set Break-checking)\n INT 1bH (invoked by BIOS on Ctrl+Break)\n DOS Functions\n -♦-"
  },
  {
    "id": "564-int_24h__critical_error_handler.html",
    "t": "INT 24H: Critical Error Handler",
    "b": "The INT 24H vector (0000:0090) is set to the address that will gain\n control when a DOS device driver encounters a so-called critical error.\n\n On program startup, the address at this vector is copied into the\n pfCritErr field of the PSP. This PSP-local copy of the address is\n restored into the interrupt table upon program exit. Therefore, changing\n the INT 24H vector will affect handling of your own program as well as any\n child programs you EXEC.\n\n The normal DOS INT 24H handler is the code that displays the message...\n\n Abort, Retry, Fail, Ignore? _\n\n ...which you see when a diskette drive door is open or the printer is off-\n line. Note: the \"Fail\" was added in DOS version 3.0.\n\n Most sophisticated programs supply their critical error handler to avoid\n having DOS screw up a carefully-maintained screen display. To supply a\n custom Critical Error handler, use fn 25H to replace interrupt vector 24H.\n\n█▌Entry▐█\n Upon entry to the INT 24H handler, the registers are as follows:\n\n BP:SI = addr of a Device Header to help identify the failing device\n DI = bits 0-7 contain an error code (bits 8-15 are undefined)\n AL = if AH bit 7=0, AL is the drive number (0=A, 1=B, etc.)\n AH = error information as follows:\n ╓7┬6┬5┬4┬3┬2┬1┬0╖\n ║*│0│i│r│f│loc│w║\n ╙╥┴─┴╥┴╥┴╥┴─┴─┴╥╜ bits mask\n ║ ║ ║ ║ ╚╦╝ ╚═► 0: 01H operation type: 0=read, 1=write\n ║ ║ ║ ║ ╚════►1-2: 06H affected disk area:\n ║ ║ ║ ║ 00=system files, 01=FAT\n ║ ║ ║ ║ 10=directory, 11=data area\n ║ ║ ║ ╚═══════► 3: 08H 1=FAIL exit is allowed ───┐\n ║ ║ ╚═════════► 4: 10H 1=RETRY exit is allowed ╞═►3.0+ only\n ║ ╚═══════════► 5: 20H 1=IGNORE exit is allowed ─┘\n ╚═══════════════► 7: 80H device type: 0=disk, 1=other\n\n * When bit 7=1 (non-disk error), bits 0-6 are not defined.\n\n You can handle the error by prompting the user to take action (e.g., close\n the drive door or turn on the printer).\n\n You can obtain additional information from DOS Fn 59H and/or the device\n driver header block pointed to by BP:SI.\n\n Warning! Be careful about using DOS fns in your Critical Error handler.\n With DOS 5.0+, ONLY the following fns can be called safely:\n\n 01H-0CH (DOS character I/O)\n 33H (all subfns are OK, including 3306H get DOS version)\n 50H (set PSP address)\n 51H and 62H (query PSP address)\n 59H (get extended error information)\n\n With DOS 2.0-3.0, you are even more limited: only 01H-0cH and\n 59H are allowed, unless you set the DOS ErrorMode flag before\n invoking INT 21H (in that case, you must avoid 01H-0cH!).\n\n█▌Exit▐█\n After handling or trying to correct the error, you can set AL with an\n action code and get back to DOS indicating one of these actions:\n\n AL=0: ignore the error\n AL=1: retry the operation\n AL=2: abort. Terminate via the INT 23H address (as on Ctrl-Break)\n AL=3: return to application indicating a failed DOS function\n\n DOS 3.0+ Examine AH on entry to see which actions are not allowed.\n\n The AL=3 option seems ideal. For instance, if an \"Open File\" operation\n caused the error because of no disk in the drive, you could let your\n application take care of it with its normal error handling. However, it\n has DISadvantages:\n\n ■ The AL=3 option is NOT available with DOS version prior to DOS 3.0.\n ■ DOS always returns error code 53H which is not too informative.\n\n Note: The DOS 4.0+ fn 6cH lets you avoid problems relating to critical\n errors on a file-by-file basis. I only wish this had existed\n since 2.1!\n\n█▌The Stack▐█\n Upon entry into the INT 24H error handler, the stack is in a known state\n as described here:\n\n IP, CS, Flags To get back to DOS via IRET\n AX,BX,CX,DX,SI,DI,BP,DS,ES Application program registers before INT 21H\n IP, CS, Flags To get back to application via IRET\n\n This information can be used to determine which DOS function failed (it's\n in AH as saved on the stack) and any parameters in other registers. But\n its primary value is that it lets your INT 24H handler restore the\n registers and exit directly to the application program.\n\n You will typically want to pretend to be DOS and set AX with a DOS error\n code and set CF=CY to indicate an error. If you exit to the application\n this way, the manual says that DOS will be in an \"unstable\" state until a\n fn higher than 0cH is used. Just be sure that the application does a\n fn 30H or some such as it handles the error.\n\n Another handy technique: Simply set an application-internal error flag,\n exit the handler with AL=0 (ignore). Then have your application check\n that flag after each DOS I/O fn. This works for all versions of DOS.\n\n The INT 24H vector is NOT taken for errors occurring during INT 25H/26H.\n\nSee Also: DOS Error Codes\n Program Startup & Exit\n DOS Functions\n -♦-"
  },
  {
    "id": "565-int_25h_26h__absolute_disk_read_write.html",
    "t": "INT 25H/26H: Absolute Disk Read/Write",
    "b": "Compatibility: 2.0+\n Expects: (on drives < 32M and DOS < 4.0)\n AL drive number (0=A, 1=B, etc.)\n CX count of sectors to read\n DX beginning sector (DOS logical sector number)\n DS:BX transfer address (destination or source buffer)\n\n Expects: (on drives > 32M and DOS >= 4.0)\n AL drive number (0=A, 1=B, etc.)\n CX ffffH\n DX beginning sector (DOS logical sector number)\n DS:BX address of a AbsDiskIORec structure.\n ──────────────────────────────────────────────────────────────────\n Returns: AX special error code (see below) if CF is set to CY\n\n IMPORTANT! This interrupt leaves one word of data on the\n stack. You must pop it off (see below).\n ──────────────────────────────────────────────────────────────────\n Info: These DOS services provide direct access to any disk sector\n available through DOS and installed block device drivers.\n\n ■ INT 25H reads sectors\n ■ INT 26H writes sectors\n\n CX,DX and...\n DS:BX Prior to DOS 4.0, CX specified the sector count and DS:BX pointed\n to the transfer buffer. With DOS 4.0+, a mechanism was added to\n allow access to sector numbers higher than 65535 (the largest\n number than can fit in the 16-bit CX register). The layout of\n the input parameters changes, depending upon the value in CX. In\n summary:\n\n When CX is NOT equal to ffffH, it specifies now many sectors you\n want to read or write, DX indicates the starting sector, and\n DS:BX points the data buffer. Note that values larger than about\n 1024 (400H) are as much as can be read or written, given the\n constraints of conventional▲ memory.\n\n When CX IS equal to ffffH, you must set DS:BX to point to an\n AbsDiskIORec structure which identifies the starting sector,\n desired number of sectors, and the location of the memory buffer.\n DX is ignored.\n\n Note: Most disks have a sector size of 512 bytes (½K), but you\n should not assume that size when allocating the transfer\n buffer. Use fn 1cH or 32H to find the true sector size.\n\n DX (or AbsDiskIORec.lStartSect, when CX=ffffH) specifies the\n starting sector, using a DOS logical sector number.\n\n DOS logical sector 0 is the DOS boot sector (the first sector in\n the DOS partition). Logical sector numbers increment first\n through each sector on a cylinder, then through each head, and\n finally through each cylinder on the drive (the exact layout is\n rarely important--just know that you can access any sector from 0\n through n, where n can be derived via fn 1cH or 32H).\n\n Notice that the Master Boot Record and any other sectors outside\n of the DOS partition are not available through this service.\n BIOS INT 13H provides complete access to all parts of a hard\n disk. DOS 3.2+ device drivers provide direct access via fns\n 440dH 41H (write track) and 440dH 61H (read track).\n\n See File Allocation Table for an overview of how DOS maps logical\n sector numbers to physical head/track/sector numbers and how to\n convert a cluster number into a logical sector number.\n\n█▌Pop the Stack!▐█\n INT 25H and INT 26H both leave one 16-bit word of data on the stack (it is\n the Flags register that would have been used in an IRET, but was left\n there when DOS use a FAR RET to get back to your program. An IRET was not\n used since that would overwrite the value in CF (used to indicate errors).\n\n Be sure to pop one word off of the stack upon return. See the example,\n below.\n\n█▌Error Codes▐█\n Errors occurring during INT 25H/26H are NOT handled by the INT 24H\n critical error handler. Upon return from INT 25H or INT 26H, the Carry\n Flag set (CF=CY=1) when a error occurred. When CF is set:\n\n AL is a device error code (00H-0cH). It is the same as bits 0-7 of\n DI upon INT 24H.\n\n Add 13H to this value (yielding 13H-1fH) and it will match one of\n the errors listed under DOS Error Codes.\n\n AH is one of these values:\n 80H = attachment failed to respond\n 40H = disk seek operation failed\n 08H = Bad CRC on diskette read\n 04H = requested sector not found\n 03H = Attempted write on write-protected diskette\n 02H = some error other than these listed above\n\n█▌Examples▐█\n Sample use of INT 25H to read the boot sector of a <32 MB diskette:\n\n mov al,0 ;select drive A\n mov dx,0 ;select the DOS Boot Sector\n mov cx,1 ;read one sector ..\n lea bx,myBuf ; ... into buffer at DS:BX\n INT 25H\n pop dx ;discard the extra word on the stack\n jnc noErr\n ...etc... ;code to handle any disk error (code in AX)\n noErr: ...etc... ;code continues when no error\n\n Sample use of INT 25H to read 20 sectors starting at logical sector 80,000\n of a >32 MB hard disk partition:\n\n mov al,0 ;select drive C\n lea bx, ioRec ;set up the local AbsDiskIORec\n mov word ptr [bx], 14464 ;large sector number, low word\n mov word ptr [bx+2],1 ;large sector number, high word\n mov word ptr [bx+4],20 ;read 20 sectors\n mov word ptr [bx+6],offset myBuf ;set buffer addr offset\n mov word ptr [bx+8],seg myBuf ; segment\n INT 25H\n pop dx ;discard the extra word on the stack\n jnc noErr\n ...etc...\n\n█▌Diskette Duplication▐█\n DOS technical documents recommend avoiding INT 25H/26H whenever possible.\n For instance, to duplicate diskettes (as with the DOS Diskcopy command),\n it is better to use IOCTL Functions:\n\n Fn 440dH 61H (read track)\n Fn 440dH 42H (format and verify track)\n Fn 440dH 41H (write track)\n\n Of course, that only works if you are certain to be running under\n DOS 3.2 or later and the device driver supports IOCTL services.\n\nSee Also: INT 13H (ROM-BIOS disk access)\n fn 440dH 41H (write track)\n fn 440dH 61H (read track)\n File Allocation Table\n DOS Functions\n -♦-"
  },
  {
    "id": "566-int_27h__terminate_but_stay_resident.html",
    "t": "INT 27H: Terminate but Stay Resident",
    "b": "Compatibility: 1.0+\n Expects: DX last addr+1 to keep resident\n (note: DX is an offset from the PSP segment)\n ──────────────────────────────────────────────────────────────────\n Returns: none (not applicable)\n ──────────────────────────────────────────────────────────────────\n Info: This service terminates the caller, leaving a portion of memory\n allocated and resident in memory. Subsequent programs will not\n overwrite the code or data left in memory. See TSR for a list of\n related topics.\n\n INT 27H is the traditional method used to install interrupt\n service routines and user-definable data tables, but it is\n ◄superseded► by DOS Fn 31H (KEEP). That fn provides a way to\n leave more than 64K resident and it allows you to set an exit\n code when you terminate.\n\n INT 27H (and all DOS exit services) restore the vectors for INTs\n 22H-24H from the exiting program's PSP. Therefore this service\n cannot be used to install a permanent Critical Error or\n Ctrl-Break handler.\n\nSee Also: fn 31H (terminate and stay resident)\n TSR/Popup Functions\n Program Startup & Exit\n DOS Functions\n DOS Interrupts\n -♦-"
  },
  {
    "id": "567-int_28h__dos_idle.html",
    "t": "INT 28H: DOS Idle",
    "b": "Compatibility: 2.0+\n Expects: none\n ──────────────────────────────────────────────────────────────────\n Returns: none\n ──────────────────────────────────────────────────────────────────\n\n This interrupt was undocumented prior to DOS 5.0, but it has been\n supported without change since DOS 2.0. It lets programs such as the\n DOS Print command carry out background tasks while the system awaits\n keyboard input.\n\n Programs that are idle (polling for input) can issue INT 28H or call\n INT 2FH 1680H to free up a timeslice so that background tasks can operate.\n DOS itself calls INT 28H during fns 01H through 0cH (DOS I/O services)\n while it is awaiting user response.\n\n This interrupt is of interest since it provides a means for TSR programs\n to gain control at a point when it is safe to use DOS services such as\n file I/O.\n\n To use this with a TSR popup program, you must intercept INT 28H. Before\n taking action, first call the previous INT 28H owner (that is, let the\n interrupt propagate down the chain). Upon return, check to see if your\n popup has been triggered. If so, it is safe to take control of the CPU.\n You must save SS:IP and all registers on entry and provide a local stack.\n Be sure to restore the stack and registers before returning from INT 28H.\n\n Warning! When you gain control via INT 28H, it is NOT SAFE to call DOS\n fns 01H-0cH unless you first set the DOS ErrorMode variable to 1.\n It IS safe to use all other DOS fns, regardless of InDOS or\n ErrorMode.\n\nSee Also: TSR/Popup Functions\n INT 2FH 1680H (give up timeslice)\n fn 34H (get InDOS and ErrorMode flag addresses)\n DOS Functions\n DOS Interrupts\n -♦-"
  },
  {
    "id": "568-int_29h__fast_putchar.html",
    "t": "INT 29H: Fast PUTCHAR",
    "b": "Compatibility: ◄Undoc► ??\n Expects: AL character to display\n ──────────────────────────────────────────────────────────────────\n Returns: ?? undocumented\n ──────────────────────────────────────────────────────────────────\n\n Info: This is ◄undocumented► through DOS 6.0 and I can't find much\n about it.\n\n INT 29H outputs a character to the screen. When ANSI.SYS is\n resident, it intercepts this vector; otherwise, it is handled\n internally by DOS.\n\n My disassembly shows that the routine fetches the current screen\n color into BL and then passes AL on to INT 10H 09H (write\n character). It updates the cursor position. It also appears to\n take special action on:\n\n 07H BEL (make a beep; don't update cursor)\n 08H BS (backspace; cursor backwards one column)\n 0aH LF (line feed; cursor to next line; scroll if needed)\n 0dH CR (carriage return; cursor to start of line)\n 1bH ESC (ANSI Escape Sequences)\n\n This fn is NOT particularly fast, compared to hand-optimized\n writes directly to video memory. In fact, I can see no\n advantage over using, say INT 10H 0eH. However, it is a bit\n faster than handle-oriented file output to the CON device.\n\nSee Also: Character I/O Functions\n INT 2fH 1a00H (is ANSI installed?)\n ANSI Escape Sequences\n DOS Interrupts\n -♦-"
  },
  {
    "id": "569-int_2ah__microsoft_network_services.html",
    "t": "INT 2aH: Microsoft Network Services",
    "b": "INT 2aH is designated as the portal to Microsoft Network services. It\n also appears that Windows uses this vector for some of its own low-level\n operations.\n\n Sorry, but TECH Help! provides no information on this API.\n\n Press ESC to Return to the Previous Topic.\n\nSee Also: DOS Interrupts\n Interrupts and BIOS Services\n -♦-"
  },
  {
    "id": "570-int_2eh__perform_dos_command.html",
    "t": "INT 2eH: Perform DOS Command",
    "b": "Compatibility: ??\n Expects: DS:SI offset of an Lstring▲ of a DOS command to perform\n (note: memory must be available when loading programs)\n ──────────────────────────────────────────────────────────────────\n Returns: ?? (it's not apparent how to obtain status of request)\n SS:SP are destroyed ◄════\n ──────────────────────────────────────────────────────────────────\n\n Info: This is ◄undocumented► through DOS 6.0. There are too many\n drawbacks to make this a really useful function (see notes).\n\n INT 2eH performs a DOS command, as if it had been typed at the\n DOS prompt.\n\n DS:SI must point to a string in which the first byte is the\n length of the string, followed by the command text. After the\n command, a byte of 0dH (CR) must be appended (but don't count it\n in the first byte). For instance:\n\n DB 0fH, \"set PROMPT=$p$g\", 0dH ;text is 0fH (15) bytes long\n\n This example illustrates the main potential use -- it is able to\n Set values into the DOS master (root) environment. In all other\n cases, fn 4bH is preferred, (e.g., EXEC COMMAND.COM, passing it\n the line \"/c dos_cmd\") since the EXEC fn is fully documented.\n\n Notes: ■ Don't use this while a batch file is running. This would cause\n a fatal reentrancy problem (COMMAND.COM uses this to execute\n batch commands). Since a program cannot control whether a\n batch is in progress, this is NOT a reliable function.\n\n ■ Be sure to free up some memory to execute programs and\n remember to relocate your local stack into the shrunken memory\n area.\n\n ■ Provide plenty of stack space -- DOS really eats it up. SS and\n SP must be saved before the call and restored directly after.\n\nSee Also: INT 2fH aexxH (hook COMMAND.COM command line)\n fn 4b00H (load and execute a program)\n DOS Environment\n -♦-"
  },
  {
    "id": "571-dpmi_services.html",
    "t": "DPMI Services",
    "b": "The DPMI (DOS Protected Mode Interface) specification describes services\n provided by a DPMI host. One popular DPMI host is Microsoft Windows and\n these DPMI services are available to Windows programs and to DOS programs\n when running under Windows 386Enh mode.\n\n Note: A solid understanding of the Intel 80x86 protected-mode\n architecture is mandatory. See Using DPMI Services for related\n information.\n\n See: INT 2fH 1680H (release time slice)\n INT 2fH 1686H (query CPU Mode / Query INT 31H services)\n INT 2fH 1687H (obtain mode-switch entry address)\n INT 2fH 168aH (get DPMI vendor's API address)\n\n INT 31H 0000H (allocate LDT descriptors)\n INT 31H 0001H (free LDT descriptor)\n INT 31H 0002H (segment to descriptor)\n INT 31H 0003H (query selector increment value)\n INT 31H 0006H (query segment base address)\n INT 31H 0007H (set segment base address)\n INT 31H 0008H (set segment limit)\n INT 31H 0009H (set descriptor access rights)\n INT 31H 000aH (create alias descriptor)\n INT 31H 000bH (query descriptor)\n INT 31H 000cH (set descriptor)\n INT 31H 000dH (allocate specific descriptor)\n INT 31H 000eH (query multiple descriptors)\n INT 31H 000fH (set multiple descriptors)\n\n INT 31H 0100H (allocate DOS memory block)\n INT 31H 0101H (free DOS memory block)\n INT 31H 0102H (resize DOS memory block)\n\n INT 31H 0200H (query real-mode interrupt vector)\n INT 31H 0201H (set real-mode interrupt vector)\n INT 31H 0202H (query processor exception handler vector)\n INT 31H 0203H (set processor exception handler vector)\n INT 31H 0204H (query protected-mode interrupt vector)\n INT 31H 0205H (set protected-mode interrupt vector)\n\n INT 31H 0300H (simulate real-mode interrupt)\n INT 31H 0301H (call real-mode for FAR RET return)\n INT 31H 0302H (call real-mode for IRET return)\n INT 31H 0303H (allocate real-mode callback address)\n INT 31H 0304H (free real-mode callback address)\n INT 31H 0305H (query state save/restore addresses)\n INT 31H 0306H (query raw mode switch address)\n\n INT 31H 0400H (query DPMI version)\n INT 31H 0401H (query DPMI capabilities)\n\n INT 31H 0500H (query free memory information)\n INT 31H 0501H (allocate memory block)\n INT 31H 0502H (free memory block)\n INT 31H 0503H (resize memory block)\n INT 31H 0504H (allocate linear memory block)\n INT 31H 0506H (query page attributes)\n INT 31H 0507H (set page attributes)\n INT 31H 0508H (map device in memory block)\n INT 31H 0509H (map conventional memory in memory block)\n INT 31H 050aH (query memory block size and base)\n INT 31H 050bH (query memory information)\n\n INT 31H 0600H (lock linear region)\n INT 31H 0601H (unlock linear region)\n INT 31H 0602H (mark real-mode region as pageable)\n INT 31H 0603H (relock real-mode region)\n INT 31H 0604H (get page size)\n\n INT 31H 0700H (mark page as demand paging candidate)\n INT 31H 0701H (discard page contents)\n\n INT 31H 0800H (physical address mapping)\n INT 31H 0801H (free physical address mapping)\n\n INT 31H 0900H (disable virtual interrupt state)\n INT 31H 0901H (enable virtual interrupt state)\n INT 31H 0902H (query virtual interrupt state)\n\n INT 31H 0a00H (query vendor-specific API entry address)\n\n INT 31H 0b00H (set debug watchpoint)\n INT 31H 0b01H (clear debug watchpoint)\n INT 31H 0b02H (query state of debug watchpoint)\n INT 31H 0b03H (reset debug watchpoint)\n\n INT 31H 0c00H (setup DPMI TSR callback)\n INT 31H 0c01H (protected-mode terminate and stay resident)\n\n INT 31H 0d00H (allocate shared memory)\n INT 31H 0d01H (free shared memory)\n INT 31H 0d02H (serialize on shared memory)\n INT 31H 0d03H (free serialization on shared memory)\n\n INT 31H 0e00H (query coprocessor status)\n INT 31H 0e01H (set coprocessor emulation)\n\n Notes: Before accessing any INT 31H services, the CPU must be in\n protected mode.\n\nSee Also: Using DPMI Services\n INT 2fH 16xxH (Enh386 Windows Services & Notifications)\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "572-using_dpmi_services.html",
    "t": "Using DPMI Services",
    "b": "DOS Extenders such as PharLap's (used in Lotus 1-2-3) and many popular\n compilers support DPMI-aware libraries and toolkits. You are advised to\n use such library calls rather than access DPMI services directly.\n\n Write or call... Intel Literature JP26 (Phone: 800-548-4725)\n 3065 Bowers Ave.\n P.O. Box 58065\n Santa Clara CA 95051-8065\n\n ...for a printed version of the DPMI spec (with required background and\n some semi-tutorial information).\n\n ■ DPMI INT 31H Services are only available while in protected mode.\n Use INT 2fH 1687H to obtain the address you must call to switch to\n protected mode.\n ■ Set up the registers and call that address (see example, below).\n ■ When in protected mode, use INT 31H DPMI Services.\n ■ To exit back to real mode, use DOS Fn 4cH (terminate).\n\n The following code fragment illustrates switching into protected mode:\n\n ;--------------------- get the DPMI entry-address for mode switch\n dd pfpDpmiSwitch ;we'll put the mode-switch entry address here\n .\n .\n .\n mov AX, 1687h ;see INT 2fH 1687H (get switch fn addr)\n int 2fH\n cmp AX,0\n jne no_DPMI ;bail out -- no DPMI host present\n\n mov pfpDpmiFns,di ;save the addr of API entry point\n mov pfpDpmiFns+2,es\n ;--------------------- allocate the memory needed by the host\n mov BX,SI ;required memory, in paragraphs\n mov AH,48H ;DOS fn 48H allocates memory\n int 21H\n jc err_exit ;bail out, no mem available\n\n mov ES,AX ;AX is the segment of the allocation\n mov AX,0 ;specify that caller is a 16-bit client\n call pfpDpmiSwitch ;call the switch address (see INT 2fH 1687H)\n jc cantSwitch ;bail out on error\n\n ;--------------------- try a fn call\n mov AX,0400H ;see INT 31H 0400H (get DPMI version)\n int 31H\n jc errHandler\n .\n .\n .\n mov AX,4c00H ;DOS fn 4cH terminates prog & switches to real mode\n int 21H\n\nSee Also: DPMI Services\n INT 2fH 16xxH (Enh386 Windows Services & Notifications)\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "573-int_2fh_1687h__get_real_to_protected_mode_switch_address.html",
    "t": "INT 2fH 1687H: Get Real-to-Protected Mode Switch Address",
    "b": "Compatibility: DPMI 0.9+\n Expects: AX 1687H (INT 2fH MUX ID and subfn number)\n ──────────────────────────────────────────────────────────────────\n Returns: AX 0000h = successful\n else = no DPMI host present\n BX flags: bit 0: 0=32-bit programs are not supported\n 1=32-bit programs are supported\n bits 1-15: not used\n CL processor type: 02H = 80286\n 03H = 80386\n 04H = 80486\n 05H = Pentium\n >5 = reserved for future Intel CPUs\n DX DPMI major + minor version number (e.g., 010aH=1.10)\n SI number of 16-byte pares needed for DPMI host private\n ES:DI entry address to call to enter Protected Mode\n ──────────────────────────────────────────────────────────────────\n Info: DPMI clients are loaded in real mode and may use this call to\n prepare for switching into protected mode.\n\n SI on return, this is an amount of real-mode memory, in 16-byte\n paragraphs, that you must supply when you process the switch (see\n below). It might be 0000H, indicating no memory needed.\n\n ES:DI on return, this is the Entry Address you must call (via a\n FAR CALL) in order to switch to protected mode. The calling\n parameters are:\n\n Entry:\n AX= 0000H = you'll be running as a 16-bit application\n 0001H = you'll be running as a 32-bit application\n ES= the segment of the memory you're be supplying to DPMI host.\n If SI was 0 after INT 2fH 1687H, then ES is ignored.\n Return:\n CF set (CY) if switch to protected mode failed\n (and AX is a DPMI Error Code)\n CS = selector for your code segment (64K limit)\n SS = selector for your stack segment (64K limit)\n DS = selector for your data segment (64K limit)\n ES = selector for your program's PSP (256-byte limit)\n FS = 0 (on 80386+ CPUs)\n GS = 0 (on 80386+ CPUs)\n\n Also, a selector has been prepared so that PSP:002e points to\n your copy of the DOS Environment.\n\n Note: To exit from protected mode, simply terminate your program via\n the standard DOS fn 4cH.\n\nSee Also: DPMI API\n INT 2fH 16xxH (Enh386 Windows Services & Notifications)\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "574-int_2fh_168ah__get_vendor_specific_dpmi_api_entry_address.html",
    "t": "INT 2fH 168AH: Get Vendor-Specific DPMI API Entry Address",
    "b": "Compatibility: DPMI 0.9+\n Expects: AX 168AH\n DS:SI address of ASCIIZ▲ string identifying the vendor\n ──────────────────────────────────────────────────────────────────\n Returns: AX 0000h = successful\n else = no such vendor API or not in Protected Mode\n ES:DI vendor-specific API Entry Address\n ──────────────────────────────────────────────────────────────────\n Info: A DPMI client may use this fn to get an address that will provide\n access to vendor-specific extensions of the DPMI specification.\n\n DS:(E)SI the string at this address must match exactly with the vendor ID.\n The string comparison is case-sensitive.\n\n ES:(E)DI on return, this is the address supplied by the vendor. Access it\n via a FAR CALL. Registers and other calling conventions are set\n by the vendor.\n\n Note: You must be in protected mode to call this.\n\nSee Also: DPMI API\n INT 2fH 16xxH (Enh386 Windows Services & Notifications)\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "575-int_31h_0000h__allocate_ldt_descriptors.html",
    "t": "INT 31H 0000H: Allocate LDT Descriptors",
    "b": "Compatibility: DPMI 0.9+\n Expects: AX 0000H\n CX desired number of descriptors to allocate\n ──────────────────────────────────────────────────────────────────\n Returns: CF NC (clear) if successful; else AX = DPMI Error Code\n AX base selector (if successful)\n ──────────────────────────────────────────────────────────────────\n Info: Allocates one or more descriptors in the LDT.\n\n If CX > 1, then AX returns with the base selector of a series.\n Use INT 31H 0000H to obtain the increment used to calculate the\n other selectors.\n\n This does not allocate memory. Use fns such as INT 31H 0501H and\n INT 31H 0504H to obtain memory before setting a descriptor to\n point to it.\n\n Use fns such as INT 31H 0002H (segment to descriptor) and\n INT 31H 0007H (set segment base address) to prepare the selector\n for use.\n\nSee Also: DPMI API\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "576-int_31h_0001h__free_ldt_descriptor.html",
    "t": "INT 31H 0001H: Free LDT Descriptor",
    "b": "Compatibility: DPMI 0.9+\n Expects: AX 0001H\n BX selector for the descriptor to be freed\n ──────────────────────────────────────────────────────────────────\n Returns: CF NC (clear) if successful; else AX = DPMI Error Code\n ──────────────────────────────────────────────────────────────────\n Info: Frees the entry in the LDT that corresponds to the specified\n selector in BX.\n\n This does not free any memory allocation associated with the\n selector.\n\nSee Also: DPMI API\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "577-int_31h_0002h__segment_to_descriptor.html",
    "t": "INT 31H 0002H: Segment to Descriptor",
    "b": "Compatibility: DPMI 0.9+\n Expects: AX 0002H\n BX real-mode segment address\n ──────────────────────────────────────────────────────────────────\n Returns: CF NC (clear) if successful; else AX = DPMI Error Code\n AX selector to access 64K starting at the real-mode paragraph\n ──────────────────────────────────────────────────────────────────\n Info: Maps a real-mode segment address to a protected-mode selector.\n\n Applications can use this in order to access segments such as\n 0040:xxxx (BIOS Data Area) and b800:xxxx (CGA/text-mode memory).\n\n You may prefer to use INT 31H 0000H to allocate a descriptor and\n then use INT 31H 0007H to point it to various real-mode\n locations.\n\nSee Also: DPMI API\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "578-int_31h_0003h__query_selector_increment_value.html",
    "t": "INT 31H 0003H: Query Selector Increment Value",
    "b": "Compatibility: DPMI 0.9+\n Expects: AX 0003H\n ──────────────────────────────────────────────────────────────────\n Returns: CF NC (clear) always successful\n AX selector increment value\n ──────────────────────────────────────────────────────────────────\n Info: When the host allocates a consecutive block of descriptors via\n INT 31H 0000H (allocate LDT descriptors) or INT 31H 0100H\n (allocate DOS memory block), it returns only a single, base\n selector.\n\n The value returned in AX can be added to that base selector (or\n others in the series) in order to obtain the valid value of the\n next selector in the series.\n\nSee Also: DPMI API\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "579-int_31h_0006h__query_segment_base_address.html",
    "t": "INT 31H 0006H: Query Segment Base Address",
    "b": "Compatibility: DPMI 0.9+\n Expects: AX 0006H\n BX selector\n ──────────────────────────────────────────────────────────────────\n Returns: CF NC (clear) if successful; else AX = DPMI Error Code\n CX:DX 32-bit linear base address of the segment\n ──────────────────────────────────────────────────────────────────\n Info: This obtains the 32-bit linear base address of the segment\n identified by the selector in BX.\n\n Use the LSL opcode to query the limit.\n\nSee Also: DPMI API\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "580-int_31h_0007h__set_segment_base_address.html",
    "t": "INT 31H 0007H: Set Segment Base Address",
    "b": "Compatibility: DPMI 0.9+\n Expects: AX 0007H\n BX selector\n CX:DX 32-bit linear base address to apply to the selector\n ──────────────────────────────────────────────────────────────────\n Returns: CF NC (clear) if successful; else AX = DPMI Error Code\n ──────────────────────────────────────────────────────────────────\n Info: This changes the base address for a descriptor in the LDT. It\n makes selector BX refer to a different location in physical\n memory.\n\nSee Also: DPMI API\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "581-int_31h_0008h__set_segment_limit.html",
    "t": "INT 31H 0008H: Set Segment Limit",
    "b": "Compatibility: DPMI 0.9+\n Expects: AX 0008H\n BX selector\n CX:DX 32-bit size of the segment -1\n ──────────────────────────────────────────────────────────────────\n Returns: CF NC (clear) if successful; else AX = DPMI Error Code\n ──────────────────────────────────────────────────────────────────\n Info: This changes the limit field of the descriptor in the LDT.\n\n CX:DX if the requested size is > 1MB, then it must be page-aligned (an\n even multiple of 4096--the low 12-bits of DX must be 0).\n\n Note: There is no corresponding fn to query the limit. Use the LSL\n opcode to do so. If the limit might be larger than 64K, you must\n use the 32-bit version of LSL.\n\nSee Also: DPMI API\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "582-int_31h_0009h__set_descriptor_access_rights.html",
    "t": "INT 31H 0009H: Set Descriptor Access Rights",
    "b": "Compatibility: DPMI 0.9+\n Expects: AX 0009H\n BX selector\n CL access rights/type byte\n CH (386+) extended access rights/type byte\n ──────────────────────────────────────────────────────────────────\n Returns: CF NC (clear) if successful; else AX = DPMI Error Code\n ──────────────────────────────────────────────────────────────────\n Info: This modifies the access rights and/or type of the LDT descriptor\n identified by the selector in BX.\n\n CL is in this form:\n ┌7┬6┬5┬4┬3┬2┬1┬0┐\n │p│dpl│1│c│x│w│a│\n └╥┴─┴─┴╥┴╥┴╥┴╥┴╥┘ bit mask\n ║ ╚╦╝ ║ ║ ║ ║ ╚═► 0: 01H 1=accessed; 0=not accessed\n ║ ║ ║ ║ ║ ╚═══► 1: 02H 1=read/write (must be 0 in code segs)\n ║ ║ ║ ║ ╚═════► 2: 04H 1=expand down; 0=expand up\n ║ ║ ║ ╚═══════► 3: 08H 1=code seg; 0=data seg\n ║ ║ ╚═════════► 4: 10H must be 1\n ║ ╚════════════►5-6: 60H CPL (protection level) must=caller\n ╚═══════════════► 7: 80H 1=present; 0=absent\n\n CH is ignored on 80286. On 386+, its bits mean:\n ┌7┬6┬5┬4┬3┬2┬1┬0┐\n │g│b│0│v│0 0 0 0│\n └╥┴╥┴╥┴╥┴─┴─┴─┴─┘ bit mask\n ║ ║ ║ ║ ╚═════╩═►0-3: 0fH ignored\n ║ ║ ║ ╚═════════► 4: 10H AVL can be 0 or 1\n ║ ║ ╚═══════════► 5: 20H must be 0\n ║ ╚═════════════► 6: 40H 1=default to 32-bit; 0=default to 16\n ╚═══════════════► 7: 80H 1=page granularity; 0=byte granularity\n\n Note: There is no corresponding fn to query the current settings. Use\n the LAR opcode to do so.\n\nSee Also: DPMI API\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "583-int_31h_000ah__create_alias_descriptor.html",
    "t": "INT 31H 000aH: Create Alias Descriptor",
    "b": "Compatibility: DPMI 0.9+\n Expects: AX 000aH\n BX selector\n ──────────────────────────────────────────────────────────────────\n Returns: CF NC (clear) if successful; else AX = DPMI Error Code\n AX data selector; alias of BX\n ──────────────────────────────────────────────────────────────────\n Info: This creates a new data descriptor in the LDT which has the same\n base and limit as the selector in BX.\n\n The original selector can be for code or data; the returned\n selector is for data.\n\n Note: The two selectors are not kept synchronized; a change to one does\n not affect the other.\n\nSee Also: DPMI API\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "584-int_31h_000bh__query_descriptor.html",
    "t": "INT 31H 000bH: Query Descriptor",
    "b": "Compatibility: DPMI 0.9+\n Expects: AX 000bH\n BX selector\n ES:DI (or ES:EDI) sel:off of 8-byte buffer to receive data\n ──────────────────────────────────────────────────────────────────\n Returns: CF NC (clear) if successful; else AX = DPMI Error Code\n ES:DI (or ES:EDI) buffer contains LDT entry\n ──────────────────────────────────────────────────────────────────\n Info: This copies an LDT entry into a local buffer.\n\n Note: Use INT 31H 000eH to get multiple entries.\n\nSee Also: DPMI API\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "585-int_31h_000ch__set_descriptor.html",
    "t": "INT 31H 000cH: Set Descriptor",
    "b": "Compatibility: DPMI 0.9+\n Expects: AX 000cH\n BX selector\n ES:DI (or ES:EDI) sel:off of 8-byte buffer containing LDT entry\n ──────────────────────────────────────────────────────────────────\n Returns: CF NC (clear) if successful; else AX = DPMI Error Code\n ──────────────────────────────────────────────────────────────────\n Info: This fills an LDT entry with information you supply.\n\n Note: Use INT 31H 000fH to set multiple entries.\n\nSee Also: DPMI API\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "586-int_31h_000dh__allocate_specific_descriptor.html",
    "t": "INT 31H 000dH: Allocate Specific Descriptor",
    "b": "Compatibility: DPMI 0.9+\n Expects: AX 000dH\n BX selector\n ──────────────────────────────────────────────────────────────────\n Returns: CF NC (clear) if successful; else AX = DPMI Error Code\n AX ?selector of allocated descriptor?\n ──────────────────────────────────────────────────────────────────\n Info: This allocates one of the first 16 entries in the LDT. Selector\n values 04H-7cH are reserved for this purpose.\n\n Note: The DPMI spec does not identify AX as a return value; so I'm\n guessing here. Also, It's not clear why you would want to\n allocate one of these puppies (perhaps to make, say, 0040H work\n as a descriptor to 0040:0000).\n\nSee Also: DPMI API\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "587-int_31h_000eh__query_multiple_descriptors.html",
    "t": "INT 31H 000eH: Query Multiple Descriptors",
    "b": "Compatibility: DPMI 0.9+\n Expects: AX 000eH\n CX number of descriptors to copy\n ES:DI (or ES:EDI) sel:off of buffer describing which selectors you\n want and space to receive data\n ──────────────────────────────────────────────────────────────────\n Returns: CF NC (clear) if successful;\n else AX = DPMI Error Code\n CX = number of entries copied\n ES:DI (or ES:EDI) buffer contains selectors and LDT entries\n ──────────────────────────────────────────────────────────────────\n Info: This copies a series of LDT entries into a local buffer. You\n must pre-fill the buffer with the desired selectors, with 8-byte\n gaps between each:\n\n The buffer is be formatted as:\n\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 2 wSel1 set by caller\n +2 8 rDesc1 filled by host\n +0aH 2 wSel2 set by caller\n +0cH 8 rDesc2 filled by host\n .\n :\n\n Note: If the call fails due to an invalid selector, the host will\n return CX as the number of valid selectors that it found before\n encountering the bad apple.\n\nSee Also: DPMI API\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "588-int_31h_000fh__set_multiple_descriptors.html",
    "t": "INT 31H 000fH: Set Multiple Descriptors",
    "b": "Compatibility: DPMI 1.0+\n Expects: AX 000fH\n CX number of descriptors to set\n ES:DI (or ES:EDI) sel:off of buffer containing a series of 2-byte\n selectors and 8-byte LDT entries\n ──────────────────────────────────────────────────────────────────\n Returns: CF NC (clear) if successful;\n else AX = DPMI Error Code\n CX = number of entries copied\n ──────────────────────────────────────────────────────────────────\n Info: This fills one or more LDT entries with data you supply.\n\n The buffer must be formatted as:\n\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 2 wSel1 valid selector to define\n +2 8 rDesc1 descriptor for that selector\n +0aH 2 wSel2 valid selector to define\n +0cH 8 rDesc2 descriptor for that selector\n .\n :\n\n Note: If the call fails due to an invalid selector, the host will\n return CX as the number of valid selectors that it found before\n encountering the bad apple.\n\nSee Also: DPMI API\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "589-int_31h_0100h__allocate_dos_memory_block.html",
    "t": "INT 31H 0100H: Allocate DOS Memory Block",
    "b": "Compatibility: DPMI 1.0+\n Expects: AX 0100H\n BX size of allocation, in 16-byte paragraphs\n ──────────────────────────────────────────────────────────────────\n Returns: CF NC (clear) if successful\n else AX = DPMI Error Code\n BX = size of largest available block, in 16-byte pares\n AX real-mode segment base address of allocated block\n DX selector for allocated block\n ──────────────────────────────────────────────────────────────────\n Info: This allocates a block of memory from the DOS pool (i.e., memory\n below the 1MB mark). It returns both a real-mode segment address\n and a protected-mode selector.\n\n This is typically used by programs which wish to share memory\n between a real-mode app and a protected mode app.\n\n BX if this is > 1000H (a request for more than 64K), and if the\n caller is in 16-bit mode, then the value returned in DX is\n actually a base selector (the first in a series). Use\n INT 31H 0003H to see how much to add to this selector to access\n the data above 64K.\n\n Each selector will have a limit of 64K except the last one whose\n limit is set to cover the remaining area.\n\n Note: You must not modify the LDT descriptor entry(s) represented by\n the returned selector(s). Use INT 31H 0101H to deallocate or use\n INT 31H 0102H to resize.\n\nSee Also: DPMI API\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "590-int_31h_0101h__free_dos_memory_block.html",
    "t": "INT 31H 0101H: Free DOS Memory Block",
    "b": "Compatibility: DPMI 1.0+\n Expects: AX 0101H\n DX base selector of selector block to free\n ──────────────────────────────────────────────────────────────────\n Returns: CF NC (clear) if successful; else AX = DPMI Error Code\n ──────────────────────────────────────────────────────────────────\n Info: This frees an allocation obtained via INT 31H 0100H (allocate DOS\n memory block). It also frees up the LDT descriptor(s) created by\n that call.\n\nSee Also: DPMI API\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "591-int_31h_0102h__resize_dos_memory_block.html",
    "t": "INT 31H 0102H: Resize DOS Memory Block",
    "b": "Compatibility: DPMI 1.0+\n Expects: AX 0102H\n BX desired new block size, in 16-byte paragraphs\n DX base selector of selector block to free\n ──────────────────────────────────────────────────────────────────\n Returns: CF NC (clear) if successful\n else AX = DPMI Error Code\n BX = size of largest available block, in 16-byte pares\n ──────────────────────────────────────────────────────────────────\n Info: Changes the size of a memory block allocated via INT 31H 0100H\n (allocate DOS memory block).\n\n Grow requests may fail when DOS memory is fragmented or when\n there are no contiguous LDT entries available.\n\n Note: You must not modify the LDT descriptor entry(s) represented by\n these DOS-block selectors. Use INT 31H 0101H to deallocate.\n\nSee Also: DPMI API\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "592-int_31h_0200h__query_real_mode_interrupt_vector.html",
    "t": "INT 31H 0200H: Query Real-mode Interrupt Vector",
    "b": "Compatibility: DPMI 0.9+\n Expects: AX 0200H\n BL interrupt number\n ──────────────────────────────────────────────────────────────────\n Returns: CF NC (clear) if successful; else AX = DPMI Error Code\n CX:DX segment:offset of requested vector\n ──────────────────────────────────────────────────────────────────\n Info: Obtains the address of a real-mode interrupt handler. The value\n return in CX is a real-mode segment address (not a selector).\n\nSee Also: DPMI API\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "593-int_31h_0201h__set_real_mode_interrupt_vector.html",
    "t": "INT 31H 0201H: Set Real-mode Interrupt Vector",
    "b": "Compatibility: DPMI 0.9+\n Expects: AX 0201H\n BL interrupt number\n CX:DX real-mode segment:offset to use for the vector\n ──────────────────────────────────────────────────────────────────\n Returns: CF NC (clear) if successful; else AX = DPMI Error Code\n ──────────────────────────────────────────────────────────────────\n Info: Changes the address of a real-mode interrupt handler.\n\n The value return in CX must be a real-mode segment address (not a\n selector). Thus, the real-mode interrupt handler must either\n reside in DOS memory (below 1MB) or you must allocate a real-mode\n callback address. See INT 31H 0100H (allocate dos mem) and\n INT 31H 0303H (allocate real-mode callback address).\n\n When hooking hardware interrupt handlers, the memory that the\n handler uses must be locked. See INT 31H 0600H (lock linear\n region).\n\nSee Also: DPMI API\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "594-int_31h_0202h__query_processor_exception_handler_vector.html",
    "t": "INT 31H 0202H: Query Processor Exception Handler Vector",
    "b": "Compatibility: DPMI 0.9+\n Expects: AX 0202H\n BL exception number (00h-ffH)\n ──────────────────────────────────────────────────────────────────\n Returns: CF NC (clear) if successful; else AX = DPMI Error Code\n CX:DX (or CX:EDX) selector:offset of exception handler\n ──────────────────────────────────────────────────────────────────\n Info: Obtains the protect-mode address of a CPU exception handler.\n\n Note: When using a DPMI 1.0 host, use INT 31H 0210H and INT 31H 0211H\n rather than this 0.9-spec fn.\n\nSee Also: DPMI API\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "595-int_31h_0203h__set_processor_exception_handler_vector.html",
    "t": "INT 31H 0203H: Set Processor Exception Handler Vector",
    "b": "Compatibility: DPMI 0.9+\n Expects: AX 0203H\n BL exception number (00h-ffH)\n CX:DX (or CX:EDX) selector:offset of exception handler\n ──────────────────────────────────────────────────────────────────\n Returns: CF NC (clear) if successful; else AX = DPMI Error Code\n ──────────────────────────────────────────────────────────────────\n Info: Sets the vector for the code to be executed during a CPU\n exception.\n\n Note: When using a DPMI 1.0 host, use INT 31H 0212H and INT 31H 0213H\n rather than this 0.9-spec fn.\n\nSee Also: DPMI API\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "596-int_31h_0204h__query_protected_mode_interrupt_vector.html",
    "t": "INT 31H 0204H: Query Protected-Mode Interrupt Vector",
    "b": "Compatibility: DPMI 0.9+\n Expects: AX 0204H\n BL interrupt number\n ──────────────────────────────────────────────────────────────────\n Returns: CF NC (clear) if successful; else AX = DPMI Error Code\n CX:DX (or CX:EDX) selector:offset of requested vector\n ──────────────────────────────────────────────────────────────────\n Info: Obtains the address of the current protected-mode interrupt\n handler for the specified interrupt. The value return in CX is a\n protected-mode selector.\n\nSee Also: DPMI API\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "597-int_31h_0205h__set_protected_mode_interrupt_vector.html",
    "t": "INT 31H 0205H: Set Protected-mode Interrupt Vector",
    "b": "Compatibility: DPMI 0.9+\n Expects: AX 0201H\n BL interrupt number\n CX:DX (or CX:EDX) selector:offset of interrupt-handler\n ──────────────────────────────────────────────────────────────────\n Returns: CF NC (clear) if successful; else AX = DPMI Error Code\n ──────────────────────────────────────────────────────────────────\n Info: Changes the address of a protected-mode interrupt handler.\n\n The value return in CX must be a protected mode selector (not a\n real-mode segment address).\n\nSee Also: DPMI API\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "598-int_31h_0210h__query_exception_handler_vector__prot__mode_.html",
    "t": "INT 31H 0210H: Query Exception Handler Vector (Prot. Mode)",
    "b": "Compatibility: DPMI 0.9+\n Expects: AX 0210H\n BL exception number (00h-ffH)\n ──────────────────────────────────────────────────────────────────\n Returns: CF NC (clear) if successful; else AX = DPMI Error Code\n CX:DX (or CX:EDX) selector:offset of exception handler\n ──────────────────────────────────────────────────────────────────\n Info: Obtains the protect-mode address of a CPU exception handler for\n the calling client.\n\nSee Also: DPMI API\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "599-int_31h_0211h__query_exception_handler_vector__real_mode_.html",
    "t": "INT 31H 0211H: Query Exception Handler Vector (Real Mode)",
    "b": "Compatibility: DPMI 0.9+\n Expects: AX 0211H\n BL exception number (00h-ffH)\n ──────────────────────────────────────────────────────────────────\n Returns: CF NC (clear) if successful; else AX = DPMI Error Code\n CX:DX (or CX:EDX) selector:offset of exception handler\n ──────────────────────────────────────────────────────────────────\n Info: Obtains the address of the client's protected-mode handler for\n the specified CPU exception (used when that exception occurs\n while the processor is in real mode).\n\n Note that CX is a protected mode selector. When a CPU exception\n occurs while in real mode, the host switches to protected mode\n and calls this address.\n\nSee Also: DPMI API\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "600-int_31h_0212h__set_exception_handler_vector__prot__mode_.html",
    "t": "INT 31H 0212H: Set Exception Handler Vector (Prot. Mode)",
    "b": "Compatibility: DPMI 0.9+\n Expects: AX 0212H\n BL exception number (00h-ffH)\n CX:DX (or CX:EDX) selector:offset of exception handler\n ──────────────────────────────────────────────────────────────────\n Returns: CF NC (clear) if successful; else AX = DPMI Error Code\n ──────────────────────────────────────────────────────────────────\n Info: Sets the address to handle a specified CPU exception, when that\n exception occurs while the CPU is in protected mode.\n\nSee Also: DPMI API\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "601-int_31h_0213h__set_exception_handler_vector__real_mode_.html",
    "t": "INT 31H 0213H: Set Exception Handler Vector (Real Mode)",
    "b": "Compatibility: DPMI 0.9+\n Expects: AX 0213H\n BL exception number (00h-ffH)\n CX:DX (or CX:EDX) selector:offset of exception handler\n ──────────────────────────────────────────────────────────────────\n Returns: CF NC (clear) if successful; else AX = DPMI Error Code\n ──────────────────────────────────────────────────────────────────\n Info: Sets the address to handle a specified CPU exception, when that\n exception occurs while the CPU is in real mode.\n\n Note that CX is a protected mode selector. When a CPU exception\n occurs while in real-mode, the host switches to protected mode\n and calls this address.\n\nSee Also: DPMI API\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "602-int_31h_0300h__simulate_real_mode_interrupt.html",
    "t": "INT 31H 0300H: Simulate Real Mode Interrupt",
    "b": "Compatibility: DPMI 0.9+\n Expects: AX 0300H\n BL interrupt number\n BH flags: must be 00H\n CX number of words to copy to the real-mode stack\n ES:DI (or ES:EDI) address of a DpmiRegRec structure.\n ──────────────────────────────────────────────────────────────────\n Returns: CF NC (clear) if successful; else AX = DPMI Error Code\n ES:DI (or ES:EDI) the DpmiRegRec structure contains returned data\n ──────────────────────────────────────────────────────────────────\n Info: Simulates a real-mode interrupt.\n\n You may use this instead of the INT nn opcode to access\n DOS Functions, Interrupts and BIOS Services, etc. The host\n switches to real mode, loads the registers, performs INT [BL],\n switches back to protected mode, copies the returned registers\n into the caller's structure and returns the status.\n\n ES:DI (or ES:EDI, when in 32-bit mode) points to a DpmiRegRec structure\n that sets up the registers on entry and will contain the modified\n register values upon return.\n\n CX is used when you are expected to push data onto the stack before\n invoking the interrupt (not a common scenario). When CX is non-\n zero, the host copies that many 2-byte words from the protected\n mode onto the real-mode stack before invoking the interrupt.\n\n Note: The DPMI host automatically handles all INT nn opcodes to provide\n BIOS and DOS services transparently. I'm not sure why you would\n use this fn.\n\nSee Also: DPMI API\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "603-int_31h_0301h__simulate_real_mode_far_call.html",
    "t": "INT 31H 0301H: Simulate Real Mode FAR CALL",
    "b": "Compatibility: DPMI 0.9+\n Expects: AX 0301H\n BH flags: must be 00H\n CX number of words to copy to the real-mode stack\n ES:DI (or ES:EDI) address of a DpmiRegRec structure.\n ──────────────────────────────────────────────────────────────────\n Returns: CF NC (clear) if successful; else AX = DPMI Error Code\n ES:DI (or ES:EDI) structure contains returned data\n ──────────────────────────────────────────────────────────────────\n Info: Simulates a FAR CALL to a real-mode procedure. The called\n procedure must return via RETF.\n\n The DPMI host switches to real mode, loads the registers,\n performs a FAR CALL to the CS:IP in the register structure,\n switches back to protected mode, copies the returned registers\n into the caller's structure and returns the status.\n\n ES:DI (or ES:EDI, when in 32-bit mode) points to a DpmiRegRec structure\n that sets up the registers on entry and will contain the modified\n register values upon return.\n\n The address of the far procedure must be in the wRegCS and wRegIP\n fields of the DpmiRegRec structure.\n\n CX is used when you are expected to push data onto the stack before\n calling int procedure. When CX is non-zero, the host copies that\n many 2-byte words from the protected mode onto the real-mode\n stack before invoking the interrupt.\n\nSee Also: DPMI API\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "604-int_31h_0302h__simulate_real_mode_call_for_iret.html",
    "t": "INT 31H 0302H: Simulate Real Mode CALL for IRET",
    "b": "Compatibility: DPMI 0.9+\n Expects: AX 0302H\n BH flags: must be 00H\n CX number of words to copy to the real-mode stack\n ES:DI (or ES:EDI) address of a DpmiRegRec structure.\n ──────────────────────────────────────────────────────────────────\n Returns: CF NC (clear) if successful; else AX = DPMI Error Code\n ES:DI (or ES:EDI) structure contains returned data\n ──────────────────────────────────────────────────────────────────\n Info: Simulates a FAR CALL with flags pushed onto the stack to a real-\n mode procedure. The called procedure must return via IRET.\n\n This works like INT 31H 0301H (which see) except that the DPMI\n host pushes the flags register before calling the procedure.\n\n You might use this when chaining a real-mode interrupt handler.\n It lets you call the original vector.\n\nSee Also: DPMI API\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "605-int_31h_0303h__allocate_real_mode_callback_address.html",
    "t": "INT 31H 0303H: Allocate Real-mode Callback Address",
    "b": "Compatibility: DPMI 0.9+\n Expects: AX 0303H\n DS:SI (or DS:ESI) sel:off of protected-mode procedure to call\n ES:DI (or DS:ESI) sel:off of buffer to hold a DpmiRegRec structure\n ──────────────────────────────────────────────────────────────────\n Returns: CF NC (clear) if successful; else AX = DPMI Error Code\n CX:DX segment:offset of real-mode callback\n ──────────────────────────────────────────────────────────────────\n Info: This obtains a segment:offset address that may be used by real-\n mode programs to execute a protected-mode procedure.\n\n This provides a means for real-mode programs, such as device\n drivers, interrupt handlers, or TSRs, to access services supplied\n by a protected-mode program or to notify that program of events\n which occur in real mode.\n\n The DPMI client uses this fn to obtain an address, then uses some\n other mechanism to pass that address to real-mode programs.\n Then, when the real-mode program call that address, the DPMI host\n fills the DpmiRegRec with the current registers, switches to\n protected mode, and then calls the protected mode procedure.\n\n DS:SI (or DS:ESI, when in 32-bit mode) is the address of a protected-\n mode procedure. It must return via an IRET, with the data in the\n DpmiRegRec at ES:(E)DI containing any return information and the\n correct CS:IP to resume control must be in the structure. That\n means you've got to dig through the stack in order to prepare for\n the return.\n\n ES:DI (or ES:EDI, when in 32-bit mode) points to a DpmiRegRec\n structure. It may be empty when you use this fn. The DPMI host\n fills it with data (as passed from the real-mode app) when it\n performs the callback.\n\n It is important to note that the segment values that will appear\n in the structure are real-mode segments, not protected mode\n selectors.\n\n Note: There is a limited number of these callbacks available per client\n (but at least 16). Be sure to use INT 31H 0304H (free real-mode\n callback address) when you no longer need it.\n\nSee Also: DPMI API\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "606-int_31h_0304h__free_real_mode_callback_address.html",
    "t": "INT 31H 0304H: Free Real-mode Callback Address",
    "b": "Compatibility: DPMI 0.9+\n Expects: AX 0304H\n CX:DX segment:offset of real-mode callback to free\n ──────────────────────────────────────────────────────────────────\n Returns: CF NC (clear) if successful; else AX = DPMI Error Code\n ──────────────────────────────────────────────────────────────────\n Info: This frees up the system resources consumed when a real-mode\n callback is allocated and it makes that callback address invalid.\n\n This is part of the DPMI system that allows a real-mode program\n to access services to otherwise communicate with a protected mode\n application.\n\n See INT 31H 0303H (allocate real-mode callback address) for\n related details.\n\nSee Also: DPMI API\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "607-int_31h_0305h__query_state_save_restore_addresses.html",
    "t": "INT 31H 0305H: Query State Save/Restore Addresses",
    "b": "Compatibility: DPMI 0.9+\n Expects: AX 0305H\n ──────────────────────────────────────────────────────────────────\n Returns: CF NC (this fn always succeeds)\n AX size of buffer, in bytes, required to save the state\n BX:CX real-mode address of routine to save/restore state\n SI:DI (or SI:EDI) protected mode addr of save/restore routine\n ──────────────────────────────────────────────────────────────────\n Info: This is used by applications which perform low-level mode\n switching. It obtains the addresses of the DPMI routine which\n saves and restores the task state.\n\n See INT 31H 0306H (query raw mode-switch address) for related\n info.\n\n AX When you perform the call the \"save/restore\" state routine, you\n will need to supply this much memory (in bytes).\n\n BX:CX this address can be called by real-mode applications to save the\n state of a protected-mode task's registers, stack, etc.\n\n SI:(E)DI this address can be called by protected-mode applications to save\n the state of a real-mode task's registers, stack, etc.\n\n Both of these routines are accessed via FAR CALL and expect:\n\n AL = requested action: 00H = save the state\n 01H = restore the state\n ES:(E)DI = address of save/restore buffer\n\nSee Also: DPMI API\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "608-int_31h_0306h__query_raw_mode_switch_address.html",
    "t": "INT 31H 0306H: Query Raw Mode-Switch Address",
    "b": "Compatibility: DPMI 0.9+\n Expects: AX 0306H\n ──────────────────────────────────────────────────────────────────\n Returns: CF NC (this fn always succeeds)\n BX:CX real-mode address of routine to switch to protected mode\n SI:DI (or SI:EDI) prot mode addr of routine to switch to real mode\n ──────────────────────────────────────────────────────────────────\n Info: This is used by applications which perform low-level mode\n switching. It obtains the addresses of the DPMI routine which\n switches into or out of real mode.\n\n See INT 31H 0305H for a way to save and restore the state of a\n task when you perform raw mode-switching.\n\n BX:CX this address can be called by real-mode applications to switch to\n protected mode.\n\n SI:(E)DI this address can be called by protected-mode applications to\n switch to real mode.\n\n Both of these routines are accessed via FAR JMP and expect:\n\n AX = new DS\n CX = new ES\n DX = new SS\n (E)BX = new (E)SP\n SI = new CS\n (E)DI = new (E)IP\n\n The host switches modes, and sets DS, ES, SS, and (E)SP, and\n jumps to SI:(E)DI.\n\n Notes: ■ It is your responsibility to save and restore the CPU state\n (see INT 31H 0305H) when switching modes.\n\n ■ You will find it easier to use fns such as INT 31H 0300H to\n force mode switching, since they handle the overhead.\n\nSee Also: DPMI API\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "609-int_31h_0400h__query_dpmi_version.html",
    "t": "INT 31H 0400H: Query DPMI Version",
    "b": "Compatibility: DPMI 0.9+\n Expects: AX 0400H\n ──────────────────────────────────────────────────────────────────\n Returns: CF NC (this fn always succeeds)\n AH DPMI major version\n AL DPMI minor version; e.g AX=030aH means version 3.10\n BX info flags (see below)\n CL processor type: 02H = 80286\n 03H = 80386\n 04H = 80486\n 05H = Pentium\n >5 = reserved for future Intel CPUs\n DH current value of virtual master PIC base interrupt\n DL current value of virtual slave PIC base interrupt\n ──────────────────────────────────────────────────────────────────\n Info: This obtains the DPMI version number supported by the DPMI host\n and some other info.\n\n BX contains some relevant bit flags:\n 1 1\n ┌5┬4┬ - ┬3┬2┬1┬0┐\n │0 0...0 0│v│r│b│\n └─┴─ - ─┴─┴╥┴╥┴╥┘ bit mask\n ║ ║ ╚► 0: 0001H 1=host is 32-bit implementation\n ║ ║ 0=host is 16-bit\n ║ ╚══► 1: 0002H 1=returns to real mode for ints\n ║ 0=returns to Virtual 86 mode for ints\n ╚════► 2: 0004H 1=virtual memory supported; 0=not\n\n Note: ■ See INT 2fH 1687H and INT 31H 0401H for related info.\n\n ■ Use INT 31H 0e00H to check for the presence and status of a\n numeric coprocessor.\n\nSee Also: DPMI API\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "610-int_31h_0401h__query_dpmi_capabilities.html",
    "t": "INT 31H 0401H: Query DPMI Capabilities",
    "b": "Compatibility: DPMI 1.0+\n Expects: AX 0400H\n ──────────────────────────────────────────────────────────────────\n Returns: CF NC (this fn always succeeds with DPMI 1.0+)\n AX capability flags (see below)\n ES:DI (or ES:EDI) selector:offset of host version info\n ──────────────────────────────────────────────────────────────────\n Info: This obtains information about the capabilities supported by the\n DPMI host.\n\n AX contains bit flags:\n 1\n ┌5┬ - ┬7┬6┬5┬4┬3┬2┬1┬0┐\n │0 ... 0│0│w│z│c│d│x│a│\n └─┴ - ┴─┴╥┴╥┴╥┴╥┴╥┴╥┴╥┘bit mask\n ║ ║ ║ ║ ║ ║ ╚► 0: 0001H 1=page accessed/dirty supported\n ║ ║ ║ ║ ║ ╚══► 1: 0002H 1=excptn. restartability suprtd\n ║ ║ ║ ║ ╚════► 2: 0004H 1=conv. mem mapping supported\n ║ ║ ║ ╚══════► 2: 0008H 1=device mapping supported\n ║ ║ ╚════════► 2: 0010H 1=demand zero-fill supported\n ║ ╚══════════► 2: 0020H 1=write-protect client supported\n ╚════════════► 2: 0040H 1=write-protect host supported\n\n ES:(E)DI on return, points to a 128-byte buffer containing information\n about the DPMI host itself. It is formatted as:\n\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 1 bVerMaj host major version #\n +1 1 vVerMin host minor version #\n +2 n szName ASCIIZ▲ host name\n 2+n ? filler to end of record\n 128 size of this structure\n\n Note: See INT 2fH 1687H and INT 31H 0400H for related info.\n\nSee Also: DPMI API\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "611-int_31h_0500h__query_free_memory_information.html",
    "t": "INT 31H 0500H: Query Free Memory Information",
    "b": "Compatibility: DPMI 0.9+\n Expects: AX 0500H\n ES:DI (or ES:EDI) sel:off of 48-byte buffer to receive info\n ──────────────────────────────────────────────────────────────────\n Returns: CF NC (this fn always succeeds)\n ES:DI buffer contains returned info\n ──────────────────────────────────────────────────────────────────\n Info: This obtains information about available physical memory, page\n swapping space, etc.\n\n DPMI 1.0 users should use INT 31H 050bH instead.\n\n ES:(E)DI must point to a 48-byte buffer. On return, it contains:\n\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 4 lAvailBytes largest free block, in bytes\n +4 4 lUnlockedPgs pages available if left unlocked\n +8 4 lLockedPgs pages available if locked\n +0cH 4 lTotLinPgs linear address space size, in pages\n +10H 4 lTotUnlkPgs number of unlocked pages\n +14H 4 lTotFreePgs number of free pages\n +18H 4 lTotPhysPgs number of physical pages\n +1cH 4 lFreeLinPgs free linear address space, in pages\n +20H 4 lTotSwapPgs size of page swapping file, in pages\n +24H 12 res (reserved)\n 48 size of this structure\n\n Notes: ■ In multi-tasking environments, these values may change at any\n time, so they should be considered as \"advisory.\"\n\n ■ Use INT 31H 0604H to learn the size of the virtual-memory pages\n used by the host.\n\n ■ Only the first field is guaranteed to contain meaningful data.\n Other fields may contain -1 (ffffffffH) if the host doesn't\n know the true values.\n\nSee Also: DPMI API\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "612-int_31h_0501h__allocate_memory_block.html",
    "t": "INT 31H 0501H: Allocate Memory Block",
    "b": "Compatibility: DPMI 0.9+\n Expects: AX 0501H\n BX:CX size of block, in bytes (must not be 0)\n ──────────────────────────────────────────────────────────────────\n Returns: CF NC (clear) if successful; else AX = DPMI Error Code\n BX:CX linear address of allocated block\n SI:DI handle used to resize and free this block\n ──────────────────────────────────────────────────────────────────\n Info: Allocates and commits a block of linear memory.\n\n You must allocate and initialize descriptors (e.g., INT 31H 0000H\n and INT 31H 0007H) in order to access this memory.\n\nSee Also: DPMI API\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "613-int_31h_0502h__free_memory_block.html",
    "t": "INT 31H 0502H: Free Memory Block",
    "b": "Compatibility: DPMI 0.9+\n Expects: AX 0502H\n SI:DI handle of memory block to free\n ──────────────────────────────────────────────────────────────────\n Returns: CF NC (clear) if successful; else AX = DPMI Error Code\n ──────────────────────────────────────────────────────────────────\n Info: Frees a block of memory that was previously allocated via\n INT 31H 0501H or INT 31H 0504H.\n\n No descriptors are freed by this call. It is the client's\n responsibility to free descriptors that map this memory. You\n should free descriptors before freeing the memory. See\n INT 31H 0001H (free LDT descriptors).\n\nSee Also: DPMI API\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "614-int_31h_0503h__resize_memory_block.html",
    "t": "INT 31H 0503H: Resize Memory Block",
    "b": "Compatibility: DPMI 0.9+\n Expects: AX 0503H\n BX:CX new size of block, in bytes (must not be 0)\n SI:DI handle of memory block to resize\n ──────────────────────────────────────────────────────────────────\n Returns: CF NC (clear) if successful; else AX = DPMI Error Code\n BX:CX new linear address of allocated block\n SI:DI new handle used to resize and free this block\n ──────────────────────────────────────────────────────────────────\n Info: Resizes a block of memory that was previously allocated via\n INT 31H 0501H or INT 31H 0504H.\n\n It is the client's responsibility to update descriptors that map\n this memory. See, for instance, INT 31H 0007H (set segment base\n address) and INT 31H 0008H (set segment limit).\n\nSee Also: DPMI API\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "615-int_31h_0504h__allocate_linear_memory_block.html",
    "t": "INT 31H 0504H: Allocate Linear Memory Block",
    "b": "Compatibility: DPMI 1.0+\n Expects: AX 0504H\n EBX desired linear address or 0\n ECX size of block, in bytes (must not be 0)\n EDX flags: bit 0: 1=create committed pages\n 0=create uncommitted pages\n 1-31: (reserved; should be 0)\n ──────────────────────────────────────────────────────────────────\n Returns: CF NC (clear) if successful; else AX = DPMI Error Code\n EBX linear address of allocated block\n ESI handle used to resize and free this block\n ──────────────────────────────────────────────────────────────────\n Info: Allocates a block of page-aligned linear address space. The base\n address of the block may be specified by the client and the\n allocated pages may be committed or uncommitted.\n\n If EBX is 0 on entry, then the host can pick any available linear\n addresses.\n\nSee Also: DPMI API\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "616-int_31h_0505h__resize_linear_memory_block.html",
    "t": "INT 31H 0505H: Resize Linear Memory Block",
    "b": "Compatibility: DPMI 1.0+\n Expects: AX 0505H\n ESI memory block handle (as obtained via INT 31H 0504H)\n ECX new size of block, in bytes (must not be 0)\n EDX flags: bit 0: 1=create committed pages\n 0=create uncommitted pages\n bit 1: 1=descriptors require update (see Notes)\n 0=do not update descriptors\n 2-31: (reserved; should be 0)\n ──────────────────────────────────────────────────────────────────\n Returns: CF NC (clear) if successful; else AX = DPMI Error Code\n EBX new linear base address of allocated block\n ESI new handle used to resize and free this block\n ──────────────────────────────────────────────────────────────────\n Info: Changes the size of a linear memory block allocated via\n INT 31H 0504H.\n\n Notes: If bit 1 of EDX is set, then you must identify the descriptors\n which need to be updated as follows: ES:EBX is the address of a\n series of 2-byte selectors whose descriptors need updating and\n EDI is the size of the array, in words.\n\nSee Also: DPMI API\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "617-int_31h_0506h__query_page_attributes.html",
    "t": "INT 31H 0506H: Query Page Attributes",
    "b": "Compatibility: DPMI 1.0+\n Expects: AX 0506H\n ESI memory block handle (as obtained via INT 31H 0504H)\n EBX base offset of page(s) of interest\n ECX number of pages\n ES:EDX address of buffer to receive returned information\n ──────────────────────────────────────────────────────────────────\n Returns: CF NC (clear) if successful; else AX = DPMI Error Code\n ES:EDX buffer contained returned info\n ──────────────────────────────────────────────────────────────────\n Info: This obtains the information about one or more pages of linear\n memory allocated via INT 31H 0504H.\n\n ES:EDX on return, this buffer will be filled with ECX 16-bit values\n formatted as follows:\n 1\n ┌5┬ - ┬7┬6┬5┬4┬3┬2┬1┬0┐\n │0 ... 0│m│a│f│w│ type│\n └─┴ - ┴─┴╥┴╥┴╥┴╥┴─┴─┴─┘ bit mask\n ║ ║ ║ ║ ╚═══╩═►0-2: 0007H 0=uncommitted; 1=committed\n ║ ║ ║ ║ 2=mapped;3=unmapped;4-7 (res)\n ║ ║ ║ ╚═══════► 3: 0008H 1=read/write; 0=read-only\n ║ ║ ╚═════════► 4: 0010H 1=access flags are in 6-6\n ║ ╚═══════════► 5: 0020H 1=page has been accessed\n ╚═════════════► 6: 0040H 1=page has been modified\n\nSee Also: DPMI API\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "618-int_31h_0507h__set_page_attributes.html",
    "t": "INT 31H 0507H: Set Page Attributes",
    "b": "Compatibility: DPMI 1.0+\n Expects: AX 0507H\n ESI memory block handle (as obtained via INT 31H 0504H)\n EBX base offset of page(s) to modify\n ECX number of pages\n ES:EDX address of buffer containing attributes to use\n ──────────────────────────────────────────────────────────────────\n Returns: CF NC (clear) if successful\n else AX = DPMI Error Code\n ECX = number of pages that were modified\n ──────────────────────────────────────────────────────────────────\n Info: This sets attributes of one or more pages within a block of\n linear memory allocated via INT 31H 0504H.\n\n This can be used to modify read/write attributes or commit an\n uncommitted block, etc.\n\n ES:EDX on entry, this buffer contains attribute settings, as described\n under INT 31H 0506H.\n\nSee Also: DPMI API\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "619-int_31h_0508h__map_device_in_memory_block.html",
    "t": "INT 31H 0508H: Map Device in Memory Block",
    "b": "Compatibility: DPMI [optional] 1.0+\n Expects: AX 0508H\n ESI memory block handle (as obtained via INT 31H 0504H)\n EBX base offset of page(s) to map\n ECX number of pages\n EDX physical address of device memory (page-aligned)\n ──────────────────────────────────────────────────────────────────\n Returns: CF NC (clear) if successful; else AX = DPMI Error Code\n ──────────────────────────────────────────────────────────────────\n Info: This maps the physical addresses assigned to a device into the\n linear addresses of a block allocated via INT 31H 0504H.\n\n This is designed to make it possible to page-out physical memory\n that is ordinarily assigned to a device, such as a video memory\n buffer or a Weitek numeric coprocessor.\n\nSee Also: DPMI API\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "620-int_31h_0509h__map_conventional_memory_in_memory_block.html",
    "t": "INT 31H 0509H: Map Conventional Memory in Memory Block",
    "b": "Compatibility: DPMI [optional] 1.0+\n Expects: AX 0508H\n ESI memory block handle (as obtained via INT 31H 0504H)\n EBX base offset of page(s) to map\n ECX number of pages\n EDX physical address of conventional memory (page-aligned)\n ──────────────────────────────────────────────────────────────────\n Returns: CF NC (clear) if successful; else AX = DPMI Error Code\n ──────────────────────────────────────────────────────────────────\n Info: This aliases linear addresses below the 1 MB boundary into the\n linear addresses of a block allocated via INT 31H 0504H.\n\nSee Also: DPMI API\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "621-int_31h_050ah__query_memory_block_size_and_base.html",
    "t": "INT 31H 050aH: Query Memory Block Size and Base",
    "b": "Compatibility: DPMI 1.0+\n Expects: AX 050aH\n SI:DI memory block handle\n ──────────────────────────────────────────────────────────────────\n Returns: CF NC (clear) if successful; else AX = DPMI Error Code\n SI:DI size of memory block, in bytes\n BX:CX base address of memory block\n ──────────────────────────────────────────────────────────────────\n Info: Returns the size of a memory block that was previously allocated\n via INT 31H 0501H or INT 31H 0504H.\n\nSee Also: DPMI API\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "622-int_31h_050bh__query_memory_information.html",
    "t": "INT 31H 050bH: Query Memory Information",
    "b": "Compatibility: DPMI 0.9+\n Expects: AX 050bH\n ES:DI (or ES:EDI) sel:off of 128-byte buffer to receive info\n ──────────────────────────────────────────────────────────────────\n Returns: CF NC (this fn always succeeds)\n ES:DI buffer contains returned info\n ──────────────────────────────────────────────────────────────────\n Info: This obtains information about available physical and virtual\n memory, etc.\n\n ES:(E)DI on entry, must point to a 128-byte buffer. On return, it\n contains:\n\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 4 lAlcPhys allocated bytes of physical memory\n +4 4 lAlcVirt allocated bytes of virtual memory\n +8 4 lAvlVirt available bytes of virtual memory\n +0cH 4 lAlcVirtTask allocd virtual mem for this virt mach\n +10H 4 lAvlVirtTask available virt mem for this virt mach\n +14H 4 lAlcVirtClnt allocated virtual mem for this client\n +18H 4 lAvlVirtClnt available virtual mem for this client\n +1cH 4 lTotLokdClnt total locked bytes for this client\n +20H 4 lMaxLokdClnt maximum locked bytes for this client\n +24H 4 lMaxLinAddr highest linear addr avail to client\n +28H 4 lLargestFree size of largest free block (bytes)\n +2cH 4 lMinAlloc minimum allocation unit (bytes)\n +30H 4 lAlignment allocation unit size (bytes)\n +34H 76 res (reserved)\n 128 size of this structure\n\n Notes: ■ In multi-tasking environments, these values may change at any\n time, so they should be considered as \"advisory.\"\n\n ■ Use INT 31H 0604H to learn the size of the virtual-memory pages\n used by the host.\n\nSee Also: DPMI API\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "623-int_31h_0600h__lock_linear_region.html",
    "t": "INT 31H 0600H: Lock Linear Region",
    "b": "Compatibility: DPMI 0.9+\n Expects: AX 0600H\n BX:CX starting linear address of memory to lock\n SI:DI size, in bytes, of region to lock\n ──────────────────────────────────────────────────────────────────\n Returns: CF NC (clear) if successful; else AX = DPMI Error Code\n ──────────────────────────────────────────────────────────────────\n Info: Locks a region of linear memory (thereby ensuring that it won't\n be moved around or swapped out).\n\n DPMI maintains a lock count. You should use INT 31H 0601H to\n unlock the region as soon as possible.\n\n This also locks any partial page at the start and end of the\n region.\n\nSee Also: DPMI API\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "624-int_31h_0601h__unlock_linear_region.html",
    "t": "INT 31H 0601H: Unlock Linear Region",
    "b": "Compatibility: DPMI 0.9+\n Expects: AX 0601H\n BX:CX starting linear address of memory to lock\n SI:DI size, in bytes, of region to lock\n ──────────────────────────────────────────────────────────────────\n Returns: CF NC (clear) if successful; else AX = DPMI Error Code\n ──────────────────────────────────────────────────────────────────\n Info: Unlocks a region of linear memory that was previously locked via\n INT 31H 0600H (thereby allowing it to be moved around or swapped\n out).\n\n DPMI maintains a lock count. The region is not unlocked until\n the lock count is decremented to 0.\n\nSee Also: DPMI API\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "625-int_31h_0602h__mark_real_mode_region_as_pageable.html",
    "t": "INT 31H 0602H: Mark Real-Mode Region as Pageable",
    "b": "Compatibility: DPMI 0.9+\n Expects: AX 0602H\n BX:CX starting linear address of memory to mark as pageable\n SI:DI size, in bytes, of region to mark\n ──────────────────────────────────────────────────────────────────\n Returns: CF NC (clear) if successful; else AX = DPMI Error Code\n ──────────────────────────────────────────────────────────────────\n Info: Advises the DPMI host that the specified memory below the 1 MB\n boundary may be paged to disk.\n\n You must mark only the conventional memory pages that you own --\n such as memory from INT 31H 0100H or allocated via DOS fn 48H.\n\n Use INT 31H 0603H (relock real-mode region) to get these pages\n back into memory.\n\nSee Also: DPMI API\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "626-int_31h_0603h__relock_real_mode_region.html",
    "t": "INT 31H 0603H: Relock Real-Mode Region",
    "b": "Compatibility: DPMI 0.9+\n Expects: AX 0603H\n BX:CX starting linear address of memory to relock\n SI:DI size, in bytes, of region to relock\n ──────────────────────────────────────────────────────────────────\n Returns: CF NC (clear) if successful; else AX = DPMI Error Code\n ──────────────────────────────────────────────────────────────────\n Info: Relocks a memory region that was previously declared pageable via\n a previous call to INT 31H 0602H (mark real-mode region as\n pageable).\n\nSee Also: DPMI API\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "627-int_31h_0604h__query_page_size.html",
    "t": "INT 31H 0604H: Query Page Size",
    "b": "Compatibility: DPMI 0.9+\n Expects: AX 0604H\n ──────────────────────────────────────────────────────────────────\n Returns: CF NC (clear) if successful; else AX = DPMI Error Code\n BX:CX page size, in bytes\n ──────────────────────────────────────────────────────────────────\n Info: Obtains the size, in bytes of a single memory page.\n\nSee Also: DPMI API\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "628-int_31h_0700h__mark_page_as_demand_paging_candidate.html",
    "t": "INT 31H 0700H: Mark Page as Demand-Paging Candidate",
    "b": "Compatibility: DPMI 0.9+\n Expects: AX 0700H\n BX:CX starting linear address of pages to mark\n SI:DI size, in bytes, of region to mark\n ──────────────────────────────────────────────────────────────────\n Returns: CF NC (clear) if successful; else AX = DPMI Error Code\n ──────────────────────────────────────────────────────────────────\n Info: Notifies the DPMI host that a specified range of pages can be\n placed at the head of the page-out candidate list. The host will\n swap them out the next time memory is needed, even if they have\n been accessed recently.\n\n This lets you optimize virtual memory access. If you know that\n some region will not be needed for a while (or may be regenerated\n easily), let it be swapped out in preference to some other memory\n that may soon be needed.\n\nSee Also: DPMI API\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "629-int_31h_0701h__discard_page_contents.html",
    "t": "INT 31H 0701H: Discard Page Contents",
    "b": "Compatibility: DPMI 0.9+\n Expects: AX 0700H\n BX:CX starting linear address of pages to discard\n SI:DI size, in bytes, of region to discard\n ──────────────────────────────────────────────────────────────────\n Returns: CF NC (clear) if successful; else AX = DPMI Error Code\n ──────────────────────────────────────────────────────────────────\n Info: Discards the entire contents of a specified region of linear\n memory.\n\n This lets you optimize virtual memory access. When a memory area\n will not be needed again, discard it. That way, the DPMI Host\n won't bother swapping it to disk.\n\nSee Also: DPMI API\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "630-int_31h_0800h__physical_address_mapping.html",
    "t": "INT 31H 0800H: Physical Address Mapping",
    "b": "Compatibility: DPMI 0.9+\n Expects: AX 0800H\n BX:CX physical address of memory\n SI:DI size of region to map, in bytes\n ──────────────────────────────────────────────────────────────────\n Returns: CF NC (clear) if successful; else AX = DPMI Error Code\n BX:CX linear address usable to access physical memory\n ──────────────────────────────────────────────────────────────────\n Info: This converts a physical address into a linear address.\n\n This allows device drivers to access device-defined memory\n addresses above 1 MB such as the Weitek math chip (usually mapped\n at 3 GB) or hardware such as video coprocessors' memory aperture.\n\nSee Also: DPMI API\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "631-int_31h_0801h__free_physical_address_mapping.html",
    "t": "INT 31H 0801H: Free Physical Address Mapping",
    "b": "Compatibility: DPMI 0.9+\n Expects: AX 0801H\n BX:CX linear address obtained via INT 31H 0800H\n ──────────────────────────────────────────────────────────────────\n Returns: CF NC (clear) if successful; else AX = DPMI Error Code\n ──────────────────────────────────────────────────────────────────\n Info: This frees resources consumed by a previous use of INT 31H 0800H\n (physical address mapping).\n\nSee Also: DPMI API\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "632-int_31h_0900h__query_and_disable_virtual_interrupt_state.html",
    "t": "INT 31H 0900H: Query and Disable Virtual Interrupt State",
    "b": "Compatibility: DPMI 0.9+\n Expects: AX 0900H\n ──────────────────────────────────────────────────────────────────\n Returns: CF NC (clear; always successful)\n AL previous setting: 00H = virtual interrupts were disabled\n 01H = virtual interrupts were enabled\n ──────────────────────────────────────────────────────────────────\n Info: Disables the virtual interrupt flag and returns the previous\n state of that flag.\n\n AH is not modified by the call, so you can return to the previous\n state immediately by calling INT 31H.\n\n If you don't need to know the previous state, you may simply use\n the CLI opcode.\n\nSee Also: DPMI API\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "633-int_31h_0901h__query_and_disable_virtual_interrupt_state.html",
    "t": "INT 31H 0901H: Query and Disable Virtual Interrupt State",
    "b": "Compatibility: DPMI 0.9+\n Expects: AX 0901H\n ──────────────────────────────────────────────────────────────────\n Returns: CF NC (clear; always successful)\n AL previous setting: 00H = virtual interrupts were disabled\n 01H = virtual interrupts were enabled\n ──────────────────────────────────────────────────────────────────\n Info: Enables the virtual interrupt flag and returns the previous state\n of that flag.\n\n AH is not modified by the call, so you can return to the previous\n state immediately by calling INT 31H.\n\n If you don't need to know the previous state, you may simply use\n the STI opcode.\n\nSee Also: DPMI API\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "634-int_31h_0902h__query_virtual_interrupt_state.html",
    "t": "INT 31H 0902H: Query Virtual Interrupt State",
    "b": "Compatibility: DPMI 0.9+\n Expects: AX 0902H\n ──────────────────────────────────────────────────────────────────\n Returns: CF NC (clear; always successful)\n AL current setting: 00H = virtual interrupts are disabled\n 01H = virtual interrupts are enabled\n ──────────────────────────────────────────────────────────────────\n Info: Obtains the current setting of the virtual interrupt flag.\n\n This fn is recommended over using the PUSHF opcode and examining\n the stack, since that returns the physical interrupt flag, rather\n than the virtualized flag tracked by the DPMI host.\n\nSee Also: DPMI API\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "635-int_31h_0a00h__get_vendor_specific_api_entry_address.html",
    "t": "INT 31H 0a00H: Get Vendor-Specific API Entry Address",
    "b": "Compatibility: DPMI 0.9+\n Expects: AX 0a00H\n DS:SI (or DS:ESI) addr of an ASCIIZ▲ string which identifies the\n DPMI host vendor\n ──────────────────────────────────────────────────────────────────\n Returns: CF NC (clear) if successful; else AX = DPMI Error Code\n ES:DI (or ES:EDI) address of API extension API entry address\n ──────────────────────────────────────────────────────────────────\n Info: If a specific DPMI host vendor supplies an extended API of DPMI\n services, you may use this fn to obtain the address of the host\n code that provides those services.\n\n Use a FAR CALL to access the extended API.\n\n Notes: ■ DPMI 1.0+ clients should use INT 2fH 168aH rather than this fn.\n\n ■ The string passed via ES:(E)DI must match the vendor's name\n exactly; the comparison is case-sensitive.\n\nSee Also: DPMI API\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "636-int_31h_0b00h__set_debug_watchpoint.html",
    "t": "INT 31H 0b00H: Set Debug Watchpoint",
    "b": "Compatibility: DPMI 0.9+\n Expects: AX 0b00H\n BX:CX linear address of watchpoint\n DL size of watchpoint (1, 2, or 4 bytes)\n DH type of watchpoint: 00H = execute\n 01H = write\n 02H = read/write\n ──────────────────────────────────────────────────────────────────\n Returns: CF NC (clear) if successful; else AX = DPMI Error Code\n ──────────────────────────────────────────────────────────────────\n Info: Sets a debug watchpoint at the specified linear address. When\n the specified action occurs, an INT 03H is invoked.\n\nSee Also: DPMI API\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "637-int_31h_0b01h__clear_debug_watchpoint.html",
    "t": "INT 31H 0b01H: Clear Debug Watchpoint",
    "b": "Compatibility: DPMI 0.9+\n Expects: AX 0b01H\n BX watchpoint handle (as obtained via INT 31H 0b00H)\n ──────────────────────────────────────────────────────────────────\n Returns: CF NC (clear) if successful; else AX = DPMI Error Code\n ──────────────────────────────────────────────────────────────────\n Info: Clears a debug watchpoint previously specified via INT 31H 0b00H\n and releases the watchpoint handle.\n\n You may use INT 31H 0b03H to clear the watchpoint without\n releasing the handle.\n\nSee Also: DPMI API\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "638-int_31h_0b02h__query_state_of_debug_watchpoint.html",
    "t": "INT 31H 0b02H: Query State of Debug Watchpoint",
    "b": "Compatibility: DPMI 0.9+\n Expects: AX 0b02H\n BX watchpoint handle (as obtained via INT 31H 0b00H)\n ──────────────────────────────────────────────────────────────────\n Returns: CF NC (clear) if successful; else AX = DPMI Error Code\n AX watchpoint status bits: bit 0: 0=not encountered\n 1=has been encountered\n 1-15: reserved\n ──────────────────────────────────────────────────────────────────\n Info: Obtains information about the status of a debug watchpoint\n previously specified via INT 31H 0b00H.\n\n You may use INT 31H 0b03H to clear the watchpoint without\n releasing the handle.\n\nSee Also: DPMI API\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "639-int_31h_0b03h__reset_debug_watchpoint.html",
    "t": "INT 31H 0b03H: Reset Debug Watchpoint",
    "b": "Compatibility: DPMI 0.9+\n Expects: AX 0b03H\n BX watchpoint handle (as obtained via INT 31H 0b00H)\n ──────────────────────────────────────────────────────────────────\n Returns: CF NC (clear) if successful; else AX = DPMI Error Code\n ──────────────────────────────────────────────────────────────────\n Info: Clears the state of a debug watchpoint. The next use of\n INT 31H 0b00H (get status) will indicate \"not encountered\".\n\nSee Also: DPMI API\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "640-int_31h_0c00h__setup_dpmi_tsr_callback.html",
    "t": "INT 31H 0c00H: Setup DPMI TSR Callback",
    "b": "Compatibility: DPMI 1.0+\n Expects: AX 0c00H\n ES:DI (or ES:EDI) address of 40-byte buffer (see below)\n ──────────────────────────────────────────────────────────────────\n Returns: CF NC (clear) if successful; else AX = DPMI Error Code\n ──────────────────────────────────────────────────────────────────\n Info: This sets up for a DPMI client to provide memory-resident\n protected-mode services to other protected-mode clients.\n\n After using this fn and INT 31H 0c00H, you will be notified\n whenever another DPMI program in the same VM is loaded or\n terminated.\n\n DS:(E)DI this points to a structure formatted as follows:\n\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 8 lDesc16Data descriptor for 16-bit data segment\n +8 8 lDesc16Code descriptor for 16-bit code segment\n +10H 2 lOff16Proc offset of 16-bit callback procedure\n +12H 2 res reserved\n +14H 8 lDesc32Data descriptor for 32-bit data segment\n +1cH 8 lDesc32Code descriptor for 32-bit code segment\n +24H 4 lOff32Proc offset of 32-bit callback procedure\n 40 size of this structure\n\n You may use INT 31H 000bH (query descriptor) to obtain info to\n fill some of the above fields. If you will support only 16-bit\n or only 32-bit applications, put zeros in the structure members\n you don't need.\n\n Notes: ■ If you only need to provide services to real-mode applications\n in the current VM, then you should use INT 31H 0300H to use DOS\n services to intercept interrupt vectors and make yourself RAM-\n resident.\n\n ■ After calling this fn, use INT 31H 02xxH services to intercept\n interrupts and use INT 31H 0c01H to make your code RAM-\n resident.\n\n When a DPMI client gets loaded, your callback address will be\n called via a FAR CALL with AX=0 when a program is loading or\n AX=1 when a program is terminating. On program loads, you will\n typically intercept one or more interrupts to supply services\n in the current VM.\n\nSee Also: DPMI API\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "641-int_31h_0c01h__protected_mode_terminate_and_stay_resident.html",
    "t": "INT 31H 0c01H: Protected-Mode Terminate and Stay Resident",
    "b": "Compatibility: DPMI 1.0+\n Expects: AX 0c01H\n BL exit code\n DX DOS memory to reserve, in paragraphs (16-byte blocks)\n ──────────────────────────────────────────────────────────────────\n Returns: none (does not return to caller)\n ──────────────────────────────────────────────────────────────────\n Info: This should be used ONLY by DPMI clients which provide protected-\n mode services to other protected-mode applications. It should be\n used only after calling INT 31H 0c00H (setup DPMI TSR callback).\n\n Notes: ■ If you only need to provide services to real-mode applications\n in the current VM, then you should use INT 31H 0300H to use DOS\n services to intercept interrupt vectors and make yourself RAM-\n resident.\n\n ■ If you have not made a previous call to INT 31H 0c00H, you will\n simply be terminated.\n\nSee Also: DPMI API\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "642-int_31h_0d00h__allocate_shared_memory.html",
    "t": "INT 31H 0d00H: Allocate Shared Memory",
    "b": "Compatibility: DPMI 1.0+\n Expects: AX 0d00H\n ES:DI (or ES:EDI) address of 28-byte info structure (see below)\n ──────────────────────────────────────────────────────────────────\n Returns: CF NC (clear) if successful; else AX = DPMI Error Code\n ES:DI (or ES:EDI) structure updated\n ──────────────────────────────────────────────────────────────────\n Info: This allocates a named block of memory that may be shared by DPMI\n clients. This may be used for interprocess communication.\n\n DS:(E)DI this selector:offset must point to a 28-byte local structure\n defined as follows:\n\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 4 lReqSize desired size of block, in bytes\n +4 4 lActualSize actual size allocated (returned)\n +8 4 lHandle handle for the allocation (returned)\n +0cH 4 lLinAddr linear addr of allocation (returned)\n +10H 6 p48szName 48-bit address of ASCIIZ▲ name for\n the shared block. First 4 bytes are\n the offset; the last 2 are selector.\n +16H 2 wRes1 reserved\n +18H 4 lRes2 reserved; must be 0\n 28 size of this structure\n\n On entry, you must fill in lReqSize and set p48szName to a 48-bit\n address of an ASCIIZ string that names the block. The host\n fills-in lAllocSize, lHandle, and lLinAddr.\n\n For 16-bit clients, the high word of p48szName must be 0000H.\n\n Note: ■ The second and subsequent client to use this fn with the same\n ASCIIZ name, will be returned info about the initial\n allocation. For such subsequent \"allocations\", the lReqSize\n field is ignored. Be sure to check the lActualSize field on\n return.\n\n ■ The first client to allocate a named block will find that the\n first 16-bytes are 0. It can gain exclusive ownership via\n INT 31H 0d02H, and store some non-zero values so that\n subsequent clients can tell that it has been initialized.\n\n ■ 0-length allocations are explicitly supported and can be used\n as a way to implement semaphores (see INT 31H 0d02H, for\n instance).\n\n ■ All of your shared memory allocations and serializations are\n freed by the host automatically when you terminate.\n\nSee Also: DPMI API\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "643-int_31h_0d01h__free_shared_memory.html",
    "t": "INT 31H 0d01H: Free Shared Memory",
    "b": "Compatibility: DPMI 1.0+\n Expects: AX 0d01H\n SI:DI handle of shared memory block as obtained via INT 31H 0d00H\n ──────────────────────────────────────────────────────────────────\n Returns: CF NC (clear) if successful; else AX = DPMI Error Code\n ──────────────────────────────────────────────────────────────────\n Info: This frees an a named block of memory that was allocated via\n INT 31H 0d00H.\n\n It actually decrements the per-VM use-count and the global\n use-count. The allocated memory is freed only when the global\n use-count has been decremented to 0.\n\nSee Also: DPMI API\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "644-int_31h_0d02h__serialize_on_shared_memory.html",
    "t": "INT 31H 0d02H: Serialize on Shared Memory",
    "b": "Compatibility: DPMI 1.0+\n Expects: AX 0d02H\n SI:DI handle of shared memory block as obtained via INT 31H 0d00H\n DX option flags: bit 0: 0=suspend client until available\n 1=return with error when unavailable\n bit 1: 0=exclusive serialization requested\n 1=shared serialization requested\n 2-15: reserved, must be 0\n ──────────────────────────────────────────────────────────────────\n Returns: CF NC (clear) if successful; else AX = DPMI Error Code\n ──────────────────────────────────────────────────────────────────\n Info: This requests that access to a shared memory block be controlled\n (serialized). This provides a means for multiple clients to\n access the block serially, avoiding simultaneous access.\n\n DX When bit 1 of DX is set, this call requests exclusive\n serialization, which effectively means \"ownership for writing\".\n Shared serialization can be considered as a way to gain \"read-\n only access\".\n\n Notes: ■ Use INT 31H 0d03H to release ownership.\n\n ■ A suspended client continues to receive interrupts and can use\n INT 31H 0d03H in an interrupt handler to cancel the\n serialization.\n\nSee Also: DPMI API\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "645-int_31h_0d03h__free_serialization_on_shared_memory.html",
    "t": "INT 31H 0d03H: Free Serialization on Shared Memory",
    "b": "Compatibility: DPMI 1.0+\n Expects: AX 0d02H\n SI:DI handle of shared memory block as obtained via INT 31H 0d00H\n DX option flags: bit 0: 0=release exclusive serialization\n 1=release shared serialization\n bit 1: 0=don't free pending serialization\n 1=free pending serialization (see note)\n 2-15: reserved, must be 0\n ──────────────────────────────────────────────────────────────────\n Returns: CF NC (clear) if successful; else AX = DPMI Error Code\n ──────────────────────────────────────────────────────────────────\n Info: This releases a access of a shared memory block that was obtained\n by a previous call to INT 31H 0d02H (serialize on shared memory).\n\n Notes: ■ The host maintains four serialization counts for each VM\n (exclusive, shared, pending shared, and pending exclusive).\n This fn actually only decrements the relevant count -- the\n serialization is actually freed only when the count goes to 0.\n\n ■ A suspended client continues to receive interrupts and can use\n this call in an interrupt handler to cancel a serialization\n that has blocked a foreground client. In that case, the call\n made by the foreground client is returned an error code of\n 8005H (request canceled).\n\nSee Also: DPMI API\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "646-int_31h_0e00h__query_coprocessor_status.html",
    "t": "INT 31H 0e00H: Query Coprocessor Status",
    "b": "Compatibility: DPMI 0.9+\n Expects: AX 0d00H\n ──────────────────────────────────────────────────────────────────\n Returns: CF NC (clear) if successful; else AX = DPMI Error Code\n AX coprocessor status bits (see below)\n ──────────────────────────────────────────────────────────────────\n Info: This obtains information about a numeric coprocessor -- whether\n one exists, its type, etc.\n\n AX on return, contains the following bit codes:\n 1 1\n ┌5┬4┬ - ┬7┬6┬5┬4┬3┬2┬1┬0┐\n │ ...│ type │ │ │ │ │\n └─┴─┴ - ┴─┴─┴─┴─┴╥┴╥┴╥┴╥┘ bit mask\n ╚══╦══╝ ║ ║ ║ ╚═► 0: 0001H 1=enabled for this client\n ║ ║ ║ ╚═══► 1: 0002H 1=client is emulating coproc\n ║ ║ ╚═════► 2: 0004H 1=numeric coproc is present\n ║ ╚═══════► 3: 0008H 1=host is emulating coproc\n ╚════════════►4-7: 00f0H coprocessor type: 0=none\n 2=80287; 3=80387; 4=80486\n 5=Pentium coproc\n\n Notes: You can use INT 31H 0400H to determine the CPU type, but you\n should not make any assumptions about the presence or features of\n a coprocessor based on the return from that call.\n\nSee Also: DPMI API\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "647-int_31h_0e01h__set_coprocessor_emulation.html",
    "t": "INT 31H 0e01H: Set Coprocessor Emulation",
    "b": "Compatibility: DPMI 0.9+\n Expects: AX 0e01H\n BX settings: bit 0: 0=disable coprocessor for this client\n 1=enable coprocessor for this client\n bit 1: 0=client will not supply coproc emulation\n 1=client will supply coprocessor emulation\n 2-15: not applicable\n ──────────────────────────────────────────────────────────────────\n Returns: CF NC (clear) if successful; else AX = DPMI Error Code\n ──────────────────────────────────────────────────────────────────\n Info: This enables or disables the numeric coprocessor for this virtual\n machine and enables/disables reflection of coprocessor exceptions\n (e.g., for emulation).\n\nSee Also: DPMI API\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "648-dpmi_error_codes.html",
    "t": "DPMI Error Codes",
    "b": "The DPMI specification (DPMI API) defines the following error/return\n codes. When a DPMI fn fails, it returns with the carry flag set and an\n error code in AX.\n\n If bit 15 of AX is clear, then AX contains an error code returned by a DOS\n fn (see DOS Error Codes).\n\n If bit 15 of AX is set, then AX contains one of the following DPMI error\n codes:\n\n 0000H DPMI_NO_ERR (and CY clear) Fn was successful.\n\n 8001H DPMI_ERR_BAD_FN Fn number is not supported by this host.\n\n 8002H DPMI_ERR_INVALID_STATE Some object is in the wrong state for the\n requested operation.\n\n 8003H DPMI_ERR_SYS_INTEGRITY The operation would endanger system\n integrity.\n\n 8004H DPMI_ERR_DEADLOCK Host detected a deadlock situation.\n\n 8005H DPMI_ERR_REQ_CANCELLED Pending serialization request was\n cancelled.\n\n 8010H DPMI_ERR_RSRC_UNAVAIL Host unable to allocate internal resources\n to satisfy the request.\n\n 8011H DPMI_ERR_DESCRP_UNAVAIL Unable to allocate a descriptor.\n\n 8012H DPMI_ERR_LINMEM_UNAVAIL Unable to allocate linear memory\n\n 8013H DPMI_ERR_PHYSMEM_UNAVAIL Unable to allocate physical memory\n\n 8014H DPMI_ERR_BACKING_UNAVAIL Unable to allocate required backing store.\n\n 8015H DPMI_ERR_CALLBACK_UNAVAIL Unable to allocate callback address.\n\n 8016H DPMI_ERR_HANDLE_UNAVAIL Unable to allocate handle.\n\n 8017H DPMI_ERR_LOCK_CNT Locking operation exceeds the maximum\n value maintained by the host.\n\n 8018H DPMI_ERR_RSRC_OWNED_EXCL Request for serialized access denied\n because the resource is owned exclusively\n by another client.\n\n 8019H DPMI_ERR_RSRC_OWNED_SHRD Request for serialized access denied\n because the resource is already serialized\n shared by another client.\n\n 8021H DPMI_ERR_INVALID_VALUE A numeric or flag value was invalid.\n\n 8022H DPMI_ERR_INVALID_SELECTOR A selector was invalid.\n\n 8023H DPMI_ERR_INVALID_HANDLE A handle was invalid.\n\n 8024H DPMI_ERR_INVALID_CALLBACK A callback parameter was invalid.\n\n 8025H DPMI_ERR_INVALID_LINADDR A linear address (either supplied as a\n parameter or implied by the request) was\n invalid.\n\n 8026H DPMI_ERR_INVALID_REQUEST The request is not supported by the\n underlying hardware.\n\nSee Also: DPMI API\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "649-dpmiregrec.html",
    "t": "DpmiRegRec",
    "b": "This structure is used in the following DPMI API services:\n\n INT 31H 0300H (simulate real-mode interrupt)\n INT 31H 0301H (call real-mode for FAR RET return)\n INT 31H 0302H (call real-mode for IRET return)\n\n DpmiRegRec\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 4 lRegDI DI or EDI\n +4 4 lRegSI SI or ESI\n +8 4 lRegBP BP or EBP\n +0cH 4 lRes (reserved, should be 00000000H)\n +10H 4 lRegBC BX or EBX\n +14H 4 lRegDX DX or EDX\n +18H 4 lRegCX CX or ECX\n +1cH 4 lRegAX AX or EAX\n +20H 2 wFlags Flags (CPU status flags)\n +22H 2 wRegES ES\n +24H 2 wRegDS DS\n +26H 2 wRegFS FS (not used in 16-bit applications)\n +28H 2 wRegGS GS (not used in 16-bit applications)\n +2aH 2 wRegIP IP (not used in fn 0300H)\n +2cH 2 wRegCS CS (not used in fn 0300H)\n +2eH 2 wRegSP SP (0000H=host provides real-mode stack)\n +30H 2 wRegSS SS (0000H=host provides real-mode stack)\n 50 size of a DpmiRegRec\n\n Notes: ■ When wRegSS and wRegSP are 0000H, the DPMI will supply a real-\n mode stack.\n\n ■ Values for segment registers must be valid for real mode (don't\n pass protected-mode selectors).\n\n ■ 16-bit applications need supply only the first two bytes of the\n 4-byte lRegXX fields.\n\n 16-bit applications need not supply values for FS and GS, even\n when running on a 80386+ CPU.\n\nSee Also: DPMI API\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "650-expanded_memory_specification__ems_.html",
    "t": "Expanded Memory Specification (EMS)",
    "b": "This topic describes the Lotus/Intel/Microsoft formal specification\n (LIM-EMS) used to access Expanded▲ Memory on a PC-compatible system.\n\n See EMM Functions for a description INT 67H services.\n\n The EMS standard provides access more memory without exceeding the 1MB\n maximum for 8088-based computers and without switching to protected mode\n on 286+ CPUs. Programs such as Lotus 1-2-3 use it to hold data for large\n spreadsheets. It is also used for RAM disks and print spoolers. Some TSR\n programs use EMS memory to hold data and code (thus minimizing use of\n conventional▲ memory).\n\n Note: The most common EMS memory is actually extended▲ memory, accessed\n via an EMS-emulation device driver such as EMM386.EXE, or 386MAX.\n\n On 286+ CPUs, the Extended Memory Specification (XMS) accesses\n additional memory without the emulation layer, so you may prefer\n to use its API rather than (or in addition to) the EMS services.\n\n█▌Determining if EMS is Installed▐█\n EMS memory is managed by an installable device driver with a device name\n of \"EMMXXXX0\" and referred to as the EMM (Expanded Memory Manager). To\n learn if the driver has been installed you can use DOS Fn 3dH to attempt\n to open the device as a file. Once opened, you can use DOS IOCTL fn\n 4407H to get the status. If the returned status (in AL) is 0, then EMM\n is NOT installed and a disk file by the name \"EMMXXXX0\" exists for some\n reason.\n\n When the EMM driver is installed, it sets the INT 67h vector to point to\n its device header. Thus, another way to test for EMS is to fetch the\n address in the vector for INT 67H (0:091c) and examine offset 0aH from\n that address. It should contain the characters \"EMMXXXX0\". See\n Device Header Layout.\n\n█▌DOS Support▐█\n Starting with version 5.0, DOS comes with an expanded memory emulation\n driver (EMM386.EXE) for 386-based computers. A few DOS device drivers\n and TSRs will take advantage of EMS if it is present:\n\n ■ DOS 4.x and 5.x disk buffers can be put in expanded memory\n (BUFFERS=nn /X), but this option was removed from DOS 6.0.\n\n ■ DOS 4.0+ RAMDISK.SYS driver lets you put a RAM disk in expanded memory\n (DEVICE=RAMDISK.SYS nnn /A).\n\n ■ DOS 4.0+ Fastopen /X command uses EMS memory for its pathname storage.\n\n ■ DOS 6.0 programs and TSRs: Defrag, Dosshell, Msbackup, Mscdex, and\n Vsafe will use EMS memory when it is available.\n\n█▌EMM Services▐█\n To access the EMS memory manager, use INT 67h with a fn code in the AX\n register, as described in EMM Functions.\n\nSee Also: EMM Functions\n Extended Memory Specification (XMS)\n DOS Interrupts\n Interrupts and BIOS Services\n -♦-"
  },
  {
    "id": "651-emm_functions.html",
    "t": "EMM Functions",
    "b": "TECH Help! describes all services supported by the Expanded Memory Manager\n version 4.0 and previous versions. 4.0 has been standard since 1987 so\n there should be few compatibility problems if you use the 4.0 functions.\n\n To access an EMM function, load AX with a function number, set other\n registers as described for the function, and invoke INT 67H. Be sure to\n check the return status in AH. A non-zero return value indicates an\n error.\n\n AX\n ▀▀▀▀▀ ─────────────────────────────────────────────── Standard Functions\n 4000H Get EMM status\n 4100H Get frame segment address\n 4200H Get memory total and available\n 4300H Open handle / allocate pages\n 44xxH Map memory (swap EMS page into/out of memory)\n 4500H Close handle / free pages\n 4600H Get EMM version number\n ─────────────────────────────────────────────── Advanced Functions\n 4700H Save mapping context\n 4800H Restore mapping context\n 4b00H Count handle's pages\n 4c00H Count active handles\n 4d00H Get page info (all handles)\n\n 4exxH Get/Set entire page map\n 4e00H Get all mapping registers into an array at ES:DI\n 4e01H Set all mapping registers from array at DS:SI\n 4e02H Get and set mapping registers (SubFns 0 and 1 combined)\n 4e03H Query size of buffer needed for SubFns 0-2\n\n 4fxxH Get/Set partial page map (EMS 4.0).\n 4f00H Get mapping registers\n 4f01H Restore mapping\n 4f02H Query size of buffer needed for SubFn 0.\n\n 50xxH Map/Unmap multiple pages (EMS 4.0).\n\n 5100H Reallocate (resize) EMS Handle (EMS 4.0).\n\n 52xxH Get/Set Handle attribute (EMS 4.0).\n 5200H Get handle attribute\n 5201H Set Handle attribute\n 5202H Query attribute capability\n\n 53xxH Get/Set Handle name (EMS 4.0).\n 5300H Get handle name\n 5301H Set handle name\n\n 54xxH Find Named Handle (EMS 4.0).\n 5400H Get handle directory\n 5401H Search for named handle\n 5401H Count all open handles\n\n 55xxH Alter Page Map and Jump (EMS 4.0).\n\n 56xxH Alter Page Map and Call (EMS 4.0).\n\n 57xxH Move/Exchange Memory (EMS 4.0).\n 5700H Move memory region\n 5701H Exchange memory regions\n\n 58xxH Get Mappable Physical Address Array (EMS 4.0).\n 5800H Get segment-to-page map array\n 5801H Count segment-to-page array entries\n ─────────────────────────────────────── Operating System Functions\n 59xxH Get Hardware configuration (EMS 4.0)\n 5900H Get hardware info\n 5901H Get unallocated raw page count\n\n 5axxH Allocate Standard/Raw Pages (EMS 4.0)\n 5a00H Allocate standard 16K byte logical pages\n 5a01H Allocate raw pages\n\n 5bxxH Alternate Map Register Set (EMS 4.0)\n 5b00H Get alternate map register set\n 5b01H Set alternate map register set\n 5b02H Get alternate map register set array size\n 5b03H Allocate alternate map register set\n 5b04H Deallocate alternate map register set\n 5b05H Allocate DMA register set\n 5b06H Enable DMA on alternate map register set\n 5b07H Disable DMA on alternate map register set\n 5b08H Deallocate DMA register set\n\n 5c00H Prepare for warm boot (EMS 4.0)\n\n 5dxxH Enable/Disable OS Function Set Functions (EMS 4.0)\n 5d00H Enable all OS-only EMM functions\n 5d01H Disable all OS-only EMM functions\n 5d02H Return access key (enable next caller to get a key)\n\nSee Also: EMS\n Extended Memory Specification (XMS)\n DOS Interrupts\n Interrupts and BIOS Services\n -♦-"
  },
  {
    "id": "652-int_67h_4000h__get_emm_status.html",
    "t": "INT 67H 4000H: Get EMM Status",
    "b": "Compatibility: EMS 3.2+\n Expects: AX 4000H\n ──────────────────────────────────────────────────────────────────\n Returns: AH EMM status\n ──────────────────────────────────────────────────────────────────\n Info: Obtain the current status of the Expanded Memory Manager.\n\n Use this only after establishing the presence of EMM support (see\n Expanded Memory Specification for details).\n\nSee Also: INT 67H: EMM Services\n Extended Memory Specification (XMS)\n Interrupts and BIOS Services\n -♦-"
  },
  {
    "id": "653-int_67h_4100h__get_frame_segment_address.html",
    "t": "INT 67H 4100H: Get Frame Segment Address",
    "b": "Expects: AX 4100H\n ──────────────────────────────────────────────────────────────────\n Returns: AH EMM status (0=successful)\n BX segment of EMS frame\n ──────────────────────────────────────────────────────────────────\n Info: Obtains the segment at which the EMS frame is mapped.\n\n The EMS frame is a 64K area, often starting at d000:0. Depending\n upon switches used when the driver is installed, the frame may\n actually start at any segment address from 8000H to 9000H (seen\n rarely) and c000H through e000H in increments of 400H.\n\n When you read or write to EMS memory, you will use INT 67H 4000H\n to map part of the EMS into this frame, then read or write to the\n 64K starting at the segment returned in BX.\n\nSee Also: INT 67H: EMM Services\n Extended Memory Specification (XMS)\n Interrupts and BIOS Services\n -♦-"
  },
  {
    "id": "654-int_67h_4200h__get_ems_memory_total___available.html",
    "t": "INT 67H 4200H: Get EMS Memory Total / Available",
    "b": "Compatibility: EMS 3.2+\n Expects: AX 4200H\n ──────────────────────────────────────────────────────────────────\n Returns: AH EMM status (0=successful)\n DX total pages (16K units)\n BX available pages (16K units)\n ──────────────────────────────────────────────────────────────────\n Info: Obtains the total amount of EMS memory that is supported and the\n amount that is currently available.\n\n Notes: DOS 6.0+ EMM386 draws EMS from the same pools as XMS▲; so the\n returned values may vary from time to time.\n\nSee Also: INT 67H: EMM Services\n Extended Memory Specification (XMS)\n Interrupts and BIOS Services\n -♦-"
  },
  {
    "id": "655-int_67h_4300h__open_emm_handle_and_allocate_memory.html",
    "t": "INT 67H 4300H: Open EMM Handle and Allocate Memory",
    "b": "Compatibility: EMS 3.2+\n Expects: AX 4300H\n BX number of pages requested (16K units)\n ──────────────────────────────────────────────────────────────────\n Returns: AH EMM status (0=successful)\n DX EMM handle of allocated memory (if successful)\n ──────────────────────────────────────────────────────────────────\n Info: Allocates EMS memory.\n\n The handle returned in DX is used in subsequent calls to map the\n EMS into the page frame and other operations.\n\n Notes: Use INT 67H 4200H to see how much EMS is available.\n\nSee Also: INT 67H: EMM Services\n Extended Memory Specification (XMS)\n Interrupts and BIOS Services\n -♦-"
  },
  {
    "id": "656-int_67h_44xxh__map_memory_into_page_frame.html",
    "t": "INT 67H 44xxH: Map Memory into Page Frame",
    "b": "Compatibility: EMS 3.2+\n Expects: AH 44H\n AL physical page number (0 to n; usually 0 to 3)\n BX logical page number to map in or ffffH (see below)\n DX EMM Handle\n ──────────────────────────────────────────────────────────────────\n Returns: AH EMM status (0=successful)\n ──────────────────────────────────────────────────────────────────\n Info: This moves the data associated with a particular 16K page of EMS\n memory into the physical frame (making that memory accessible).\n\n For instance, assuming that the page frame starts at d000:0, then\n calling this with AX=4401H will put the BXth page of your\n allocation into d000:0400.\n\n BX is the desired page of EMS memory. It can range from 0 to n-1,\n where n is the size of the allocation (as used in INT 67H 4300H).\n\n With EMS spec 4.0, you can set BX=ffffH to unmap a 16K portion of\n the EMS frame. For instance, if AX=4401H and BX=ffffH, then the\n data from EmsSeg:0400 through EmsSeg:07ff will be locked into\n place and cannot be read or written. To remap a page, use the\n same parameters, specifying a valid logical page number in BX.\n\n Notes: You may remap only one 16K page at a time with this fn. You may\n prefer INT 67H 50xxH to map multiple pages.\n\nSee Also: INT 67H: EMM Services\n Extended Memory Specification (XMS)\n Interrupts and BIOS Services\n -♦-"
  },
  {
    "id": "657-int_67h_4500h__close_emm_handle_and_free_memory.html",
    "t": "INT 67H 4500H: Close EMM Handle and Free Memory",
    "b": "Compatibility: EMS 3.2+\n Expects: AX 4500H\n DX EMM Handle (as obtained via INT 67H 4300H)\n ──────────────────────────────────────────────────────────────────\n Returns: AH EMM status (0=successful)\n ──────────────────────────────────────────────────────────────────\n Info: Release memory allocated via INT 67H 4300H and makes the DX\n handle invalid for future calls.\n\nSee Also: INT 67H: EMM Services\n Extended Memory Specification (XMS)\n Interrupts and BIOS Services\n -♦-"
  },
  {
    "id": "658-int_67h_4600h__get_emm_version_number.html",
    "t": "INT 67H 4600H: Get EMM Version Number",
    "b": "Compatibility: EMS 3.2+\n Expects: AX 4600H\n ──────────────────────────────────────────────────────────────────\n Returns: AH EMM status (0=successful)\n AL EMM version number in BCD (e.g., 32H is EMM 3.2; 40H = 4.0)\n ──────────────────────────────────────────────────────────────────\n Info: Use this to ensure that the installed version supports any\n special features you wish to access.\n\n Notes: EMM 4.0 has been standard since 1987 and it is usually quite safe\n to assume 4.0 is present. Furthermore, in most cases, you can\n get by without using any of the features unique to 4.0.\n\nSee Also: INT 67H: EMM Services\n Extended Memory Specification (XMS)\n Interrupts and BIOS Services\n -♦-"
  },
  {
    "id": "659-int_67h_4700h__save_mapping_context.html",
    "t": "INT 67H 4700H: Save Mapping Context",
    "b": "Compatibility: EMS 3.2+\n Expects: AX 4700H\n DX EMM handle owned by caller\n ──────────────────────────────────────────────────────────────────\n Returns: AH EMM status (0=successful)\n ──────────────────────────────────────────────────────────────────\n Info: EMM will save the current mapping of physical to logical EMS\n pages, so that a TSR program or device driver may page-in its own\n memory transparently to the interrupted program.\n\n Use INT 67H 4800H restores the original mapping.\n\nSee Also: INT 67H: EMM Services\n Extended Memory Specification (XMS)\n Interrupts and BIOS Services\n -♦-"
  },
  {
    "id": "660-int_67h_4800h__restore_mapping_context.html",
    "t": "INT 67H 4800H: Restore Mapping Context",
    "b": "Compatibility: EMS 3.2+\n Expects: AX 4800H\n DX EMM handle owned by caller\n ──────────────────────────────────────────────────────────────────\n Returns: AH EMM status (0=successful)\n ──────────────────────────────────────────────────────────────────\n Info: EMM will restore the page mapping to what it was upon a previous\n INT 67H 4700H call with the same handle. Device drivers and TSRs\n should use this before exiting to the application.\n\nSee Also: INT 67H: EMM Services\n Extended Memory Specification (XMS)\n Interrupts and BIOS Services\n -♦-"
  },
  {
    "id": "661-int_67h_4b00h__count_handle_s_pages.html",
    "t": "INT 67H 4b00H: Count Handle's Pages",
    "b": "Compatibility: EMS 3.2+\n Expects: AX 4b00H\n DX EMM Handle (as obtained via INT 67H 4300H)\n ──────────────────────────────────────────────────────────────────\n Returns: AH EMM status (0=successful)\n ──────────────────────────────────────────────────────────────────\n Info: Returns number of EMS pages owned by a handle.\n\nSee Also: INT 67H: EMM Services\n Extended Memory Specification (XMS)\n Interrupts and BIOS Services\n -♦-"
  },
  {
    "id": "662-int_67h_4c00h__count_active_handles.html",
    "t": "INT 67H 4c00H: Count Active Handles",
    "b": "Compatibility: EMS 3.2+\n Expects: AX 4c00H\n ──────────────────────────────────────────────────────────────────\n Returns: AH EMM status (0=successful)\n ──────────────────────────────────────────────────────────────────\n Info: This obtains the number of active EMM handles. You might use\n this to calculate the buffer size needed for INT 67H 4d00H.\n\nSee Also: INT 67H: EMM Services\n Extended Memory Specification (XMS)\n Interrupts and BIOS Services\n -♦-"
  },
  {
    "id": "663-int_67h_4d00h__get_page_information_for_all_handles.html",
    "t": "INT 67H 4d00H: Get Page Information For All Handles",
    "b": "Compatibility: EMS 3.2+\n Expects: AX 4d00H\n ES:DI buffer to receive return information\n ──────────────────────────────────────────────────────────────────\n Returns: AH EMM status (0=successful)\n BX count of active handles\n ES:DI buffer contains (BX*4) bytes of data\n ──────────────────────────────────────────────────────────────────\n Info: Returns the size of allocations for all currently-open EMM\n handles.\n\n ES:DI on entry, the buffer at this address should be large enough to\n hold the returned data. You need 4 bytes for each handle. Use\n INT 67H 4c00H to see how many handles exist.\n\n On return, this buffer contains BX entries in the form:\n\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 2 wHandle the handle number\n +2 2 wAllocdPgs size of allocation, in 16K units\n 4 size of one record\n\nSee Also: INT 67H: EMM Services\n Extended Memory Specification (XMS)\n Interrupts and BIOS Services\n -♦-"
  },
  {
    "id": "664-int_67h_4exxh__get_set_entire_page_map.html",
    "t": "INT 67H 4exxH: Get/Set Entire Page Map",
    "b": "Compatibility: EMS 3.2+\n Expects: AH 4eH\n AL subfn: 00H=Get all mapping registers into ES:DI\n 01H=Set all mapping registers from data at DS:SI\n 02H=Swap all mapping registers (01H and 00H combined)\n 03H=Query size of buffer needed for fns 00H-02H\n ES:DI (subfns 00H and 02H) buffer to receive mapping registers\n DS:SI (subfns 01H and 02H) buffer containing mapping registers\n ──────────────────────────────────────────────────────────────────\n Returns: AH EMM status (0=successful)\n AL (subfn 03H) size, in bytes of buffer for mapping registers\n ES:DI (subfn 00H and 02H) buffer contains returned information\n ──────────────────────────────────────────────────────────────────\n Info: This fn is designed to support multi-tasking operating systems in\n order to more fully control EMS.\n\n This also provides a way to quickly map all four pages of EMS\n memory into the frame in one call. Just use INT 67H 44xxH four\n times to map four pages into memory, then use subfn 00H to save\n that state. Later, use subfn 01H to restore that state.\n\n ES:DI and DS:SI point to data buffers. Use subfn 03H to see how large\n the buffer should be.\n\n The mapping register data contains a variety of hardware-\n dependant information; its layout is not documented.\n\nSee Also: INT 67H: EMM Services\n Extended Memory Specification (XMS)\n Interrupts and BIOS Services\n -♦-"
  },
  {
    "id": "665-int_67h_4fxxh__get_set_partial_page_map.html",
    "t": "INT 67H 4fxxH: Get/Set Partial Page Map",
    "b": "Compatibility: EMS 4.0+\n Expects: AH 4fH\n AL subfn: 00H=Save some mapping registers\n DS:SI=list of registers to query\n ES:DI=buffer to receive data\n 01H=Restore some mapping registers\n DS:SI=data obtained via subfn 00H\n 02H=Query buffer size for subfns 00H and 01H\n BX=count of pages to be saved/restored\n ──────────────────────────────────────────────────────────────────\n Returns: AH EMM status (0=successful)\n AL (subfn 02H) size, in bytes of buffer for data buffers\n ES:DI (subfn 00H) buffer contains returned information\n ──────────────────────────────────────────────────────────────────\n Info: This fn is similar to INT 67H 4exxH, in that it saves/restores\n the page mapping registers. This version lets you specify a\n subset (e.g., save/restore just one or two pages).\n\n Before using subfn 4f00H, you should use subfn 4f02H to see how\n large of a buffer you will need.\n\n DS:SI (subfn 4f00H) is a list that identifies which mapping registers\n you wish to save. The list is formatted as:\n\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 2 wPgCnt number of 16K pages to save\n +2 2 wSeg1 segment of first physical pg to save\n +4 2 wSeg2 segment of second physical pg to save\n .\n :\n etc.\n\n ES:SI (subfn 4f00H) is a buffer to receive mapping-register data. You\n should use subfn 4f02H to see how large this should be.\n\nSee Also: INT 67H: EMM Services\n Extended Memory Specification (XMS)\n Interrupts and BIOS Services\n -♦-"
  },
  {
    "id": "666-int_67h_50xxh__map_unmap_multiple_pages.html",
    "t": "INT 67H 50xxH: Map/Unmap Multiple Pages",
    "b": "Compatibility: EMS 4.0+\n Expects: AH 50H\n AL subfn: 00H=Use page numbers\n DS:SI=list of LogicalPgNos/PhysicalPgNos\n 01H=Use physical segment addresses\n DS:SI=list of LogicalPgNos/Segments\n CX count of pages to map\n DX EMM Handle (as obtained via INT 67H 4300H)\n ──────────────────────────────────────────────────────────────────\n Returns: AH EMM status (0=successful)\n ──────────────────────────────────────────────────────────────────\n Info: This lets you map two or more pages of EMS into the EMS frame\n (you may use INT 67H 44xxH to map individual pages).\n\n AL=00H This version identifies the pages to map by using physical page\n numbers (for instance, 00H means the first 16K of the frame, 01H\n means the second, etc.)\n\n AL=01H This version identifies the pages to map by using segment\n addresses (for instance, d000H means the first 16K of the frame,\n d400H means the second, etc. -- assuming the EMS frame starts at\n d000:0)\n\n DS:SI points to a list that identifies which logical pages you want\n mapped into the frame. It is formatted as:\n\n EmsMapInfoRec\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 2 wLogPgNo 0000H-n (pages in the handle)\n +2 2 wFrameLoc1 identifies where to put the EMS page:\n subfn 00H: a frame page (usually 0-3)\n subfn 01H: a segment address\n +4 2 wFrameLoc2 identifies where to put another EMS page\n .\n :\n etc.\n\n Notes: ■ As with INT 67H 44xxH, you can unmap a page (making it\n inaccessible until remapped) by specifying a wLogPgNo of ffffH.\n\n To remap the page, use a valid wLogPgNo (e.g., a value in the\n range of the size of the handle).\n\n ■ When using subfn 5001H, the segment identified by wFrameLoc\n must be a valid segment value that matches the start of a 16K\n region within the EMS frame.\n\nSee Also: INT 67H: EMM Services\n Extended Memory Specification (XMS)\n Interrupts and BIOS Services\n -♦-"
  },
  {
    "id": "667-int_67h_5100h__resize_ems_handle.html",
    "t": "INT 67H 5100H: Resize EMS Handle",
    "b": "Compatibility: EMS 4.0+\n Expects: AX 5100H\n BX desired new size, in 16K pages\n DX EMM Handle (as obtained via INT 67H 4300H)\n ──────────────────────────────────────────────────────────────────\n Returns: AH EMM status (0=successful)\n ──────────────────────────────────────────────────────────────────\n Info: Expands or shrinks the size of an EMS allocation.\n\n When increasing the size of the allocation, the data in the\n currently-allocated pages is retained.\n\n Resizing to 0 (CX=0000H) does NOT free up a handle; be sure to\n free the handle (via fn INT 67H 4500H) before terminating your\n application.\n\nSee Also: INT 67H: EMM Services\n Extended Memory Specification (XMS)\n Interrupts and BIOS Services\n -♦-"
  },
  {
    "id": "668-int_67h_52xxh__get_set_handle_attribute.html",
    "t": "INT 67H 52xxH: Get/Set Handle Attribute",
    "b": "Compatibility: EMS 4.0+\n Expects: AH 52H\n AL subfn: 00H=Query handle attribute\n 01H=Set handle attribute\n 12H-Query capability\n DX EMM Handle (as obtained via INT 67H 4300H)\n ──────────────────────────────────────────────────────────────────\n Returns: AH EMM status (0=successful)\n AL (fn 5200H) attribute: 00H = volatile\n 01H = non-volatile (lives thru reboot)\n (fn 5202H) support: 00H = NO support for non-volatile pgs\n 01H = OK to tag as non-volatile\n ──────────────────────────────────────────────────────────────────\n Info: EMS 4.0 describes this system in which you can mark the pages of\n a handle as \"volatile\" and \"non-volatile\". Pages of a\n non-volatile handle will be intact after a warm boot.\n\n Most EMS cards and EMM emulators do not support this capability,\n so don't waste your time or mine.\n\nSee Also: INT 67H: EMM Services\n Extended Memory Specification (XMS)\n Interrupts and BIOS Services\n -♦-"
  },
  {
    "id": "669-int_67h_53xxh__get_set_handle_name.html",
    "t": "INT 67H 53xxH: Get/Set Handle Name",
    "b": "Compatibility: EMS 4.0+\n Expects: AH 53H\n AL subfn: 00H=Query handle name\n ES:DI addr of 8-byte buffer to receive name\n 01H=Set handle attribute\n DS:SI addr of 8-byte buffer containing name\n DX EMM Handle (as obtained via INT 67H 4300H)\n ──────────────────────────────────────────────────────────────────\n Returns: AH EMM status (0=successful)\n ES:DI (fn 5301H) contains current name of the handle\n ──────────────────────────────────────────────────────────────────\n Info: Named handles provide a means for separate applications to share\n information in EMS pages -- assuming both applications know the\n name.\n\n EMS handle names are 8 bytes long and may contain any values,\n 00H-ffH. A handle whose name is all 0s is considered to be\n unnamed.\n\n Notes: Use INT 67H 54xxH to get access to a named handle.\n\nSee Also: INT 67H: EMM Services\n Extended Memory Specification (XMS)\n Interrupts and BIOS Services\n -♦-"
  },
  {
    "id": "670-int_67h_54xxh__find_named_handle.html",
    "t": "INT 67H 54xxH: Find Named Handle",
    "b": "Compatibility: EMS 4.0+\n Expects: AH 54H\n AL subfn: 00H=Query handle directory\n ES:DI addr buffer to receive data\n 01H=Search for named handle\n DS:SI addr of 8-byte buffer containing name\n 02H=Count all open handles\n ──────────────────────────────────────────────────────────────────\n Returns: AH EMM status (0=successful)\n ES:DI (fn 5400H) contains returned data (see below)\n DX (fn 5401H) handle with specified name\n BX (fn 5402H) count of handles; use a buffer size of BX*10\n ──────────────────────────────────────────────────────────────────\n Info: This lets applications work together, sharing EMS pages, as long\n as each app knows an 8-character name.\n\n ES:DI (fn 5400H) returns with this buffer filled with EMS handle names.\n It is formatted as:\n\n EmsHandleNameRec\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 2 wHandle an EMM handle\n +2 8 abName 8-bytes of the name\n 10 size of one EmsHandleNameRec\n +0aH 2 wHandle2\n +0cH 8 abName\n .\n :\n etc.\n\n Before using fn 5400, use fn 5402H to see how large the buffer\n should be.\n\n Notes: Names can be any 8 byte. When a handle has a name of all 0s, it\n is considered to be unnamed. See INT 67H 53xxH (get/set name).\n\nSee Also: INT 67H: EMM Services\n Extended Memory Specification (XMS)\n Interrupts and BIOS Services\n -♦-"
  },
  {
    "id": "671-int_67h_55xxh__alter_page_map_and_jmp.html",
    "t": "INT 67H 55xxH: Alter Page Map and JMP",
    "b": "Compatibility: EMS 4.0+\n Expects: AH 55H\n AL subfn: 00H=Use page numbers in prMapInfo->wFrameLoc\n 01H=Use segment addresses in prMapInfo->wFrameLoc\n DS:SI address of an EmsMapAndJmpRec (see below)\n DX EMM Handle (as obtained via INT 67H 4300H)\n ──────────────────────────────────────────────────────────────────\n Returns: (none)\n ──────────────────────────────────────────────────────────────────\n Info: This lets you swap some pages of executable code into memory,\n then execute that code.\n\n DS:SI points to a structure that identifies which pages to map and\n where to jump. If is formatted as:\n\n EmsMapAndJmpRec\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 4 pCodeAddr FAR address to JMP\n +4 1 bPgCnt number of pages to map\n +5 4 prMapInfo FAR addr of an EmsMapInfoRec\n 9 size of this structure\n\n Depending upon AL, the wFrameLoc fields of the EmsMapInfoRec will\n contain either page numbers (usually 0-3) or segment address (for\n instance, d000H, d400H, etc).\n\n Notes: See INT 67H 50xxH (map multiple pages) for related info.\n\n This fn does not provide a mechanism to return control to the\n caller. Use INT 67H 56xxH (map and call) to CALL rather than\n JMP.\n\nSee Also: INT 67H: EMM Services\n Extended Memory Specification (XMS)\n Interrupts and BIOS Services\n -♦-"
  },
  {
    "id": "672-int_67h_56xxh__alter_page_map_and_call.html",
    "t": "INT 67H 56xxH: Alter Page Map and CALL",
    "b": "Compatibility: EMS 4.0+\n Expects: AH 55H\n AL subfn: 00H=Use page numbers in EmsMapInfoRec.wFrameLoc\n 01H=Use segment addresses in EmsMapInfoRec.wFrameLoc\n DS:SI address of an EmsMapAndCallRec (see below)\n DX EMM Handle (as obtained via INT 67H 4300H)\n ──────────────────────────────────────────────────────────────────\n Returns: AH EMM status (0=successful)\n ──────────────────────────────────────────────────────────────────\n Info: This lets you swap some pages of executable code into memory,\n then execute that code, as if you had used a FAR CALL. Upon\n return, the page mapping is restored to its previous state.\n\n DS:SI points to a structure that identifies which pages to map and\n where to jump. If is formatted as:\n\n EmsMapAndCallRec\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 4 pCodeAddr FAR address to JMP\n +4 1 bNewPgCnt number of pages to map\n +5 4 prNewMapInfo FAR addr of an EmsMapInfoRec\n containing desired mappings\n +9 1 bSavePgCnt number of pages\n +0aH 4 prSaveMapInfo FAR addr of an EmsMapInfoRec with\n mappings to restore upon return\n 14 size of this structure\n\n Depending upon AL, the wFrameLoc fields of the EmsMapInfoRec will\n contain either page numbers (usually 0-3) or segment address (for\n instance, d000H, d400H, etc).\n\n Notes: See INT 67H 50xxH (map multiple pages) for related info.\n\n Unlike INT 67H 55xxH (map and JMP), this returns a an EMM status\n code upon return.\n\n The executed code must use a FAR RET to get back to the caller.\n\nSee Also: INT 67H: EMM Services\n Extended Memory Specification (XMS)\n Interrupts and BIOS Services\n -♦-"
  },
  {
    "id": "673-int_67h_57xxh__move_exchange_memory.html",
    "t": "INT 67H 57xxH: Move/Exchange Memory",
    "b": "Compatibility: EMS 4.0+\n Expects: AH 57H\n AL subfn: 00H=Move memory\n 01H=Exchange memory\n DS:SI address of an EmsMoveInfoRec (see below)\n ──────────────────────────────────────────────────────────────────\n Returns: AH EMM status (0=successful; 92H is just a warning)\n ──────────────────────────────────────────────────────────────────\n Info: Use this to transfer blocks of memory into, out of, or within EMS\n memory or conventional memory. Segment overflow and overlapping\n moves are allowed; blocks as large as 1M are allowed.\n\n DS:SI points to a structure that describes the data to be\n moved/exchanged. If is formatted as:\n\n EmsMoveInfoRec\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 4 lRgnLength DWORD size, in bytes to move/xchg\n +4 1 bSrcType src type: 00H=conventional; 01H=EMS\n +5 2 wSrcHandle EMM Handle (or 0 if src in conv mem)\n +7 2 wSrcAddr src segment or page\n +9 2 wSrcOffset src offset within page or segment\n +0bH 1 bDestType dest type: 00H=conventional; 01H=EMS\n +0cH 2 wDestHandle EMM Handle (or 0 if dest in conv mem)\n +0eH 2 wDestAddr dest segment or page\n +10H 2 wDestOffset dest offset in page or segment\n 18 size of this structure\n\n Notes: a return code of 92H is not an error; just a warning.\n\nSee Also: INT 67H: EMM Services\n Extended Memory Specification (XMS)\n Interrupts and BIOS Services\n -♦-"
  },
  {
    "id": "674-int_67h_58xxh__get_mappable_physical_address_array.html",
    "t": "INT 67H 58xxH: Get Mappable Physical Address Array",
    "b": "Compatibility: EMS 4.0+\n Expects: AH 58H\n AL subfn: 00H=Get segment-to-page map array\n ES:DI = buffer to receive data\n 01H=Get count of segment-to-page array entries\n ──────────────────────────────────────────────────────────────────\n Returns: AH EMM status (0=successful)\n ES:DI (fn 5800H) buffer contains data (see below)\n CX (fn 5801H) count of entries (buffer size is CX * 4)\n ──────────────────────────────────────────────────────────────────\n Info: This obtains a cross-reference between all EMS page numbers and\n the segments at which they are physically located.\n\n ES:DI (fn 5800H) on entry, this buffer must be (n * 4) bytes long.\n Obtain n by using fn 5801H.\n\n On return, this buffer contains n 4-byte entries formatted as:\n\n EmsSegToPgMapRec\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 2 wSeg segment address (conv mem or EMS frame)\n +2 2 wPgNo EMS page number\n 4 size of one EmsSegToPgMapRec\n\n +4 2 wSeg2\n +6 2 wPgNo2\n .\n :\n etc.\n\n Notes: All of the wSeg values are mappable memory segments. On 386-\n based emulators, the lowest of these segments may be in\n conventional memory, there may be some gaps, and four pages will\n exist in the EMS frame.\n\n On 8088 CPUs with physical LIM-EMS hardware, this usually returns\n just four entries--mapping the EMS frame.\n\nSee Also: INT 67H: EMM Services\n Extended Memory Specification (XMS)\n Interrupts and BIOS Services\n -♦-"
  },
  {
    "id": "675-int_67h_59xxh__get_hardware_configuration.html",
    "t": "INT 67H 59xxH: Get Hardware Configuration",
    "b": "Compatibility: EMS 4.0+\n Expects: AH 59H\n AL subfn: 00H=Get hardware Info\n ES:DI = buffer to receive data\n 01H=Get unallocated raw page count\n ──────────────────────────────────────────────────────────────────\n Returns: AH EMM status (0=successful)\n ES:DI (fn 5900H) buffer contains data (see below)\n BX (fn 5901H) unallocated raw pages\n DX (fn 5901H) total raw pages\n ──────────────────────────────────────────────────────────────────\n Info: This is designed for use by operating systems only and may be\n disabled at any time.\n\n It obtains hardware-related info and info on \"raw pages\" (that\n is, pages that are not 16K -- used on a rarely-seen EMS board).\n\n ES:DI (fn 5900H) on entry, this points to a 10-byte buffer. On return,\n it is filled with data, formatted as:\n\n EmsHardwareInfoRec\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 2 wRawPgParas size of a raw page, in 16-byte units\n +2 2 wAltRegSets number of extra mapping reg sets\n +4 2 wSaveSize size of buffer needed for saving mapping\n context; also returned by INT 67H 4e03H\n +6 2 wDMAChnls number reg sets to handle DMA\n +8 2 wDMAOddball 0=normal; 1=non-standard DMA handling\n 10 size of this structure\n\n BX,DX (fn 5901H) On nearly all hardware implementation of LIM-EMS,\n pages are exactly 16K. One oddball allows for \"raw\" pages of\n smaller pages (submultiples of 16K).\n\n In most cases, these return the same as from INT 67H 4200H.\n\nSee Also: INT 67H: EMM Services\n Extended Memory Specification (XMS)\n Interrupts and BIOS Services\n -♦-"
  },
  {
    "id": "676-int_67h_5axxh__allocate_standard_or_raw_pages.html",
    "t": "INT 67H 5axxH: Allocate Standard or Raw Pages",
    "b": "Compatibility: EMS 4.0+\n Expects: AH 5aH\n AL subfn: 00H=Allocate standard 16K pages\n BX = desired number of standard pages\n 01H=Allocate raw pages\n BX = desired number of raw pages\n ──────────────────────────────────────────────────────────────────\n Returns: AH EMM status (0=successful)\n DX EMM Handle\n ──────────────────────────────────────────────────────────────────\n Info: This is designed for use by operating systems only and may be\n disabled at any time.\n\n This allocates EMS memory, as with INT 67H 4300H, but can\n allocate \"raw\" pages (other than 16K) on the rare EMS board that\n supports that oddness.\n\nSee Also: INT 67H: EMM Services\n Extended Memory Specification (XMS)\n Interrupts and BIOS Services\n -♦-"
  },
  {
    "id": "677-int_67h_5bxxh__alternate_map_register_set.html",
    "t": "INT 67H 5bxxH: Alternate Map Register Set",
    "b": "Compatibility: EMS 4.0+\n Expects: AH 5bH\n AL subfn: 00H=Query alternate map register set\n 01H=Set alternate map register set\n BL = new alternate map register set number\n ES:DI => buffer to receive data\n 02H=Query alternate map register set array size\n 03H=Allocate alternate map register set\n 04H=Deallocate alternate map register set\n 05H=Allocate DMA register set\n 06H=Enable DMA on alternate map register set\n BL = DMA register set number\n DL = DMA channel number\n ES:DI => buffer to receive data\n 07H=Disable DMA on alternate map register set\n BL = alternate map register set number\n 08H=Deallocate DMA register set\n BL = DMA register set number\n ──────────────────────────────────────────────────────────────────\n Returns: AH EMM status (0=successful)\n BL (5b00H) current active alternate register map set\n (5b03H) alternate map registers set number\n (5b05H) DMA register set number\n ES:DI (5b00H) map register context save area (if BL=0)\n DX (5b02H) size of array\n ──────────────────────────────────────────────────────────────────\n Info: This is designed for use by operating systems only and may be\n disabled at any time.\n\n These fns are used by an operating system in support of low-level\n functions such as tampering with DMA.\n\nSee Also: INT 67H: EMM Services\n Extended Memory Specification (XMS)\n Interrupts and BIOS Services\n -♦-"
  },
  {
    "id": "678-int_67h_5c00h__prepare_for_warm_boot.html",
    "t": "INT 67H 5c00H: Prepare for Warm Boot",
    "b": "Compatibility: EMS 4.0+\n Expects: AX 5c00H\n ──────────────────────────────────────────────────────────────────\n Returns: AH EMM status (0=successful)\n ──────────────────────────────────────────────────────────────────\n Info: This is designed for use by operating systems only and may be\n disabled at any time.\n\n This fn warns the EMM that the system is about to reboot. A very\n few hardware-based EMS implementations can maintain valid data\n across a warm boot.\n\n See INT 67H 52xxH (get/set handle attribute).\n\nSee Also: INT 67H: EMM Services\n Extended Memory Specification (XMS)\n Interrupts and BIOS Services\n -♦-"
  },
  {
    "id": "679-int_67h_5dxxh__enable_disable_os_function_set_functions.html",
    "t": "INT 67H 5dxxH: Enable/Disable OS Function Set Functions",
    "b": "Compatibility: EMS 4.0+\n Expects: AX 5dH\n AL subfn: 00H=Enable all OS-only EMM functions\n 01H=Disable all OS-only EMM functions\n 02H=Free access key (enable next caller to get a key)\n BX,CX access key\n ──────────────────────────────────────────────────────────────────\n Returns: AH EMM status (0=successful)\n BX,CX (fns 5d00H and 5d01H) access key (returned only the first\n time called or after using fn 5d02H).\n ──────────────────────────────────────────────────────────────────\n Info: These fns are used by an operating system in an effort to keep\n programs from performing certain OS-level EMS operations. It is\n not to be used by applications.\n\n The first call to fns 5d00H or 5d01H obtain a 32-bit value which\n must be used in subsequent calls to 5dxxH fns.\n\nSee Also: INT 67H: EMM Services\n Extended Memory Specification (XMS)\n Interrupts and BIOS Services\n -♦-"
  },
  {
    "id": "680-emm_status.html",
    "t": "EMM Status",
    "b": "Upon return from an INT 67h request to the Expanded Memory Manager, the\n AH register always contains a status/error code. If the status is not 0,\n then the requested function was not performed and any values returned by\n EMM are meaningless. These errors are defined:\n\n Status Meaning\n ▀▀▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n 0 no error; function was successful; returned parms are OK\n\n 80H internal error in EMM driver\n 81H EMS memory board hardware malfunction\n 82H EMM is busy\n 83H invalid handle\n 84H undefined function requested\n 85H no more EMM handles available\n 86H error in save or restore of mapping context\n 87H allocation request was larger than total EMS memory\n 88H allocation request was larger than available pages\n 89H you can't open a handle with a page count of 0\n 8aH your handle doesn't own that many pages\n 8bH illegal mapping. Only physical pages 0-3 are defined\n 8cH mapping context save area is full\n 8dH you can save context only once per handle\n 8eH you can't restore context without a prior save\n 8fH Subfunction parameter in AL not defined\n ────────────────────────────────────────────── (EMS 4.0 codes)\n 90H attribute type undefined\n 91H non-volatility not supported\n 92H source and dest overlap in EMS RAM (warning, not error)\n 93H destination area in handle too small\n 94H conventional memory overlaps EMS RAM\n 95H offset too large in block move\n 96H block size too large; ie, > 1M\n 97H source and dest are in same handle and overlap\n 98H source or dest memory type invalid (in offset 4 of packet)\n 9aH alternate map register set in not supported\n 9bH all alternate map/DMA register sets are all allocated\n 9cH all alternate map/DMA register sets are not supported\n 9dH specified alternate map/DMA register set invalid or in use\n 9eH dedicated DMA channels are not supported\n 9fH specified DMA channel is not supported\n a0H no handle matches specified name\n a1H the specified name already exists\n a2H source offset+region length > 1M (attempted to wrap)\n a3H contents of specified data packet are corrupted or invalid\n a4H access to this function has been denied (bad access key)\n\nSee Also: INT 67H: EMM Services\n -♦-"
  },
  {
    "id": "681-int_2fh__multiplex_interrupt.html",
    "t": "INT 2fH: Multiplex Interrupt",
    "b": "The INT 2fH vector (at 0000:00bc) is a portal to many varied services;\n some installed by DOS and others by device drivers, utility programs,\n Windows, etc. It is sometimes call the Multiplex or MUX Interrupt.\n TECH Help! covers the following INT 2fH services:\n\n AX DOS 5.0 TSRs & drivers AX Defined elsewhere in TECH Help!\n ▀▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀ ▀▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n 01xxH Print spooler services 4a11H DoubleSpace API services\n 0600H Assign installed?\n 1000H Share installed? 16xxH Windows 386Enh-Mode services\n 1100H is network installed?\n 1400H Nlsfunc installed? 17xxH Windows Clipboard access\n 15xxH Mscdex services\n 1680H AppIdle Release timeslice 40xxH Windows VDD fns for VM-aware apps\n 1a00H ANSI.SYS installed?\n 43xxH HIMEM.SYS / XMS Services\n 48xxH Doskey services xxfbH FaxBIOS Services\n 4axxH HMA Allocations (undoc'd)\n 4bxxH Dosshell / Switcher API\n 54xxH POWER.EXE (undocumented)\n adxxH Keyb services\n aexxH COMMAND.COM hook services\n b000H Graftabl installed?\n b7xxH Append services\n\n TSR programs and device drivers intercept INT 2fH to install themselves\n into the \"mux-process chain\". Later, another program may use INT 2fH to\n see if that TSR has been installed and to request various services.\n\n█▌DOS Versions▐█\n INT 2fH is not defined for version prior to DOS 3.0. In DOS 3.0, INT 2fH\n is defined ONLY for the print spooler and the value of AH (which is now\n critical) had no meaning.\n\n The various services may or may not be available with a particular version\n of DOS, since they are supplied by external programs. For instance, the\n Windows clipboard fns are available on any DOS version which can run\n Windows 3.0 or later, but only while Windows is running.\n\n█▌Accessing MUX Services▐█\n To use a service, load AH with the mux ID and load AL with the fn number,\n load other registers as needed, and invoke INT 2fH.\n\n Nearly all INT 2fH handlers support fn AL=0 to mean \"check to see if the\n service is installed\". The service is installed if AL=ffH on return.\n Note that just checking AL may not be sufficient, since any program can\n hook into the chain. See below.\n\n Mux IDs AH=00H through AH=bfH are reserved by Microsoft. Other\n applications can hook into the chain using values from c0H-ffH.\n\n█▌Creating Your Own MUX Process▐█\n INT 2fH can be used as a gateway for installing and communicating with\n your own TSR programs. The idea is to avoid forcing programmers to pick\n arbitrary interrupt vectors for use in communication with installed TSRs.\n\n To install a MUX process: Install an INT 2fH handler by saving the\n current vector and installing a vector to your code via DOS Fns 35H\n and 25H. Your handler watches for its MUX number (in AH) and on\n calls which specify any other MUX number, passes control to the saved\n vector via a FAR JMP. If nothing else, you can use this technique to\n check if your TSR has been installed previously (when executed, do an\n INT 2fH with AH=yourMuxNumber and AL=0).\n\n Mux numbers 00H-bfH are reserved by DOS. You may pick any number\n between c0H and ffH. However, there is some danger that another\n application is using you Mux ID. The recommended way to avoid this\n problem is:\n\n 1 Use INT 2FH with AL=0, starting with AH=ffH. If upon return, you\n don't get back your own unique return code, then keep trying lower\n mux IDs, working down to AH=c0H.\n\n 2 If you never find your own process, then you know you have not been\n installed. Otherwise, pick one of the mux IDs which was not used (an\n unused mux ID will leave AX unchanged after INT 2fH).\n\n 3 Hook into the INT 2fH chain. Your code should check for you Mux ID\n in AH, and when AL is 0, should return ffH in AL, and some uniquely-\n identifying code in other registers (so that step 1, above, can\n recognize your mux process).\n\n ■ When you later use INT 2Fh to access your own service, you must use\n logic similar to that in step 1, since you won't know your Mux ID in\n advance.\n\n Note: If your mux process uses DOS services or runs with interrupts\n enabled, you should make your process re-entrant.\n\nSee Also: DOS Interrupts\n DOS Functions\n Device Drivers\n -♦-"
  },
  {
    "id": "682-int_2fh_01xxh__dos_print_spooler_functions.html",
    "t": "INT 2fH 01xxH: DOS Print Spooler Functions",
    "b": "Compatibility: 3.0+\n See: 0100H (get installed state)\n\n 0101H (submit file to spooler)\n\n 0102H (cancel specified files)\n\n 0103H (cancel all files)\n\n 0104H (hold jobs and query status)\n\n 0105H (continue printing)\n\n 0106H (get printer device header)\n\nSee Also: INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "683-int_2fh_0100h__is_print_exe_installed_.html",
    "t": "INT 2fH 0100H: Is Print.Exe Installed?",
    "b": "Compatibility: 3.0+\n Expects: AX 0100H\n ──────────────────────────────────────────────────────────────────\n Returns: AL status: 00H = is not installed\n ffH = is installed\n ──────────────────────────────────────────────────────────────────\n Info: Checks to see if PRINT.EXE has been executed and is resident in\n memory.\n\n Notes: The DOS print spooler is a dinosaur and has very little actual\n value.\n\nSee Also: INT 2fH 01xxH: DOS Print Spooler Functions\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "684-int_2fh_0101h__submit_file_to_spooler.html",
    "t": "INT 2fH 0101H: Submit File to Spooler",
    "b": "Compatibility: 3.0+\n Expects: AX 0101H\n DS:DX addr of an AddFileRec (see below) describing file to enqueue\n ──────────────────────────────────────────────────────────────────\n Returns: AX error code (if CF=CY)\n ──────────────────────────────────────────────────────────────────\n Info: Enqueues a file for background printing (only if PRINT.EXE is\n resident in memory.\n\n DS:DX is the address of a data packet formatted as follows:\n\n AddFileRec\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 1 bLevel must be 00H)\n +1 4 pfszFilespec Far address of an ASCIIZ▲ filespec\n of the file to print. No wildcards.\n 5 size of an AddFileRec\n\n Note: A Microsoft Technote warns users of this fn to use only \"well-\n formed\" (fully-qualified) filespecs of files that already exist.\n PRINT does not perform error checking.\n\nSee Also: INT 2fH 01xxH: DOS Print Spooler Functions\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "685-int_2fh_0102h__remove_file_from_print_queue.html",
    "t": "INT 2fH 0102H: Remove File from Print Queue",
    "b": "Compatibility: 3.0+\n Expects: AX 0102H\n DS:DX address of an ASCIIZ▲ string of a filespec to remove from\n the print queue. It may contain wildcards▲ (to remove\n multiple files from the queue).\n ──────────────────────────────────────────────────────────────────\n Returns: AX error code (if CF=CY)\n ──────────────────────────────────────────────────────────────────\n Info: Removes one or more files that have been added to the Print queue\n (only if PRINT.EXE is resident in memory).\n\nSee Also: INT 2fH 01xxH: DOS Print Spooler Functions\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "686-int_2fh_0103h__cancel_all_files.html",
    "t": "INT 2fH 0103H: Cancel All Files",
    "b": "Compatibility: 3.0+\n Expects: AX 0103H\n ──────────────────────────────────────────────────────────────────\n Returns: none\n ──────────────────────────────────────────────────────────────────\n Info: Stops the current print job and removes all files from the print\n queue (only if PRINT.EXE is resident in memory).\n\nSee Also: INT 2fH 01xxH: DOS Print Spooler Functions\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "687-int_2fh_0104h__hold_all_jobs_and_get_status.html",
    "t": "INT 2fH 0104H: Hold All Jobs and Get Status",
    "b": "Compatibility: 3.0+\n Expects: AX 0104H\n ──────────────────────────────────────────────────────────────────\n Returns: DX error count (consecutive errors Print had while trying to\n output last character)\n DS:SI addr of a series of 64-byte filespecs naming enqueued files\n ──────────────────────────────────────────────────────────────────\n Info: Stops the current print job and returns the address of the print\n queue (only if PRINT.EXE is resident in memory.\n\n DS:SI is the far address of a series of 64-byte entries that identify\n the files that are in the queue. Each entry is an ASCIIZ▲ string\n of the drive, path, and filename, followed by a variable number\n of unused bytes (to pad the record to 64).\n\n The first entry is the name of the file that is currently being\n printed. The end of the queue is identified if the first byte in\n the entry is 00h.\n\n Notes: Printing is suspended until you use INT 2fH 0105H (restart\n queue).\n\n Don't modify the queue directly. Use INT 2fH fns to add and\n delete files.\n\nSee Also: INT 2fH 01xxH: DOS Print Spooler Functions\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "688-int_2fh_0105h__resume_printing.html",
    "t": "INT 2fH 0105H: Resume Printing",
    "b": "Compatibility: 3.0+\n Expects: AX 0105H\n ──────────────────────────────────────────────────────────────────\n Returns: none\n ──────────────────────────────────────────────────────────────────\n Info: After using INT 2fH 0105H (hold print queue/get status), this\n resume printing at the first job in the print queue.\n\nSee Also: INT 2fH 01xxH: DOS Print Spooler Functions\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "689-int_2fh_0106h__get_printer_device_driver_header.html",
    "t": "INT 2fH 0106H: Get Printer Device Driver Header",
    "b": "Compatibility: 3.0+\n Expects: AX 0106H\n ──────────────────────────────────────────────────────────────────\n Returns: AX 0000H and CF=NC=0 if the queue is currently empty\n or error code (if CF=CY)\n DS:SI the address of the DevHdrRec of the device driver that is\n currently in use by Print.Exe for print spooling.\n ──────────────────────────────────────────────────────────────────\n Info: This provides a way to ascertain the name and other attributes of\n the device that is in use for print spooling.\n\nSee Also: INT 2fH 01xxH: DOS Print Spooler Functions\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "690-int_2fh_0600h__is_assign_com_installed_.html",
    "t": "INT 2fH 0600H: Is Assign.Com Installed?",
    "b": "Compatibility: 3.0+\n Expects: AX 0600H\n ──────────────────────────────────────────────────────────────────\n Returns: AL status: 00H = is not installed\n ffH = is installed\n ──────────────────────────────────────────────────────────────────\n Info: Checks to see if the DOS Assign.Com program has been executed and\n is resident in memory.\n\nSee Also: INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "691-int_2fh_1000h__is_share_exe_installed_.html",
    "t": "INT 2fH 1000H: Is Share.Exe Installed?",
    "b": "Compatibility: 3.0+\n Expects: AX 1000H\n ──────────────────────────────────────────────────────────────────\n Returns: AL status: 00H = is not installed\n ffH = is installed\n ──────────────────────────────────────────────────────────────────\n Info: Checks to see if the DOS SHARE.EXE program (which provides file-\n locking functions) has been executed and is resident in memory.\n\n Notes: Windows (and maybe others) intercept this vector and always\n return a non-zero.\n\n To really check to see if file-sharing support is installed, try\n locking a file via DOS fn 5cH and check the error/return code.\n\nSee Also: INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "692-int_2fh_1100h__is_network_support_installed_.html",
    "t": "INT 2fH 1100H: Is Network Support Installed?",
    "b": "Compatibility: 3.0+\n Expects: AX 1100H\n ──────────────────────────────────────────────────────────────────\n Returns: AL status: 00H = is not installed\n ffH = is installed\n ──────────────────────────────────────────────────────────────────\n Info: Checks to see if network support code has been installed and is\n resident in memory.\n\nSee Also: INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "693-int_2fh_1400h__is_nlsfunc_exe_installed_.html",
    "t": "INT 2fH 1400H: Is Nlsfunc.Exe Installed?",
    "b": "Compatibility: 3.0+\n Expects: AX 1400H\n ──────────────────────────────────────────────────────────────────\n Returns: AL status: 00H = is not installed\n ffH = is installed\n ──────────────────────────────────────────────────────────────────\n Info: Checks to see if NLSFUNC.EXE (National Language Support provider)\n has been executed and is resident in memory.\n\nSee Also: INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "694-int_2fh_15xxh__mscdex_cd_rom_functions.html",
    "t": "INT 2fH 15xxH: Mscdex CD-ROM Functions",
    "b": "Compatibility: 6.0+\n See: 1500H (get installed state / count drives)\n\n 150DH (query CD-ROM drive letters)\n\nSee Also: INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "695-int_2fh_1500h__is_mscdex_installed__count_drive_letters.html",
    "t": "INT 2fH 1500H: Is MSCDEX Installed?/Count Drive Letters",
    "b": "Compatibility: 6.0+\n Expects: AX 1500H\n BX 0000H\n ──────────────────────────────────────────────────────────────────\n Returns: BX number of CD-ROM drive letters (0=not installed)\n ──────────────────────────────────────────────────────────────────\n Info: Checks to see if MSCDEX.EXE (the Microsoft CD-ROM support driver)\n has been installed and returns the number of drive letters in use\n by CD-ROMs.\n\n Use INT 2fH 150dH (query CD-ROM drive letters) to learn which\n drive letters that are in use.\n\nSee Also: INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "696-int_2fh_150dh__query_cd_rom_drive_letters.html",
    "t": "INT 2fH 150dH: Query CD-ROM Drive Letters",
    "b": "Compatibility: 6.0+\n Expects: AX 150dH\n ES:BX address of buffer to receive drive letters\n ──────────────────────────────────────────────────────────────────\n Returns: ES:BX buffer contains data\n ──────────────────────────────────────────────────────────────────\n Info: Obtains a list of DOS logical drive letters that are mapped to\n CD-ROMs.\n\n ES:BX on entry, this buffer must be at least as long, in bytes, as the\n value obtained by a previous call to INT 2fH 1500H (count\n drives).\n\n On return, the buffer contains a series of one-byte values\n identifying the CD-ROM drives, where 0=A, 1=B, 2=C, etc.\n\n For instance, if there are two CD-ROM drives, and ES:[BX+0]=0cH\n and ES:[BX+1]=12H, then drives M and S are CD-ROMs (i.e.,\n 'A'+0cH='M' and 'A'+12H='S').\n\nSee Also: INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "697-int_2fh_1a00h__is_ansi_sys_installed_.html",
    "t": "INT 2fH 1a00H: Is ANSI.SYS Installed?",
    "b": "Compatibility: 3.0+\n Expects: AX 1a00H\n ──────────────────────────────────────────────────────────────────\n Returns: AL status: 00H = is not installed\n ffH = is installed\n ──────────────────────────────────────────────────────────────────\n Info: Checks to see if the ANSI.SYS console device driver has been\n installed (via CONFIG.SYS) and is resident in memory.\n\n Use this before assuming that ANSI Console Escape Sequences will\n work.\n\nSee Also: INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "698-int_2fh_43xxh__himem_sys__extended_memory_manager__services.html",
    "t": "INT 2fH 43xxH: HIMEM.SYS (Extended Memory Manager) Services",
    "b": "Compatibility: 3.0+\n See: INT 2fH 4300H (is HIMEM.SYS installed?)\n\n INT 2fH 4310H (get XMM entry address)\n\n XMS Functions (services available via XMM entry address)\n\nSee Also: Extended Memory Specification (XMS Overview)\n Expanded Memory Specification (EMS Overview)\n DOS Protected Mode Interface (DPMI API Functions)\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "699-int_2fh_4300h__is_himem_sys__xms_support__installed_.html",
    "t": "INT 2fH 4300H: Is HIMEM.SYS (XMS Support) Installed?",
    "b": "Compatibility: 3.0+\n Expects: AX 4300H\n ──────────────────────────────────────────────────────────────────\n Returns: AL status: 00H = is not installed\n 80H = is installed\n ──────────────────────────────────────────────────────────────────\n Info: Checks to see if HIMEM.SYS or compatible XMS provider has been\n loaded in CONFIG.SYS and is resident in memory.\n\n To access XMS services, use INT 2fH 4310H (get XMM entry address)\n and place FAR calls to the entry address returned by that fn.\n\n See Extended Memory Specification for info on XMS services.\n\nSee Also: INT 2fH 43xxH: HIMEM.SYS Functions\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "700-int_2fh_4310h__get_himem_sys__xmm__entry_address.html",
    "t": "INT 2fH 4310H: Get HIMEM.SYS (XMM) Entry Address",
    "b": "Compatibility: 3.0+\n Expects: AX 4310H\n ──────────────────────────────────────────────────────────────────\n Returns: ES:BX far address of the XMS function dispatcher\n ──────────────────────────────────────────────────────────────────\n Info: Obtains the address of the XMS function dispatcher, though which\n all eXtended Memory Specification services are accessed.\n\n Before using this fn, use INT 2fH 4300H to check to see if the\n XMS provider has been installed.\n\n See Extended Memory Specification (XMS) for information on how to\n access XMS services and a description of the available fns.\n\n Example: ;--------------- check for and access an EMM fn\n dd pfEmmFns ;will hold 32-bit segment:offset addr\n .\n .\n .\n mov ax,4300H\n int 2fH\n cmp al,80H ;is support present?\n jne no_ems ; no, go\n\n mov ax,4310H ;get entry address\n int 2fH\n mov word ptr [pfEmmFns],bx\n mov word ptr [pfEmmFns+2],es\n ;--------------- now call a service\n mov ah,00H ;get XMS version\n call [pfEmmFns] ; this is a far call\n ;--------------- on most calls, check for AX=0001 (error)\n\nSee Also: INT 2fH 43xxH: HIMEM.SYS Functions\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "701-int_2fh_48xxh__doskey_com_functions.html",
    "t": "INT 2fH 48xxH: DOSKEY.COM Functions",
    "b": "Compatibility: 3.0+\n See: 4800H (is DOSKEY.COM installed?)\n\n 4810H (get keyboard input / expand macro)\n\nSee Also: INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "702-int_2fh_4800h__is_doskey_com_installed_.html",
    "t": "INT 2fH 4800H: Is DOSKEY.COM Installed?",
    "b": "Compatibility: 5.0+\n Expects: AX 4800H\n ──────────────────────────────────────────────────────────────────\n Returns: AL status: 00H = Doskey is not installed\n else= Doskey is installed\n ──────────────────────────────────────────────────────────────────\n Info: Checks to see if the DOS 5.0+ DOSKEY.COM keyboard utility has\n been installed and is resident in memory.\n\n The only access to Doskey services is via INT 2fH 4810H, which\n will get a line of text input (using Doskey editing keys) and\n expand a string of text into its Doskey-macro equivalent.\n\nSee Also: INT 2fH 48xxH (Doskey Functions)\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "703-int_2fh_4810h__get_keyboard_input_with_doskey_editing.html",
    "t": "INT 2fH 4810H: Get Keyboard Input with Doskey Editing",
    "b": "Compatibility: 5.0+\n Expects: AX 4810H\n DS:DX address of special-format 128-byte buffer to hold input\n ──────────────────────────────────────────────────────────────────\n Returns: AX status: 00H =success and...\n DS:DX buffer contains input text or\n DS:DX[+1] contains 00H (means macro name was\n used; call again to expand the macro)\n else =unsuccessful (bad input parms)\n ──────────────────────────────────────────────────────────────────\n Info: This fn performs two services:\n\n ■ Gets up to 126 bytes of text input from the keyboard (it can\n edit an existing line of text, too).\n\n It recognizes and handles all of the Doskey editing keys,\n including arrow keys, F8 to search the history list, etc.\n\n ■ Expands a Doskey macro to process parameters such as $1, or $*,\n etc.\n\n DS:DX On entry, this points to a buffer formatted as a DkLineRec:\n\n DkLineRec\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 1 bBufMax must be 80H\n +1 1 bTextLen size of input text less the CR at end\n +2 126 abText area to hold input text\n 128 size of a DkLineRec structure\n\n The bBufMax field must contain 80H. The bTextLen must be the\n length of the current line of text (use 00H to input new text).\n For instance,\n\n db 80H,00H, 126 dup (0)\n\n On return, bTextLen will contain the length of the input, not\n including a CR (ASCII 0dH) which is appended to the end. And\n abText will contain the characters of the input text.\n\n If, the user started the line with the name of a Doskey macro.\n then this fn set bTextLen to 00h. In that case, you should\n immediately call this fn again to obtain the expanded text of the\n macro. In that case, this fn displays the expanded text and\n places its size in bTextLen and the text itself in abText.\n\n Notes: ■ Doskey does not initially display abText. When using this fn\n to edit an existing line of text (i.e., when bTextLen is non-\n zero on entry), you may want to use DOS fn 09H or 40H to\n display the text before calling.\n\n ■ There appears to be no way to differentiate between the case\n where the user typed Enter only and the case where the user\n typed a macro name.\n\n ■ All Doskey keystrokes are supported, including those that\n handle command-line history (such as up arrow to see\n previously-typed commands). When the user inputs text, that\n line is added to the command-line history. If you expect to\n process macros, you must always call this fn again when the\n bTextLen comes back containing 00H.\n\n ■ Be sure to use INT 2fH 4800H to verify that Doskey is loaded\n before using this fn.\n\nSee Also: INT 2fH 48xxH (Doskey Functions)\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "704-int_2fh_4axxh__hma_suballocations.html",
    "t": "INT 2fH 4AxxH: HMA Suballocations",
    "b": "Compatibility: ◄Undoc► 5.0+\n\n See: 4a01H (Get HMA Free Space)\n\n 4a02H (Allocate HMA Space)\n\n XMS 05H Local enable A20\n XMS 06H Local disable A20\n XMS 07H Query A20 state\n\n 3306H DOS function to see if DOS is loaded in the HMA.\n\n The INT 2Fh 4axxH functions are undocumented through DOS 6.2 but have\n been available since DOS 5.0 added the DOS=HIGH command to CONFIG.SYS.\n They provide a means to allocate memory in the HMA▲, but only when DOS is\n loaded high and it is not using the entire 64K of the HMA.\n\n The BUFFERS= setting the CONFIG.SYS soaks up the free space. If BUFFER=\n is small, there may be as much as 16K of HMA available.\n\n The DOS 6.2 version of DoubleSpace will automatically use about 12K of the\n space (if that much is available). The DBLSPACE.SYS \"driver\" moves the\n MRCI engine there by (when you don't use the /NOHMA option).\n\n The One Owner Rule\n HIMEM.SYS allocates the entire 64K-16 bytes of the HMA in one block (see\n XMS 01H), so it is said that the HMA can have only one owner. These\n suballocations do not violate this rule -- DOS owns the entire HMA, it\n just leases out the part that it doesn't need to whoever requests it.\n\n No Deallocation Service\n DOS does not provide a means to free up the part of the HMA that you\n allocate. There appears to be no \"allocation chain\" or \"memory control\n blocks\". It simply maintains an internal pointer to the first free byte,\n and allocates from that point upward.\n\nSee Also: INT 2fH: Multiplex Interrupt\n Extended Memory Specification (XMS)\n DOS Functions\n -♦-"
  },
  {
    "id": "705-int_2fh_4a01h__query_hma_free_space_and_address.html",
    "t": "INT 2fH 4a01H: Query HMA Free Space and Address",
    "b": "Compatibility: ◄Undoc► 5.0+\n Expects: AX 4a01H ◄Undocumented►\n ──────────────────────────────────────────────────────────────────\n Returns: ES:DI Address of free space in the HMA▲\n BX Available HMA space, in bytes\n ──────────────────────────────────────────────────────────────────\n Info: Applications, device drivers, and TSRs may use this function as\n the first step in obtaining a smallish chunk of memory outside of\n conventional memory without using any UMB▲ space.\n\n On return, BX describes how much available memory there is in the\n HMA and ES:DI has its address.\n\n If DOS is not loaded high (see DOS=HIGH), then BX returns with\n 0000H and ES:DI returns with FFFF:FFFF.\n\n After determining if there is enough memory for your needs (there\n may be as much as about 16K or as little as 0, see Notes), use\n INT 2fH 4a02H to allocate the desired amount.\n\n Notes: ■ This service is undocumented, but has been available since\n DOS 5.0.\n\n ■ The BUFFERS= setting eats up the available HMA space, so there\n may be verry little free by the time you request it.\n\n ■ The DBLSPACE.SYS \"device driver\" for DOS 6.2 uses about 12K of\n the HMA (unless the /NOHMA option is used). Thus, on many\n systems, as little as 2K-4K will be free.\n\n ■ Before accessing the HMA addreses, be sure that A20 is enabled.\n See XMS 07H. It is normally enabled all of the time when DOS\n is high.\n\n ■ You may use DOS fn 3306H as an independent check to see if\n DOS is loaded in the HMA. Some other driver or TSR might\n own the HMA and intercept INT 2fH 4axxH and provide its own\n suballocation system.\n\nSee Also: INT 2fH: Multiplex Interrupt\n Extended Memory Specification (XMS)\n DOS Functions\n -♦-"
  },
  {
    "id": "706-int_2fh_4a02h__suballocate_hma_memory.html",
    "t": "INT 2fH 4a02H: Suballocate HMA Memory",
    "b": "Compatibility: ◄Undoc► 5.0+\n Expects: AX 4a02H ◄Undocumented►\n BX Requested size, in bytes\n ──────────────────────────────────────────────────────────────────\n Returns: ES:DI Address of free space in the HMA▲\n FFFF:FFFF (error) DOS is not high or insufficient memory\n ──────────────────────────────────────────────────────────────────\n Info: Applications, device drivers, and TSRs may use this function as\n to obtain a smallish chunk of memory outside of conventional\n memory without using any UMB▲ space.\n\n On return, ES:DI is the address of the allocation, if the request\n succeeded. If DOS is not loaded high (so this fn is not\n supported) of if BX is larger than the available HMA space, then\n ES:DI returns with FFFF:FFFF.\n\n Before attempting this call, use INT 2fH 4a01H to check how much\n HMA space is available.\n\n Notes: ■ This service is undocumented, but has been available since\n DOS 5.0.\n\n ■ Before accessing the HMA addreses, be sure that A20 is enabled.\n See XMS 07H. It is normally enabled all of the time when DOS\n is high. When using an HMA suballocation in a TSR or device\n driver, you should be sure to restore the stat of the A20\n before terminating or otherwise releasing control.\n\nSee Also: INT 2fH: Multiplex Interrupt\n Extended Memory Specification (XMS)\n DOS Functions\n -♦-"
  },
  {
    "id": "707-int_2fh_4bxxh__task_switcher_functions.html",
    "t": "INT 2fH 4BxxH: Task Switcher Functions",
    "b": "Compatibility: 3.0+\n See: Switcher API Overview for background info.\n\n 4b01H (build notification chain)\n\n 4b02H (is switcher installed? / get service addr)\n\n 4b03H (allocate switcher ID)\n\n 4b04H (free switcher ID)\n\n 4b05H (identify instance data)\n\n Switcher Services and Notifications (interact with the switcher)\n\n These functions are used by application programs, especially TSRs, which\n have special needs with regard to task switching; for instance, programs\n which must prevent the DOS Shell from swapping them out or switching to\n another program (say, via Alt+Tab). They also enable a TSR to maintain\n instance data--a unique data area for each DOS session.\n\nSee Also: INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "708-switcher_api.html",
    "t": "Switcher API",
    "b": "See Switcher API Overview for background information.\n\n █▌Switcher API▐█ INT 2fH 4B01H Build Notification Chain\n INT 2fH 4B02H Is Switcher Installed? / Get Service Addr\n INT 2fH 4B03H Allocate Switcher ID\n INT 2fH 4B04H Free Switcher ID\n INT 2fH 4B05H Identify Instance Data\n\n █▌Services▐█ SwSrvcFn 0000H Get Switcher Version\n SwSrvcFn 0001H Test Memory Region\n SwSrvcFn 0002H Suspend Switcher\n SwSrvcFn 0003H Resume Switcher\n SwSrvcFn 0004H Hook Notification Chain\n SwSrvcFn 0005H Unhook Notification Chain\n SwSrvcFn 0006H Query API Support\n\n█▌Notifications▐█ SwNtfyFn 0000H A Switcher Is Being Initialized\n SwNtfyFn 0001H Can Switcher Please Suspend Your Session?\n SwNtfyFn 0002H Switcher Is Suspending Your Session\n SwNtfyFn 0003H Switcher Is Activating Your Session\n SwNtfyFn 0004H Session Is Now Active\n SwNtfyFn 0005H Switcher Is Creating a Session\n SwNtfyFn 0006H Switcher Is Destroying a Session\n SwNtfyFn 0007H Switcher Is Exiting\n\n █▌Structures▐█ SwApiInfoRec\n SwCallbackInfoRec\n SwStartupInfoRec\n SwInstanceItemRec\n SwVersionRec\n\nSee Also: Switcher API Overview\n INT 2fH\n DOS Functions\n -♦-"
  },
  {
    "id": "709-switcher_api_overview.html",
    "t": "Switcher API Overview",
    "b": "█▌Overview▐█\n Starting with DOS 5.0, Microsoft published information on coexisting with\n the DOS task-switcher. For most applications, actions of a task switcher\n are transparent, but a few programs need to avoid the potential pitfalls\n possible when they are turned off and on by an external program.\n\n█▌Who Needs the Switcher API?▐█\n Some programs need to take special precautions when running under a task\n switcher. For instance, modem programs will be in big trouble if they get\n switched-out while online with a remote computer. These programs can\n process SwNtfyFn 0001H and indicate when switching-out would be bad news.\n\n Some TSR programs installed before the switcher can provide different\n context for each DOS session. For instance, the Doskey TSR maintains a\n separate \"command history\" and \"macro set\" for each DOS session. All\n sessions share the same code space, but a separate data area is maintained\n for each session.\n\n Some programs need to take precautions about the use of global resources\n that may be destroyed without proper handling. For instance, a word\n processor may create temporary files. Each session of the program should\n maintain separate files to avoid problems.\n\n Note: Much of the Switcher API is concerned with a situation in which\n two or more switchers are active simultaneously and having them\n coexist peacefully. Unless you are writing a task switcher, you\n may ignore most of the API.\n\n█▌Using the Switcher API▐█\n If you need to be switcher-aware, follow these steps:\n\n 1) Use INT 2fH 4B02H to see if a task-switcher is active. This also\n returns the service entry address.\n\n 2) Use INT 2fH 4B05H to identify regions of your memory which must be\n maintained for each session. The switcher will automatically save\n and restore these areas for each session when tasks are switched.\n\n 3) If you need to be notified of a pending task-switch (in order to\n clean up before the switch or to block the switch altogether), call\n the service entry address with AX=0004H to \"hook\" the notification\n chain (see SwSrvcFn 0004H). Thereafter, the switcher will call a\n designated procedure in your code before switching you out.\n\n And remember to use SwSrvcFn 0005H later, to unhook yourself before\n you terminate.\n\nSee Also: Switcher API\n INT 2fH\n TSR Functions\n DOS Functions\n -♦-"
  },
  {
    "id": "710-int_2fh_4b01h__build_notification_chain.html",
    "t": "INT 2fH 4B01H: Build Notification Chain",
    "b": "Compatibility: 5.0+\n Expects: AX 4B01H (INT 2fH)\n CX:DX address of switcher service function handler\n ES:BX 0000:0000 (on initial call; see below)\n ...or...\n address of a SwCallbackInfoRec needing processing (when\n intercepting this INT 2fH fn; see below)\n ──────────────────────────────────────────────────────────────────\n Returns: ES:BX 0000:0000 (on initial call)\n ...or...\n address of a local SwCallBackInfoRec (when intercepting)\n ──────────────────────────────────────────────────────────────────\n Info: This fn creates a linked list of notification function handlers.\n Applications which need to be notified of task-switcher\n activities may intercept this fn and process subsequent calls\n (made by other programs) as follows:\n\n If you don't need to process switcher notifications, just JMP to\n the previous INT 2fH handler.\n\n If you do need notifications, your INT 2fH handler should:\n\n ■ First, chain to any previously-installed handlers by pushing\n the FLAGS register and performing a FAR CALL to the previous\n handler.\n\n ■ On return from that CALL, create a SwCallbackInfoRec from local\n memory and fill it in (including the address of your code that\n will handle switcher notifications). Copy the returned value\n of ES:BX into the pfNextHandler field of the structure.\n\n ■ Place the address of your own SwCallbackInfoRec into ES:BX and\n execute an IRET.\n\n These steps result in a chain of INT 2fH handlers, each of which\n can process subsequently-installed handlers.\n\nSee Also: INT 2fH 4BxxH: Task Switcher Functions\n Switcher Services and Notifications\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "711-int_2fh_4b02h__is_switcher_installed____get_service_addr.html",
    "t": "INT 2fH 4B02H: Is Switcher Installed? / Get Service Addr",
    "b": "Compatibility: 5.0+\n Expects: AX 4B02H (INT 2fH)\n BX 0000H (must be 0)\n ES 0000H (must be 0)\n ──────────────────────────────────────────────────────────────────\n Returns: AX 0000H if task switcher is installed\n ES:BX address of service-function handler (if switcher installed)\n 0000:0000 if switched is not installed\n ──────────────────────────────────────────────────────────────────\n Info: This determines whether a task switcher has been installed and\n obtains the service function address (used for accessing switcher\n services).\n\n It is possible that more than one task switcher is active (for\n instance, if DOSSHELL is executed while in a Windows command\n prompt session). To see if that's the case, use SwSrvcFn 0000H\n and examine the pfPrevSwitcher field of the SwVersionRec\n structure returned by that call.\n\n Task switchers that intercept this call can enable interrupts can\n use any DOS fns.\n\nSee Also: INT 2fH 4BxxH: Task Switcher Functions\n Switcher Services and Notifications\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "712-int_2fh_4b03h__allocate_switcher_id.html",
    "t": "INT 2fH 4B03H: Allocate Switcher ID",
    "b": "Compatibility: 5.0+\n Expects: AX 4B03H (INT 2fH)\n BX 0000H\n ES:DI Service-function address of task switcher to allocate\n ──────────────────────────────────────────────────────────────────\n Returns: AX 0000H if successful (if a switcher ID is available\n BX switcher ID for caller (if successful)\n ──────────────────────────────────────────────────────────────────\n Info: Programs which wish to act as a task switcher (or session\n manager) must obtain a switcher ID. That ID will be in the range\n 0000h-000fH; it will used as the high four bits in the task IDs\n it creates for tasks it handles.\n\n The first task switcher loaded must intercept this fn and provide\n this service (you know you're the first when INT 2fH 4B02H\n returns AX=0000h).\n\n This in NOT called by normal application programs--only by task\n switchers.\n\nSee Also: INT 2fH 4BxxH: Task Switcher Functions\n Switcher Services and Notifications\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "713-int_2fh_4b04h__free_switcher_id.html",
    "t": "INT 2fH 4B04H: Free Switcher ID",
    "b": "Compatibility: 5.0+\n Expects: AX 4B04H (INT 2fH)\n BX Switcher ID to be freed (obtained from INT 2fH 4B03H)\n ES:DI Service-function address of task switcher to free\n ──────────────────────────────────────────────────────────────────\n Returns: AX 0000H and...\n BX 0000H if service was successful (else, invalid ID)\n ──────────────────────────────────────────────────────────────────\n Info: Multiple task switchers may be active (see INT 2fH 4B03H). When\n one of them terminates, it must call this fn to notify the parent\n (first) switcher that it is quitting.\n\n This in NOT called by normal application programs--only by task\n switchers.\n\nSee Also: INT 2fH 4BxxH: Task Switcher Functions\n Switcher Services and Notifications\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "714-int_2fh_4b05h__identify_instance_data.html",
    "t": "INT 2fH 4B05H: Identify Instance Data",
    "b": "Compatibility: 5.0+\n Expects: AX 4B04H (INT 2fH)\n ES:BX 0000:0000\n CX:DX address of switcher service function handler\n ──────────────────────────────────────────────────────────────────\n Returns: ES:BX 0000:0000 if no instance data chain\n else, address of a SwStartupInfoRec\n ──────────────────────────────────────────────────────────────────\n Info: This provides a way for application programs (such as TSRs) to\n tell the switcher about any \"instance data\" (memory areas that\n are unique for each task). For example, Doskey preserves a\n command-line history for each DOS session, even though the\n program code need be in memory once.\n\n This fn creates a linked list of Identify Instance Data handlers.\n Application programs which need to preserve instance data must\n intercept INT 2fH and process fn AX=4b05H as follows:\n\n If you don't need to process Instance Data requests, just JMP to\n the previous INT 2fH handler.\n\n If you do need instance data, your INT 2fH handler should:\n\n ■ First, chain to any previously-installed handlers by pushing\n the FLAGS register and performing a FAR CALL to the previous\n handler.\n\n ■ On return from that CALL, create a SwStartupInfoRec from local\n memory and fill it in (including the address of your list of\n SwInstanceItemRec structures. Copy the returned value of\n ES:BX into the pfNextDev field of the structure.\n\n ■ Place the address of your own SwCallbackInfoRec into ES:BX and\n execute an IRET.\n\n These steps result in a chain of INT 2fH handlers, each of which\n can process subsequently-installed handlers.\n\nSee Also: INT 2fH 4BxxH: Task Switcher Functions\n Switcher Services and Notifications\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "715-swntfy_fn_0000h__a_switcher_is_being_initialized.html",
    "t": "SwNtfy Fn 0000H: A Switcher Is Being Initialized",
    "b": "Expect: AX 0000H\n ES:DI addr of switcher's service-entry address\n ──────────────────────────────────────────────────────────────────\n Return: AX 0000H if OK, as far as you're concerned\n ──────────────────────────────────────────────────────────────────\n Info: Task switchers call this fn when they are initialized.\n\n Programs that must take special action to coexist with a task\n switcher may need to handle this notification fn, but in most\n cases, it can be ignored.\n\n ES:SI will contain the task switcher's service entry address. You can\n call that address with AX=0000H if you want some information\n about the task switcher that is being initialized.\n\n Return: AX=0000H if you have no objections to this new switcher being\n installed. If a program returns a non-zero value, all tasks may\n receive SwNtfyFn 0007H (switcher is exiting).\n\nSee Also: Switcher Services and Notifications\n INT 2fH 4bxxH (switcher functions)\n -♦-"
  },
  {
    "id": "716-swntfy_fn_0001h__can_switcher_suspend_your_session_.html",
    "t": "SwNtfy Fn 0001H: Can Switcher Suspend Your Session?",
    "b": "Expect: AX 0001H\n BX ID of the session that is about to be suspended\n ES:DI addr of switcher's service-entry address\n ──────────────────────────────────────────────────────────────────\n Return: AX 0000H if OK to suspend, as far as you're concerned\n 0001H if you object to the switch\n ──────────────────────────────────────────────────────────────────\n Info: Task switchers call this fn when they are about to perform a\n session switch. Your application can prevent the switch or\n perform any special cleanup needed, then allow the switch to take\n place. When called, interrupts are enabled and all DOS fns can\n be used.\n\n BX will contain the session ID of the session that is about to be\n switched out. Global TSRs may wish to take special actions for\n each session.\n\n ES:SI will contain the task switcher's service entry address. Use this\n address if you need to call service fns such as SwSrvcFn 0001H\n (test memory region) to determine how you feel about being\n switched out.\n\n Return: AX=0000H if you have no objection to being switched out. If any\n task returns a non-zero value, the session will not be switched\n out and all tasks may receive SwNtfyFn 0004H (session is active).\n\nSee Also: Switcher Services and Notifications\n INT 2fH 4bxxH (switcher functions)\n -♦-"
  },
  {
    "id": "717-swntfy_fn_0002h__switcher_is_suspending_your_session.html",
    "t": "SwNtfy Fn 0002H: Switcher Is Suspending Your Session",
    "b": "Expect: AX 0002H\n BX ID of the session that is about to be suspended\n ES:DI addr of switcher's service-entry address\n ──────────────────────────────────────────────────────────────────\n Return: AX 0000H if OK to suspend, as far as you're concerned\n 0001H if you object to the switch\n ──────────────────────────────────────────────────────────────────\n Info: Task switchers first call SwNtfyFn 0001H to see if a session\n switch is OK, then they call this fn directly before suspending\n your session. This is the last chance for your application to\n prevent the switch. When called, interrupts are disabled you\n should NOT use any DOS fns.\n\n BX will contain the session ID of the session that is about to be\n switched out. Global TSRs may wish to take special actions for\n each session.\n\n ES:SI will contain the task switcher's service entry address. Use this\n address if you need to call service fns such as SwSrvcFn 0001H\n (test memory region) to determine how you feel about being\n switched out.\n\n Return: AX=0000H if you have no objection to being switched out. If any\n task returns a non-zero value, the session will not be switched\n out and all tasks may receive SwNtfyFn 0004H (session is active).\n\nSee Also: Switcher Services and Notifications\n INT 2fH 4bxxH (switcher functions)\n -♦-"
  },
  {
    "id": "718-swntfy_fn_0003h__switcher_is_activating_your_session.html",
    "t": "SwNtfy Fn 0003H: Switcher Is Activating Your Session",
    "b": "Expect: AX 0003H\n BX ID of the session that is about to be activated\n CX flags: 0001H=this is a new session\n 0000H=resuming a previously-suspended session\n ES:DI addr of switcher's service-entry address\n ──────────────────────────────────────────────────────────────────\n Return: AX 0000H (you must return 0 in all cases)\n ──────────────────────────────────────────────────────────────────\n Info: Task switchers call this to let you know that a new session is\n about to be started or that a suspended session is about to be\n resumed. When a session is resumed, this is called only after\n all instance data and the session's interrupt table has been\n reinstalled.\n\n When called, interrupts are disabled you should NOT enable\n interrupts or use any DOS fns.\n\n BX will contain the session ID of the session that is about to be\n activated. Global TSRs may wish to keep track of new sessions if\n they take special actions for each session. You can identify a\n new session by bit 0 of the value in CX.\n\n ES:SI will contain the task switcher's service entry address. Use this\n address if you need to call any task-switcher service fns.\n\n Return: AX=0000H (must be 0)\n\n Notes: For new sessions, this will be preceded by a SwNtfyFn 0005H\n (create session).\n\nSee Also: Switcher Services and Notifications\n INT 2fH 4bxxH (switcher functions)\n -♦-"
  },
  {
    "id": "719-swntfy_fn_0004h__session_is_now_active.html",
    "t": "SwNtfy Fn 0004H: Session Is Now Active",
    "b": "Expect: AX 0003H\n BX ID of the session that is now active\n CX flags: 0001H=this is a new session\n 0000H=resuming a previously-suspended session\n ES:DI addr of switcher's service-entry address\n ──────────────────────────────────────────────────────────────────\n Return: AX 0000H (you must return 0 in all cases)\n ──────────────────────────────────────────────────────────────────\n Info: Task switchers call this to let you know that a new session has\n been started or that a suspended session has been resumed.\n\n When called, interrupts are enabled you may use all DOS fns.\n\n BX will contain the session ID of the session that has been\n activated.\n\n ES:SI will contain the task switcher's service entry address. Use this\n address if you need to call any task switcher service fns.\n\n Return: AX=0000H (must be 0)\n\nSee Also: Switcher Services and Notifications\n INT 2fH 4bxxH (switcher functions)\n -♦-"
  },
  {
    "id": "720-swntfy_fn_0005h__switcher_is_creating_a_session.html",
    "t": "SwNtfy Fn 0005H: Switcher Is Creating a Session",
    "b": "Expect: AX 0005H\n BX ID for the new session\n ES:DI addr of switcher's service-entry address\n ──────────────────────────────────────────────────────────────────\n Return: AX 0000H if OK to create the session\n 0001H if you object to the new session\n ──────────────────────────────────────────────────────────────────\n Info: Task switchers call this to let you know that a new session is\n about to be created. It gives you a chance to object to the new\n session (fir instance, if you don't have enough memory to track\n it safely).\n\n When called, interrupts are enabled you may use all DOS fns.\n\n BX will contain the session ID of the new session. The high 4 bits\n are the Switcher ID (see INT 2fH 4b03H) and the low 12 bits are\n an arbitrary (not necessarily sequential) number.\n\n ES:SI will contain the task switcher's service entry address. Use this\n address if you need to call any task-switcher service fns.\n\n Return: AX=0000H to indicate that you don't object to the new session. If\n any task returns 0001H, the session will not be started and all\n tasks may receive SwNtfyFn 0006H (session has been destroyed).\n\nSee Also: Switcher Services and Notifications\n INT 2fH 4bxxH (switcher functions)\n -♦-"
  },
  {
    "id": "721-swntfy_fn_0006h__switcher_is_destroying_a_session.html",
    "t": "SwNtfy Fn 0006H: Switcher Is Destroying a Session",
    "b": "Expect: AX 0006H\n BX ID of the session\n ES:DI addr of switcher's service-entry address\n ──────────────────────────────────────────────────────────────────\n Return: AX 0000H (you must return 0 in all cases)\n ──────────────────────────────────────────────────────────────────\n Info: Task switchers call this to let you know that a session is about\n to be destroyed. It gives you a chance perform any cleanup\n needed to process the end of a session.\n\n When called, interrupts are enabled you may use all DOS fns.\n\n BX will contain the session ID of the session that is about to be\n destroyed. (Note: it need not be the current active session).\n\n ES:SI will contain the task switcher's service entry address. Use this\n address if you need to call any task-switcher service fns.\n\n Return: AX=0000H you must return 0. Tasks have not veto power here.\n\n Notes: You may get this call without first seeing a SwNtfyFn 0006H\n (session is being created). That call is broadcasted when some\n task has vetoed the new session. In that case, you may ignore\n this call.\n\nSee Also: Switcher Services and Notifications\n INT 2fH 4bxxH (switcher functions)\n -♦-"
  },
  {
    "id": "722-swntfy_fn_0007h__switcher_is_exiting.html",
    "t": "SwNtfy Fn 0007H: Switcher Is Exiting",
    "b": "Expect: AX 0007H\n BX flags: 0001H this is the only task switcher\n 0000H other task switchers exist\n ES:DI addr of switcher's service-entry address\n ──────────────────────────────────────────────────────────────────\n Return: AX 0000H (you must return 0 in all cases)\n ──────────────────────────────────────────────────────────────────\n Info: Task switchers call this to let you know when they are\n terminating. It gives you a chance perform any necessary cleanup\n and disable any extra processing that you were doing to coexist\n with the switcher.\n\n When called, interrupts are enabled you may use all DOS fns.\n\n BX bit 0 will be set (BX=0001H) is this is the only active task\n switcher. All other bits will be 0.\n\n ES:SI will contain the task switcher's service entry address. Use this\n address if you need to call any task-switcher service fns.\n\n Return: AX=0000H you must return 0. Tasks have not veto power here.\n\nSee Also: Switcher Services and Notifications\n INT 2fH 4bxxH (switcher functions)\n -♦-"
  },
  {
    "id": "723-swsrvc_fn_0000h__get_switcher_version.html",
    "t": "SwSrvc Fn 0000H: Get Switcher Version",
    "b": "Expects: AX 0000H\n ──────────────────────────────────────────────────────────────────\n Returns: CF Carry Flag is clear (NC) is successful and...\n ES:BX address of a SwVersionRec structure\n ──────────────────────────────────────────────────────────────────\n Info: Use a FAR call to the switcher entry address (see INT 2fH 4b02H)\n to obtain info about the active task switcher, including its\n name, version number, and the APIs it supports.\n\n See SwVersionRec for a layout of the returned data.\n\nSee Also: Switcher Services and Notifications\n INT 2fH 4bxxH (switcher functions)\n -♦-"
  },
  {
    "id": "724-swsrvc_fn_0001h__test_memory_region.html",
    "t": "SwSrvc Fn 0001H: Test Memory Region",
    "b": "Expects: AX 0001H\n ES:BX address of first byte to test\n CX size, in bytes, of memory region to test\n ──────────────────────────────────────────────────────────────────\n Returns: CF Carry Flag is clear (NC) is successful and...\n AX result code: 0000H = global memory\n 0001H = global and local memory\n 0002H = local memory\n ──────────────────────────────────────────────────────────────────\n Info: Use a FAR call to the switcher entry address (see INT 2fH 4b02H)\n to learn whether a particular block of memory is global or local\n to the current session. Local memory areas are replaced whenever\n a session switch occurs.\n\n One use for this is to find out if your application or TSR\n program code is stored in global memory (started before the task\n switcher), or local memory (started in a task-switcher session).\n Global TSRs are never swapped out.\n\nSee Also: Switcher Services and Notifications\n INT 2fH 4bxxH (switcher functions)\n -♦-"
  },
  {
    "id": "725-swsrvc_fn_0002h__suspend_switcher.html",
    "t": "SwSrvc Fn 0002H: Suspend Switcher",
    "b": "Expects: AX 0002H\n ES:DI address of new service function handler\n ──────────────────────────────────────────────────────────────────\n Returns: CF Carry Flag is clear (NC) is successful and...\n AX result code: 0000H = suspended\n 0001H = not suspended, don't start\n 0002H = not suspended, OK to start\n ──────────────────────────────────────────────────────────────────\n Info: This service is used ONLY by a task-switching program that wants\n to suspend the active task switcher and provide task-switching\n services.\n\n Applications should not use this service. If you need to keep a\n switcher from suspending a session, you must hook into the\n notification chain (via SwNtfyFn 0004H) and handle SwNtfyFn 0001H\n (query suspend) calls.\n\nSee Also: Switcher Services and Notifications\n INT 2fH 4bxxH (switcher functions)\n -♦-"
  },
  {
    "id": "726-swsrvc_fn_0003h__resume_switcher.html",
    "t": "SwSrvc Fn 0003H: Resume Switcher",
    "b": "Expects: AX 0003H\n ES:DI address of calling switcher's service function handler\n ──────────────────────────────────────────────────────────────────\n Returns: CF Carry Flag is clear (NC) is successful\n CF is set (CY) if the switcher does not support this fn.\n ──────────────────────────────────────────────────────────────────\n Info: This service is used ONLY by a task-switching program that has\n previously suspended another task switcher.\n\n Applications should not use this service. If you need to keep a\n switcher from suspending a session, you should hook into the\n notification chain (via SwNtfyFn 0004H) and handle SwNtfyFn 0001H\n (query suspend) calls.\n\nSee Also: Switcher Services and Notifications\n INT 2fH 4bxxH (switcher functions)\n -♦-"
  },
  {
    "id": "727-swsrvc_fn_0004h__hook_notification_chain.html",
    "t": "SwSrvc Fn 0004H: Hook Notification Chain",
    "b": "Expects: AX 0004H\n ES:DI address of an SwCallbackInfoRec structure\n ──────────────────────────────────────────────────────────────────\n Returns: AX 0000H and CF is clear (NC) if successful\n CF is set (CY) if the switcher does not support this fn.\n ──────────────────────────────────────────────────────────────────\n Info: Applications use this fn when they wish to be notified of task-\n switcher operations such as switching session out.\n\n To access this fn, fill-in an SwCallbackInfoRec structure and use\n a FAR call to the switcher entry address (see INT 2fH 4b02H).\n Your program code pointed to by the pfHandler in that structure\n will then receive notifications in the form of FAR calls with AX\n specifying a notification fn number.\n\n Note: Before terminating your program (for instance, a TSR which\n receives notifications) you must use SwSrvcFn 0005H (unhook).\n\nSee Also: Switcher Services and Notifications\n INT 2fH 4bxxH (switcher functions)\n -♦-"
  },
  {
    "id": "728-swsrvc_fn_0005h__unhook_notification_chain.html",
    "t": "SwSrvc Fn 0005H: Unhook Notification Chain",
    "b": "Expects: AX 0005H\n ES:DI address of an SwCallbackInfoRec structure\n ──────────────────────────────────────────────────────────────────\n Returns: AX 0000H and CF is clear (NC) if successful\n CF is set (CY) if the switcher does not support this fn.\n ──────────────────────────────────────────────────────────────────\n Info: Use this fn before terminating an application which has used\n SwSrvcFn 0004H (hook notification chain). This stops the task-\n switcher from calling your notification handler.\n\nSee Also: Switcher Services and Notifications\n INT 2fH 4bxxH (switcher functions)\n -♦-"
  },
  {
    "id": "729-swsrvc_fn_0006h__query_api_support.html",
    "t": "SwSrvc Fn 0006H: Query API Support",
    "b": "Expects: AX 0006H\n BX an API Identifier (see below)\n ──────────────────────────────────────────────────────────────────\n Returns: AX 0000H and CF is clear (NC) if successful and...\n ES:BX address of an SwApiInfoRec structure for the API in BX\n ──────────────────────────────────────────────────────────────────\n Info: This locates the program (global or in the current session) which\n provides the best level of support for certain application\n interface services (APIs).\n\n It provides a means for such programs a NetWare and LAN Manager\n to negotiate to find which of them provides the best support for\n a particular API.\n\n Standard programs have no reason to use this service.\n\n BX is a code that specifies the API in which you are interested:\n 0001H NETBIOS\n 0002H 802.2\n 0003H TCP/IP\n 0004H Lan Manager named pipes\n 0005H NetWare APX\n\n Programs which hook into the notification chain (SwSrvcFn 0004H)\n indicate their API support via a list of SwApiInfoRec structures\n which are pointed to by the pfarAPIs field of SwCallbackInfoRec\n used in that call.\n\nSee Also: Switcher Services and Notifications\n INT 2fH 4bxxH (switcher functions)\n -♦-"
  },
  {
    "id": "730-swapiinforec.html",
    "t": "SwApiInfoRec",
    "b": "SwApiInfoRec\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 2 wRecLength size of this structure, in bytes (10)\n +2 2 wApiType type of asynchronous API supported by program\n +4 2 wVerMajor version number (major) eg with \"3.10\", use 0003H\n +6 2 wVerMinor version number (minor) eg with \"3.10\", use 000aH\n +8 2 wSupportLvl code 0000H-0004H (see below)\n 10 size of a SwApiInfoRec structure\n\n wApiType this code identifies API protocol supported by an application.\n It must be one of:\n 0001H NETBIOS\n 0002H 802.2\n 0003H TCP/IP\n 0004H Lan Manager named pipes\n 0005H NetWare APX\n\n wSupportLvl this code identifies how much support this program provides\n for the API specified in wApiType. It is one of:\n\n 0001H Minimal support. Program prevents a session switch\n after an API call is made (e.g., DOS's InterLink).\n\n 0002H API-level support. The program prevents switching\n while requests remain to be processed; but enables switching\n when all request are completed.\n\n 0003H Switcher compatibility. Allows switching even when\n unfinished requests are outstanding; but this may be limited\n by internal constraints such as buffer sizes, etc..\n\n 0004H Seamless compatibility. Allows switching at any time.\n\n This structure is used in SwSrvcFn 0006H (query API support). It enables\n API handlers to determine which program supplies the highest level of\n support for asynchronous task-switching API services.\n\n It is also referred to in SwCallbackInfoRecs. A series of these\n structures may exist for each client program that provides task-switching\n API support--one for each supported API. The list ends when the\n wRecLength field is 0000H.\n\nSee Also: Switcher Services and Notifications\n INT 2fH 4bxxH (switcher functions)\n -♦-"
  },
  {
    "id": "731-swcallbackinforec.html",
    "t": "SwCallbackInfoRec",
    "b": "SwCallbackInfoRec\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 4 pfrNext address of next SwCallbackInfoRec in the\n notification chain (or 0000:0000 if last entry)\n +4 4 pfHandler addr of notification-function handler\n +8 4 res (reserved)\n +0c 4 pfarAPIs address of list of SwApiInfoRec structures.\n 16 size of an SwCallbackInfoRec structure\n\n pfrNext this is the address of the next SwCallbackInfoRec in the\n chain; it is stored by programs which intercept INT 2fH 4b01H\n (build notification chain).\n\n pfHandler the FAR address of the code that will be called for various\n notification functions.\n\n pfarAPIs the FAR address of the first of a series of SwApiInfoRec\n structures that identify how much support this program\n provides for various asynchronous request APIs. The list ends\n when the first field of that structure is 0000H.\n\n This structure is used in SwSrvcFn 0004H (hook notification chain) and in\n INT 2fH 4b01H (build notification chain). It is part of the system that\n allows programs to be notified when they are about to be switched out or\n that they can resume operation, etc.\n\nSee Also: Switcher Services and Notifications\n INT 2fH 4bxxH (switcher functions)\n -♦-"
  },
  {
    "id": "732-swstartupinforec.html",
    "t": "SwStartupInfoRec",
    "b": "SwStartupInfoRec\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 2 wVersion ignored; not used\n +2 4 pfrNext addr of previous handler's SwStartupInfoRec\n +6 4 res1 ignored; not used\n +0aH 4 res2 ignored; not used\n +0eH 4 pfarInst address of list of SwInstanceItemRec structures.\n 18 size of an SwStartupInfoRec structure\n\n pfrNext this is the address of the next SwStartupInfoRec in the chain;\n it is stored by programs which intercept INT 2fH 4b05H\n (identify instance data).\n\n pfarInst the FAR address of a series of SwInstanceItemRec structures\n that identify memory regions which must be kept unique for\n each session. The structures are sequential in memory, and\n the list ends when the first field if the SwInstanceItemRec is\n 0000:0000.\n\n This structure is used in INT 2fH 4b05H (identify instance data). It is\n part of the system that allows programs to be reentrant across multiple\n tasks by reserving memory areas for buffers and variables. The task\n switcher will save and restore the correct data for each task.\n\n Programs that need to maintain instance data typically have the switcher\n save and restore their stack, along with a specially-defined portion of\n their data segment (including some or all program variables).\n\nSee Also: Switcher Services and Notifications\n INT 2fH 4bxxH (switcher functions)\n -♦-"
  },
  {
    "id": "733-swinstanceitemrec.html",
    "t": "SwInstanceItemRec",
    "b": "SwInstanceItemRec\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 4 pfData address of the instance data (or 0000:0000 if\n last record in the list)\n +4 2 wSize size of the instance data, in bytes\n 6 size of an SwInstanceItemRec structure\n\n pfData this is the address of a data area which needs to be saved on\n each task switch and restored when that task is reactivated.\n SwInstanceItemRec structures are organized as a sequential\n list. When pfData is 0000:0000 it indicates the end of the\n list.\n\n wSize the size of the data area, in bytes. Note that the maximum\n size is 64K; but you can create two or more of these\n structures to identify a region that is larger.\n\n This structure is pointed to by the pfarInst field of an SwStartupInfoRec\n used in INT 2fH 4b05H (identify instance data). It is part of the\n system that allows programs to be reentrant across multiple tasks by\n reserving memory areas for buffers and variables.\n\nSee Also: Switcher Services and Notifications\n INT 2fH 4bxxH (switcher functions)\n -♦-"
  },
  {
    "id": "734-swversionrec.html",
    "t": "SwVersionRec",
    "b": "SwVersionRec\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 2 wApiMajor task-switching protocol version (major)\n +2 2 wApiMinor task-switching protocol version (minor)\n +4 2 wProgMajor task-switcher program version (major)\n +6 2 wProgMinor task-switcher program version (minor)\n +8 2 wSwitcherID ID number of this task switcher\n +0aH 2 wFlags operation flags\n +0cH 4 pfszName addr of ASCIIZ▲ name of switcher program\n +10H 4 pfPrevSwchr entry address of next task switcher in chain (or\n 0000:0000 if last in chain)\n 20 size of an SwVersionRec structure\n\n wApiMajor and...\n wApiMinor identify the highest version of task-switching protocol\n supported by this switcher. For instance, 3.10 would have\n wApiMajor=0003H and wApiMinor=000aH.\n wProgMajor and...\n wProgMinor identify the version of the task switcher program; using the\n same format as the API fields.\n\n wSwitcherID is the ID number of this switcher, as obtained via an\n INT 2fH 4b03H (allocate switcher ID) call.\n\n wFlags Only bit 0 has meaning. When bit 0 is 1, then this switcher\n is currently disabled. All other bits must be 0.\n\n pfszName Is the far address of an ASCIIZ▲ string of the name of this\n switcher.\n\n pfPrevSwchr Is the entry address of another task switcher. When this\n field is 0000:0000, it's the end of the line. Otherwise, you\n can get info about that switcher by using SwSrvcFn 0000H (get\n version) via a call to this address.\n\n This structure is obtained via SwSrvcFn 0000H which could be called after\n using INT 2fH 4b02H (detect switcher).\n\nSee Also: Switcher Services and Notifications\n INT 2fH 4bxxH (switcher functions)\n -♦-"
  },
  {
    "id": "735-int_2fh_adxxh__keyb_com_functions.html",
    "t": "INT 2fH adxxH: KEYB.COM Functions",
    "b": "Compatibility: 3.0+\n See: ad80H (query KEYB.COM version)\n\n ad81H (set KEYB.COM active code page)\n\n ad82H (set KEYB.COM country flag)\n\n ad83H (query KEYB.COM country flag)\n\n KEYB.COM is a DOS program which provides national language support for\n typing special characters on various keyboards.\n\n These functions are available only when the KEYB.COM command has been\n executed and is resident in memory. Use INT 2fH ad80H to see if it is\n loaded.\n\nSee Also: INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "736-int_2fh_ad80h__is_keyb_com_installed____get_version.html",
    "t": "INT 2fH ad80H: Is KEYB.COM Installed? / Get Version",
    "b": "Compatibility: 5.0+\n Expects: AX ad80H\n ──────────────────────────────────────────────────────────────────\n Returns: BX 0000H is KEYB.COM is not loaded\n version: BH is major version number (e.g 03H for 3.10)\n BL is minor version number (e.g 0aH for 3.10)\n ──────────────────────────────────────────────────────────────────\n Info: Determines whether KEYB.COM has been executed and is resident in\n memory and returns the version number.\n\nSee Also: INT 2fH adxxH: KEYB.COM Functions\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "737-int_2fh_ad81h__set_keyb_com_active_code_page.html",
    "t": "INT 2fH ad81H: Set KEYB.COM Active Code Page",
    "b": "Compatibility: 5.0+\n Expects: AX ad81H\n BX Code Page\n ──────────────────────────────────────────────────────────────────\n Returns: CF Carry Flag is set if there is an error\n AX 0001H (error code) if the code page is not valid\n ──────────────────────────────────────────────────────────────────\n Info: This is similar to using the DOS command, Mode CON CP SEL=nnn; it\n activates the specified code page (character set) for the\n keyboard.\n\n As with that Mode command, a code page cannot be selected unless\n the KEYBOARD.SYS device driver has been installed and unless it\n has been previously prepared (Mode CON CP PREP=).\n\nSee Also: INT 2fH adxxH: KEYB.COM Functions\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "738-int_2fh_ad82h__set_keyb_com_country_flag.html",
    "t": "INT 2fH ad82H: Set KEYB.COM Country Flag",
    "b": "Compatibility: 5.0+\n Expects: AX ad82H\n BL flag: 00H = default keyboard\n ffH = alternate keyboard\n ──────────────────────────────────────────────────────────────────\n Returns: CF Carry Flag is set if there is an error\n ──────────────────────────────────────────────────────────────────\n Info: When KEYB.COM is active and the KEYBOARD.SYS has been installed,\n you can toggle between one keyboard layout an another via\n Ctrl+Alt+F1 and Ctrl+Alt+F2. Clearing the country flag (BL=00H)\n is equivalent to the former and setting the country flag (BL=ffH)\n is equivalent to the latter.\n\nSee Also: INT 2fH adxxH: KEYB.COM Functions\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "739-int_2fh_ad83h__query_keyb_com_country_flag.html",
    "t": "INT 2fH ad83H: Query KEYB.COM Country Flag",
    "b": "Compatibility: 5.0+\n Expects: AX ad83H\n ──────────────────────────────────────────────────────────────────\n Returns: BL flag: 00H = default keyboard\n ffH = alternate keyboard\n ──────────────────────────────────────────────────────────────────\n Info: When KEYB.COM is active and the KEYBOARD.SYS has been installed,\n you can toggle between one keyboard layout an another via\n Ctrl+Alt+F1 and Ctrl+Alt+F2.\n\n The return value, in BL, identifies which keyboard layout is\n currently active. BL=00H indicates that the Ctrl+Alt+F1 (default)\n is active and BL=ffH indicates that the Ctrl+Alt+F2 (secondary)\n layout is active.\n\nSee Also: INT 2fH adxxH: KEYB.COM Functions\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "740-int_2fh_aexxh__command_processor_command_line_hook.html",
    "t": "INT 2fH aexxH: Command Processor Command-Line Hook",
    "b": "Compatibility: ◄Undoc► 3.0+\n\n This MUX interrupt is ◄undocumented► through DOS 6.0. It is intended\n as way to intercept commands submitted to the DOS command processor\n (COMMAND.COM). A TSR hooked into the chain can examine a command line\n and decide to pass it on (do nothing) or process the command its own way.\n\n For instance, this provides a way to implement additional \"DOS internal\"\n commands and/or keep users from executing dangerous command such as DEL\n or FORMAT.\n\n See: ae00H (notify pending command)\n\n ae01H (process hooked command)\n\nSee Also: INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "741-int_2fh_ae00h__notify_pending_command.html",
    "t": "INT 2fH ae00H: Notify Pending Command",
    "b": "Compatibility: ◄Undoc► 3.0+\n Expects: AX ae00H\n DX ffffH\n DS:BX address of length-prefixed command-line buffer\n DS:SI address of an 8-byte upshifted, blank-padded command name\n ──────────────────────────────────────────────────────────────────\n Returns: AL flag: 00H = no, ISR does not want to intercept\n ffH = yes, ISR will process the command\n ──────────────────────────────────────────────────────────────────\n Info: This is intended as a way to intercept commands typed at the DOS\n command prompt before COMMAND.COM gets a chance to process them.\n\n A TSR program hooks INT 2fH and watches for AX=ae00H. Then it\n compares the text at DS:SI with a command that it wishes to\n intercept. If it wants to handle that command, it sets AL=ffH\n and executes an IRET. If it has no interest, it just passes\n control to the next INT 2fH handler.\n\n Don't process the command yet. When you signal interest in a\n command, COMMAND.COM will immediately execute INT 2fH ae01H and\n you should take action only upon that event.\n\n DS:BX On entry, DS:BX points to a command line buffer in the form:\n RawCmdLineRec\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 1 bBufLen length of the buffer\n +1 1 bTextLen length of the command-line text (abText)\n +2 n abText text of the command line\n 2+n 1 bCr one byte of 0dH (Carriage Return)\n 3+n size of a RawCmdLineRec structure\n\n Note that this is layout is similar to that used in DOS fn 0aH\n (get buffered string input), which COMMAND.COM uses to obtain\n user input.\n\n When intercepting commands, you must save a copy of this buffer.\n See Notes, below.\n\n DS:SI On entry, DS:SI points to an upshifted, blank-padded version of\n the first word on the command line. This text will be exactly\n eight characters long; space characters (ASCII 20H) are appended\n to the text to fill-out the 8-character buffer:\n CmdNameRec\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 8 abCmd blank-padded command name\n 8 size of a CmdNameRec structure\n\n AL If you wish to intercept this command, set AL to ffH and return\n to DOS via an IRET. COMMAND.COM will issue an INT 2fH with\n AX=ae01H immediately, and you can take action then.\n\n If you do not wish to intercept this command, you should pass it\n down the chain by using a FAR JMP to the address which originally\n handled INT 2fH when your TSR was installed.\n\n Notes: When COMMAND.COM issues the subsequent INT 2fH ae01H, it does not\n supply the DS:BX pointer to the full command line; therefore, you\n must save this address for use in the ae01H subfunction.\n\nSee Also: INT 2fH aexxH Command Processor Hook\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "742-int_2fh_ae01h__process_hooked_command.html",
    "t": "INT 2fH ae01H: Process Hooked Command",
    "b": "Compatibility: ◄Undoc► 3.0+\n Expects: AX ae01H\n DS:SI address of an 8-byte upshifted, blank-padded command name\n (save command-line text addr from previous INT 2fH ae00H)\n ──────────────────────────────────────────────────────────────────\n Returns: Previously-passed command buffer should be modified:\n Set the length field to 00H to indicate command completed.\n ──────────────────────────────────────────────────────────────────\n Info: This is part two of a system that lets TSRs intercept commands\n typed at the DOS command prompt.\n\n See INT 2fH ae00H for details on what happens in part one. After\n you return AL=ffH from that notification, COMMAND.COM immediately\n calls this function (AX=ae01H) to give you a crack at processing\n the command.\n\n Important: This command does not supply the full command-line\n text. You must save the DS:BX value passed in the previous\n AX=ae00H notification.\n\n █▌Handling a Command Internally▐█\n Examine the command line text (as pointed to by the DS:BX\n obtained in the earlier ae00H call). Take whatever action you\n deem necessary. Set the command length to 0 (DS:BX+1) and IRET\n to return control to COMMAND.COM.\n\n █▌Cancelling a Command▐█\n Just set the saved DS:[BX+1] to 00H and IRET to return control to\n COMMAND.COM.\n\n █▌Pre-processing a Command▐█\n It is possible to examine command-line switches and options, make\n some changes, and then pass the result on to be handled by\n COMMAND.COM or some other INT 2fH handler. In this case, use a\n FAR JMP to pass control down the chain of INT 2fH handlers, to\n give them a crack at the command. In any case, if the command-\n line length is non-zero, it will be processed eventually --\n either by another INT 2fH handler or by COMMAND.COM.\n\n Notes: ■ If Doskey is installed (see INT 2fH 4800H), then Doskey will\n get a crack at the command-line before you do. You might\n consider chaining into that service as well.\n\n ■ Note that batch file commands are passed through this system,\n so you can make a bullet-proof connad filter.\n\nSee Also: INT 2fH aexxH Command Processor Hook\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "743-int_2fh_b000h__is_graftabl_com_installed_.html",
    "t": "INT 2fH b000H: Is GRAFTABL.COM Installed?",
    "b": "Compatibility: 5.0+\n Expects: AX b000H\n ──────────────────────────────────────────────────────────────────\n Returns: AL status: 00H = GRAFTABL.COM is not installed\n ffH = GRAFTABL.COM is installed\n ──────────────────────────────────────────────────────────────────\n Info: Checks to see if the DOS 5.0+ GRAFTABL.COM program has been\n executed and its graphics-character definitions have been made\n resident.\n\n GRAFTABL.COM installs data that defines how ASCII characters 80H-\n ffH are displayed while in graphics mode (see Video Modes). It\n loads about 1K of data into memory and modifies the INT 1fH\n vector to point to that data.\n\n GRAFTABL.COM is used only by CGA owners, and even then, very\n rarely.\n\nSee Also: Font Definition Data\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "744-int_2fh_b7xxh__append_exe_functions.html",
    "t": "INT 2fH b7xxH: APPEND.EXE Functions",
    "b": "Compatibility: 3.0+\n See: b700H (is APPEND.EXE installed?)\n\n b702H (query APPEND version)\n\n b704H (query APPEND path string)\n\n b706H (query APPEND option settings)\n\n b707H (set APPEND options)\n\n b711H (set APPEND truename flag)\n\n These functions are available only when the APPEND.EXE command has been\n executed. When resident, the Append command modifies the functionality of\n DOS fns...\n 3dH (open file)\n 4300H (get file attribute)\n 4eH (find file)\n 6cH (extended file open/create)\n ...so that DOS will search a series of directories (in addition to the\n current default directory) in an attempt to locate files.\n\n Notes: ■ The Append command is rarely used. It was designed as a stop-\n gap measure to allow old programs (that did not recognized\n pathnames) to work in the DOS 2.0+ environment.\n\n ■ One potential use for APPEND.EXE is that it provides a way to\n effectively increase the maximum number of directories on your\n command search path (the Path command). When you use\n Append /X, DOS will look through the APPEND directories when it\n attempts to locate program names.\n\nSee Also: INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "745-int_2fh_b700h__is_append_exe_installed_.html",
    "t": "INT 2fH b700H: Is APPEND.EXE Installed?",
    "b": "Compatibility: 5.0+\n Expects: AX b700H\n ──────────────────────────────────────────────────────────────────\n Returns: AL status: 00H = APPEND is not installed\n ffH = APPEND is installed\n ──────────────────────────────────────────────────────────────────\n Info: Checks to see if the DOS APPEND.EXE data-search-path utility has\n been installed and is resident in memory.\n\n Append changes its behavior significantly, depending upon the\n current option settings. See INT 2fH b706H (query APPEND option\n settings) before assuming that APPEND will take a particular\n action.\n\nSee Also: INT 2fH b7xxH: APPEND.EXE Functions\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "746-int_2fh_b702h__get_append_exe_version.html",
    "t": "INT 2fH b702H: Get APPEND.EXE Version",
    "b": "Compatibility: 4.0+\n Expects: AX b702H\n ──────────────────────────────────────────────────────────────────\n Returns: CF Carry Flag clear (NC) if no error\n AX ffffH means this version compatible with DOS 4.0+\n ──────────────────────────────────────────────────────────────────\n Info: Returned values other than ffffH indicate some version older than\n that of DOS 4.0.\n\n The interface to APPEND.EXE has not changed, up to and including\n DOS 6.0.\n\nSee Also: INT 2fH b7xxH: APPEND.EXE Functions\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "747-int_2fh_b704h__get_append_exe_path_string.html",
    "t": "INT 2fH b704H: Get APPEND.EXE Path String",
    "b": "Compatibility: 5.0+\n Expects: AX b704H\n ──────────────────────────────────────────────────────────────────\n Returns: ES:DI Address of the ASCIIZ▲ \"data search path\"\n ──────────────────────────────────────────────────────────────────\n Info: This returns the address of the APPEND search path. It is in a\n form similar to the DOS command search path (maintained by the\n Path command).\n\n The APPEND path is a series of directory names, separated by\n semi-colons (;) and ending with a byte of 00H; for instance:\n\n c:\\mydata;d:\\data\\old;d:\\utils\\config\\ini0\n\n Note: A quick check shows that this returns the address of a buffer\n that appears be at least 128 bytes long. Thus, it may be\n possible to add directories to the append path by modifying this\n buffer.\n\nSee Also: INT 2fH b7xxH: APPEND.EXE Functions\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "748-int_2fh_b706h__query_append_exe_option_settings.html",
    "t": "INT 2fH b706H: Query APPEND.EXE Option Settings",
    "b": "Compatibility: 4.0+\n Expects: AX b706H\n ──────────────────────────────────────────────────────────────────\n Returns: CF Carry Flag clear (NC) if no error\n BX current APPEND.EXE option settings (see below)\n ──────────────────────────────────────────────────────────────────\n Info: This obtains the APPEND option flags which affect how APPEND\n operates:\n\n BX On return, BX contains the settings as follows:\n AppendOptsRec\n 1 1 1 1 1\n ╓5┬4┬3┬2┬1- ┬1┬0╖\n ║x│e│p│0 0...0 n║\n ╙╥┴╥┴╥┴─┴── ┴─┴╥╜ bit mask\n ║ ║ ║ ╚═► 0: 0001H enabled (0=APPEND is disabled)\n ║ ║ ╚═══════════► 13: 2000H /PATH:ON option is in effect\n ║ ╚═════════════► 14: 4000H /E option is in effect\n ╚═══════════════► 15: 8000H /X:ON option is in effect\n\n bit 0 is always 1 (if APPEND is loaded), unless a program has used\n INT 2fH b707H to clear this bit and thereby disable APPEND.\n\n bit 13 When /PATH:ON is in effect, APPEND will search the APPEND\n directories for a file, even if a path was given in the filespec.\n\n bit 14 When /E is in effect, APPEND maintains a copy of the append path\n in the DOS Environment (in the form APPEND=path;path;...)\n\n bit 14 When /X:ON is in effect, APPEND will search the APPEND path for\n DOS fns that execute programs (such as 4b00H) and for fns that\n search for files (4eH) When bit 15 is 0, APPEND searches only\n for file open requests (3dH and 6cH).\n\n Notes: You may change settings and/or disable APPEND altogether via\n INT 2fH b707H (set APPEND options).\n\nSee Also: INT 2fH b7xxH: APPEND.EXE Functions\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "749-int_2fh_b707h__set_append_exe_options___disable_append.html",
    "t": "INT 2fH b707H: Set APPEND.EXE Options / Disable APPEND",
    "b": "Compatibility: 4.0+\n Expects: AX b707H\n BX an AppendOptsRec bit-record defining desired settings (clear\n bit 0 to disable APPEND).\n ──────────────────────────────────────────────────────────────────\n Returns: CF Carry Flag clear (NC) if no error\n ──────────────────────────────────────────────────────────────────\n Info: This changes the various APPEND.EXE option settings.\n\n INT 2fH b706H for the layout of the bits in the BX register.\n\n Notes: These settings are system-global. Before making changes, use\n INT 2fH b706H (query settings) and save the result. Then restore\n the saved settings before terminating your program.\n\nSee Also: INT 2fH b7xxH: APPEND.EXE Functions\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "750-int_2fh_b711h__set_append_exe_truename_flag.html",
    "t": "INT 2fH b711H: Set APPEND.EXE Truename Flag",
    "b": "Compatibility: 4.0+\n Expects: AX b711H\n ──────────────────────────────────────────────────────────────────\n Returns: CF Carry Flag clear (NC) if no error\n ──────────────────────────────────────────────────────────────────\n Info: This is an oddball. When you call this fn, it sets a one-shot\n APPEND internal flag which affects what happens on the next call\n to any of:\n\n 3dH (open file via handle)\n 4300H (get file attribute)\n 4eH (find file)\n 6cH (extended file open/create)\n\n Each of these DOS fns require an ASCIIZ▲ filespec as a parameter.\n When the Truename flag is set, APPEND overwrites the input\n parameter with the full and actual name of the file. It then\n resets the internal Truename flag.\n\n You must be sure to that the filespec parameter you pass to those\n DOS fns has plenty of unused space at the end. APPEND may expand\n that filespec to as large as 79 bytes (a 2-byte d:, 64-byte\n \\path, and a 12-character filename.ext and a terminating byte of\n 00H.\n\n Notes: This service is available only if APPEND.EXE is loaded. If you\n just want a flexible way to obtain a fully-qualified\n d:\\path\\filename.exe (given an ambiguous or partial filename),\n you might try using the undocumented DOS Fn 60H: Query TrueName.\n\nSee Also: INT 2fH b7xxH: APPEND.EXE Functions\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "751-int_2fh_17xxh__windows_clipboard_functions.html",
    "t": "INT 2fH 17xxH: Windows Clipboard Functions",
    "b": "Compatibility: 3.0+\n \n See: 1700H (IdentifyWinOldApVersion / is clipboard available?)\n 1701H (OpenClipboard / lock access)\n 1702H (EmptyClipboard)\n 1703H (SetClipboardData / put data into clipboard)\n 1704H (GetClipboardDataSize)\n 1705H (GetClipboardData / get data from clipboard)\n\n 1708H (CloseClipboard / unlock access)\n 1709H (ClipboardCompact / will my data fit?)\n 170aH (GetDeviceCaps)\n\n Notes: These functions are available to programs running in a DOS\n session under Windows.\n\n Accessible data formats are limited; this API does not support\n RegisterClipboardFormat and EnumClipboardFormats, so custom data\n layouts can't be used.\n\n To obtain data from the Windows clipboard:\n ■ Use INT 2fH 1700H to see if clipboard fns are available.\n ■ Use INT 2fH 1701H to gain ownership of the clipboard.\n ■ Use INT 2fH 1704H to see how much of a specific type of data is in the\n clipboard.\n ■ Prepare a buffer to receive that data.\n ■ Use INT 2fH 1705H to obtain a copy of the data into your buffer.\n ■ Use INT 2fH 1708H to release ownership of the clipboard.\n\n To store data into the Windows clipboard:\n ■ Use INT 2fH 1700H to see if clipboard fns are available.\n ■ Use INT 2fH 1701H to gain ownership of the clipboard.\n ■ Use INT 2fH 1702H to clear out the current contents.\n ■ Use INT 2fH 1709H to see if your data will fit in the clipboard.\n ■ Use INT 2fH 1703H to copy your data to the clipboard.\n ■ Use INT 2fH 1708H to release ownership of the clipboard.\n\nSee Also: INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "752-int_2fh_1700h__is_clipboard_available_.html",
    "t": "INT 2fH 1700H: Is Clipboard Available?",
    "b": "Compatibility: WIN 3.0+\n Expects: AX 1700H\n ──────────────────────────────────────────────────────────────────\n Returns: AX 1700H = Clipboard fns are not available\n else = AL= major version number\n AH= minor version number\n ──────────────────────────────────────────────────────────────────\n Info: Use this to see if you are running in a DOS session under Windows\n and to see if clipboard support is available. Equivalent to\n IdentifyWinOldApVersion.\n\nSee Also: INT 2fH 17xxH: Windows Clipboard Functions\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "753-int_2fh_1701h__get_access_to_clipboard.html",
    "t": "INT 2fH 1701H: Get Access to Clipboard",
    "b": "Compatibility: WIN 3.0+\n Expects: AX 1701H\n ──────────────────────────────────────────────────────────────────\n Returns: AX 0000h = clipboard already open (fn failed)\n else = opened successfully\n ──────────────────────────────────────────────────────────────────\n Info: You must use this fn before any other clipboard fns. It enables\n INT 2fH access to the clipboard by giving ownership to the window\n displayed by the WinOldApp program. Equivalent to OpenClipboard.\n\n Be sure to use INT 2fH 1708H (close clipboard) when finished\n accessing the clipboard.\n\nSee Also: INT 2fH 17xxH: Windows Clipboard Functions\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "754-int_2fh_1702h__discard_clipboard_contents.html",
    "t": "INT 2fH 1702H: Discard Clipboard Contents",
    "b": "Compatibility: WIN 3.0+\n Expects: AX 1702H\n ──────────────────────────────────────────────────────────────────\n Returns: AX 0000h = fn failed\n else = fn completed successfully\n ──────────────────────────────────────────────────────────────────\n Info: Discards the current contents of the Windows clipboard and frees\n up any memory used to hold that data. Equivalent to\n EmptyClipboard.\n\n The clipboard must be open. See INT 2fH 1701H.\n\nSee Also: INT 2fH 17xxH: Windows Clipboard Functions\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "755-int_2fh_1703h__put_data_into_the_clipboard.html",
    "t": "INT 2fH 1703H: Put Data into the Clipboard",
    "b": "Compatibility: WIN 3.0+\n Expects: AX 1703H\n DX WinOldApp-supported clipboard data format code\n ES:BX address of data to store\n SI:CX size of data, in bytes\n ──────────────────────────────────────────────────────────────────\n Returns: AX 0000h = fn failed\n else = success; data was placed in clipboard\n ──────────────────────────────────────────────────────────────────\n Info: This puts data into the Windows clipboard, making it available to\n Windows applications and programs which use this INT 2fH API.\n Equivalent to SetClipboardData.\n\n Programs should use INT 2fH 1709H (to see if the data will fit in\n the clipboard) before using this fn.\n\n Only a few data types are supported. See Clipboard Data Formats.\n\nSee Also: INT 2fH 17xxH: Windows Clipboard Functions\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "756-int_2fh_1704h__query_size_of_clipboard_data.html",
    "t": "INT 2fH 1704H: Query Size of Clipboard Data",
    "b": "Compatibility: WIN 3.0+\n Expects: AX 1704H\n DX WinOldApp-supported clipboard data format code\n ──────────────────────────────────────────────────────────────────\n Returns: DX:AX size, in bytes of the data, including any headers.\n DX is the high word and AX is the low word.\n 0000:0000 means no data in format DX was found.\n ──────────────────────────────────────────────────────────────────\n Info: This obtains the size of the data that is currently in the\n clipboard. Equivalent to GetClipboardDataSize.\n\n Only a few data types are supported. See Clipboard Data Formats.\n\n On CF_BITMAP-formatted data (DX=0002H), the returned size will\n include the size of the 24-byte header.\n\nSee Also: INT 2fH 17xxH: Windows Clipboard Functions\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "757-int_2fh_1705h__copy_clipboard_data_to_buffer.html",
    "t": "INT 2fH 1705H: Copy Clipboard Data to Buffer",
    "b": "Compatibility: WIN 3.0+\n Expects: AX 1705H\n DX WinOldApp-supported clipboard data format code\n ES:BX address of buffer to receive data (see NOTE, below)\n ──────────────────────────────────────────────────────────────────\n Returns: AX 0000h = fn failed (DX-type data not present)\n else = success; data was copied to buffer\n ──────────────────────────────────────────────────────────────────\n Info: This copies data from the clipboard to a local buffer.\n Equivalent to GetClipboardData.\n\n NOTE!: You must be certain that your buffer is large enough to hold the\n data. Use INT 2fH 1704H (GetClipboardDataSize) to see how large\n the buffer must be. There is no sanity check--and clipboard data\n can be very large.\n\nSee Also: INT 2fH 17xxH: Windows Clipboard Functions\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "758-int_2fh_1708h__release_control_of_the_clipboard.html",
    "t": "INT 2fH 1708H: Release Control of the Clipboard",
    "b": "Compatibility: WIN 3.0+\n Expects: AX 1708H\n ──────────────────────────────────────────────────────────────────\n Returns: AX 0000h = error\n else = success\n ──────────────────────────────────────────────────────────────────\n Info: This releases control of the clipboard so that Windows\n applications and other DOS apps can place data into it.\n Equivalent to CloseClipboard.\n\n In general, your clipboard access should take place all at once:\n open it, access it, then close it.\n\nSee Also: INT 2fH 17xxH: Windows Clipboard Functions\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "759-int_2fh_1709h__see_if_data_will_fit_in_clipboard.html",
    "t": "INT 2fH 1709H: See if Data Will Fit in Clipboard",
    "b": "Compatibility: WIN 3.0+\n Expects: AX 1709H\n SI:CX desired memory size needed\n ──────────────────────────────────────────────────────────────────\n Returns: DX:AX Largest block of free memory available to clipboard\n 0000:0000 = error or no memory\n ──────────────────────────────────────────────────────────────────\n Info: This checks to see if a specified amount of data will fit into\n the clipboard. It appears to call the Windows memory manager to\n have it rearrange moveable memory blocks to make room for a\n specified-size memory allocation. Equivalent to\n ClipboardCompact.\n\n Typical usage is to set SI (high word) and CX (low word) to the\n size of the data you intend to place in the clipboard. Call this\n fn, and if DX:AX returns with the same or larger value, then its\n OK to go ahead with INT 2fH 1703H (put data into clipboard).\n\nSee Also: INT 2fH 17xxH: Windows Clipboard Functions\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "760-int_2fh_170ah__obtain_device_capabilities.html",
    "t": "INT 2fH 170aH: Obtain Device Capabilities",
    "b": "Compatibility: WIN 3.0+\n Expects: AX 170aH\n DX GDI information index (see below)\n ──────────────────────────────────────────────────────────────────\n Returns: AX integer value of desired item\n 0000h = error\n ──────────────────────────────────────────────────────────────────\n Info: This can be used to obtain information about the capabilities of\n the Windows display device driver. Equivalent to GetDeviceCaps.\n\n This calls the windows fn GetDeviceCaps, passing an hDC (handle\n to a Device Context) of the display device.\n\n DX is one of the index numbers that may be used in the Windows\n GetDeviceCaps call. For instance, DX=0004H obtains the\n horizontal size of the display, in pixels and DX=0006H obtains\n the vertical size.\n\n These index values (and the often bit-encoded) return values can\n be found by browsing the Windows.H - part of the SDK.\n\n Note: It's not clear to me why this fn is included with the Clipboard\n fns.\n\nSee Also: INT 2fH 17xxH: Windows Clipboard Functions\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "761-clipboard_data_formats.html",
    "t": "Clipboard Data Formats",
    "b": "The following data formats are supported by the INT 2fH Windows Clipboard\n functions:\n\n 0001H (CF_TEXT) The data is an array of text characters. Each line\n ends with a carriage return/linefeed (0dH,0aH) combination. A\n null character (00H) signals the end of the data.\n\n 0002H (CF_BITMAP) The data is a bitmap (see CbBmpRec structure, below).\n\n 0007H (CF_OEMTEXT) The data is an array of text characters in the OEM\n character set. Each line ends with a carriage return/linefeed\n (0dH,0aH) combination. A null character (00H) signals the end of\n the data.\n\n 0081H (CF_DSPTEXT) The data is a textual representation of a private\n data format (for instance, RTF text with text-formatting codes).\n The clipboard viewer displays this in text format in lieu of the\n privately-formatted data.\n\n 0082H (CF_DSPBITMAP) The data is a bitmap representation of a private\n format. The clipboard viewer displays this in bitmap format in\n lieu of the privately formatted data (see CbBmpRec, below).\n\n Each of the text formats is composed of one long ASCIIZ▲ string,\n optionally broken into lines with CR/LF pairs.\n\n When CF_BITMAP or CF_DSPBITMAP data types are used, the data is prefaced\n by the following structure; the image data follows it, starting at offset\n 16H. When calculating the memory needs to hold this data, add 22 bytes to\n the total to account for this header.\n\n CbBmpRec\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 2 wType always 0000H\n +2 2 wWidth bitmap width, in pixels\n +4 2 wHeight bitmap height, in pixels\n +6 2 wWideBytes bytes per raster line\n +8 1 bPlanes color planes in bitmap\n +9 1 bBitsPixels adjacent color bits per pixel\n +0aH 8 pfBits points to abData (ignore this)\n +12H 2 wWidDim bitmap width in 0.1 mm units\n +14H 2 wHighDim bitmap height in 0.1 mm units\n 22 size of formatted header\n +16H n abData bitmap data starts here\n\nSee Also: INT 2fH 17xxH: Windows Clipboard Functions\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "762-some_published_vxd_ids.html",
    "t": "Some Published VxD IDs",
    "b": "VxDs are Windows Virtual Device Drivers. A VxD runs at CPU privilege\n level 0 and thus has access to protected-mode CPU operations.\n\n The following list provides the VxD ID numbers that can be used in\n INT 2fH 1684H (get device entry address) calls. Documentation on the API\n services provided by VxDs can be hard to find (some info can be gleaned\n from DDK source code files). In most cases, a fn number is passed in\n AX and most VxDs support fn 0000H to mean \"get installed state/query\n version\".\n\n 0000H (Undef) Can be used if VxD does not provide an API\n\n 0001H (VMM) Virtual Machine Manager\n 0002H (Debug) Win386 Debug Device\n\n 0003H (VPICD) Virtual PIC (Programmable Interrupt Controller) Device\n 0004H (VMAD) Virtual DMA (direct memory access) Device\n 0005H (VTD) Virtual Timer Device\n 0006H (V86MMGR) Virtual-86 Mode Memory Manager Device\n 0007H (PageSwap) Demand Paging Swap Device services\n 0008H (Parity) handles Parity errors\n 0009H (Reboot) handles virtual reboots\n 000aH (VDD) Virtual Display Device\n 000bH (VSD) Virtual Sound Device\n 000cH (VMD) Virtual Mouse Device\n 000dH (VKD) Virtual Keyboard Device\n 000eH (VCD) Virtual COMM Device\n 000fH (VPD) Virtual Printer Device\n\n 0010H (BlockDev) formerly Virtual Hard Disk Device (VHD)\n 0011H (VMCPD) Virtual Math Coprocessor Device\n 0012H (EBIOS) PS/2 Extended BIOS\n 0013H (BIOSXlat) BIOS protected mode translation\n 0014H (VNETBIOS) Virtual NetBIOS\n 0015H (DOSMGR) Virtual MS-DOS Manager\n 0016H (WINLOAD)\n 0017H (SHELL)\n 0018H (VMPoll)\n 0019H (VPROD)\n 001aH (DOSNET)\n 001bH (VFD) Virtual Floppy Device\n 001cH (LoadHi) Global EMM Import\n 001dH (WINDEBUG)\n 001eH (TSRLoad) TSR instance utility\n 001fH (BIOSHook) BIOS Interrupt hooker VxD\n\n 0020H (INT13) Virtual INT 13H (BIOS Disk I/O) Device\n 0021H (PageFile) Demand Paging Swap Device services\n 0022H (SCSI)\n 0023H (MCA_POS) Microchannel Architecture Programmable Option Select\n 0024H (SCSIFD) SCSI FastDisk\n 0025H (VPEND) Virtual Pen Device\n 0026H (APM) Advanced Power Management\n\n 0200H (Novell IPX)\n 0202H (Win386 Soft-ICE/W Debugger)\n 0442H (VTDAPI)\n 0445H (VSBD) Virtual SoundBlaster Device\n 1020H (VCV) MS C/C++ 7. CodeView\n 28c0H (VXD.386) Generic Virtual Device\n\n IDs 0000H-1f00H are reserved for Microsoft VxDs (Virtual Devices). To\n have Microsoft assign you a VxD ID of your very own, send Compuserve\n email to INTERNET:vxdid@microsoft.com.\n\nSee Also: INT 2fH 16xxH: Enh386 Windows Services & Notifications\n DPMI Services\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "763-int_2fh_16xxh__enh386_windows_services___notifications.html",
    "t": "INT 2fH 16xxH: Enh386 Windows Services & Notifications",
    "b": "Compatibility: Win 3.0+\n See: 1600H (srvc: is enh386 windows installed?)\n 1602H (srvc: get enh386 windows entry-point address)\n 1605H (ntfy: windows is about to startup)\n 1606H (ntfy: windows is about to terminate)\n 1607H (ntfy: device call out)\n 1608H (ntfy: windows initialization is finished)\n 1609H (ntfy: windows is terminating)\n\n 1680H (srvc: release time-slice)\n 1681H (srvc: begin critical section)\n 1682H (srvc: end critical section)\n 1683H (srvc: get current VM ID)\n 1684H (srvc: get VxD device API entry-point address)\n 1685H (srvc: switch VMs and callback)\n 1686H (srvc: detect INT 31h DPMI services)\n\n Notes: ■ These functions relate to Enhanced-Mode Windows. They are\n fully-documented in the Windows Device Driver Kit (DDK) since\n they are usually used as means for a DOS-level device driver to\n communicate with Windows and Windows device drivers.\n\n ■ The services are tools that can be called by utilities, TSRs,\n and device drivers to access services provided by Windows.\n\n ■ The notifications represent INT 2fH fns that are invoked by\n Windows. To receive these notifications, you are expected to\n chain into INT 2fH and watch for AX=16xxH.\n\nSee Also: INT 2fH: Multiplex Interrupt\n DPMI Services\n DOS Functions\n -♦-"
  },
  {
    "id": "764-int_2fh_1600h__is_enh386_windows_installed_.html",
    "t": "INT 2fH 1600H: Is Enh386 Windows Installed?",
    "b": "Compatibility: Win 3.x\n Expects: AX 1600H\n ──────────────────────────────────────────────────────────────────\n Returns: AX if Enhanced-Mode Windows is not running, AL=00H or AL=80H.\n if Enh386 Win 3.x+ is installed: AL = major version number\n AH = minor version number\n if Win/386 2.x is installed AL=01H or ffH\n ──────────────────────────────────────────────────────────────────\n Info: You may use this service to see if you are running is a DOS\n session under Enhanced-Mode Windows.\n\nSee Also: INT 2fH 16xxH: Enh386 Windows Services & Notifications\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "765-int_2fh_1602h__get_enh386_windows_entry_point_address.html",
    "t": "INT 2fH 1602H: Get Enh386 Windows Entry-Point Address",
    "b": "Compatibility: Win 3.x\n Expects: AX 1602H\n ──────────────────────────────────────────────────────────────────\n Returns: ES:DI far address of Windows entry-point procedure\n ──────────────────────────────────────────────────────────────────\n Info: This is an obsolete call used with Windows/386 ver 2.x. It is\n maintained for compatibility. Check the DDK if you need this fn.\n\nSee Also: INT 2fH 16xxH: Enh386 Windows Services & Notifications\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "766-int_2fh_1605h__windows_is_about_to_startup.html",
    "t": "INT 2fH 1605H: Windows Is About to Startup",
    "b": "Compatibility: Win 3.x\n Expect: AX 1605H\n CX 0000H\n DX flags: bit 0=1 if standard mode\n bit 0=0 if enhanced 368 mode\n DI version number (major in hi byte; minor is low byte)\n DS:SI 0000:0000\n ──────────────────────────────────────────────────────────────────\n Return: CX 0000H if OK to continue starting Windows\n else Windows will not start\n DS:SI addr of an Enable/Disable Virtual Mode handler\n ES:BX addr of a Win386_Startup_Info_Structure\n ──────────────────────────────────────────────────────────────────\n Info: TSRs and DOS-level device drivers may intercept this function as\n a way to be notified when Windows (standard mode or enhanced 386\n mode) is about to start up. It lets you free up extended memory\n for use by Windows; for instance, DOS's SmartDrive disk cache\n intercepts this call for that purpose.\n\n By returning CX != 0, you can prevent Windows from running. In\n that case, you really ought to display a message to ell the user\n what's going on.\n\n If the CPU is in Virtual 8086 Mode, you must set it back to Real\n Mode and there are several other important steps. Please check\n the Windows Device Driver Kit (DDK) for full information.\n\n Your handler will later receive an INT 2fH 1608H notification to\n indicate that windows is actually starting up or an INT 2fH 1609H\n if Windows finds that it can't start.\n\nSee Also: INT 2fH 16xxH: Enh386 Windows Services & Notifications\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "767-int_2fh_1606h__windows_is_about_to_terminate.html",
    "t": "INT 2fH 1606H: Windows Is About to Terminate",
    "b": "Compatibility: Win 3.x\n Expect: AX 1606H\n DX flags: bit 0=1 if standard mode\n bit 0=0 if enhanced 368 mode\n ──────────────────────────────────────────────────────────────────\n Return: none\n ──────────────────────────────────────────────────────────────────\n Info: TSRs and DOS-level device drivers may intercept this function as\n a way to be notified when Windows is about to terminate.\n\n Your handler will later receive an INT 2fH 1609H notification to\n indicate that windows is actually terminating.\n\nSee Also: INT 2fH 16xxH: Enh386 Windows Services & Notifications\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "768-int_2fh_1607h__device_call_out.html",
    "t": "INT 2fH 1607H: Device Call Out",
    "b": "Compatibility: Win 3.x\n Expect: AX 1607H\n BX Device ID (see VxD IDs)\n ?? other regs, as defined per device\n ──────────────────────────────────────────────────────────────────\n Return: ?? varies per device\n ──────────────────────────────────────────────────────────────────\n Info: TSRs and DOS-level device drivers may intercept this function as\n a way to receive communication from a Windows device driver.\n\n This is normally used by a TSR which has loaded a windows virtual\n device (and therefore knows its ID) or to access APIs published\n for existing Windows Virtual Device drivers (VxD). The virtual\n device invokes this fn to request specific actions. You may\n return information in registers.\n\n The INT 2fH 1684H (get device entry-point) service provides\n another means of communication.\n\nSee Also: INT 2fH 16xxH: Enh386 Windows Services & Notifications\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "769-int_2fh_1608h__windows_initialization_is_complete.html",
    "t": "INT 2fH 1608H: Windows Initialization is Complete",
    "b": "Compatibility: Win 3.x\n Expect: AX 1608H\n ──────────────────────────────────────────────────────────────────\n Return: none\n ──────────────────────────────────────────────────────────────────\n Info: TSRs and DOS-level device drivers may intercept this function as\n a way to be notified when Windows has finished initializing.\n\n When called, all virtual-device initialization is complete--so a\n device driver or TSR can call virtual-device entry points.\n\n You may need to process INT 2fH 1607H call outs between the start\n of initialization (INT 2fH 1605H) and receipt of this call.\n\nSee Also: INT 2fH 16xxH: Enh386 Windows Services & Notifications\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "770-int_2fh_1609h__windows_is_terminating.html",
    "t": "INT 2fH 1609H: Windows is Terminating",
    "b": "Compatibility: Win 3.x\n Expect: AX 1609H\n ──────────────────────────────────────────────────────────────────\n Return: none\n ──────────────────────────────────────────────────────────────────\n Info: TSRs and DOS-level device drivers may intercept this function as\n a way to be notified when Windows is terminating. It lets you\n prepare to return to operating in a non-Windows environment.\n\n Windows calls this at the start of a Sys_VM_Terminate device\n control call. All devices still exist at the time of this call,\n so you can still call device entry-point addresses, if necessary.\n\nSee Also: INT 2fH 16xxH: Enh386 Windows Services & Notifications\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "771-int_2fh_1680h__program_idle__release_timeslice_.html",
    "t": "INT 2fH 1680H: Program Idle (Release Timeslice)",
    "b": "Compatibility: 3.0+\n Expects: AX 1680H\n ──────────────────────────────────────────────────────────────────\n Returns: AL status: 00H = system supports Idle Calls\n else= system does not support program suspension\n ──────────────────────────────────────────────────────────────────\n Info: DOS programs and TSRs should use this while waiting for user\n input. It announces to the system (DOS or Windows) that the\n program is willing to give up the current timeslice.\n\n Before calling this the first time, you should use DOS fn 35H to\n check that the vector for INT 2FH is non-zero.\n\n The system does not suspend your program unless there is another\n task ready to run; most often, control will immediately return.\n\n You should place a call to this fn inside your idle loop,\n whenever waiting for keyboard input or polling the mouse, etc.\n\n Notes: This fn is also described (with the same parameters and\n functionality) as part of the DPMI specification.\n\nSee Also: INT 28H: DOS Idle\n INT 2fH 16xxH: Enh386 Windows Services & Notifications\n DPMI Services\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "772-int_2fh_1681h__begin_critical_section.html",
    "t": "INT 2fH 1681H: Begin Critical Section",
    "b": "Compatibility: Win 3.x\n Expects: AX 1681H\n ──────────────────────────────────────────────────────────────────\n Returns: none\n ──────────────────────────────────────────────────────────────────\n Info: DOS programs (including TSRs and device drivers), when running\n under Virtual-8086 mode (as when Enh386-Mode Windows is running)\n can use this call to prevent a task-switch from occurring.\n\n While in a critical section no other tasks, except hardware\n interrupt handlers, are allowed to run. Use INT 2fH 1682H (end\n critical section) as soon as possible.\n\nSee Also: INT 2fH 16xxH: Enh386 Windows Services & Notifications\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "773-int_2fh_1682h__end_critical_section.html",
    "t": "INT 2fH 1682H: End Critical Section",
    "b": "Compatibility: Win 3.x\n Expects: AX 1682H\n ──────────────────────────────────────────────────────────────────\n Returns: none\n ──────────────────────────────────────────────────────────────────\n Info: This releases control, allowing Windows (or other VM handler) to\n resume time-slice sharing among currently-active tasks.\n\n After signalling entry into a critical section (INT 2fH 1681H),\n you should use this service as soon as possible.\n\nSee Also: INT 2fH 16xxH: Enh386 Windows Services & Notifications\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "774-int_2fh_1683h__get_current_virtual_machine_id.html",
    "t": "INT 2fH 1683H: Get Current Virtual Machine ID",
    "b": "Compatibility: Win 3.x\n Expects: AX 1683H\n ──────────────────────────────────────────────────────────────────\n Returns: BX virtual machine identifier\n ──────────────────────────────────────────────────────────────────\n Info: DOS programs and device drivers can use this service to learn\n which virtual machine (e.g., DOS session) is running. This is\n handy if your TSR maintains separate data or execution contexts\n for each VM or DOS session.\n\n Windows typically runs in VM 0001H (but that's not guaranteed in\n the future). Also, Windows may need to recycle VM IDs, so you\n are supposed to monitor for VM starts and terminations (though it\n is not obvious how to do so).\n\nSee Also: INT 2fH 16xxH: Enh386 Windows Services & Notifications\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "775-int_2fh_1684h__get_device_entry_point_address__for_vxds_.html",
    "t": "INT 2fH 1684H: Get Device Entry-Point Address (for VxDs)",
    "b": "Compatibility: Win 3.x\n Expects: AX 1684H\n BX Device ID (see VxD IDs)\n ES:DI 0000:0000 (required for pre-3.0 Windows)\n ──────────────────────────────────────────────────────────────────\n Returns: ES:DI device entry-point address\n 0000:0000 if that device does not support entry-point calls\n ──────────────────────────────────────────────────────────────────\n Info: TSRs and DOS-level device drivers may use this function as a way\n to communicate with a Windows virtual device driver (VxD).\n\n This is normally used to access \"published\" APIs supplied by\n software vendors or it can be called by a TSR which has loaded a\n windows virtual device (and therefore knows its ID).\n\n Windows virtual device drivers can use this to provide various\n services to DOS device drivers and TSRs. To access any such\n services, set registers as needed by the device, and use a FAR\n CALL to execute the code at ES:DI.\n\n The INT 2fH 1607H (device call out) service provides another\n means of communication.\n\nSee Also: INT 2fH 16xxH: Enh386 Windows Services & Notifications\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "776-int_2fh_1685h__switch_vms_and_callback.html",
    "t": "INT 2fH 1685H: Switch VMs and CallBack",
    "b": "Compatibility: Win 3.x\n Expects: AX 1685H\n BX VM_ID (virtual machine ID)\n CX flags: bit 0: 1=wait until interrupts are enabled\n bit 1: 1=wait until critical section is released\n DX:SI 32-bit priority boost setting (DX=high word, SI=low word)\n ES:DI callback function address\n ──────────────────────────────────────────────────────────────────\n Returns: AX return code: 0000H (and CF is clear) in successful\n 0001H invalid VM_ID\n 0002H invalid priority boost\n 0003H invalid flags\n ──────────────────────────────────────────────────────────────────\n Info: This causes Windows to switch to a specified virtual machine and\n then call a specified address.\n\n This is used by network support software or software which needs\n to perform certain functions while executing in a specific\n virtual machine.\n\n Please see the Windows Device Driver Kit (DDK) for full\n information.\n\nSee Also: INT 2fH 16xxH: Enh386 Windows Services & Notifications\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "777-int_2fh_1686h__detect_int_31h_dpmi_services.html",
    "t": "INT 2fH 1686H: Detect INT 31h DPMI Services",
    "b": "Compatibility: Win 3.x\n Expects: AX 1686H\n ──────────────────────────────────────────────────────────────────\n Returns: AX 0000h = INT 31H (DPMI) services are available\n else = not available\n ──────────────────────────────────────────────────────────────────\n Info: TSRs and device drivers can use this to detect whether INT 31H\n (DPMI) protected-mode services are available.\n\n Protected mode services are used to allocate and manage memory\n while the CPU is in protected mode.\n\n See DOS Protected Mode Interface for related information.\n\n Note: The DPMI spec describes this fn differently. It says INT 2fH\n AX=1686H is a way to determine the current CPU operating mode.\n If AX=0000H on return, then you can assume protected mode.\n Otherwise, the CPU is in either Real Mode or Virtual 86 Mode.\n\n I'm not sure who wins the INT 2fH API war.\n\nSee Also: INT 2fH 16xxH: Enh386 Windows Services & Notifications\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "778-int_2fh_40xxh__virtual_display_driver_functions.html",
    "t": "INT 2fH 40xxH: Virtual Display Driver Functions",
    "b": "Compatibility: Win 3.0+\n\n See: 4000H (srvc: enable VM-assisted video save/restore)\n\n 4001H (ntfy: about to switch to background)\n 4002H (ntfy: about to switch to foreground)\n\n 4003H (srvc: enter critical section)\n 4004H (srvc: exit critical section)\n\n 4005H (ntfy: saving video registers)\n 4006H (ntfy: restoring video registers)\n\n 4007H (srvc: disable VM-assisted save/restore)\n\n Notes: ■ These functions are used by programs which expect to be run in\n virtual machines under Enhanced-Mode Windows.\n\n They provide access to some Virtual Display Device (VDD)\n services and notifications to help them manage the screen as\n they are swapped into and out of the foreground.\n\n In general, these fns are used only by programs which do weird\n stuff to the video display; for instance, programs which\n display in video modes which are not supported by the VDD or\n perform on-the-fly modifications to on-screen fonts, etc.\n\n ■ The services are tools that can be called by VM-aware\n applications to access services provided by the VDD.\n\n ■ The notifications represent INT 2fH fns that are invoked by the\n Windows VDD. To receive these notifications, VM-aware\n applications can intercept INT 2fH and watch for AX=40xxH.\n\nSee Also: INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "779-int_2fh_4000h__enable_vm_assisted_video_save_restore.html",
    "t": "INT 2fH 4000H: Enable VM-Assisted Video Save/Restore",
    "b": "Compatibility: Win 3.x\n Expects: AX 4000H\n ──────────────────────────────────────────────────────────────────\n Returns: AL video support: 00H no support provided\n 01H no modes virtualized in background\n 02H only text modes virtualized in background\n 03H only text and single-plane graphics modes\n 04H only text, single plane and VGA gfx modes\n ffH all supported video modes virtualized\n ──────────────────────────────────────────────────────────────────\n Info: This allows a VM-aware application to gain more control over how\n the screen is saved and restored by the VDD (Virtual Device\n driver). This is typically called when the VM-aware app is\n initializing. After calling:\n\n ■ The VDD saves the current settings of the video registers. The\n VDD will use these settings before calling INT 2fH 4005H and\n INT 2fH 4006H (save and restore video register).\n\n ■ The VDD will use INT 2fH 4005H and INT 2fH 4006H when it needs\n to save and restore video register settings. The idea is that\n you can provide your own handler for these fns.\n\n ■ The VDD will no longer save the contents of the virtual display\n across screen switches. It will be your responsibility to\n intercept INT 2fH 4002H and refresh your own video mode and\n screen when you are switched to the foreground.\n\n Use INT 2fH 4007H (disable VM-assisted video save/restore) to\n return to allowing the VDD to have full responsibilities.\n\nSee Also: INT 2fH 40xxH: Virtual Display Driver Functions\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "780-int_2fh_4001h__notify_background_switch.html",
    "t": "INT 2fH 4001H: Notify Background Switch",
    "b": "Compatibility: Win 3.x\n Expects: AX 4001H\n ──────────────────────────────────────────────────────────────────\n Returns: none\n ──────────────────────────────────────────────────────────────────\n Info: VM-aware applications can intercept this fn. The VDD calls it\n when it is switching the application into the background.\n\n After being switched into the background, the application\n continues running, but will be frozen if it attempts to access\n video memory (and the screen is in a mode in which background\n access is not supported by the VDD--see INT 2fH 4000H).\n\nSee Also: INT 2fH 40xxH: Virtual Display Driver Functions\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "781-int_2fh_4002h__notify_foreground_switch.html",
    "t": "INT 2fH 4002H: Notify Foreground Switch",
    "b": "Compatibility: Win 3.x\n Expects: AX 4002H\n ──────────────────────────────────────────────────────────────────\n Returns: none\n ──────────────────────────────────────────────────────────────────\n Info: VM-aware applications can intercept this fn. The VDD calls it\n when it is switching the application into the foreground.\n\n Applications which access video memory while in the background\n will be frozen by the VDD (if the screen is in an unsupported\n video modes INT 2fH 4000H). This fn notifies the VM-aware\n application that it now has access to video memory.\n\n If the application has not called INT 2fH 4000H (enable VM-\n assisted video save/restore) then the VDD automatically restores\n the screen before calling this fn.\n\nSee Also: INT 2fH 40xxH: Virtual Display Driver Functions\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "782-int_2fh_4003h__enter_critical_section.html",
    "t": "INT 2fH 4003H: Enter Critical Section",
    "b": "Compatibility: Win 3.x\n Expects: AX 4003H\n ──────────────────────────────────────────────────────────────────\n Returns: none\n ──────────────────────────────────────────────────────────────────\n Info: This signals to the VDD that the VM-aware application is entering\n a critical section, during which time the video registers should\n not be reprogrammed. It cause the VDD to delay that action for\n up to 1 second.\n\n You should use INT 2fH 4004H (exit critical section) within\n 1000ms (1 second) of making this call. It 1000ms elapse without\n the VDD getting an INT 2fh 40004H call, it goes ahead and\n reprograms the video registers anyway.\n\nSee Also: INT 2fH 40xxH: Virtual Display Driver Functions\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "783-int_2fh_4004h__exit_critical_section.html",
    "t": "INT 2fH 4004H: Exit Critical Section",
    "b": "Compatibility: Win 3.x\n Expects: AX 4004H\n ──────────────────────────────────────────────────────────────────\n Returns: none\n ──────────────────────────────────────────────────────────────────\n Info: After a previous call to INT 2fH 4003H (enter critical section),\n you should use this fn to signal the end of the critical session.\n\n If the VDD has been delaying an update to the video registers, it\n will perform it immediately upon receipt of this call.\n\n Calls to this fn without a preceding call to INT 2fH 4003H are\n ignored by the VDD.\n\nSee Also: INT 2fH 40xxH: Virtual Display Driver Functions\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "784-int_2fh_4005h__save_video_register_state.html",
    "t": "INT 2fH 4005H: Save Video Register State",
    "b": "Compatibility: Win 3.x\n Expect: AX 4005H\n ──────────────────────────────────────────────────────────────────\n Return: none\n ──────────────────────────────────────────────────────────────────\n Info: VM-aware applications which have used INT 2fH 4000H (enable VM-\n assisted video save/restore) can intercept this fn and take\n whatever action is needed to save the state of the video\n registers.\n\n The VDD calls this fn when it is about to access video memory;\n for instance, when it about to copy video memory to the\n clipboard.\n\n The application must save the registers and return within 1000ms\n (1 second) or the VDD will go ahead and access video memory\n anyway.\n\nSee Also: INT 2fH 40xxH: Virtual Display Driver Functions\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "785-int_2fh_4006h__restore_video_register_state.html",
    "t": "INT 2fH 4006H: Restore Video Register State",
    "b": "Compatibility: Win 3.x\n Expect: AX 4006H\n ──────────────────────────────────────────────────────────────────\n Return: none\n ──────────────────────────────────────────────────────────────────\n Info: VM-aware applications which have used INT 2fH 4000H (enable VM-\n assisted video save/restore) can intercept this fn and take\n whatever action is needed to restore the state of the video\n registers to what it was at the time of the previous\n INT 2fH 4006H (save vid regs) call.\n\n Before calling this, the VDD restores the registers to what they\n were at the time of the original INT 2fH 4000H call; thus the\n application need only modify video registers which differ from\n their earlier settings.\n\nSee Also: INT 2fH 40xxH: Virtual Display Driver Functions\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "786-int_2fh_4007h__disable_vm_assisted_video_save_restore.html",
    "t": "INT 2fH 4007H: Disable VM-Assisted Video Save/Restore",
    "b": "Compatibility: Win 3.x\n Expects: AX 4007H\n ──────────────────────────────────────────────────────────────────\n Return: none\n ──────────────────────────────────────────────────────────────────\n Info: This stops the VDD from notifying a VM-aware application about\n video register activities and pending background/foreground\n switches.\n\n The VDD will no longer call:\n\n INT 2fH 4001H (ntfy: about to switch to background)\n INT 2fH 4002H (ntfy: about to switch to foreground)\n\n INT 2fH 4005H (ntfy: save video registers)\n INT 2fH 4006H (ntfy: restore video registers)\n\n And it will ignore calls to:\n\n INT 2fH 4003H (srvc: enter critical section)\n INT 2fH 4004H (srvc: exit critical section)\n\n This is typically used by VM-aware applications when they are\n terminating.\n\nSee Also: INT 2fH 40xxH: Virtual Display Driver Functions\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "787-doublespace_overview.html",
    "t": "DoubleSpace Overview",
    "b": "TECH Help! covers these DoubleSpace and MRCI Topics:\n\n DoubleSpace API INT 2fH 4a11H and IOCTL services\n Compressed Volume File Layout (CVF internal structures)\n Mapping DOS FAT to MDFAT For CVF spelunkers\n\n DBLSPACE.INI Commands Boot-time configuration settings\n\n Using a Compressed RAM Disk Just a tip for power users\n\n MRCI API (INT 2fH 4a12H Real-time Compression fns)\n\n█▌Overview▐█\n DoubleSpace compression is implemented in levels:\n\n ■ The lowest level is the MRCI support which compresses and uncompresses\n data with a few simple API calls. MRCI fns may be installed in a ROM\n module.\n\n ■ The next level is the DoubleSpace device driver (DBLSPACE.BIN) which is\n installed at boot time. It emulates a disk drive by reading from and\n writing to a standard DOS file (i.e., a Compressed Volume File▲).\n\n ■ Finally, the program DBLSPACE.EXE is an external DOS command which\n installs DoubleSpace support, compresses disk volumes, and tweaks the\n DoubleSpace configuration file (DBLSPACE.INI).\n\n█▌Boot Sequence▐█\n At system startup, the BIOS reads and executes the boot sector of the\n boot drive. That reads and executes file IO.SYS which reads and executes\n MSDOS.SYS (all of this is the normal pre-DoubleSpace sequence).\n\n New with DOS 6.0: Before MSDOS.SYS begins processing CONFIG.SYS, it looks\n for DBLSPACE.BIN in the root of the boot drive. If found, it is loaded\n into the highest part of conventional▲ memory and executed.\n\n Next DBLSPACE.BIN looks in the root of the boot drive for DBLSPACE.INI.\n It reads this file to learn how it should configure itself (which CVFs to\n mount and which drive IDs to swap, etc.).\n\n After DBLSPACE.BIN is done mounting and swapping, it passes control back\n to MSDOS.SYS which finally reads CONFIG.SYS (from the root of the\n swapped-in drive C) and processes its commands.\n\n If the command, DEVICEHIGH=DBLSPACE.SYS, is found, then a small program\n (DBLSPACE.SYS) is executed. All it does is find the DBLSPACE.BIN code\n (remember, it starts out high in conventional memory) and move it into a\n UMB▲ if UMBs are available or to the lowest available addresses in\n conventional memory (if no UMBs exist).\n\n DOS 6.2 Notes: DBLSPACE.SYS may move the 15K MRCI engine into the HMA▲\n if there is room. The DOS 6.2 Mem /A command reveals how much HMA is\n free.\n\n This also has the effect of \"locking-in\" the DoubleSpace drive letters,\n including any \"reserved IDs\" needed for mounting compressed floppy\n diskettes.\n\n Note that DBLSPACE.BIN contains all of the drive-emulation code as well as\n the lower-level MRCI compression engine (about 15K of code). However, it\n is possible for MRCI to install itself earlier in the boot sequence...\n\n█▌Before the Boot Sequence▐█\n It is possible for an adapter card (a hard disk controller, most likely)\n to install its own MRCI engine. It could do that by having ROM-based code\n in the ROM-Scan address range. That code would intercept INT 1aH to\n provide the MRCI support API (presumably it would provide hardware-\n assisted compression support).\n\n In that case, DBLSPACE.BIN would use the ROM-based MRCI engine and discard\n its own internal version.\n\n█▌DoubleSpace Compression▐█\n DoubleSpace uses a variation of the \"Lempel-Ziv\" compression scheme. In\n simple terms, it works by keeping track of repeated sequences. When the\n same sequence appears later, it just refers to the previous data rather\n than keeping duplicates. For instance....\n\n The rain in Spain falls, mainly.\n\n ...is compressed to...\n\n The rain ■Sp■falls, m■ly.\n ↑ ↑ ↑\n 3,3 9,4 12,3\n\n The codes 3,3, 9,4, and 12,3 identify repeated sequences. The first code\n specifies the position of the original text (as a distance backward from\n the current position) and the second code specifies the length of the\n repeated text. The actual algorithms (as well as library code to do the\n work) can be licensed from Microsoft for no fee.\n\n DoubleSpace compression is around 1.7 to 1 with \"real world\" data files.\n Other systems, such as PKZIP and LHARC get better compression, but only in\n \"batch mode\" where they can work with an entire file at once. DoubleSpace\n is \"real time\" system which must work with data in 8K chunks (a 16-sector\n cluster).\n\n█▌Accessing the APIs▐█\n\n See DoubleSpace API and MRCI API for information on how to use these\n services.\n\n Most application programs will have no need to access these services.\n Exceptions exist; for instance, a backup program can use MRCI Fn 0001H\n (compress data) to save disk space on the target disk.\n\n Another example: At this writing, there is no utility to perform simple\n DoubleSpace operations such as \"Get Drive Info\" while in a DOS session\n under Windows. As you may know, the DOS Dblspace command aborts with the\n \"Can't run under Windows\" message (Note: fixed with DOS 6.2).\n\nSee Also: DoubleSpace API\n DBLSPACE.INI\n MRCI API\n DOS Functions\n -♦-"
  },
  {
    "id": "788-using_a_compressed_ram_disk.html",
    "t": "Using a Compressed RAM Disk",
    "b": "█▌Overview▐█\n Although the technique described here is interesting, its usefulness is\n debatable. Some experts say that you can get better mileage out of your\n extended memory by using it in a disk cache. However, a large RAM disk\n used as your TEMP directory will speed up I/O Redirection and Windows\n Print Manager tremendously.\n\n A compressed RAM disk provides nearly double the storage for the same\n amount of RAM. The speed difference is negligible (it's still far faster\n than the fastest uncached hard disk).\n\n█▌Prerequisites▐█\n ■ You must install the RAM disk earlier than DBLSPACE.SYS in your\n CONFIG.SYS file. Otherwise, each time you mount the RAM disk,\n DoubleSpace will modify DBLSPACE.INI to take over its drive ID (and the\n next time you boot, the RAM disk's ID will be one notch higher... ad\n infinitum).\n\n ■ You must have at least one available DoubleSpace reserved drive ID.\n Use Dblspace /LIST to check this. If not, run Dblspace, choose Options\n from the Tools menu, and change the setting.\n\n█▌The Simple, Vanilla Technique▐█\n ■ Create a 1.2 MB RAM disk. For instance..\n DEVICEHIGH=c:\\dos\\ramdrive.sys 1200 /E (in CONFIG.SYS)\n DEVICEHIGH=c:\\dos\\Dblspace.sys (in this order)\n\n ...and create a compressed drive....\n\n DBLSPACE /CREATE D: /NEW=E: /SIZE=0.50 (in AUTOEXEC.BAT)\n DBLSPACE /SIZE /RESERVE=0 E: (no reserved space needed)\n\n ...each time you boot.\n\n ■ This slows-down your boot sequence and you may want to use less than\n 1.2 MB for your RAM disk.\n\n█▌The Interesting Technique▐█\n Quick overview:\n Create a \"dummy\" compressed volume file on a diskette. Copy it to your\n hard disk. In AUTOEXEC.BAT, copy it to a RAM disk and mount it. A\n 600K RAM disk will yield about 1 MB of fast RAM disk storage.\n\n Step-by-step instructions:\n\n 1) Format a 1.2M diskette in drive A...\n Format a: /U /VDbl_RAMDisk\n\n 2) Create a minimum-size CVF▲ on the diskette; for instance,\n Dblspace /COMPRESS A: /res=0\n Dblspace /SIZE=0.56 A:\n\n 3) Unmount the compressed volume:\n Dblspace /UNMOUNT A:\n\n 4) Clear the attributes of the CVF:\n Attrib -h -r -s A:\\DBLSPACE.000\n\n 5) Copy the CVF to your hard disk, giving it a different name:\n Copy A:\\DBLSPACE.000 C:\\DUMMY.CVF\n\n Note: You no longer need the compressed diskette.\n\n 6) Setup CONFIG.SYS to create a 600K RAM disk; for instance:\n DEVICEHIGH=c:\\dos\\ramdrive.sys 600 /E\n\n Put this BEFORE installing DBLSPACE.SYS. We'll assume that your RAM\n disk is drive D.\n\n 7) Setup AUTOEXEC.BAT. Add these lines:\n SET RAMDRV=D: (create a handy e-var)\n Copy C:\\DUMMY.CVF %RAMDRV%\\DBLSPACE.000 (put CVF on RAM disk)\n Dblspace /MOUNT %RAMDRV% (make it accessible)\n\n Reboot. From now on, drive D (or whatever) will be your compressed RAM\n drive and its host will have a higher letter, such as E or F.\n\n█▌Refinements▐█\n ■ Between steps 2 and 3, pre-load the diskette with often-used programs\n and batch files. When you mount the pre-filled CVF, the programs will\n be ready for action.\n\n While you're at it, create a TEMP directory on the diskette. And in\n AUTOEXEC.BAT, use Set TEMP=%RAMDRV%\\TEMP.\n\n ■ Steps 2 and 6 minimize the memory use of the RAM disk. The technique\n works fine for larger RAM disks (in fact, you may want to use about 1MB\n to get best performance from Windows Print Manager).\n\n ■ In step 5, be sure to store the dummy CVF on a compressed disk; since\n it is mostly empty (and it was formatted with /U in step 1), it will\n take very little physical disk storage.\n\n ■ General tip for using RAM disks: Step 7 creates an e-var to identify\n the RAM disk. In batch files that refer to the RAM disk drive ID, use\n %RAMDRV%\\ in place of D:\\. That way, if you end up changing the drive\n ID of the RAM disk, one change to AUTOEXEC.BAT fixes all of your batch\n files and MAKE files.\n\n Notes: ■ In nearly all respects, DoubleSpace treats a RAM disk as if it\n were a hard disk. The one apparent difference is in\n Dblspace /LIST, it will identify a disk as a \"Compressed\n RAMDrive\" or \"Local RAMDrive\" only if its volume label is\n \"MS-RAMDRIVE\".\n\n ■ By default, Smartdrv will provide disk caching for a compressed\n RAM disk. This is particularly wasteful (if somewhat\n humorous). Be sure to disable all caching for your RAM disk;\n for instance, if the RAM disk host drive is E, add E- to the\n Smartdrv command line in your AUTOEXEC.BAT file.\n\nSee Also: DoubleSpace (overview)\n -♦-"
  },
  {
    "id": "789-dblspace_ini_commands.html",
    "t": "DBLSPACE.INI Commands",
    "b": "█▌Overview▐█\n The DoubleSpace support driver (DBLSPACE.BIN) reads the text file▲,\n DBLSPACE.INI, in order to decide which CVFs▲ to access and what drive\n IDs to use. This topic describes the contents of DBLSPACE.INI.\n\n DBLSPACE.INI is in the root of the physical boot disk (it is typically\n swapped to an ID such as H: or I: by the time you look for it). It has\n read-only, hidden, and system file attributes; use Dir /A to see it\n listed.\n\n You can edit the file with any text editor, such as the DOS Edit command.\n You must clear its attributes first (Attrib H:\\Dblspace.ini -H -S -R).\n\n Before making changes, I recommend that you prepare a boot diskette with\n an editor and other tools. Oh, yeah -- make a copy of DBLSPACE.INI, too.\n\n█▌DBLSPACE.INI Commands▐█\n\n MaxRemovableDrives=n\n DoubleSpace maintains a series of structures to keep track of mounted\n drives. At boot time, DoubleSpace allocates memory for one structure\n for each drive which was activated plus an extra n such structures.\n See INT 2fH 4a11H 0009H (Count DISK_UNIT structures).\n\n A normal setting: MaxRemovableDrives=2\n\n To change: Choose Options in the Tools menu.\n\n FirstDrive=drvLtr\n Specifies the lowest drive letter available for a host or compressed\n drive. DoubleSpace ignores FirstDrive and simply takes control of\n all drive IDs starting from the original ID of the disk that contains\n the first CVF mounted (see ActivateDrive, below).\n\n LastDrive=drvLtr\n Specifies the highest drive letter available for a host or compressed\n drive.\n\n Notes: ■ DoubleSpace assigns drive IDs starting at LastDrive and working\n down toward FirstDrive.\n\n DoubleSpace will increase LastDrive automatically when\n necessary. For instance, if you mount a volume from a high-\n lettered drive, DoubleSpace will need to consume drive letters\n up to and including that drive's original ID.\n\n ■ See INT 2fH 4a11H 0001H (get drive map).\n\n MaxFileFragments=nnnn\n When a CVF is fragmented, DoubleSpace must maintain an internal\n structure to keep track of each fragment (this avoids having to hit\n the FAT of the host). This command determines how much memory to\n allocate. See INT 2fH 4a11H 0008H (get CVF Fragmentation Info).\n\n During installation, nnnn is set to a whopping 2600. That's because\n a CVF may need to be created in multiple, discontiguous sections when\n the host disk is large and has little free space.\n\n But 2600 is a worst-case scenario. After the initial installation,\n MaxFileFragments is adjusted automatically to reflect the actual\n memory needs. It is set to the actual number of file fragments on\n all CVFs plus a fudge factor of 110.\n\n To see how fragmented your CVFs ended up, subtract 110 from the\n current setting.\n\n ActivateDrive=d,dn\n │ │└────── CVF number (0-9)\n drv1 ──┘ └─────── drv2\n\n One or more of these ActivateDrive= commands appear at the end of\n DBLSPACE.INI. Each command identifies the locations of a hard disk\n volume to mount automatically at system startup, and the drive ID to\n use for it and its host.\n\n n specifies which CVF▲ to mount. It is a digit, 0 to 9--the last\n digit of the CVF file extension.\n\n See INT 2fH 4a11H 0005H (mount volume) and\n See INT 2fH 4a11H 0002H (swap drive IDs)\n\n If n is 0\n The volume was created by compressing existing files. The compressed\n volume ID will be swapped with the host ID, so...\n\n drv1 is the drive letter to be used for the host.\n drv2 is the drive letter to be used for the compressed volume. It also\n identifies the original (unswapped) ID of the drive on which the CVF is\n stored.\n\n Example: ActivateDrive=H,C0\n The file C:\\DBLSPACE.000 is mounted and IDs are swapped. The host ID\n will be H: and the compressed volume will be called C:.\n\n If n is not 0\n The volume was created by compressing free space. The compressed\n volume ID will not be swapped, so...\n\n drv1 is the drive letter to be used for the compressed volume.\n drv2 is the original drive letter of the host.\n\n Example: ActivateDrive=G,C1\n Mounts C:\\DBLSPACE.001 as drive G:. No swapping occurs.\n\n Example: ActivateDrive=H,C0\n ActivateDrive=D,C1\n C:\\DBLSPACE.000 is mounted as drive C: and the host ID is swapped and\n can be accessed as drive H:.\n\n C:\\DBLSPACE.001 is mounted for access as drive D:. The host ID was\n swapped in the first line, so DBLSPACE.001 will be on drive H.\n\n Note: When changing these settings, be sure to assign drive letters\n that are within the range of FirstDrive= and LastDrive=.\n\n Enable386=?\n Debug=?\n These two commands are recognized by Dblspace.Exe, but are\n undocumented in any source I could find. I would guess, that\n Enable386= lets DoubleSpace support use 32-bit optimized compression\n code and would only be needed on a machine that appears to be a 286\n but is really a 386+. The Debug= line may be an undeleted remnant\n from beta tests; DBLSPACE.BIN does not recognize it.\n\nSee Also: DoubleSpace (overview)\n -♦-"
  },
  {
    "id": "790-int_2fh_4a11h__doublespace_api_services.html",
    "t": "INT 2fH 4a11H: DoubleSpace API Services",
    "b": "Compatibility: 6.0+\n\n See: BX=0000H (query DoubleSpace version/first & last drive)\n BX=0001H (get DoubleSpace drive mapping)\n BX=0002H (swap drive letters)\n BX=0003H (reserved; used by SmartDrive disk cache)\n BX=0004H (reserved; used by SmartDrive disk cache)\n BX=0005H (mount a DoubleSpace drive)\n BX=0006H (unmount a DoubleSpace drive)\n\n BX=0007H (get drive size & free space)\n BX=0008H (get CVF file fragment info)\n BX=0009H (get count of DISK_UNIT structures)\n\n BX=000aH (set automount drives; DOS 6.2+)\n BX=000bH (query automount drives; DOS 6.2+)\n\n DS IOCTL 'F' (flush DoubleSpace cache)\n DS IOCTL 'I' (flush and invalidate DoubleSpace cache)\n DS IOCTL 'S' (get actual free space; DOS 6.2+)\n\n Compressed Volume File Layout (CVF internal structures)\n DoubleSpace API Error/Return Codes (codes returned by these fns)\n MRCI API (Microsoft Real-time Compression Interface fns)\n\n To use the API, set AX to 4a11H and set other registers as described\n in each fn, then execute an INT 2FH. The two IOCTL calls are just\n DOS fn 4404H (IOCTL read) services.\n\n Notes: ■ These services are available only if DoubleSpace (or compatible\n compression service) was activated upon system startup.\n\n ■ For most applications, the existence of DoubleSpace is entirely\n transparent. In general, only specialized disk utility\n programs need to access these fns.\n\nSee Also: DoubleSpace Overview\n DoubleSpace API\n DOS fn 4404H (get control data from block device)\n DOS Functions\n -♦-"
  },
  {
    "id": "791-int_2fh_4a11h_bx_0000h__get_dblspace_version___drives.html",
    "t": "INT 2fH 4a11H BX=0000H: Get Dblspace Version & Drives",
    "b": "Compatibility: 6.0+\n Expects: AX 4a11H (mux number)\n BX 0000H (DoubleSpace fn code)\n ──────────────────────────────────────────────────────────────────\n Returns: AX DoubleSpace API Error Code (0000H=success)\n BX 444dH signature; 'M','D')\n CL first drive letter used by DoubleSpace (41H='A', etc.)\n CH count of drives letters used by DoubleSpace\n DX Version number (an internal code) high bit indicates current\n code location (high or low memory)\n ──────────────────────────────────────────────────────────────────\n Info: You may use this fn to see if DoubleSpace is installed and to\n obtain the range of drive letters that it uses.\n\n CL is the ASCII code for a drive letter (for instance, 45H=E).\n CH is a count of how many drive IDs are controlled by DoubleSpace;\n for instance, CX=0544H means drives D,E,F,G, and H are available\n to DoubleSpace for use as drive IDs.\n\n DX The low 15 bits identify the version number (this shows up as\n 0006H on my PC).\n\n Bit 15 is a location flag: When set, it indicates that\n DBLSPACE.BIN is not at its final location (for instance, the\n DEVICEHIGH=DBLSPACE.SYS command is not in CONFIG.SYS or has not\n been executed yet.\n\nSee Also: DoubleSpace Overview\n DoubleSpace API\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "792-int_2fh_4a11h_bx_0001h__get_dblspace_drive_mapping.html",
    "t": "INT 2fH 4a11H BX=0001H: Get Dblspace Drive Mapping",
    "b": "Compatibility: 6.0+\n Expects: AX 4a11H (mux number)\n BX 0001H (DoubleSpace fn code)\n DL drive number to check (0=A, 1=B, etc)\n ──────────────────────────────────────────────────────────────────\n Returns: AX DoubleSpace API Error Code (0000H=success)\n BH compressed drive sequence number (0-255)\n BL bits 0-6: host drive number (if drive is compressed)\n bit 7: compressed drive flag (1=compressed)\n ──────────────────────────────────────────────────────────────────\n Info: You may use this fn as part of a system to determine whether a\n particular drive ID represents a CVF▲ or a host drive.\n Interpreting the return results can be a little bit tricky:\n\n AX on return, if AX is non-zero, then DoubleSpace has not been\n loaded and DL is a standard (uncompressed, unswapped) drive ID.\n\n BH on return, BH is the sequence number; that is, the number of the\n file extension of the CVF. For instance, if BH returns with 01H,\n (and if BL indicates that this is a compressed drive) then the\n CVF is named DBLSPACE.001 (in the root of its host).\n\n BL on return, if the high bit is set, then drive DL is a compressed\n drive and the low 7 bits of BL identify the drive ID of the host.\n\n For instance, a return value of BL=83H means that DL was a\n compressed volume whose CVF is now on drive D (0=A, 1=B, etc.).\n All DOS-level fns will be able to access that host as drive D,\n but its drive ID may have been swapped, so BIOS-level fns to\n access the physical drive may use a different drive number.\n\n To learn the original drive number for the drive on which the CVF\n is stored, you must make a second call to this fn, this time\n setting DL to the value returned in the low 7 bits of BL. If\n BL=DL upon return from that second call, then that drive is host\n to itself (the drive IDs have been swapped); therefore BIOS\n access is via the BL value returned in the first call.\n\n Notes: This seems far too complicated; I hope I made it clearer than the\n Microsoft dox!\n\nSee Also: DoubleSpace Overview\n DoubleSpace API\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "793-int_2fh_4a11h_bx_0002h__dblspace_swap_drive.html",
    "t": "INT 2fH 4a11H BX=0002H: Dblspace Swap Drive",
    "b": "Compatibility: 6.0+\n Expects: AX 4a11H (mux number)\n BX 0002H (DoubleSpace fn code)\n DL compressed drive number to swap with its host\n ──────────────────────────────────────────────────────────────────\n Returns: AX DoubleSpace API Error Code (0000H=success)\n ──────────────────────────────────────────────────────────────────\n Info: This swaps a DoubleSpace compressed drive's ID with the ID of its\n host drive.\n\n For instance, if drive C contains a CVF▲ named DBLSPACE.000, then\n when DoubleSpace starts up, it will mount that CVF as drive J\n (for example).\n\n To set up so the compressed volume is drive C (and set the host\n as drive J), you would set DL to 9 (0=A, 1=B,...9=J)\n\n Notes: ■ There is no \"unswap\" variation of this fn; if you attempt to\n swap a previously-swapped drive, this fn returns an error.\n\n ■ DBLSPACE.BIN performs disk swapping automatically, based on\n settings in DBLSPACE.INI. I recommend against using this fn.\n\nSee Also: DoubleSpace Overview\n DoubleSpace API\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "794-int_2fh_4a11h_bx_0005h__mount_dblspace_drive.html",
    "t": "INT 2fH 4a11H BX=0005H: Mount Dblspace Drive",
    "b": "Compatibility: 6.0+\n Expects: AX 4a11H (mux number)\n BX 0005H (DoubleSpace fn code)\n DL drive number to assign to CVF (0=A, 1=B, etc)\n ES:SI addr of DsActivateRec (undocumented; see below)\n ──────────────────────────────────────────────────────────────────\n Returns: ES:SI bErrCode field is DoubleSpace API Error Code (00H=success)\n ──────────────────────────────────────────────────────────────────\n Info: The documentation for this fn is incomplete--Microsoft explains\n that it is \"very, very complicated.\" It involves constructing a\n file fragment list, recomputing the BitFAT, and checking for\n MDFAT crosslinks.\n\n We are told that the best way to mount a drive is to spawn a copy\n of DBLSPACE.EXE, using a command line with the following syntax:\n\n DBLSPACE.EXE /MOUNT[=seq] host_drv [/NEWDRIVE=new_drv]\n\n For instance...\n\n DBLSPACE.EXE /MOUNT=1 C: /NEWDRIVE=H\n\n ...will mount the CVF named C:\\DBLSPACE.001 as drive H. Keep in\n mind the exception Dblspace makes when mounting a .000 volume; in\n that case, it automatically swaps the host ID with the compressed\n volume ID.\n\n ES:DI on entry, ES:DI must point to a local activation record. The\n available documentation describes only the first few fields of\n this structure, as follows:\n\n DsActivateRec\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 2 abSig must be 444dH ('M','D')\n +2 1 bCmdCode must be 4dH ('M') Mount command\n +3 1 bResult returns a DoubleSpace API Error Code\n +4 1 bHostDrvNo host drive number (0=A, 1=B, etc.)\n +5 ? rDiskUnit undocumented structure goes here\n (different for DOS 6.0 and DOS 6.2)\n 5+? length of DsActivateRec (undocumented)\n\n We don't have documentation on the rDiskUnit structure (and we\n are told it is complicated and changed with DOS 6.2), so we can't\n use this call. We do know that DBLSPACE.BIN allocates a number\n of them, depending upon the MaxRemovableDrives setting in\n DBLSPACE.INI (see INT 2fH 4a11H 0009H).\n\n On entry, the bHostDrvNo field contains the drive number of the\n host drive and (presumably), something in rDiskUnit identifies\n the CVF▲ name (or sequence number).\n\n On return, the bResult field contains 00H if the operation was\n successful or a DoubleSpace API Error Code if the volume could\n not be mounted.\n\n Note: This looks like a wrapper for an undocumented IOCTL call.\n Compare to DS IOCTL 'F' and DS IOCTL 'I'.\n\nSee Also: DoubleSpace Overview\n DoubleSpace API\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "795-int_2fh_4a11h_bx_0006h__unmount_dblspace_drive.html",
    "t": "INT 2fH 4a11H BX=0006H: Unmount Dblspace Drive",
    "b": "Compatibility: 6.0+\n Expects: AX 4a11H (mux number)\n BX 0006H (DoubleSpace fn code)\n DL compressed drive number to unmount (0=A, 1=B, etc.)\n ──────────────────────────────────────────────────────────────────\n Returns: AL DoubleSpace API Error Code (00H=success)\n ──────────────────────────────────────────────────────────────────\n Info: This unmounts a compressed volume; severing the connection\n between a compressed volume and its drive ID.\n\n It's probably a bad idea to unmount an drive on which files are\n open (for instance), or anytime Windows is running.\n\nSee Also: DoubleSpace Overview\n DoubleSpace API\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "796-int_2fh_4a11h_bx_0007h__get_dblspace_disk_size___free_space.html",
    "t": "INT 2fH 4a11H BX=0007H: Get Dblspace Disk Size / Free Space",
    "b": "Compatibility: 6.0+\n Expects: AX 4a11H (mux number)\n BX 0007H (DoubleSpace fn code)\n DL compressed drive to query\n ──────────────────────────────────────────────────────────────────\n Returns: AX DoubleSpace API Error Code (0000H = success)\n DS:SI address of DsSpaceInfoRec (see below)\n ──────────────────────────────────────────────────────────────────\n Info: This obtains the true total space and free space available in the\n specified volume.\n\n Note: the newer (6.2) DS IOCTL 'S' function is the preferred\n method of obtaining this information.\n\n DS:SI on return, DS:SI points to the following data structure:\n\n DsSpaceInfoRec\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 4 lTotSects total data sectors in the disk\n +4 4 lFreeSects available sectors in the disk\n 8 size of a DsSpaceInfoRec (undocumented)\n\n Notes: ■ This changes DS, pointing it into DBLSPACE.BIN local data area.\n So take notice (and change it back to point to your local data\n area after this call).\n\n ■ The return values in lTotSects and lFreeSects are expressed in\n 512-byte sectors.\n\n ■ The maximum physical size of a DoubleSpace compressed volume\n is 512 MB. Thus, the largest value you can expect returned in\n lTotSects is 1,048,576 (0010 0000H) sectors.\n\n ■ Use DOS fn 36H to obtain the estimated storage for the drive.\n\n ■ The documented API does not provide an estimated compression\n ratio, but you can derive it by comparing lTotSects to the\n value obtained from DOS fn 36H.\n\nSee Also: DoubleSpace Overview\n DS IOCTL 'S' (Get DriveSpace Pointers)\n DoubleSpace API\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "797-int_2fh_4a11h_bx_0008h__get_cvf_fragmentation_info.html",
    "t": "INT 2fH 4a11H BX=0008H: Get CVF Fragmentation Info",
    "b": "Compatibility: 6.0+\n Expects: AX 4a11H (mux number)\n BX 0008H (DoubleSpace fn code)\n DL any compressed drive number (0=A, 1=B, etc.)\n ──────────────────────────────────────────────────────────────────\n Returns: AX DoubleSpace API Error Code (0000H=success)\n BX maximum entries in file fragment heap\n CX available entries in file fragment heap\n ──────────────────────────────────────────────────────────────────\n Info: DoubleSpace maintains an internal list of information that\n describes the fragmentation of CVFs▲. This fn obtains\n information about that list.\n\n DL on entry, is any valid compressed drive number. A single\n fragment heap is used for all CVFs.\n\n CX on return, is the total size of the fragment heap. It is the\n value of the MaxFileFragments setting in DBLSPACE.INI.\n\n BX on return, is the number of unused fragment entries in the file\n fragment heap.\n\n Notes: ■ By tracking CVF fragments internally, DoubleSpace avoids\n needing to reread the FAT of the host drive.\n\n ■ A CVF will be very fragmented if, during initial compression,\n there was very little free space on the disk. By default,\n MaxFileFragments is initially set to a whopping 2600. But\n DBLSPACE.EXE adjusts it downward (to the actual needs plus a\n fudge factor of 110) to avoid forcing DBLSPACE.BIN to allocate\n a lot of memory each time DOS boots.\n\n ■ You can save some memory by defragmenting your CVFs with the\n DOS 6 Defrag command; however, Defrag won't modify a mounted\n CVF. Before defragmenting a CVF, you must unmount it (which is\n awkward for your boot drive) and change its file attributes to\n clear the hidden, system, and read-only bits.\n\nSee Also: DoubleSpace Overview\n DoubleSpace API\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "798-int_2fh_4a11h_bx_0009h__get_count_of_disk_unit_structures.html",
    "t": "INT 2fH 4a11H BX=0009H: Get Count of DISK_UNIT Structures",
    "b": "Compatibility: 6.0+\n Expects: AX 4a11H (mux number)\n BX 0009H (DoubleSpace fn code)\n DL any compressed drive number (0=A, 1=B, etc.)\n ──────────────────────────────────────────────────────────────────\n Returns: AX DoubleSpace API Error Code (0000H=success)\n CL count of DISK_UNIT structures allocated by DBLSPACE.BIN\n ──────────────────────────────────────────────────────────────────\n Info: This determines how many compressed volumes can be mounted\n simultaneously.\n\n This is related to the value of the MaxRemovableDrives setting in\n DBLSPACE.INI. This fn returns that number plus the number of\n successful ActivateDrive lines in DBLSPACE.INI.\n\nSee Also: DoubleSpace Overview\n DoubleSpace API\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "799-int_2fh_4a11h_bx_000ah__set_automount_drives.html",
    "t": "INT 2fH 4a11H BX=000aH: Set Automount Drives",
    "b": "Compatibility: 6.2+\n Expects: AX 4a11H (mux number)\n BX 000aH (DoubleSpace fn code)\n CX:DX bitmap of drives to enable/disable for automount (see below)\n ──────────────────────────────────────────────────────────────────\n Returns: AX DoubleSpace API Error Code (0000H=success)\n CX:DX bitmap indicating previous automount settings\n ──────────────────────────────────────────────────────────────────\n Info: This service is new for DOS 6.2.\n\n This lets you enable and disable automounting for some or all\n removable-media drives. In conjunction with INT 2fH 4a11H 000bH,\n you can use it to see if automounting is possible.\n\n CX:DX Is treated as a 32-bit bitmap, with the lowest 26 bits each\n representing one drive. Bit 0 of DX represents drive A, bit 1 is\n drive B...bit 15 is drive P. Bit 0 of CX represents drive Q,\n etc.\n\n A bit-value of 1 specifies to enable the drive for automounting.\n\n On Entry: CX:DX specifies which drives you want to enable and\n disable for automounting.\n\n On Return: CX:DX contains the previous settings.\n\n Notes: ■ If all automounting is disabled (Automount=0 in DBLSPACE.INI),\n then this call will have no effect.\n\n ■ You can see if automounting is possible by using this fn to\n try to enable a drive, then using INT 2fH 4a11H 000bH (query\n automount drives) to see if the change was recorded.\n\nSee Also: DoubleSpace Overview\n DoubleSpace API\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "800-int_2fh_4a11h_bx_000bh__query_automount_drives.html",
    "t": "INT 2fH 4a11H BX=000bH: Query Automount Drives",
    "b": "Compatibility: 6.2+\n Expects: AX 4a11H (mux number)\n BX 000bH (DoubleSpace fn code)\n ──────────────────────────────────────────────────────────────────\n Returns: AX DoubleSpace API Error Code (0000H=success)\n CX:DX bitmap of drives to enabled for automount (see below)\n ──────────────────────────────────────────────────────────────────\n Info: This service is new for DOS 6.2.\n\n This lets you learn which drives are enabled for automounting.\n In conjunction with INT 2fH 4a11H 000aH, you can use it to see if\n automounting is possible.\n\n CX:DX On return indicates which drive IDs are enabled for automounting.\n It is a 32-bit bitmap, with the lowest 26 bits each representing\n one drive. Bit 0 of DX represents drive A, bit 1 is drive\n B...bit 15 is drive P. Bit 0 of CX represents drive Q, etc.\n\n A bit-value of 1 indicates that the drive is enabled for\n automounting; 0 indicates that it is not.\n\n Notes: ■ If all automounting is disabled (Automount=0 in DBLSPACE.INI),\n then this call will always return 0000:0000.\n\n ■ You can determine if automounting is possible by using\n INT 2fH 4a11H 000aH (set automount drives) to try to enable a\n drive, then using this fn to see if the change was recorded.\n\nSee Also: DoubleSpace Overview\n DoubleSpace API\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "801-doublespace_api_error_return_codes.html",
    "t": "DoubleSpace API Error/Return Codes",
    "b": "The DoubleSpace API (INT 2fH 4a11H and related IOCTL fns) may return the\n following error codes:\n\nINT 2fH Error Codes\n\n 0000H I2F_NO_ERR fn was successful\n 0100H I2F_ERR_BAD_FN invalid fn number in BX\n 0101H I2F_ERR_BAD_DRV invalid drive number specified\n 0102H I2F_ERR_NOT_COMPR specified drive number is not compressed\n 0103H I2F_ERR_ALREADY_SWAPPED host drive already swapped\n 0104H I2F_ERR_NOT_SWAPPED drive is not swapped (I assume that this is\n returned by an undocumented fn)\n\nIOCTL and INT 2fH 4a11H 0005H (mount volume) Error Codes\n\n 4f4bH OK_NO_ERROR The IOCTL calls return 'OK' in the bResult\n field of the IOCTL packet if no error.\n\n 01H LETTER_BOUNDARY_ERROR Drive letter not available for DoubleSpace\n (use a drive letter between FirstDrive and\n LastDrive; see INT 2fH 4a11H 0000H)\n 02H UNIT_USED_ERROR Drive letter already in use (use an unused\n drive letter)\n 03H NO_FREE_SLOT_ERROR No more disk units (increase the\n MaxRemovableDrives setting in DBLSPACE.INI)\n\n 09H TOO_CLUTTERED_ERROR CVF is too fragmented (increase the\n MaxFileFragments setting in DBLSPACE.INI)\nSee Also: DoubleSpace Overview\n DoubleSpace API\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "802-doublespace_ioctl_fn__f___flush_doublespace_cache.html",
    "t": "DoubleSpace IOCTL fn 'F': Flush DoubleSpace Cache",
    "b": "Compatibility: 6.0+\n Expects: AX 4404H (INT 21H IOCTL Read service number)\n BL any compressed drive number (1=A, 2=B, etc)\n CX 10 (size of an DsIoctlRec; see below)\n DS:DX address of a DsIoctlRec with an 'F' (ASCII 46H) in\n the bCmdCode field)\n ──────────────────────────────────────────────────────────────────\n Returns: DS:DX bResult contains a DoubleSpace API Error Code (00H=success)\n ──────────────────────────────────────────────────────────────────\n Info: DoubleSpace maintains internal caches for its cluster data,\n BitFAT and MDFAT data (see CVF Layout).\n\n This IOCTL fn forces DoubleSpace to update the CVF▲ on disk to\n reflect the currently-cached data.\n\n The cache is still considered valid. Use DS IOCTL 'I' to force\n DoubleSpace to invalidate the cache and re-read the disk.\n\n DS:DX points to a DsIoctlRec as follows:\n\n DsIoctlRec\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 2 abSig must be 444dH ('M','D')\n +2 1 bCmdCode must be 46H ('F') Flush command\n +3 2 bResult returns a DoubleSpace API Error Code\n +5 5 res (reserved; 0)\n 10 size of a DsIoctlRec structure\n\n To use this fn, set up the packet and the registers, and call\n INT 21H. See DOS fn 44H (device I/O Control) for related DOS\n functions.\n\n On return, check bResult for an error code. The value 4f4bH\n ('OK') indicates success.\n\n Note: You can force DoubleSpace and SmartDrive to flush their disk-\n sector caches via DOS fn 0dH (reset disk).\n\nSee Also: DoubleSpace Overview\n DoubleSpace API\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "803-doublespace_ioctl_fn__i___flush_and_invalidate_cache.html",
    "t": "DoubleSpace IOCTL fn 'I': Flush and Invalidate Cache",
    "b": "Compatibility: 6.0+\n Expects: AX 4404H (INT 21H IOCTL Read service number)\n BL any compressed drive number (1=A, 2=B, etc)\n CX 10 (size of a DsIoctlRec; see below)\n DS:DX address of a DsIoctlRec with an 'I' (ASCII 49H) in\n the bCmdCode field)\n ──────────────────────────────────────────────────────────────────\n Returns: DS:DX bResult contains a DoubleSpace API Error Code (00H=success)\n ──────────────────────────────────────────────────────────────────\n Info: DoubleSpace maintains internal caches for its cluster data,\n BitFAT and MDFAT data (see CVF Layout).\n\n This IOCTL fn forces DoubleSpace to update the CVF▲ on disk to\n reflect the currently-cached data AND to invalidate its cache (so\n it will read future data requests from the disk).\n\n This is handy for disk utility programs which need to ensure that\n changes they make to a CVF are recognized immediately.\n\n DS:DX points to a DsIoctlRec as follows:\n\n DsIoctlRec\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 2 abSig must be 444dH ('M','D')\n +2 1 bCmd must be 46H ('I') flush & Invalidate\n +3 2 bResult returns a DoubleSpace API Error Code\n +5 5 res (reserved; 0)\n 10 size of a DsIoctlRec structure\n\n To use this fn, set up the packet and the registers, and call\n INT 21H. See DOS fn 44H (device I/O Control) for related DOS\n functions.\n\n On return, check bResult for an error code. The value 4f4bH\n ('OK') indicates success.\n\nSee Also: DoubleSpace Overview\n DoubleSpace API\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "804-doublespace_ioctl_fn__s___get_drivespace_pointers.html",
    "t": "DoubleSpace IOCTL fn 'S': Get DriveSpace Pointers",
    "b": "Compatibility: 6.2+\n Expects: AX 4404H (INT 21H IOCTL Read service number)\n BL any compressed drive number (1=A, 2=B, etc)\n CX 13 (size of an DsSpcIoctlRec; see below)\n DS:DX address of a DsSpcIoctlRec with an 'S' (ASCII 53H) in\n the bCmdCode field)\n ──────────────────────────────────────────────────────────────────\n Returns: DS:DX bResult contains a DoubleSpace API Error Code (00H=success)\n ──────────────────────────────────────────────────────────────────\n Info: This obtains the true (incompressible) total space and free space\n available in the specified volume.\n\n Note: This fn is new for DOS 6.2; the INT 2fH 4a11H 0007H fn\n returns similar info for pre-6.2 systems, but is unreliable in\n that the specified drive may have been unmounted.\n\n DS:DX points to a DsSpcIoctlRec as follows:\n\n DsSpcIoctlRec\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 2 abSig must be 444dH ('M','D')\n +2 1 bCmdCode must be 46H ('S') Space command\n +3 2 bResult returns a DoubleSpace API Error Code\n +5 4 plSects returns addr of 8 bytes of info\n decsribing total & free space in heap\n +9 4 plClusts returns addr of a 4-byte value holding\n the heap free space, in clusters\n 13 size of a DsSpcIoctlRec structure\n\n To use this fn, set up the packet and the registers, and call\n INT 21H. See DOS fn 44H (device I/O Control) for related DOS\n functions.\n\nOn return check bResult for an error code. The value 4f4bH ('OK')\n indicates success.\n\n plSects will contain a 4-byte pointer. At that address will be two\n 4-byte values. The first will contains the size of the\n sector heap for the specified drive, in sectors. The second\n value will contain the current free space in the sector heap, in\n sectors.\n\n plClusts will contain a 4-byte pointer. At that address is a single\n 4-byte value containing the maximum number of incompressible\n clusters that can be stored on the specified drive.\n\n This is the \"worst case\" free space for the drive.\n\n The high byte should be examined before using the value. If this\n byte is ffH, then the rest of the value is invalid and should be\n treated as 0.\n\n Notes: ■ The returned information is valid as long as the drive is\n mounted.\n\n ■ To ensure that this obtains up-to-the-minute information, you\n should use DOS fn 0dH (reset disk), followed by DS IOCTL 'I'\n (flush and invalidate cache) before making the call.\n\n ■ \"Install\" programs should use this fn when checking to see if\n there is enough disk space, especially if you are about to copy\n incompressable files (such as .ZIP files of PKLITE-style\n compressed executables) to the target drive.\n\nSee Also: DoubleSpace Overview\n DoubleSpace API\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "805-doublespace_compressed_volume_file_layout.html",
    "t": "DoubleSpace Compressed Volume File Layout",
    "b": "█▌Overview▐█\n DoubleSpace maintains all information structures and compressed data for a\n DoubleSpace volume within a Compressed Volume File (CVF). This topic\n describes the layout of CVF. CVF region summary:\n\n MDBPB All kinds of info, including addresses of other regions\n BitFAT Sector allocation tables; one bit represents one sector\n Res1 (1 reserved sector)\n MDFAT Information describing each compressed cluster\n Res2 (31 reserved sectors)\n BootSect a standard Boot Sector (sans boot program code)\n Res3 (variable number of reserved sectors) contains MdStamp1\n FAT The familiar File Allocation Table for the volume\n RootDir The root directory for the volume\n Res4 (2 reserved sectors)\n SectHeap the compressed data\n MdStamp2 marks the end of the CVF\n\n█▌Details▐█\n Size\n Name (sectors) Description\n▀▀▀▀▀▀▀▀ ▀▀▀▀▀▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n MDBPB 1 This is a standard BPBRec (BIOS Parameter Block),\n followed by additional fields describing the CVF. Very\n important.\n\n BitFAT varies One bit for each sector in the SectHeap. A 1 means the\n sector is in use and 0 means it's free. The BitFAT may\n be as large as 256 sectors (128K).\n\n Res1 1 (reserved for future use by DoubleSpace)\n\n MDFAT varies A table of 4-byte bit-packed MdFatEntryRec structures.\n Each entry describes one cluster in the FAT; thereby\n mapping each cluster to its actual data in the CVF. The\n MDFAT may be as large as 512 sectors (256K).\n\n Res2 31 (reserved for future use by DoubleSpace)\n\n BootSect 1 Although a CVF is never booted, this is formatted as\n a standard BootSectorRec which simulates an uncompressed\n disk of the estimated size.\n\n Res3 varies (reserved) One or more sectors are left empty in order\n to position the FAT at a favorable sector-multiple from\n the start of the CVF.\n\n The first four bytes of the first sector in this region\n contain the first DoubleSpace stamp (MdStamp1): '°DR0'\n (f8H, 44H, 52H, 00H).\n\n FAT varies This is a standard File Allocation Table. It may be\n a 12-bit FAT (for volumes < 4086 clusters) or a 16-bit\n FAT for larger volumes.\n Note that there is only one FAT.\n\n RootDir 32 The root directory for the volume; it is\n 512 DirEntryRecs of 32 bytes each (exactly 32 sectors in\n all cases, even small CVFs).\n\n Res4 2 (reserved)\n\n SectHeap varies The sectors containing the compressed data. Each sector\n is represented in the BitFAT. When all sectors are\n filled, the volume is full (even though DOS may think\n there is free space because of unused FAT entries).\n\n MdStamp2 1+ Marks the end of a CVF; the first four bytes of the last\n full sector contain 'MDR0' (4dH, 44H, 52H, 00H).\n\nSee Also: DoubleSpace Overview\n DoubleSpace API\n DOS Functions\n -♦-"
  },
  {
    "id": "806-cvf_region__mdbpb.html",
    "t": "CVF Region: MDBPB",
    "b": "This region occupies the first sector of the CVF▲. It contains the\n following structure which describes the size and layout of the CVF.\n\nMdBpbRec\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 3 abJmpCode JMP opcode to start of boot code\n +3 8 abOem OEM name= \"MSDSP6.0\"\n ──────────────────────────────────────────── Standard BPBRec\n\n +0bH 2 wSectSize bytes per sector (always 512; 200H)\n +0dH 1 bClustSects sectors per cluster (always 16; 10H)\n +0eH 2 wResSects boot and reserved sectors\n +10H 1 bFatCnt number of FATs (always 1; see note)\n +11H 2 wRootEntries max DirEntryRecs in root (always 512; 200H)\n +13H 2 wTotSects total number of sectors in media\n 0000H means >32 MB, so use lBigTotSects\n +15H 1 bMedia media descriptor (always F8H; i.e., hard disk)\n +16H 2 wFatSects number of sectors in one FAT\n +18H 2 wSectsPerTrk sectors per track (random, ignored)\n +1aH 2 wHeads number of read/write heads (random, ignored)\n +1cH 4 lHidSects hidden sectors)\n +20H 4 lBigTotSects 32-bit TotSects in volume\n ───────────────────────────────────── DoubleSpace Extensions\n\n +24H 2 wMdFatStart logical sector of start of MDFAT\n +26H 1 bSectShift sector-to-bytes shift (sector is 2ⁿ bytes)\n +27H 2 wMdResSects number of sectors before BootSect\n +29H 2 wRootStart logical sector of start of root directory\n +2bH 2 wHeapStart logical sector of start of Sector Heap\n +2dH 2 wFirstData Number of MDFAT entries (clusters) which are\n occupied by the DOS boot sector, reserved, and\n root directory.\n +2fH 1 bBitFatPgs size of the BitFAT, in 2K pages\n +30H 2 wRes1 (reserved)\n +32H 1 bClustShift cluster-to-sector shift (cluster is 2ⁿ sectors)\n +33H 2 wRes2 (reserved)\n +35H 4 lRes3 (reserved)\n +39H 4 lRes4 (reserved)\n +3dH 1 bFlag12Bit 01H=12-bit FAT, 00H=16-bit FAT\n +3eH 2 wMaxMBs Maximum CVF uncompressed capacity, in Megabytes\n (not actual size; see below)\n 64 size of an MdBpbRec structure\n ───────────────────────────────────────────── sector padding\n +40H 450 res5 reserved (empty space to end of sector)\n\n abJmpCode through ...\nlBigTotSects The first fields line up with a standard BPB. Additional\n details can be found in BootSectorRec and BpbRec.\n\n bFatCnt A CVF \"disk\" is unusual in that it contains only one copy of\n the standard FAT. DoubleSpace \"virtualizes\" this, making it\n seem as though two identical copies exist. See FAT.\n\n wMdFatStart logical sector (from start of CVF) of the MDFAT; seek to\n (wMdFatStart+1)*wSectSize bytes from the start of the CVF to\n read this.\n\n bSectShift Log base 2 of wSectSize; handy for calculating how many bytes\n can fit in a sector (one sector = 2ⁿ bytes).\n\n wMdResSects This describes how many sectors are reserved before the DOS\n Boot sector in the compressed volume.\n\n wRootStart logical sector (from start of CVF) of the first sector of the\n root directory. Seek to (wMdResSects+wRootStart)*wSectSize\n bytes from the start of the CVF to get to the start of this.\n\n wHeapStart logical sector (from start of CVF) of the first data sector.\n Data in the sector heap is usually compressed. See SectHeap.\n\n wFirstData tells how many 4-byte entries in the MDFAT are reserved for\n non-data allocations, including DOS boot sector, reserved, and\n root directory. Thus, the first meaningful MdFatEntryRec is\n really (wFirstData*4) bytes from the start of the MDFAT.\n\n bBitFatPgs Size of the BitFAT, in 2K units; i.e., the BitFAT is\n (bBitFatPgs*2048) bytes long.\n\n bClustShift Log base 2 of bClustSects; handy for calculating how many\n sectors are in a cluster (one cluster = 2ⁿ sectors).\n\n res3 contains \"16 \" on my system\n\n bFlag12Bit indicates whether the FAT is represented with 12-bit entries\n or 16-bit entries (00H=16-bit; 01H=12-bit).\n\n wMaxMBs Capacity of the CVF, in Megabytes. It is the basis that was\n used when DoubleSpace calculated the size of the variable-\n length BitFAT, MDFAT, and FAT regions.\n\n This is also the upper limit on the size of the Sector Heap,\n in the case where all the data stored in the CVF is\n incompressible.\n\n Note that it is NOT the actual size of the CVF--only the\n capacity of the internal bookkeeping regions. In most cases,\n this specifies a much larger size than is actually used, but\n it makes it easier for DoubleSpace to grow and shrink the\n volume. DoubleSpace typically wastes several hundred Kbytes\n of disk space when it prepares a large CVF (for instance, it\n set up a 512 MB-capacity CVF on my 350 MB disk).\n\n Notes: Although the first part of this structure is formatted as a DOS\n 4.0+ boot sector, this sector is never booted or executed as\n code.\n\nSee Also: CVF Layout\n DoubleSpace Overview\n DoubleSpace API\n DOS Functions\n -♦-"
  },
  {
    "id": "807-cvf_region__bitfat.html",
    "t": "CVF Region: BitFAT",
    "b": "The BitFAT is a simple one-bit-to-one-sector mapping of the contents of\n the Sector Heap. Unlike the standard FAT, this does not provide\n information in the location of files or cluster fragmentation--it simply\n indicates which sectors are currently in use.\n\n For safety and integrity, the BitFAT is rebuilt (by scanning the MDFAT)\n each time a volume is mounted.\n\n The BitFAT region starts at sector 1 (512 bytes from the start) of\n the CVF. It may be as large as 256 sectors (128K=131,072 bytes).\n\n Each 16-bit word in this region represents a group of 16 sectors of the\n Sector Heap. When a bit is set (1), it indicates that the sector is in\n use and when clear (0) indicates that the sector is free. The high bit\n (bit 15) corresponds to the first sector of the 16-sector group and low\n bit (bit 0) represents the 16th sector in the group:\n\n (WORD) BitFAT+0 BitFAT+2 BitFAT+4\n ┌┴──────────────────────────────┐┌┴─────── - ───┐┌┴── - -\n │1 1 1 1 1 1 ││1 1 1 1 ││1 1 1\n ╓5┬4┬3┬2┬1┬0┬9┬8╥7┬6┬5┬4┬3┬2┬1┬0╖╓5┬4┬3┬2┬\\ \\1┬0╖╓5┬4┬3┬\\\n ║ │ │ │ │ │ │ │ ║ │ │ │ │ │ │ │ ║║ │ │ │ │/ / │ ║║ │ │ │/\n ╙╥┴╥┴╥┴╥┴╥┴╥┴╥┴╥╨╥┴╥┴╥┴╥┴╥┴╥┴╥┴╥╜╙╥┴╥┴╥┴╥┴\\ \\╥┴╥╜╙╥┴╥┴╥┴\\\nSectHeap+0 ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║\n +1 ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║\n +2 ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║\n +3 ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║\n +4 ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║\n +5 ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║\n +6 ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║\n +7 ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║\n +8 ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║\n +9 ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║\n +10 ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║\n +11 ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║\n +12 ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║\n +13 ║ ║ ║ ║ ║ ║ ║ ║ ║ ║ ║\n +14 ║ ║ ║ ║ ║ ║ ║ ║ ║ ║\n +15 ║ ║ ║ ║ ║ ║ ║ ║ ║\n SectHeap+16 ║ ║ ║ ║ ║ ║ ║ ║\n +17 ║ ║ ║ ║ ║ ║ ║\n +18 ║ ║ ║ ║ ║ ║\n +19 ║ ║ ║ ║ ║\n SectHeap+30 ║ ║ ║ ║\nSee Also: CVF Layout +31 ║ ║ ║\n DoubleSpace Overview +32 ║ ║\n DoubleSpace API +33 ║\n DOS Functions +34...\n -♦-"
  },
  {
    "id": "808-cvf_region__mdfat.html",
    "t": "CVF Region: MDFAT",
    "b": "See also: Mapping DOS FAT to MDFAT for info on interpreting the MDFAT.\n\n The MDFAT contains one 32-bit entry for each FAT cluster. Each entry\n describes the location in the Sector Heap of the start of the cluster, how\n many sequential sectors are actually occupied, and whether the data is\n compressed or raw.\n\n The MDFAT region starts one sector after the end of the BitFAT; its\n location can be calculated as MdBpbRec.wMdFatStart+1 sectors from the\n start of the CVF. It may be as large as 512 sectors (256K=262,144 bytes).\n\n Each 32-bit entry is formatted as follows:\n\nMdFatEntryRec\n 3 3 2 2 2 2 2 2 2 2 2 2 \\\\\n╓1┬0┬9┬8┬7┬6┬5┬4╥3┬2┬1┬0┬//┬1┬0╖\n║u│r│sizRaw │sizCmpr│0│location║\n╙╥┴╥┴─┴─┴─┴─┴─┴─╨─┴─┴╥┴─┴//┴─┴─╜ bits mask\n ║ ║ ╚══╦══╝ ╚══╦══╝ ║ ╚══════╩═► 0-20: 001fffffH location of the first\n ║ ║ ║ ║ ║ sector (NOT an offset from\n ║ ║ ║ ║ ║ Sector Heap; see below)\n ║ ║ ║ ║ ╚══════════► 21: 00200000H reserved for future use\n ║ ║ ║ ╚═══════════════►22-25: 03c00000H size (sectors) as stored\n ║ ║ ╚═══════════════════════►26-29: 3c000000H size when uncompressed\n ║ ╚════════════════════════════► 30: 40000000H 1 = uncompressed (raw)\n ╚══════════════════════════════► 31: 80000000H 1 = entry is in use\n\n location (bits 0-20; 21 bits) This identifies the location of the first of\n one or more contiguous sectors in the Sector Heap that contain\n the data represented by FAT entry that corresponds to this\n MDFAT entry.\n\n Add 1 to this number to get the sector offset from the start\n of the CVF.\n\n A 21-bit number can be as large as 2,097,152, so an MDFAT is able\n to describe 33,554,432 (2M * 16) sectors or a 16 GB disk\n (although DoubleSpace supports only up to a maximum of 512 MB).\n\n The up-to-16 CVF sectors that contain one \"compressed cluster\" of\n data are always contiguous.\n\n res (bit 21; 1 bit) this bit is always cleared to 0. It is reserved\n for future use.\n\n sizCmpr (bits 22-25; 4 bits) this is the number (-1) of sectors used to\n contain the cluster's data; i.e., 0000=1, 0001=2, 0010=3, ...\n 1111=16.\n\n It is possible for this to be larger than sizRaw, but only when\n sizRaw is less than 15.\n\n sizRaw (bits 26-29; 4 bits) this is the size (-1) of the data when it is\n uncompressed; i.e., 0000=1, 0001=2, 0010=3, ... 1111=16.\n\n For an uncompressed cluster (isUncmpr=1), the content of this\n field is undefined.\n\n isUncmpr (bit 30; 1 bit) This flag indicates whether or not the data for\n this cluster is stored in compressed form.\n\n 1 indicates uncompressed (raw); 0 indicates compressed.\n\n DoubleSpace will store a cluster in uncompressed format if it\n finds that the compression algorithm cannot save at least one\n sector in a given cluster (for instance, when storing pre-\n compressed .ZIP files).\n\n isUsed (bit 31; 1 bit) This flag indicates whether or not this\n MdFatEntryRec is currently in use (see notes, below).\n\n 1 indicates used; 0 indicates unused.\n\n Notes: ■ To locate a file's compressed data sectors: Obtain the file's\n starting cluster number from the directory entry and, using\n standard File Allocation Table-chain tracing, determine what\n clusters it occupies. Add MdBpbRec.wFirstData to a DOS FAT\n cluster number and use the sum as an index into the MDFAT.\n\n See Mapping DOS FAT to MDFAT for illustrated details.\n\n ■ To decompress a cluster: Seek to the first sector of the\n cluster in the Sector Heap and read sizCmpr sectors into a\n local buffer. Use MRCI Fn 0002H to decompress the data.\n\n ■ A compressed cluster begins with 'MD00' (4dH,44H,00H,00H) or\n 'MD0☺' (4dH,44H,00H,01H) or 'MD0☻' (4dH,44H,00H,02H). But use\n the isUncmpr field to see if it is compressed. See Sector Heap\n for related info.\n\n ■ The isUsed flag helps DoubleSpace support FAT-based undelete\n programs. When sector of the FAT is written to disk,\n DoubleSpace compares the old FAT to the changed FAT and checks\n the isUsed flag of the corresponding entry in the MDFAT. It\n can infer one of the following operations:\n\n DOS allocated a cluster:\n isUsed=0 and FAT entry went from 0 to any\n\n DOS or utility freed a cluster (e.g., a DS-unaware defragger):\n isUsed=1 and FAT entry went from any to 0\n\n Utility resurrected a cluster (e.g., undelete):\n isUsed=0 and FAT entry went from 0 to any\n\n Bookkeeping integrity lost (should never happen):\n isUsed=1 and FAT entry went from 0 to any\n\n ■ Each time DoubleSpace mounts a volume, it rebuilds the BitFAT\n based on the contents of the MDFAT.\n\n ■ An entry containing 00000000H: It is possible for an\n MdFatEntryRec to contain only zeros. This can occur when you\n open a file, and seek at least 8K past the end of the last\n cluster in the file, then write at least one byte.\n\n In this case, DoubleSpace considers the cluster to be\n \"infinitely compressible.\" The 8K of disk space represented by\n the corresponding FAT entry takes no sectors in the heap. If\n you find the need to \"decompress\" the data represented by such\n an entry, just return a full cluster of 0s.\n\n Interestingly, if you use Copy (or other command) to duplicate\n a file with such a cluster, the resulting physical length will\n be larger--the duplicated cluster of 0s will occupy one\n physical sector.\n\nSee Also: Mapping DOS FAT to MDFAT\n CVF Layout\n DoubleSpace Overview\n DoubleSpace API\n DOS Functions\n -♦-"
  },
  {
    "id": "809-cvf_region__bootsect.html",
    "t": "CVF Region: BootSect",
    "b": "The BootSect is one-sector long (512 bytes). It is located 31 sectors\n after the end of the MDFAT; its location can be obtained from the\n wMdResSects field (offset 27H) of the MdBpbRec.\n\n It is identical to a standard Boot Sector, as it would exist for a\n physical drive of the (estimated) disk size except that it does NOT\n necessarily contain any executable boot code. It exists as part of the\n DoubleSpace \"simulation\" of a real disk.\n\n One Boot Sector field bears mention: the bFatCnt (offset 10H) contains\n 02H, even though the CVF does not maintain a duplicate of the FAT. When\n programs request a sector which would be part of the second FAT,\n DoubleSpace returns a sector from the \"first\" (only) FAT.\n\nSee Also: CVF Layout\n DoubleSpace Overview\n DoubleSpace API\n DOS Functions\n -♦-"
  },
  {
    "id": "810-cvf_region__fat.html",
    "t": "CVF Region: FAT",
    "b": "The FAT is a variable-length region formatted as a File Allocation Table.\n\n It is located a variable number of sectors after the end of the\n BootSect region; its location can be calculated as\n MdBpbRec.wResSects+wMdResSects sectors from the start of the CVF.\n\n It may be formatted as a 12-bit FAT or a 16-bit FAT.\n\n 12-bit: Used for volumes less than 32 MB of uncompressed data (this\n includes compressed diskettes). A 12-bit FAT uses 1½-bytes-per-\n entry and 0ff7h-0fffh have special meaning, so it maxes out at\n 4086 clusters.\n\n 16-bit: Used for volumes greater than 4086 clusters (32 MB). A 16-bit\n FAT can handle up 65526 16K clusters or 512K of uncompressed data\n (same as the DoubleSpace max volume size).\n\n See File Allocation Table for details.\n\n The \"cluster numbers\" contained in this FAT are actually used as indirect\n pointers into the MDFAT, rather than actual disk locations.\n\n See Mapping DOS FAT to MDFAT for a full discussion.\n\n One interesting note: COMMAND.COM accesses both the FAT and the MDFAT when\n you use Dir /c. In order to obtain the initial FAT entry, it uses the (I\n thought) long-obsolete fn 11H (find first file via FCB). The advantage of\n this over fn 4eH is that it returns a raw directory entry, and therefore\n supplies a pointer into the FAT.\n\n█▌Virtual 2nd FAT▐█\n Since the beginning of time, all DOS disks have contained two copies\n (presumably with the idea of data integrity and recovery).\n\n However, DoubleSpace maintains a single FAT for the volume. Since some\n disk utilities rely on finding the second copy directly after the first,\n DoubleSpace simulates or \"virtualizes\" the second FAT. Requests to read\n from those \"second FAT\" sectors are served up data from the first (only)\n FAT and attempted writes to the second FAT are sent to the \"first\" FAT.\n\n█▌Standard (FAT) Undelete Operations▐█\n When DOS or a utility writes to the FAT, DoubleSpace compares the old FAT\n to the modified FAT and, based on the changes (and the isUsed bit in the\n MdFatEntryRec), it can infer one of the following operations:\n\n DOS allocated a cluster:\n isUsed=0 and FAT entry went from 0 to any\n\n DOS or utility freed a cluster (e.g., a DoubleSpace-unaware defragger):\n isUsed=1 and FAT entry went from any to 0\n\n Utility resurrected a cluster (e.g. Undelete):\n isUsed=0 and FAT entry went from 0 to any\n\n Depending upon the inference, DoubleSpace can then take action to rectify\n and propagate the changes through the MDFAT and the BitFAT.\n\nSee Also: CVF Layout\n DoubleSpace Overview\n DoubleSpace API\n DOS Functions\n -♦-"
  },
  {
    "id": "811-cvf_region__rootdir.html",
    "t": "CVF Region: RootDir",
    "b": "The RootDir is a 32-sector (16K=16,384 bytes) region formatted as a\n directory. It is located directly after the end of the FAT; its\n location can be calculated as MdBpbRec.wMdResSects+wMdRootStart sectors\n from the start of the CVF.\n\n It contains 512 DirEntryRecs. These are identical in every way to\n standard directory entries. DoubleSpace does not appear to use any of the\n \"reserved\" bytes in the directory entry structure.\n\nSee Also: CVF Layout\n DoubleSpace Overview\n DoubleSpace API\n DOS Functions\n -♦-"
  },
  {
    "id": "812-cvf_region__sector_heap.html",
    "t": "CVF Region: Sector Heap",
    "b": "The Sector Heap is a variable-length region that contains all of the file\n data for the CVF \"disk\". When DoubleSpace needs to store data in a\n compressed volume, it gets a free sector from the sector heap and sets the\n corresponding bit in the BitFAT to indicate the sector is in use.\n\n The Sector Heap is located 2 sectors after the end of the RootDir; its\n location can be obtained from the wHeapStart field (offset 2bH) of the\n MdBpbRec.\n\n DoubleSpace will not create a volume smaller than about 600K (about 1.2M\n of storage), so expect the Sector Heap to be at least 1200 sectors long.\n\n█▌Cluster Allocations▐█\n Sectors are allocated individually, but always in sequential groups that\n represent a cluster (16 sectors= 8K of uncompressed data) in the FAT.\n\n This provides DoubleSpace with \"bonus\" compression since it gives very\n little physical storage for cluster slack▲--the up to 8191 bytes of disk\n storage that can be left empty in the last cluster of a file. In the\n worst-case scenario, a 1-byte file uses only one sector (512 bytes) of the\n CVF while on a regular disk, a 1-byte file uses 8092 bytes (16 sectors).\n\n Therefore, a 1-byte file (actually any file containing less than 513\n bytes) yields DoubleSpace's maximum compression ratio, 16-to-1.\n\n Stand-alone compression tools such as PKZIP can take maximum advantage of\n saving on file slack when they compress a series of short files. For\n instance, ten 1-byte files compress into a file not much longer than\n 10 bytes, yielding a ratio of around 8000-to-1.\n\n█▌Cluster Tags▐█\n Most sectors in the heap contain compressed data, but some do not. For\n instance, DoubleSpace does not bother compressing data in files smaller\n than 512 bytes. Also, the DoubleSpace compression algorithm cannot\n squeeze any air out of most types of previously-compressed data, such a\n .ZIP and .ARC compressed files.\n\n Entries in the MDFAT identify which clusters are stored in compressed form\n and which are stored raw. As an additional safeguard and aid to data\n recovery, the first sector in each cluster begins with one of the\n following 4-byte tags (as documented):\n\n 'DS00' (4DH, 44H, 00H, 00H) IHV Level 2\n 'DS0☺' (4DH, 44H, 00H, 01H) \"MaxCompressed\" (IHV Level Max)\n 'DS0☻' (4DH, 44H, 00H, 02H) \"StandardCompressed\"\n 'DS0♥' (4DH, 44H, 00H, 03H) IHV Level 3\n 'DS0♦' (4DH, 44H, 00H, 04H) IHV Level 4\n\n IHV might be \"Independent Hardware Vendor\". Could be anything.\n\n In actual use, I have not seen the 00H version and presume that it is\n obsolete. The 01H and 02H versions appear in my CVFs. The MRCI Fn 0001H\n (compress) starts with a similar 'MD0☻' tag. And data backed up by\n Msbackup stores some data as ??,??,??,'M','D',00, 02.\n\n Uncompressed (incompressable) clusters have no initial tag. Since it is\n possible for an incompressible cluster to begin with one of these tags,\n you should refer to the MDFAT rather than making any assumptions.\n\nSee Also: CVF Layout\n DoubleSpace Overview\n DoubleSpace API\n DOS Functions\n -♦-"
  },
  {
    "id": "813-cvf_region___md_stamps_.html",
    "t": "CVF Region: \"MD Stamps\"",
    "b": "DoubleSpace places special signatures at two places in the CVF. These are\n used in verifying the integrity of the volume and would come in handy in\n recovering a CVF▲.\n\n MdStamp1 is located in first four bytes of a reserved sector that is\n directly after the BootSect. It is:\n\n '°DR0' (f8H, 44H, 52H, 00H).\n\n MdStamp2 is located in first four bytes of the last complete sector in the\n CVF. It is:\n\n 'MDR0' (4dH, 44H, 52H, 00H)\n\n For instance, if the CVF is an exact multiple of 512 bytes long,\n then it is in the last sector. Otherwise, it is in the sector\n just before the last (partial) sector.\n\n Notes: The MdStamp1 was undoubtedly 'MDR0' originally, but a Microsoft\n source code file claims Mentions that the first byte was changed\n to f8H to make DoubleSpace drives compatible with Colorado Memory\n Systems tape backup software.\n\n F8H is a standard media descriptor byte that one might find in\n the first sector following the boot sector on a hard disk (it is\n normally the first byte of a standard FAT).\n\nSee Also: CVF Layout\n DoubleSpace Overview\n DoubleSpace API\n DOS Functions\n -♦-"
  },
  {
    "id": "814-mapping_dos_fat_to_mdfat.html",
    "t": "Mapping DOS FAT to MDFAT",
    "b": "Any system which analyses a CVF▲ must trace FAT chains and examine the\n corresponding MdFatEntryRecs in the MDFAT. Observe:\n\n DirEntryRec starting cluster number ══╗\nDirectory ╓───────────────────┬─┬───────────────────┬───┬───┬─▼─┬───────╖\nEntry ═══►║M Y F I L E T X T│a│ │tim│dat│003│ size ║\n ╙─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─║─┴─┴─┴─┴─╜\n ╔══════════════════════════════════════════╝\nFAT 000 001 002 ║03 004 005 006 007 008 009 00a 00b ...\n ┌─┬─┐┌─┬─┐┌─┬─┐┌▼┬─┐┌─┬─┐╔═══╗┌─┬─┐┌─┬─┐┌─┬─┐┌─┬─┐┌─┬─┐┌─┬─┐\n │mid││fff││000││004═►006═╝fff╚►007═►fff││000││000││000││000│...\n └─┴─┘└─┴─┘└─┴─┘└─┴─┘└─┴─┘└─┴─┘└─┴─┘└─┴─┘└─┴─┘└─┴─┘└─┴─┘└─┴─┘\n ╚═╦═╝╚═╦═╝ ╚═╦═╝╚══╩═════════════════════════╗\n ║ ╚═══════╗ ╚══════════════════════╗ ║\n ╚══════════╗ ╚══════╗ ║ ║\nMDFAT n+000 n+001 n+002 ║ n+003 ║ n+004 n+005 ║ n+006 ║ n+007\n ┌─┬─┬─┬─┐┌─┬─┬─┬─┐┌─┬─┬─┬─┐┌▼┬─┬─┬─┐┌▼┬─┬─┬─┐┌─┬─┬─┬─┐┌▼┬─┬─┬─┐┌▼┬─┬─┬─┐\n │ ││ ││ ││f 3 08e││f 1 092││0 0 000││f 6 094││1 0 09b│\n ..└─┴─┴─┴─┘└─┴─┴─┴─┘└─┴─┴─┴─┘└─┴─┴─┴║┘└─┴─┴─┴║┘└─┴─┴─┴─┘└─┴─┴─┴║┘└─┴─┴─┴║┘\n(n=MdBpbRec.wFirstData) ╔════════════╝ ║ ╔═══════════╝ ║\n ║ ╔═════════════╝ ║ ║\n ║ ║ ╔══════╝ ╔══════════════╝\nCVF Sector Heap ╒═════╩════╕╒═╩══╕╒════════╩══════════╕╒╩╕\n ┌─┐┌─┐┌─┐┌─┐┌─┐┌─┐┌─┐┌─┐┌─┐┌─┐┌─┐┌─┐┌─┐┌─┐┌─┐┌─┐┌─┐┌─┐┌─┐┌─┐┌─┐\n │ ││ ││ ││ ││ ││ ││ ││ ││ ││ ││ ││ ││ ││ ││ ││ ││ ││ ││ ││ ││ │...\n └─┘└─┘└─┘└─┘└─┘└─┘└─┘└─┘└─┘└─┘└─┘└─┘└─┘└─┘└─┘└─┘└─┘└─┘└─┘└─┘└─┘\n .. 89 8a 8b 8c 8d 8e 8f 90 91 92 93 94 95 96 97 98 99 91 9b 9c 9d\n\n This diagram illustrates how FAT entries correspond to MDFAT entries.\n\n ■ MYFILE.TXT, starts at cluster 003H (as found in a Directory Entry).\n The FAT chain shows that it occupies clusters 003, 004, 006, and 007\n (cluster 005 is apparently in use by another file).\n\n ■ To get the MdFatEntryRecs of interest, we add MdBpbRec.wFirstData to\n each cluster number. For instance, if wFirstData is 0010H, then we\n are interested in MDFAT entries 013H, 014H, 016H, and 017H.\n\n ■ To read a particular MdFatEntryRec, m, seek in the CVF to the start\n of the MDFAT+(m*4) and read 4 bytes (the size of an MdFatEntryRec).\n Each entry describes the physical location of the compressed data.\n\n ■ The low 21 bits indicate a CVF logical sector number and bits 22-25\n contain one less than the count of the sectors occupied by the\n cluster. To convert a CVF logical sector number to a file offset,\n add 1 to it and multiply the sum by MdBpbRec.wSectSize (usually 512).\n\n In the diagrammed example, we could access the first byte of the file as\n follows...\n\n wClusterNo = 0003H (obtained from directory entry)\n mdClusterNo = wClusterNo + MdBpbRec.wFirstData\n\n lMdFatFileOffset = (MdBpbRec.wMdFatStart+1) * MdBpbRec.wSectSize\n lItemOffset = lMdFatFileOffset + (wMdClusterNo * 4)\n\n ...we seek to lItemOffset and read the 4-byte MdFatEntryRec. We find that\n the low 21 bits contain 00008eH (the location) and that bits 22-25 contain\n 03H (sizCmpr) and bits 26-29 contain 0fH (sizRaw). We calculate...\n\n lClustStartSect = location+1\n lCvfSectOffset = lClustStartSect * MdBpbRec.wSectSize\n\n wCmprsdBytes = (sizCmpr + 1) * MdBpbRec.wSectSize\n wUnCmprsdBytes = (sizRaw + 1) * MdBpbRec.wSectSize\n\n ...and at last, we can seek to CVF offset lCvfSectOffset and read\n wCmprsdBytes of data into an internal buffer. If we bother to examine the\n compressed data we'd see that the first four bytes are something like\n 'MD0☻' (4dH,44H,00H,02H).\n\n We could use MRCI Fn 0002H (setting MRCRequestRec.wDestLen=wUnCmprsdBytes)\n to decompress the data.\n\n Notes: ■ COMMAND.COM accesses both the FAT and the MDFAT when you use\n Dir /c. In order to obtain the initial FAT entry, it uses the\n long-obsolete fn 11H (find first file via FCB). The advantage\n of this over fn 4eH is that it returns a raw directory entry,\n and therefore supplies a pointer into the FAT.\n\n ■ As you trace a FAT chain, you may encounter a corresponding\n MDFatEntryRec containing 00000000H. Such an entry indicates\n that no sectors are used by that cluster.\n\n This can occur, for instance, if you open a file, seek at least\n 8K past the end of the last cluster in the file, then write at\n least one byte. To \"decompress\" such a cluster, just fill the\n buffer with zeros.\n\nSee Also: CVF Region: MDFAT\n CVF Layout\n DoubleSpace Overview\n DoubleSpace API\n DOS Functions\n -♦-"
  },
  {
    "id": "815-microsoft_real_time_compression_interface__mrci_.html",
    "t": "Microsoft Real-time Compression Interface (MRCI)",
    "b": "Microsoft Real-Time Compression Interface (MRCI; pronounced \"mercy\")\n provides a means for application programs and system utilities to compress\n and decompress data.\n\n It is normally installed as part of DBLSPACE.BIN file which is loaded at\n boot time (see DoubleSpace Overview), but it may exist as ROM-based,\n hardware-assisted server installed via ROM-Scan at system powerup.\n\n See: INT 2fH 4a12H (see if MRCI is installed; get entry addr, etc.)\n INT 1aH b001H (check for ROM-based MRCI server)\n\n MRCI Fn 0001H (compress data)\n MRCI Fn 0002H (decompress data)\n MRCI Fn 0020H (incrementally decompress data)\n MRCI Fn ffffH (deinstall server; not used)\n\n MRCI API Error/Return Codes (codes returned by these fns)\n\n MRCInfoRec structure\n MRCRequestRec structure\n\n Notes: ■ In order to use MRCI fns, you must obtain the API entry address\n (and a MRCInfoRec used in every call) via INT 2fH 4a12H.\n\n ■ The decompression services require knowledge of the original\n (uncompressed) size of the data.\n\n ■ Pragmatically, the uses of these fns are limited. Since you\n can assume that a disk compression system such as DoubleSpace\n is installed, there is no reason to compress data for storage\n on a local hard disk.\n\n You might want to use MRCI for storing backup data to diskette\n or perhaps for sending data across a network (or other\n bandwidth bottleneck, such as a modem line). Msbackup uses\n MRCI fns to compress backup data.\n\n ■ One novel idea is to use MRCI to compress screen data for\n temporary storage in RAM. For instance, a 4K text-mode screen\n typically compresses to a few hundred bytes.\n\nSee Also: DoubleSpace Overview\n DoubleSpace API\n DOS Functions\n -♦-"
  },
  {
    "id": "816-int_2fh_4a12h__get_mrci_installed_state_and_entry_address.html",
    "t": "INT 2fH 4a12H: Get MRCI Installed State and Entry Address",
    "b": "Compatibility: 6.0+\n Expects: AX 4a12H (mux number)\n CX 4d52H ('MR' see notes)\n DX 4349H ('CI')\n ──────────────────────────────────────────────────────────────────\n Returns: CX 4943h ('IC', if successful)\n DX 524dh ('RM')\n ES:DI address of an MRCInfoRec describing the MRCI server\n ──────────────────────────────────────────────────────────────────\n Info: Use this to learn if a MRCI server is present and available via\n the INT 2fH interrupt. If successful, it returns the address of\n a data structure that describes the capabilities of the MRCI\n server and supplies the entry address used for accessing its API.\n\n CX and...\n DX are used in a weird but respectable technique to detect the\n presence of a MRCI-compliant server.\n\n Use CX=4d52H and DX=4349H to check for Microsoft's MRCI driver\n (or one that is simulating it). And on return, if CX=4943H and\n DX=524dH, then the server is present.\n\n The algorithm is generic: the CX and DX values are shuffled\n around in a well-defined manner--they are processed by the\n following code fragment:\n\n xchg ch,cl\n xchg dh,dl\n xchg cx,dx\n\n A non-Microsoft MRCI server may take special action when it\n receives different input values, but it will shuffle them around\n as shown. The Microsoft server requires CX and DX as shown.\n\n ES:DI If the returned values of CX and DX are as expected, ES:DI will\n point to an 18-byte MRCInfoRec structure.\n\n Notes: ■ MRCI allows for the possibility of a hardware-based compression\n handler (for instance, one installed via ROM-Scan). In that\n case, it installs itself as an INT 1aH handler.\n\n If the INT 2FH service fails to return results, you should try\n INT 1aH b001H to see if a hardware/ROM-based server has been\n installed.\n\n Before installing a MRCI server, you should check the INT 1aH\n version of this fn. If a hardware assisted MRCI server is\n installed, it is probably faster than your software-only\n version. If you do install a MRCI server, you should intercept\n both vectors. Only one MRCI server (the last one installed)\n can be active.\n\n ■ Before using INT 2FH or INT 1aH, you should check their\n interrupt vectors to make sure that they are not 0000:0000.\n\nSee Also: MRCI API\n INT 1aH b001H (check for ROM-based MRCI server)\n DoubleSpace Overview\n DoubleSpace API\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "817-mrci_fn_0001h__compress_data.html",
    "t": "MRCI Fn 0001H: Compress Data",
    "b": "Compatibility: 6.0+\n Expects: AX 0001H\n CX caller type: 0000H=APPLICATION client (InDOS is clear)\n 0001H=SYSTEM client (InDOS is set)\n DS:SI address of a pre-filled MRCRequestRec structure:\n .pfbSrc=address of data to compress\n .wSrcLen=size of uncompressed data, in bytes\n .pfbDest=buffer to receive compressed data\n .wDestLen=size of buffer at pfbDest\n ES:BX address of a MRCInfoRec structure obtained via INT 2fH 4a12H\n ──────────────────────────────────────────────────────────────────\n Returns: AX 0000H = success\n else = MRCI API Error Code\n DS:SI wDestLen field (offset 0eH) is size of compressed data\n ──────────────────────────────────────────────────────────────────\n Info: This fn compresses data. The source and destination addresses\n (and other important details) are identified in the MRCRequestRec\n structure. The API entry address is obtained via INT 2fH 4a12H.\n\n To use this call, you must:\n\n 1 Set up the request record.\n\n 2 Make certain that the InDOS Flag is clear (APPLICATION clients)\n or set (SYSTEM clients) (see CX notes, below)\n\n 3 Start a Windows Critical Section (see INT 2aH 8001H). We are\n told to use this exact sequence...\n\n push ax\n mov ax,8001H\n int 2aH\n pop ax\n\n ...since Windows may look for and patch this sequence of code.\n\n 4 Set up the CPU registers and call the MRCI entry address (it is\n the pfpEntry field of the MRCInfoRec obtained via INT 2fH 4a12H\n or INT 1aH B001H).\n\n 5 End the Windows Critical Section (see INT 2aH 8101H). We are\n told to use this exact sequence:\n\n push ax\n mov ax,8101H\n int 2aH\n pop ax\n\n 6 Check the return code in AX and the value returned in the\n wDestLen field of the MRCRequestRec.\n\n CX identifies the type of caller you are. It is one of:\n\n 0=APPLICATION client: You may only call this fn when the InDOS\n flag is clear (zero).\n\n 1=SYSTEM client: You may only call this fn when the InDOS flag is\n set (non-zero)\n\n This distinction is important for TSR writers. InDOS is always\n clear when application program code is being executed. But it is\n possible for a TSR to take control while InDOS is set and in that\n case, it should call MRCI services with CX=0001H.\n\n You may obtain the address of the InDOS flag via DOS fn 34H.\n\n Notes: ■ Check AX for a returned error code. And check the wDestLen\n field of the MRCRequestRec structure.\n\n In order to decompress later, you must save the value returned\n in wDestLen.\n\n ■ The MRCI server will compress the data only if it can save at\n least one MRCRequestRec.wChunkLen unit. If compression fails,\n remember to record this fact and save the source data and its\n length in order to \"decompress\" it (i.e., copy it verbatim)\n correctly later.\n\n ■ The result data begins with 'MD0☻' (4DH, 44H, 00H, 02H) -- a\n value that's different from either of the 4-byte signatures\n seen in DoubleSpace compressed clusters (see Sector Heap).\n\nSee Also: MRCI API\n DoubleSpace Overview\n DoubleSpace API\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "818-mrci_fn_0002h__decompress_data.html",
    "t": "MRCI Fn 0002H: Decompress Data",
    "b": "Compatibility: 6.0+\n Expects: AX 0002H\n CX caller type: 0000H=APPLICATION client (InDOS is clear)\n 0001H=SYSTEM client (InDOS is set)\n DS:SI address of a pre-filled MRCRequestRec structure:\n .pfbSrc=address of compressed data\n .wSrcLen=(ignored)\n .pfbDest=buffer to receive decompressed data\n .wDestLen=exact size of the data when decompressed\n ES:BX address of a MRCInfoRec structure obtained via INT 2fH 4a12H\n ──────────────────────────────────────────────────────────────────\n Returns: AX 0000H = success\n else = MRCI API Error Code\n DS:SI wDestLen field (offset 0eH) is size of uncompressed data\n ──────────────────────────────────────────────────────────────────\n Info: This fn decompresses data that was compressed via MRCI Fn 0001H\n (compress data). The source and destination addresses and other\n important details are identified in the MRCRequestRec structure.\n The API entry address is obtained via INT 2fH 4a12H.\n\n Before using this call, you must ensure the correct state of the\n InDOS Flag (corresponding to the value in CX) and you must start\n a Windows Critical Section. See MRCI Fn 0001H for info about\n these requirements.\n\n You must know the exact size of the data after it is decompressed\n and put that amount in the wDestLen of the MRCRequestRec\n structure. MRCI needs this to know when to stop decompressing.\n\n Notes: ■ Check AX for a returned error code. And check the wDestLen\n field of the MRCRequestRec structure.\n\n ■ The MRCI server will NOT decompress data that is not compressed\n (for instance when a previous call to MRCI Fn 0002H failed\n because the data was incompressible). To decide whether or not\n to decompress, you may examine the four-byte header and/or\n maintain separate information about each block of data\n compressed.\n\n Data compressed by MRCI starts with a 4-byte header such as\n 'MD0☻' (4DH, 44H, 00H, 02H).\n\n ■ To decompress data found in a DoubleSpace CVF, you must know\n the size the data will be after it is uncompressed. You can\n obtain a file size from the RootDir region of the CVF.\n\n Alternately, you can make a series of calls to MRCI Fn 0020H\n (incremental decompress) and look for some sort of end-of-file\n marker or (perhaps) hope for an error return code that helps\n decide when you have reached the end of the valid compressed\n data.\n\nSee Also: MRCI API\n DoubleSpace Overview\n DoubleSpace API\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "819-mrci_fn_0020h__incrementally_decompress_data.html",
    "t": "MRCI Fn 0020H: Incrementally Decompress Data",
    "b": "Compatibility: 6.0+\n Expects: AX 0020H\n CX caller type: 0000H=APPLICATION client (InDOS is clear)\n 0001H=SYSTEM client (InDOS is set)\n DS:SI address of a pre-filled MRCRequestRec structure:\n .pfbSrc =address of compressed data\n .wSrcLen =(ignored)\n .pfbDest =start of buffer (first call)\n next addr in buffer (subsequent calls;\n automatically updated by server)\n .wDestLen=desired number of bytes to decompress on this\n call (see below).\n .lIncInfo=must be 0 on the first call. It is updated\n by the server automatically on each call.\n ES:BX address of a MRCInfoRec structure filled via INT 2fH 4a12H\n ──────────────────────────────────────────────────────────────────\n Returns: AX 0000H = success\n else = MRCI API Error Code\n DS:SI wDestLen field (offset 0eH) is size of uncompressed data\n ──────────────────────────────────────────────────────────────────\n Info: This fn decompresses data that was compressed via MRCI Fn 0001H\n (MRCI compress data). It lets you decompress just a portion of\n the source data; for instance, DoubleSpace uses this to\n decompress individual sectors while accessing CVF disk data in\n larger (up to 8K) cluster blocks.\n\n The source and destination addresses (and other important\n details) are identified in the MRCRequestRec structure. The API\n entry address is obtained via INT 2fH 4a12H.\n\n Before using this call, you must ensure the correct state of the\n InDOS Flag (corresponding to the value in CX) and you must start\n a Windows Critical Section. See MRCI Fn 0001H for info about\n these requirements.\n\n MRCReqestRec fields:\n pfbSrc On the first call, set this to the address of the start of a\n compressed block. MRCI will expect this to begin with a four-\n byte header such as 'MD0☻' (4DH, 44H, 00H, 02H) or 'DS0☻' (44H,\n 53H, 00H, 02H); the latter is seen in the Sector Heap of\n DoubleSpace CVFs.\n\n After each call, MRCI updates the offset portion of this field to\n indicate the next address in the source buffer that is to be\n decompressed. Do not change this field between calls to this fn.\n\n wSrcLen is ignored in this call. The amount of data to be decompressed\n is determined by the wDestLen field.\n\n pfbDest On the first call, set this to the address of the start of your\n buffer to receive the decompressed data.\n\n After each call, MRCI updates the offset portion of this field to\n indicate the next, unused address in the destination buffer.\n MRCI uses previously-decompressed data as it decompresses each\n new byte of the compressed data, so do not change this field\n between calls to this fn.\n\n wDestLen is the desired length of the data after decompression; i.e., the\n number of bytes to store into the destination buffer.\n\n MRCI does not know when it has reached the end of the valid\n compressed data and will happily continue \"decompressing\"\n garbage. If you don't know the size the data should be after\n decompression, you can try decompressing one byte at a time, and\n look for some recognizable end of file mark. In some cases, MRCI\n will know that it is trying to decompress garbage, and will\n return an error in AX; but you cannot depend on that.\n\n lIncInfo must be set to 0 on the first call. Thereafter, MRCI uses it to\n maintain state information between calls. Do not modify this\n between calls to this fn.\n\n Notes: ■ Check AX for a returned error code. And check the wDestLen\n field of the MRCRequestRec structure to see if all of the\n requested data was returned.\n\n ■ See MRCI Fn 0002H (decompress data) for related information.\n\nSee Also: MRCI API\n DoubleSpace Overview\n DoubleSpace API\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "820-mrci_fn_ffffh__deinstall_server.html",
    "t": "MRCI Fn ffffH: Deinstall Server",
    "b": "Compatibility: 6.0+\n Expects: AX ffffH\n ES:BX address of a MRCInfoRec structure filled via INT 2fH 4a12H\n ──────────────────────────────────────────────────────────────────\n Returns: AX 0000H = success\n else = MRCI API Error Code\n ──────────────────────────────────────────────────────────────────\n Info: This fn is used only by MRCI servers. If, at load time, a MRCI\n server detects that another MRCI server is already active, it can\n compare the capacities and version of the installed server to\n those of it own.\n\n If it believes that it can do a better job, it (presumably) could\n use this fn to tell the other driver to deinstall itself.\n\n However, the example code in the MRCI spec does not use this.\n Instead, it edits the old server's MRCInfoRec structure to point\n to its own entry address (a technique which would not work if the\n structure were in ROM).\n\nSee Also: MRCI API\n -♦-"
  },
  {
    "id": "821-mrci_api_error_return_codes.html",
    "t": "MRCI API Error/Return Codes",
    "b": "The Microsoft Real-time Compression Interface (MRCI API) functions may\n return the following error codes:\n\n 0000H MRCI_NO_ERR fn was successful\n\n 0001H MRCI_ERR_NOT_SUPPORTED Unsupported fn number in AX\n\n 0002H MRCI_ERR_BUSY MRCI support is busy. This could happen,\n for instance, if a background task such as\n SmartDrv is using MRCI support. Just try\n the operation again.\n\n 0003H MRCI_ERR_BUF_OVERFLOW Destination buffer too small\n\n 0004H MRCI_ERR_INCOMPRESSIBLE Source data could not be compressed (MRCI\n returns this if it sees that compressing the\n data will not save at least one wChunkLen\n unit of data (see MRCRequestRec).\n\n When this error is returned, the content of\n the destination buffer is undefined.\n\n 0005H MRCI_ERR_BAD_FORMAT Compressed data is in unrecognized format.\n This is returned when the source contains\n uncompressed data with no recognizable MRCI\n header. It may occur on a source buffer\n overrun; but that is not guaranteed by the\n spec.\n\nSee Also: MRCI API\n DoubleSpace API\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "822-mrcinforec.html",
    "t": "MRCInfoRec",
    "b": "This structure is maintained by the MRCI server. Calls to\n INT 2fH 4a12H and INT 1aH b001H obtain the address of one of these\n and all MRCI API compression and decompression fns require that ES:BX\n point to this structure on entry.\n\nMRCInfoRec\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 4 lVendor e.g., Microsoft is 'MSFT' 4dH, 53H, 46H, 54H\n +4 2 wVenVer vender version number\n +6 2 wMrciVer MRCI spec. version number\n +8 4 pfpEntry FAR address of MRCI API handler\n +0cH 2 wCaps Server capabilities bit flags (see below)\n +0eH 2 wHWCaps same as wCaps, but for hardware assist (if any)\n +10H 2 wMaxDataLen maximum size of data that can be compressed or\n decompressed\n 18 size of a MRCInfoRec structure\n\n lVendor is a four-byte string identifying the vender that produced the\n currently-active MRCI server.\n\n wVenVer is the vendor's internal version number and...\n wMrciVer is the version of the MRCI specification that this server\n supports.\n\n The high byte is the major version number and the low byte is\n the minor; e.g., 010aH would be version 1.10.\n\n pfpEntry is the entry address used to access MRCI API services. Set up\n the registers with a fn code in AX, etc. and then call this\n address using a FAR CALL.\n\n Beware of the IMPORTANT constraints before calling this\n address. See MRCI fn 0001H for calling sequence. Failure to\n check InDOS and set a Windows Critical Section will result in\n a system crash and loss of data.\n\n wCaps is a set of bit flags that indicates which MRCI capabilities\n are supported by this server:\n 1 1\n ┌5┬4───6┬5┬4┬3┬2┬1┬0┐\n │r│0...0│i│0 0 0│d│c│\n └╥┴─────┴╥┴─┴─┴─┴╥┴╥┘ bit mask\n ║ ║ ║ ╚═► 0: 0001H can \"standard\" compress\n ║ ║ ╚═══► 1: 0002H can \"standard\" decompress\n ║ ╚═══════════► 5: 0020H can incremental decompress\n ╚═══════════════════►15: 8000H this MRCInfoRec is Read-Only\n\n Note that bits 3,4, and 5 are explicitly reserved. They may\n relate to the \"max-compress\" idea that surfaces in the early\n DOS 6 beta dox, but appears to have been squashed by the\n Stacker lawsuit.\n\n wHWCaps is a bit-packed flag with each bit identical in meaning to\n that of wCaps, but representing capabilities of a hardware-\n assisted, ROM-based MRCI server. This is 0000H with software-\n based MRCI servers.\n\n wMaxDataLen The maximum amount of data that can be compressed or\n decompressed in one block. Microsoft's MRCI server version\n 1.0 supports 32769-byte blocks.\n\n All MRCI servers are required to support at least 8192.\n\n Notes: Since this is maintained inside the data area owned by the MRCI\n server, it's probably not wise to muck around in it.\n\n However, Microsoft source code examples modify the pfpEntry field\n of the old MRCI server when installing a new one.\n\nSee Also: MRCI API\n DoubleSpace API\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "823-mrcrequestrec.html",
    "t": "MRCRequestRec",
    "b": "The MRCI API compression and decompression services require the\n address of this structure in DS:SI on entry. It describes what data\n to be processed and where to put the result.\n\nMRCRequestRec\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 4 pfbSrc far address of source buffer\n +4 2 wSrcLen size of source buffer, in bytes\n +6 2 wRes reserved\n +8 4 pfbDest address of destination buffer\n +0cH 2 wDestLen size of destination data or buffer, in bytes\n +0eH 2 wChunkLen \"early-out\" chunk size, in bytes\n +10H 4 lIncInfo used in incremental decompression\n 20 size of a MRCRequestRec structure\n\n pfbSrc FAR address of source data:\n Compress: Address of data to compress\n Decompress: Address of data to decompress\n Inc. Decompress: FIRST CALL: start of compressed block\n OTHER CALLS: updated automatically\n\n wSrcLen length, in bytes, of source data:\n Compress: Amount of data to compress\n Decompress: ignored (data length is given by wDestLen)\n Inc. Decompress: ignored\n\n pfbDest FAR address of destination buffer:\n Compress: Address of buffer to receive compressed data\n Decompress: address if buffer to receive decompressed data\n Inc. Decompress: FIRST CALL: start of dest buffer\n OTHER CALLS: updated automatically\n\n wDestLen length, in bytes, of destination data:\n Compress: ENTRY: Size of the destination buffer\n RETURN: Size of the compressed data\n Decompress: Exact size of the uncompressed data (MRCI\n uses this to know when to stop decompressing)\n Inc. Decompress: FIRST CALL: must be 0\n OTHER CALLS: desired bytes of uncompressed\n data. Take care to avoid asking for more\n data than was originally compressed!\n\n wChunkLen Use for compression performance. If the MRCI server cannot\n save at least wChunkLen bytes across the length specified in\n wSrcLen, then MRCI returns an MRCI API Error Code of 0004H\n (incompressible data).\n\n It also provides a means for the server to provide a speed\n optimization: After compressing for a while, it may notice\n that the remaining uncompressed data will fit within an even-\n multiple of wChunkLen. In that case, it can store the data\n verbatim or use a simplified compression technique on the\n remaining data.\n\n DoubleSpace uses a chunk size of 512 (since it allocates disk\n space in sectors). The Flash File system uses 1-byte chunks\n to minimize sector slack.\n\n lIncInfo is used only during Incremental Compression (MRCI Fn 0020H).\n FIRST CALL: set this DWORD to 0.\n OTHER CALLS: this is updated by MRCI; leave it alone.\n\nSee Also: MRCI API\n DoubleSpace API\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "824-int_1ah_b001h__query_rom_hardware_based_mrci_support.html",
    "t": "INT 1aH b001H: Query ROM/Hardware-Based MRCI Support",
    "b": "Expects: AX b001H\n CX 4d52H ('MR')\n DX 4349H ('CI')\n ──────────────────────────────────────────────────────────────────\n Returns: CX 4943h ('IC', if successful)\n DX 524dh ('RM', if successful)\n ES:DI address of an MRCInfoRec describing the MRCI server\n ──────────────────────────────────────────────────────────────────\n Info: See INT 2fH 4a12H for information on the parameters.\n\n This fn is defined by the MRCI API as a way for a hardware or\n ROM-based MRCI server to make its presence known and as a way for\n a software-based MRCI server to learn whether it should install\n itself.\n\n The idea is that a ROM-based and/or hardware-assisted compression\n system will be installed during ROM-Scan, before DOS or other\n operating system is loaded and thus may be unable to take control\n of the standard INT 2fH vector.\n\n The MRCI spec recommends that applications check for the server\n via INT 2fH 4a12H and if it is not found there, use this INT 1aH\n service.\n\n Notes: Before using INT 1aH, you should check its interrupt vectors to\n make sure that it is not 0000:0000.\n\nSee Also: MRCI API\n DoubleSpace Overview\n DoubleSpace API\n INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "825-int_2fh_xxfbh__faxbios_functions.html",
    "t": "INT 2fH xxfbH: FaxBIOS Functions",
    "b": "The FaxBIOS is a specification created by the FaxBios Association in 1991.\n It describes an API that can be used by programs that work with fax/modem\n adaptors to send and receive faxes.\n\n The FaxBIOS API is not universally-accepted, but it is used by some major\n OEMs. It describes several hundred services -- too many and too esoteric\n to be covered by TECH Help!. To get a copy of the printed specification:\n COMPUSERVE: Go FAXBIOS\n Fax request: (510) 540-5835\n Mail request: FaxBios Association\n 2625 Alcatraz Ave Suite 275\n Berkeley CA 94705\n\n█▌Check FaxBIOS Installed State▐█\n The FaxBIOS uses a \"universal\" technique for installing the server and\n for clients to check for installation. It installs a MUX service (see\n INT 2fH) but rather than picking a hard-coded MUX-ID, it uses an\n algorithmic technique that avoid the possibility of other MUX processes\n taking the same MUX number.\n\n To test for the presence of FaxBIOS, your program should:\n\n 1) Start with a candiateMuxID of 80H.\n\n 2) if candiateMuxID >= ffH, FaxBIOS is not present; exit.\n\n 3) Invoke INT 2fH, with AH=candiateMuxID.\n\n 4) On return, if AL=ffH, check the string at DX:DI to see if it is an\n exact match with \"FaxBiosjpc\" if so you've found the MUX-ID and\n FaxBios services are installed. Go to step 6.\n\n 5) If AL was not ffH or the string at DX:DI did not match, then\n increment candiateMuxID and loop to step 2.\n\n 6) Try the Sys_Login service (for instance):\n Set AH=muxID, AL=fbH\n BX=0001H (the fn number for Sys_Login), and\n DX:DI=addr of a 23-byte LOGIN_CANONICAL_REC structure\n Invoke INT 2fH. On return:\n AL will contain ffH if FaxBIOS is still present and\n CX will contains a FaxBIOS status code and\n the structure at DX:DI will contain lots of data.\n\n Notes: ■ The FaxBIOS provides lots of capabilities that would take\n thousands of programming hours to reproduce. For instance, it\n converts a text file directly into a FAX. It also provides\n structures and file standards for phonebooks, activity logs, a\n scheduling system, etc. (along with easy-to-use APIs to access\n these data).\n\n ■ When you examine existing fax/modem control programs, you will\n often find a one-to-one comparison between features of the\n control program and the features of the FaxBIOS API.\n\nSee Also: INT 2fH: Multiplex Interrupt\n DOS Functions\n -♦-"
  },
  {
    "id": "826-accessing_upper_memory.html",
    "t": "Accessing Upper Memory",
    "b": "█▌Overview▐█\n Starting with DOS 5.0, DOS supports access to Upper Memory Blocks (UMBs▲)\n on 386+ based computers which have installed the HIMEM.SYS and EMM386.EXE\n device drivers and have use DOS=UMB in CONFIG.SYS.\n\n Notes: ■ See XMS for info on accessing Extended memory▲\n ■ See EMS for info on accessing Expanded memory▲\n ■ See INT 2fH 4axxH for info on allocating part of the HMA▲\n\n At the user-interface level, just use the DOS Loadhigh command or the\n DEVICEHIGH= CONFIG.SYS command to load a TSR or device driver into upper\n memory. TSRs and applications can also make use of upper memory via:\n\n Fn 5800H (query allocation strategy) 3.0+\n Fn 5801H (set allocation strategy) 3.0+\n Fn 5802H (query upper-memory link state) 5.0+\n Fn 5803H (set upper-memory link state) 5.0+\n\n█▌Allocating in UMBs▐█\n To obtain access to an unallocated portion of a UMB, use the following\n steps:\n\n 1) Use fn 5802H and save the current UMB link state.\n\n 2) Use fn 5803H with BX=0001H to link-in upper memory.\n\n 3) Use fn 5800H and save the current allocation strategy code.\n\n 4) Use fn 5801H with BX=0041H (for instance) to set the allocation\n strategy to \"best fit high-only\".\n\n 5) Use fn 48H with BX=ffffH to learn the size of the largest available\n allocation in upper memory.\n\n 6) Use fn 48H with BX=desired_size to allocate the memory. The segment\n returned in AX will be higher than a000H if the memory was allocated\n in a UMB.\n\n 7) Be sure to use fns 5803H and 5801H to restore the previous link state\n and allocation strategy saved in steps 1 and 3. And use fn 49H to\n free the allocation when you're done with it.\n\n█▌Loading a TSR High▐█\n A TSR can load itself into a upper memory automatically, without having\n the user use the Loadhigh command via these steps:\n\n 1) Check to see if this is the second copy of your program. One\n technique is to hook INT 2fH and watch for your own MUX-ID (and\n communicate with the resident copy via your own internal API).\n Another it to examine the MCB chain and look for your own name.\n Another way might be to see if your PSP is above a000H.\n\n If this is the second copy, just initialize yourself and exit via\n fn 31H (terminate and stay resident).\n\n 2) Set the link to upper memory via fn 5803H and select a \"load high\n only\" allocation strategy via fn 5801H.\n\n 3) Make sure there is enough upper memory for your program.\n\n 4) Examine the DOS Environment to learn the filespec (including drive\n and path) that was used to start you.\n\n 5) Use DOS fn 4b00H (or a variant) to load and execute another copy of\n your program. Since the UMB-link is set and there is enough high\n RAM, the copy will be loaded into upper memory.\n\n 6) Restore the UMB-link and allocation strategy via fns 5803H and 5801H\n and terminate normally via fn 4cH.\n\n Of course, if there is no room in upper memory, you should install\n yourself normally, into conventional memory.\n\n Important: If you use this technique, be sure to provide a way for users\n to override (e.g., a /LOW command-line option). Many users require very\n specific control over UMB usage.\n\n█▌HMA Suballocations▐█\n A small part of the HMA▲ (up to about 16K, but often much less) may be\n available for use by device drivers and TSRs. It is usually occupied by\n DOS buffers (see BUFFERS=) or by the MRCI-engine portion of the\n DoubleSpace support for DOS 6.2.\n\n See the ◄undocumented► function INT 2fH 4axxH for details.\n\nSee Also: Memory Control Functions\n DOS Functions\n -♦-"
  },
  {
    "id": "827-debug_commands.html",
    "t": "Debug Commands",
    "b": "In the summary below: addr is XXXX -OR- XXXX:XXXX -OR- segreg:XXXX\n range is addr,addr -OR- addr L byte_count\n value is XXXX\n port is XX\nAll numbers, values, counts, and addresses must be in hexadecimal notation.\n\nCommand Function\n──────────────────── ──────────────────────────────────────────────────────\n? Help. List command syntax\n\nA [addr] Assemble. Enter assembly language mnemonics; press\n <Enter> on a blank line to stop entering code\n\nC range addr Compare blocks of memory\n\nD [addr] Display (dump) memory in hex and ASCII\n\nE addr [bytes] Enter (edit) bytes and strings into memory\n\nF range bytes Fill memory with pattern of bytes\n\nG [=addr] [[addr]...] Go. Execute code at CS:IP (or at =addr) with\n optional breakpoints at indicated addresses\n\nH value1 value2 Hexarithmetic. Display value1+value2 and value1-value2\n\nI port Input. Display value of an INP for indicated port\n\nL [addr] Load. Load file of Name at indicated addr or CS:100\n or\nL [addr] drv sec cnt Load cnt absolute disk sectors from drive drv, sector\n sec into memory starting at address addr (or CS:100)\n\nM range addr Move block of memory to addr\n\nN d:file [parms] Name. Set up for Load or Write with file and parms\n\nO port byte Output a byte to a port\n\nP [=addr][count] Proceed. Single-step execute a CALL, LOOP, INT, etc.\n\nQ Quit. Exit from Debug\n\nR [register] Registers. Displays current values. Allows input\n of values to a register or Flags. It also sets for\n next Unassemble to start at CS:IP.\n\nS range bytes Search memory. Show addrs that contain the bytes\n\nT [=addr][count] Trace. Single-step execute count opcodes (or 1)\n\nU [addr] or [range] Unassemble. Display opcode mnemonics at addr (or 128\n bytes starting at last addr Unassembled)\n\nW [addr] Write from memory to file named in previous Name\n command or the initial file). Writes starting from\n addr (or CS:100) for size in BX:CX\n\nW [addr] drv sec cnt Write cnt absolute disk sectors from memory starting\n at addr. Start writing at sector sec of drive drv\n\nXA count eXpanded mem Allocate count 16K pages of EMS▲ memory\nXD handle eXpanded mem Deallocate EMS pages of handle\nXM lpage ppage handle eXpanded mem Map logical EMS page to physical page\nXS eXpanded mem Status. Display status of EMS memory\n\nSee Also: 80x86/87 Opcodes\n EMS\n TECH Topics\n -♦-"
  },
  {
    "id": "828-standard_i_o_and_i_o_redirection.html",
    "t": "Standard I/O and I/O Redirection",
    "b": "█▌Overview▐█\n Starting with version 2.0, DOS supports the UNIX-like concept of\n redirection of the Standard Input and Standard Output devices. It is the\n basis of a technique which lets one program feed input into or capture\n output from another program.\n\n Unless redirected, Standard Input comes from the keyboard and Standard\n Output goes to screen; both are functions of the CON device. A parent\n process (such as COMMAND.COM) can redirect either Standard Input or Output\n or both before passing control to a child process. This can be a powerful\n way to pass information from process to process with a minimum of\n programming overhead.\n\n See File Handles for a list of pre-defined Standard I/O handles.\n\n Use DOS Character I/O functions or Fns 3fH/40H to read/write Standard I/O.\n Use file handle 02H (Standard Error device) with Fn 40H to make sure a\n message is displayed.\n\n Use DOS Fn 46H to redirect the Standard I/O.\n Use DOS Fn 4bH to execute a child process.\n Use DOS Fn 4400H to see if Standard I/O has been redirected.\n\n The Device Attribute of a device driver indicates if the device is to be\n used as the default Standard Input and/or Standard Output device.\n\n█▌COMMAND.COM & Standard I/O▐█\n The DOS command processor examines each command line for I/O redirection\n symbols before it performs an internal command or EXECs a program:\n\n process < filespec EXEC process; keyboard input will come from the file\n\n process > filespec EXEC process; screen output will go to the file\n\n process >> filespec EXEC process; output will be appended to the file\n\n process1 | process2 1. EXEC process1; output goes to temporary file\n 2. EXEC process2; keyboard input comes from the\n temporary file\n 3. delete the temporary file\n\n Notes: ■ Output redirection with '>' creates the output file, truncating\n its length to 0 before the first characters are written.\n Use '>>' if you want to append text to the end of an existing\n file.\n\n ■ You can use the pipe (\"|\") symbol to chain several DOS commands\n and programs together:\n\n DIR | SORT | FIND /v \"i\" >myfile.txt\n\n ■ Each temporary pipe file will have a unique name formed from\n hex digits of the current date and time.\n\n Prior to DOS 3.0, the temporary files are created in the\n current default directory of the default drive.\n\n With DOS 3.0+, COMMAND.COM looks for the TEMP directory and\n puts temporary files there. By setting TEMP to a RAM disk, I/O\n piping is much faster.\n\n ■ Redirection of the ECHO command is handy for several uses:\n ECHO ^L >PRN (force a formfeed on the printer)\n ECHO y|DEL *.* (answer \"yes\" to the \"Are you sure?\" prompt)\n ECHO ATDT 1(213)555-1234 >AUX (dial the phone)\n\n ■ Redirect output to the NUL device to get rid of some DOS\n messages:\n\n COPY *.COM d: >NUL (avoid the \"1 File(s) copied\" message)\n\n ■ COMMAND.COM will ignore redirection symbols enclosed in quotes:\n\n REM I am using the greater-than sign \">\" in this remark\n\nSee Also: Handle-Oriented File I/O\n DOS Functions\n -♦-"
  },
  {
    "id": "829-program_startup___exit.html",
    "t": "Program Startup & Exit",
    "b": "█▌Overview▐█\n DOS is able to load and execute two types of program files -- COM and EXE.\n\n Because of the segmented address space of the Intel 8088/80x86 CPUs and\n the fact that JMPs and CALLs are address-relative, either type of program\n may be loaded and executed at any paragraph address in conventional▲\n memory. Thus, code can be made resident in \"low\" memory and other code\n can be loaded and executed above it in memory. Programs are never written\n with the assumption that they'll be loaded at a certain address (except\n the boot sector and some self-booting, copy-protected games).\n\n ■ A COM-format file is a binary image of the code and data of the\n program. The file must be less than 64K, and no segment-address\n relocation takes place.\n\n ■ An EXE-format file contains an EXE Header that directs the loader in\n performing adjustments to segment references in a load module.\n\n█▌All Programs▐█\n Before either a COM- or EXE-format program is loaded, DOS selects a\n segment address, called the PSP (Program Segment Prefix) as the load base\n for the program. By default, DOS selects the lowest available address in\n conventional memory, but it is possible to control the location via DOS\n fn 58H. Then DOS performs these steps:\n\n ■ It makes a duplicate of the current DOS Environment for the program.\n DOS Fn 4bH (EXEC) lets a parent program create a different environment.\n For instance, a program can run COMMAND.COM, setting the DOS prompt to\n include the text \"Use EXIT to return to UltraProg>\".\n\n ■ It places a text string identifying the program's load path at the end\n of the environment (in DOS 3.0+).\n\n ■ It fills the fields of the PSP with information useful to the program\n (See Program Segment Prefix for a complete layout):\n • The amount of memory available to the program\n • The segment address of the DOS Environment\n • 0-2 unopened File Control Blocks (FCBs) as parsed from the command\n line (Note: if you open the first FCB, it will overwrite part of the\n second).\n • The command parameters: text entered in the command line after the\n program name (examine this for options and filename parameters)\n • The previous vectors for INT 22H, INT 23H, and INT 24H\n\n ■ It sets the default Disk Transfer Address (DTA) to PSP:0080\n\n ■ It sets the AX register to indicate the validity of the drive IDs (if\n any) of the filespec parameters entered on the command line:\n • if AL=0ffH, then the first drive ID was invalid\n • if AH=0ffH, then the second drive ID was invalid\n\n█▌EXE Programs▐█\n EXE-format programs define multiple program segments, including a code,\n data, and stack segment. The EXE file is loaded starting at PSP:0100. As\n it is loaded, a bunch of information is read from the EXE Header at the\n start of file and segment address-relocation is performed. This means\n that references such as...\n\n mov ax,data_seg\n mov ds,ax\n ...and...\n call my_far_proc\n\n ...must be adjusted to allow for the fact that the program is being loaded\n into an arbitrarily-selected memory segment. See EXE Header for details\n of the header and the relocation process.\n\n After relocation, control is passed to the load module via a FAR jump to\n the CS:IP that was read from the EXE header.\n\n When the EXE-format program gets control:\n ■ DS and ES are set to the PSP\n ■ CS, IP, SS, and SP are set to values indicated in the EXE Header\n ■ The PSP.wNextSeg field is set to a value in the EXE header. Normally,\n all of available memory is allocated to the program.\n\n█▌COM Programs▐█\n COM-format programs define a single segment. The bytes of the COM file\n are read from disk and stored into memory starting at PSP:0100. Note that\n a COM program can use multiple segments, but it must calculate or derive\n segment addresses, using the PSP segment as a base.\n\n Traditionally, COM programs have been preferred over EXE programs for\n short assembly language utilities. They load faster since no segment\n relocation is needed, and they take less disk space since the bytes of\n the EXE header and the stack segment need not be present in the load\n module. However, COM programs are starting to be phased out, since you\n can't write OS/2- or Windows-specific programs in COM format.\n\n Compilers and linkers may refer to COM programs as those using the \"tiny\"\n memory model.\n\n ■ CS, DS, ES, and SS are set the same as the PSP.\n ■ SP is set to the end of the PSP segment (usually 0fffeH, but it will be\n lower if a full 64K is not available). The word at offset 06H of the\n PSP is set to indicate how much of the program segment is available.\n ■ All system memory above the Program Segment is allocated to the\n program.\n ■ A word of 00H is pushed onto the stack.\n ■ IP is set to 100H (the first byte of the load module) by a JMP to\n PSP:100.\n\n█▌Exiting a Program▐█\n At one time (back in the days of DOS 1.1), it took several pages to\n explain the Rube Goldberg scheme DOS provided for exit from a program.\n It got easier starting with DOS 2.0. You can exit by:\n\n ■ Using DOS Fn 4cH (EXIT) at any time, regardless of register values.\n ■ Using DOS Fn 00H or INT 20H when your CS is the same as the PSP\n\n Prior to DOS 2.0, you needed to save the PSP segment at startup. Then to\n exit, you would PUSH it on the stack, PUSH a word of 00H, then do a FAR\n RETurn. This sends control to PSP:0000 which contains the opcodes for\n INT 20H. This ensures that CS is set as expected by DOS.\n\n DOS Fn 4cH eliminates this complication, and it lets you return an\n exit code▲ to the parent process (usually COMMAND.COM) which can be tested\n by the parent program or the \"IF ERRORLEVEL\" batch file command.\n\n You may also terminate a program and make it permanently memory resident\n (TSR), by using either INT 27H or DOS Fn 31H (KEEP). The latter has the\n advantages that you can make more than 64K resident and you can return an\n exit code▲ that can be tested by the parent process.\n\n TSR programs are handy for installing custom patches to various DOS and\n BIOS services. It is the concept used by popup utilities such as SideKick\n and TECH Help! (to name two popular instances).\n\n When a program exits:\n ■ All of its memory is freed, including the allocation for its copy of\n the environment. Exception: When exiting via TSR exits (INT 27H and\n fn 31H) the specified memory and your environment memory is preserved.\n TSRs should explicitly free their environment if they won't need it\n later.\n ■ Its files are closed and file buffers flushed.\n ■ Redirection, if any, is cancelled.\n ■ Critical error handler (INT 24H), Ctrl+Break handler (INT 23H), and\n Terminate (INT 22H) vectors are restored from the PSP.\n ■ Control is passed back to the parent, via a FAR JMP to the address that\n was previously in the INT 22H vector.\n\nSee Also: Process Control Functions .. index of DOS Startup and Exit fns\n Program Segment Prefix ..... detailed layout of the PSP\n TSR ........................ submenu of popup-program topics\n DOS Fn 26H ................. build a PSP\n DOS Fn 4bH (EXEC)........... load and execute programs\n DOS Fn 62H ................. obtain PSP of the current program\n DOS Fn 2fH ................. obtain current Disk Transfer Address\n DOS Environment ............ determine the drive and directory\n from which you were loaded, etc.\n DOS Functions\n TECH Topics\n -♦-"
  },
  {
    "id": "830-system_compatibility.html",
    "t": "System Compatibility",
    "b": "The following flags are used in TECH Help! to refer to differences in\n various IBM-compatible platforms. When you see one of these items, it\n indicates that the function, variable, port, or feature under discussion\n is specific for that particular version of the PC and probably does not\n apply to other versions (especially older versions).\n\n AT applies to the IBM AT or compatible: based on an 80286 CPU\n 286 applies to any computer based on the 80826, including the XT-286,\n PS/2 models 50 and 60, and various clones.\n\n PS/2 applies to IBM PS/2 only (\"real\" PS/2s based on 286/386 CPU)\n\n 386 applies to PCs which use 80386 CPU (supports virtual 86 mode)\n 486 applies to PCs which use 80486 CPU (has build-in math chip)\n Pentium applies to PCs which use Pentium (80586) CPU\n In general, all 386+ CPUs are in same category, software-wise.\n\n PC/XT applies to either the PC or XT, but specifically NOT the AT\n XT applies to the XT (mostly refers to differences in disk BIOS)\n\n PCjr applies ONLY to the PCjr (in other words, ignore it)\n\n (none) when no reference is given, the topic applies to all members of\n the PC family, and has remained compatible through the variations\n in ROM-BIOS firmware and PC (and clone) hardware.\n\n Press <Esc> to\n Return to the Previous Topic\nSee Also: DOS Versions\n TECH Topics\n -♦-"
  },
  {
    "id": "831-dos_versions.html",
    "t": "DOS Versions",
    "b": "TECH Help! indicates variations and incompatibilities between DOS versions\n by displaying a highlighted version number as a warning flag.\n\n Where DOS Functions or DOS Interrupts changed significantly between\n versions, these flags are used to let you see them at a glance; e.g.:\n\n 2.0+ .............. or (none) applies to DOS version 2.0 and higher\n 2.x .............. applies to DOS 2.0 or 2.1 or 2.11, etc.\n 3.0+ .............. applies to DOS versions starting at DOS 3.0\n\n MS-DOS and PC-DOS ... identifies differences between generic DOS and\n IBM's customized (OEM) version\n\n This topic summarizes changes from version to version of DOS. For a\n programmer's-eye view of version differences, see:\n\n DOS Function Index - by DOS Version\n\n█▌Version Summaries▐█\n The fundamental DOS services were roughed out with DOS 1.0 and stabilized\n (read: debugged) with version 1.1. If your program must be able to run\n under DOS 1.1, you must use only DOS Functions lower than 2fH.\n\n When IBM introduced a hard disk PC (the XT), it released DOS version\n 2.0 -- a significant upgrade, including:\n\n ■ Multiple directories to enhance access to large capacity media.\n ■ Handle-Oriented File I/O superseded the hard-to-use FCB File I/O to\n simplify file/device access.\n ■ Standard I/O Redirection for generalized UNIX-like device\n independence.\n ■ Installable Device Drivers to interface non-standard equipment & RAM\n disks and included the ANSI.SYS console driver\n\n DOS 2.1 fixed a few bugs and added support for the PCjr diskette drives.\n\n DOS 3.0 came out with the AT and included support its 20M hard disk. It\n added support for 16-bit FAT entries to minimize slack space on\n hard disks. Added extended error reporting for DOS functions.\n\n Significant new DOS commands: Attrib, Label, VDISK.SYS RAM disk\n\n Change Summary:\n Fn 3dH (open) supports file sharing\n Fn 44H subFns 08H (check removable) and 0bH (set retry count)\n Fn 59H extended error information\n Fn 5aH create temporary (unique) file\n Fn 5bH create new file (create only in it doesn't exist)\n Fn 5cH lock/unlock file\n Fn 62H get PSP address\n INT 24H indicates which of (abort, retry, ignore) are valid.\n\n DOS 3.1 included some network services (file sharing, locking,\n redirecting).\n\n Significant new DOS commands: Join, Subst\n\n Change Summary:\n Fn 44H SubFns 09H and 0aH were added for network support\n Fn 5eH (network printer) and 5fH (network device redirection)\n\n DOS 3.2 came out with the IBM Convertible PC. It expanded on the device\n driver IOCTL Functions to include DOS-blessed disk formatting,\n etc.\n\n Significant new DOS commands: Replace, Xcopy, DRIVER.SYS\n\n Change Summary:\n\n Fn 44H was extended to support Generic IOCTL and to support\n logical drives with subFns 440dH, 440eH, and 440fH.\n\n DOS 3.3 was released with the PS/2. It supports the 1.4M 3½\" diskettes.\n\n Significant new DOS commands: Append, Call, Chcp, Fastopen,\n Nlsfunc\n\n Change summary:\n ■ Attrib can work on a tree of subdirectories\n ■ Backup will format a diskette on the fly if you specify /F\n ■ batch commands can be truly silent (e.g., @ECHO OFF is not\n seen) and one batch file can execute another and return to\n the caller\n ■ Date and Time modify CMOS Memory for 'permanent' time changes\n ■ Fdisk supports logical volumes; lets you break a large hard\n disk ( > 32M ) into two drives. See Extended DOS Partition\n ■ Additional national language support:\n • Keyb replaces KEYBxx and uses the KEYBOARD.SYS data file\n • Nlsfunc installs Code Page font-switching\n • New command Chcp selects/displays current active code page\n • New drivers PRINTER.SYS and DISPLAY.SYS support fonts\n • Mode supports code page selection and switching\n\n ■ DOS Functions were added:\n • Fn 440cH prepare and select code page fonts\n • Fn 66H select code page fonts (when Nlsfunc is resident)\n • Fn 67H increase the max number of file handles\n • Fn 68H forced update of a file to disk ('commit' a write)\n\n DOS 4.0 Adds some support for expanded memory and disk partitions > 32M.\n It provides a long overdue point-and-shoot DOS shell.\n\n Significant new DOS commands: Dosshell, Install, Mem, Switches\n\n Change summary:\n ■ Append is somewhat smarter; less chance of disasters\n ■ Backup automatically formats destination disk (/F not needed)\n ■ BUFFERS= (in CONFIG.SYS) can use EMS▲ memory; I/O is faster\n ■ Del /p pauses to confirm each of a wildcard file delete\n ■ Fastopen is faster and can use EMS memory to hold data\n ■ Format /f:size accepts size in Kbytes; /v:lbl sets volume\n label\n ■ Graphics works with EGA/VGA modes; supports more printers\n ■ Mode sets keyboard repeat rate; number of lines on the screen\n ■ REM can be used in the CONFIG.SYS file (it's about time!)\n ■ Replace /u overwrites destination files older than source\n ■ Tree has been brought up to about a 1984 level of\n sophistication\n ■ DEVICE= (config cmd) device drivers added/changed:\n • Ansi.Sys can restore screen layouts other than 80x25\n • Xma2ems.Sys and Xmaem.Sys supports EMS (expanded memory)\n • Vdisk.Sys can use EMS memory\n\n ■ DOS Functions were added/changed:\n • Fn 33H can now return the drive number of the boot disk\n • Fn 440cH (CL=5fH/7fH) provides a means to query/set the\n screen display mode, number of rows, etc.\n • Fn 6cH is a new all-purpose file Open/Create tool.\n • INT 25H/26H provide access to logical sectors > 65535\n DOS 4.01 The stable (debugged) version of DOS 4.0. Accept no substitute.\n\n DOS 5.0 was released by Microsoft, after it wrested control back from\n IBM. This is the most significant upgrade in many years.\n\n Supports 2.88M diskette drives.\n\n Significant new DOS commands: DEVICEHIGH=, DOS=, Doskey, Edit,\n EMM386.EXE, Help, HIMEM.SYS, Loadhigh, Mirror, Qbasic, Setver,\n Undelete, Unformat\n\n Change summary:\n ■ Memory-management for 386+ computers, including access to\n UMBs via DOS=, DEVICEHIGH= and Loadhigh, and EMM386.EXE.\n ■ Data recovery via Mirror, Undelete and Unformat\n ■ Text editor, EDIT.COM (really part of Qbasic)\n ■ Command-line retriever, Doskey\n ■ Access to Hidden and System files, via Attrib\n ■ View sorted directories and other options in Dir command\n ■ Setver tricks apps into seeing a different DOS version\n ■ All commands accept /? to mean \"show syntax\"\n ■ Numerous small \"quality of life\" changes\n\n ■ DOS Functions were added/changed (note: The DOS 5.0 Tech Ref\n documents many previously-undocumented services. This lists\n only those that are actually new with DOS 5.0. See\n DOS Function Index - by DOS Version for a complete list).\n\n • Fn 1fH and 32H (Get Disk Parameter Block) are very useful.\n • Fn 3306H gets the actual DOS version (30H only gets the\n SetVer simulated version number)\n • IOCTL fns 440dH 68H (sense media type)\n • IOCTL fns 4410H, and 4411H obtain info about IOCTL support\n • Fn 4b05H is a rarely-needed variation of EXEC services.\n • Fn 5802H and 5803H are memory-support services.\n • INT 2fH: Several add-on APIs are now documented.\n\n DOS 6.0 is basically DOS 5.0 with an armful of bundled utility programs\n and a few minor changes to DOS itself.\n\n Significant new DOS commands: Choice, Dblspace, Defrag, Deltree,\n Help, InterLnk, InterSvr, Memmaker, Move, Msav, Msbackup, Msd,\n Power, Truename, VSafe.\n\n Change summary:\n ■ Disk compression via DoubleSpace and MRCI API.\n ■ File defragmenter, Defrag, speeds up some disk I/O\n ■ Laptop tools: Power (see APM API) and InterLink\n ■ Memory-usage optimizer, MemMaker.\n ■ CONFIG.SYS handling changes:\n Clean Boot (press F5 to skip CONFIG.SYS and AUTOEXEC.BAT)\n Interactive Boot (press F8 to verify each CONFIG.SYS command)\n MultiConfig Menus let you define sets of config options\n\n ■ DOS services were added/changed:\n • No new INT 21H fns defined.\n • DoubleSpace API (via INT 2fH)\n • MRCI API (via INT 2fH)\n • APM API (via INT 2fH)\n • INT 2fH 16xxH Windows 386Enh-Mode services\n • INT 2fH 17xxH Windows Clipboard access\n • INT 2fH 40xxH Windows VDD fns for VM-aware apps\n\n DOS 6.2 is a mildly-aerobic exercise in butt-covering. It was released\n after the media began playing up problems with DOS 6.0,\n especially the DoubleSpace feature. Microsoft's jump to \"6.2\"\n was probably prompted to make this look better than IBM's 6.1.\n\n Significant new DOS commands: ScanDisk\n\n Change summary:\n ■ DoubleSpace can automount floppy diskettes\n ■ \"DoubleGuard\" halts the system if it finds that a program has\n overwritten any of the DoubleSpace memory area.\n ■ DoubleSpace can uncompress a disk.\n ■ DoubleSpace can use part of the HMA▲ (if you set BUFFERS=\n small enough).\n ■ SmartDrive now caches CD-ROMs. Very handy.\n ■ Command /Y /CbatName single-steps through a batch file.\n ■ Clean Boot lets you bypass the normal loading of DBLSPACE.BIN\n ■ Interactive Boot steps through AUTOEXEC.BAT\n ■ ScanDisk checks the disk for bad sectors and marks them as\n bad in the FAT, thereby avoiding many potential problems with\n DoubleSpace, Defrag, at al. It's about time.\n ■ Dir, Mem, Chkdsk, et al. display large numbers with commas.\n ■ Copy, Move, and Xcopy now prompt before overwriting a file.\n The predefined e-var COPYCMD sets the default action and\n command line options /Y or /-Y can override.\n\n ■ DOS interrupts and functions were added/changed:\n INT 2fH 4axxH HMA Suballocations\n INT 2fH 4a11H 000aH select which drives are automount-enabled\n INT 2fH 4a11H 000bH query which drives are automount-enabled\n DS IOCTL 'S' Improved way to get actual fres space on\n compressed drives\n (perhaps others; I don't have the full info right now)\n\n█▌Compatibility▐█\n In general, higher numbered versions are compatible with lower-numbered\n versions. Most software is written to work with DOS 2.x since that is\n still a common incarnation. The added features of DOS 3.x and even 4.x\n are relatively insignificant, so there is little reason to develop\n software that relies on these \"new\" features (with the exception of\n networking applications).\n\n One common compatibility problem is seen on PCs with a limited amount of\n memory. Higher numbered DOS versions often take up more RAM from the\n available pool and thus leave less room for application programs.\n\n Version Date On Disk In Memory\n ▀▀▀▀▀▀▀ ▀▀▀▀▀▀▀▀ ▀▀▀▀▀▀▀ ▀▀▀▀▀▀▀▀▀\n DOS 1.0 08-04-81 11,551 12,144 On Disk is the size of COMMAND.COM\n DOS 1.1 05-07-82 13,279 12,400 +IO.SYS\n DOS 2.0 03-08-83 39,424 24,800 +MSDOS.SYS\n DOS 2.1 10-20-83 39,551 24,800\n DOS 3.0 08-14-84 58,926 37,024 In Memory as reported by CHKDSK.\n DOS 3.1 03-07-85 60,534 37,040 More RAM used with SHARE, MODE, etc.\n DOS 3.2 12-30-85 68,637 44,704 and some CONFIG.SYS directives.\n DOS 3.3 03-17-87 77,566 46,048\n DOS 4.0 06-17-88 106,431 90,736\n DOS 5.0 08-15-90 112,478 varies*\n DOS 6.0 03-10-93 131,433 varies§\n DOS 6.2 09-30-93 133,323 varies§\n\n * Starting with DOS 5.0, it is possible to load much of DOS into upper\n memory blocks▲, so its use of conventional memory can be as little as\n about 20K.\n\n § With DOS 6.0+, most configurations will include 43K of RAM used by\n DoubleSpace and MRCI. It may be in upper memory.\n\n Also, the On Disk size should include the 50-65K of DBLSPACE.BIN\n (though optional, the majority of systems use it).\n\n█▌MS-DOS vs PC-DOS vs OEM Versions▐█\n In many respects, these variation of DOS are identical. For programmers,\n there are no differences in using the DOS Functions or other facets of the\n programming interface. OEM versions may have additional \"external\n commands\" (add-on utility programs), including custom hardware support,\n such as in Compaq's TAPE command.\n\n Other differences: MS-DOS usually includes RAMDRIVE.SYS, while PC-DOS\n supplies VDISK.SYS. MS-DOS includes SMARTDRV.SYS (or SMARTDRV.EXE), while\n older versions of PC-DOS supply an undocumented disk cache driver named\n IBMCACHE.SYS.\n\n One thing to watch for is the naming convention used for the two system\n files which get executed at boot time. IBM's file names are IbmBio.Com\n and IbmDos.Com. Generic MS-DOS uses Io.Sys and MsDos.Sys. This causes\n problems when you try to convert from MS-DOS to PC-DOS or vice versa\n manually (an old version of the DOS Sys command may have trouble when it\n doesn't find the filenames it expects).\n\n The bundled utilities diverged considerably, starting with DOS 5.\n\n█▌Traps and Pitfalls▐█\n Most DOS system-level functions are upwardly-compatible with older\n versions, but there are several places you can't take that for granted.\n Most of the items in the following list are relatively unimportant, but it\n might save you several hours of debugging time.\n\n ■ DOS Fn 1bH stopped returning a pointer to the actual FAT in DOS 2.0 and\n just returns a pointer to a media descriptor byte.\n\n ■ DOS Fn 4fH (Find Next File) had a subtle change between DOS version 2.x\n and 3.x. You are now required to keep DS:DX pointing to the\n information from a 4eH (Find First File) call. DOS 2.x just assumed it\n was in the DTA.\n\n ■ DOS Fn 30H modifies BX and CX in DOS 3.0+\n\n ■ DOS Fn 38H (Country Info) returns an incompatible Country Info Block.\n\n ■ The three 16-bit words at the end of the BPB (used in device drivers)\n switched from being \"optional\" to \"mandatory\" with DOS 3.0. Also, be\n aware that some non-IBM installed device drivers do NOT store the BPB\n in the boot sector of the hard disk (this only applies to hard disks\n which are not installed with ROM-Scan and thus need not have a\n partition table and are not self-booting).\n\n ■ Under DOS 4.0, the BPB is enlarged and the boot sector contains data\n including the volume label and a quasi-unique serial number.\n\n ■ Under DOS 5.0+, the SmartDrive disk cache may begin writing to disk\n asynchronously (screwing up your highly-optimized communications\n program). Force a cache flush via fn 0dH and/or DS IOCTL 'F'.\n\n As of 1993, there are very few users of DOS 2.x, but you will still run\n into some DOS 3.x systems. Most programmers feel safe writing for the\n 3.0+ API, letting users with older systems fend for themselves.\n\n In my opinion, you should NOT employ and rely on fns that are new for\n DOS 4.0+ unless you state that on the outside of your package. In my\n experience, there are very few DOS services that are really needed (for\n standard application programs) that have not been available since DOS 2.1.\n\n Exceptions: Add-on APIs, such as DoubleSpace or INT 2fH 48xxH (Doskey\n services), which you can test for and work-around when not present.\n\nSee Also: DOS Function Index - by DOS Version\n System Compatibility\n -♦-"
  },
  {
    "id": "832-int_33h__mouse_support.html",
    "t": "INT 33H: Mouse Support",
    "b": "0000H Reset/Query driver presence 0013H Set max for speed doubling\n 0001H Display pointer 0014H Exchange event handlers\n 0002H Hide pointer 0015H Query status buffer size\n 0003H Query position & buttons 0016H Save mouse status\n 0004H Move pointer 0017H Restore mouse status\n 0005H Query button-pressed count 0018H Install mouse+key event handler\n 0006H Query button-released count 0019H Get addr of mou+key evt handler\n 0007H Set horizontal range 001aH Set mouse sensitivity\n 0008H Set vertical range 001bH Query mouse sensitivity\n 0009H Set graphics pointer shape 001cH Set mouse interrupt rate\n 000aH Set text pointer mask 001dH Set display page\n 000bH Query last motion distance 001eH Query active display page\n 000cH Set event handler 001fH Deactivate mouse driver\n 000dH Enable lightpen emulation 0020H Activate mouse driver\n 000eH Disable lightpen emulation 0021H Reset mouse driver\n 000fH Set pointer speed 0024H Query mouse type, IRQ#\n 0010H Set exclusion area\n\n To access the mouse support: load the registers as described under each\n function, set AX to the function number, and execute INT 33H.\n\n In most text-mode applications, very few functions are actually needed.\n In a graphics mode application, you had better stick to the Windows or\n other GUI or TUI environment mouse support.\n\n To determine if the mouse is present, use INT 33H 0000H. This resets the\n mouse driver and, in general, all of the default settings are adequate.\n Note that you can probably assume that the user knows how to install the\n mouse (via executing MOUSE.COM or installing MOUSE.SYS in CONFIG.SYS).\n\n You may poll for mouse activity via INT 33H 0003H or install an event\n handler via INT 33H 000cH or INT 33H 0018H and take action whenever a\n button gets pressed. A common technique is to have your event handler\n simply set values into global variables which can be examined by any part\n of your program at any time.\n\n One thing to note is that all screen coordinates used by the driver are\n specified as if the screen were in a \"virtual graphics mode\". For text-\n mode applications, a character position is considered to be 8 points wide\n and 8 points tall. Thus, to specify a screen (X,Y) of (10,11), pass the\n value (80,88). Similarly, when the support indicates that the mouse is at\n (632,80), then the pointer is actually on character (79,10). Just divide\n each coordinate by 8 (or shift right 3 times).\n\n█▌Mouse Droppings▐█\n One tricky part of text-mode mouse programming relates to an effect I call\n mouse droppings. When you perform direct writes to the video buffer (and\n in doing so, overwrite the position of the mouse), the mouse support won't\n know about any new character or attribute at the pointer position. When\n the mouse is then moved, the driver will restore the old character and\n attribute instead of the new one you have written.\n\n To avoid this, you must use INT 33H 0002H (hide ptr) before writing\n directly to the video RAM and use INT 33H 0001H (show ptr) afterward.\n Note that if you stick to INT 10H video I/O, you won't have this problem,\n since the mouse support intercepts such I/O calls and eliminates the\n problem.\n\n█▌TSR Programs▐█\n When writing a TSR which uses the mouse, you must take care to avoid the\n mouse-droppings problem, as well as related problems having to do with\n interrupting an executing program.\n\n When installing your TSR, call INT 33H 0015H and allocate a buffer of the\n indicated size. When the TSR is popped up, you must use INT 33H 0016H to\n save the state of the mouse, and use INT 33H 000cH, INT 33H 0014H, or\n INT 33H 0018H to install your event handler. Upon exiting from your TSR,\n you must use INT 33H 0017H to restore the mouse state for the interrupted\n program.\n\n█▌Versions▐█\n The Microsoft Mouse is the industry standard and it is generally okay for\n an application to assume that the mouse is 100% Microsoft compatible.\n\n MS Mouse driver version 6.0 (circa 1983) supported only MouFns 0-17H and\n 1dH-1eH. Driver version 6.1 (circa 1984) supports all the functions\n listed above, adding the ability to install a more flexible event handler\n (check for Shift-, Ctrl-, or Alt- clicks), CRT page awareness, mouse\n sensitivity control, and a way to disable the mouse driver.\n\n Since all of these improvements have existed for several years (with\n nothing new, to speak of), there should be no problem with using any of\n the newer functions. However, a few non-Microsoft mouse devices do not\n support the later fns. For best compatibility, you might try sticking\n with fns 0000H-0017H.\n\nSee Also: API Service Index\n INT 15H 84H (joystick support)\n IRQs: Hardware Interrupts\n DOS Functions\n -♦-"
  },
  {
    "id": "833-int_33h_0000h__reset_query_installed_state.html",
    "t": "INT 33H 0000H: Reset/Query Installed State",
    "b": "Expects: AX 0000H\n ──────────────────────────────────────────────────────────────────\n Returns: AX Mouse installed status: 0000H = not installed (don't use!)\n FFFFH = installed\n BX number of mouse buttons\n ──────────────────────────────────────────────────────────────────\n Info: Resets the mouse. Use this function to determine if mouse\n support is present. It performs a hardware and software reset\n (see INT 33H 0021H for a way to performs just a software reset).\n\n For text-mode applications, this function does the following:\n\n • Moves the mouse pointer to the center of the screen\n • Hides the pointer (use INT 33H 0001H to display it).\n • Clears any \"exclusion area\" set via INT 33H 0010H.\n • Sets the pointer mask to the default: inverse-attribute of\n character at pointer (use INT 33H 000aH to change the\n appearance of the pointer).\n • Sets the range to the height and width of the entire screen\n (use INT 33H 0007H, and INT 33H 0008H or INT 33H 0010H to limit\n the mouse pointer display area).\n • Sets up for pointer drawing on video pg 0 (see INT 33H 001dH).\n • Enables Lightpen emulation (see INT 33H 000dH).\n • Sets pointer speed ratio to horizontal: 8 to 8; vertical 8 to\n 16 and sets the maximum doubling threshold to 64 mickeys\n (see INT 33H 001aH).\n\nSee Also: INT 33H: Mouse Support\n Interrupts and BIOS Services\n -♦-"
  },
  {
    "id": "834-int_33h_0001h__show_mouse_pointer.html",
    "t": "INT 33H 0001H: Show Mouse Pointer",
    "b": "Expects: AX 0001H\n ──────────────────────────────────────────────────────────────────\n Returns: none\n ──────────────────────────────────────────────────────────────────\n Info: This unhides the mouse pointer. It actually increments an\n internal counter used by the mouse support to determine when to\n show the pointer.\n\n That counter starts as -1 (after an INT 33H 0000H or 0021H\n reset). This call increments it to 0.\n\n Whenever the counter is 0, the mouse pointer is displayed and\n tracked on-screen. When the counter is 0, subsequent Show\n Pointer calls are ignored. Calls to INT 33H 0002H (hide pointer)\n decrement the counter.\n\n This logic relieves programs of the burden of global tracking of\n the hidden/displayed state. A subroutine may always use\n INT 33H 0001H at the beginning and INT 33H 0002H at the end,\n without affecting the shown/hidden state of the calling routine.\n\n This function also resets the \"exclusion area\" set via\n INT 33H 0010H.\n\nSee Also: INT 33H: Mouse Support\n Interrupts and BIOS Services\n -♦-"
  },
  {
    "id": "835-int_33h_0002h__hide_mouse_pointer.html",
    "t": "INT 33H 0002H: Hide Mouse Pointer",
    "b": "Expects: AX 0002H\n ──────────────────────────────────────────────────────────────────\n Returns: none\n ──────────────────────────────────────────────────────────────────\n Info: This removes the mouse pointer from the screen (if it is\n currently visible). It actually decrements an internal pointer-\n display cursor. If that counter is 0 before the call, the mouse\n pointer is removed from the screen.\n\n Use this function before performing any direct writes to the\n video display (if doing so will overwrite the mouse pointer) and\n call INT 33H 0001H (show ptr) after writing to the screen. See\n the discussion of Mouse Droppings under INT 33H.\n\nSee Also: INT 33H: Mouse Support\n Interrupts and BIOS Services\n -♦-"
  },
  {
    "id": "836-int_33h_0003h__query_position___button_status.html",
    "t": "INT 33H 0003H: Query Position / Button Status",
    "b": "Expects: AX 0003H\n ──────────────────────────────────────────────────────────────────\n Returns: BX Button status: bit 0 = left button down (BX & 1) == 1\n bit 1 = right button down (BX & 2) == 2\n bit 2 = center button down (BX & 4) == 4\n CX X coordinate (horizontal) divide by 8 for text clm\n DX Y coordinate (vertical) divide by 8 for text line\n ──────────────────────────────────────────────────────────────────\n Info: This returns the current position of the mouse pointer, and the\n current status of the mouse buttons.\n\n Rather than constantly polling this function, many programmers\n prefer to install a mouse event handler via INT 33H 000cH or\n INT 33H 0018H and maintain global variables for instant access to\n mouse information.\n\n Notes: All X,Y coordinates are virtual coordinates and when working with\n text mode, you must divide each value by 8 to get a character\n clm,row.\n\nSee Also: INT 33H: Mouse Support\n Interrupts and BIOS Services\n -♦-"
  },
  {
    "id": "837-int_33h_0004h__set_mouse_pointer_position.html",
    "t": "INT 33H 0004H: Set Mouse Pointer Position",
    "b": "Expects: AX 0004H\n ──────────────────────────────────────────────────────────────────\n Returns: CX X coordinate (horizontal) multiply text clm by 8\n DX Y coordinate (vertical) multiply text line by 8\n ──────────────────────────────────────────────────────────────────\n Info: This sets the driver's internal pointer coordinates.\n\n The pointer moves there, even if it is currently hidden (see\n INT 33H 0002H) or if X,Y is in the exclusion area (see\n INT 33H 0010H).\n\n If X,Y is outside the range set by INT 33H 0007H and\n INT 33H 0008H, then the pointer is \"pinned\" within the range\n rectangle (it will be set to the nearest valid limit).\n\n It is rare to need to move the pointer; the best policy is to let\n the user do the driving.\n\n Notes: All X,Y coordinates are virtual coordinates and when working with\n text mode, you must divide each value by 8 to get a character\n clm,row.\n\nSee Also: INT 33H: Mouse Support\n Interrupts and BIOS Services\n -♦-"
  },
  {
    "id": "838-int_33h_0005h__query_button_pressed_counter.html",
    "t": "INT 33H 0005H: Query Button-Pressed Counter",
    "b": "Expects: AX 0005H\n BX Button to query (0=left, 1=right, 2=center)\n ──────────────────────────────────────────────────────────────────\n Returns: AX Button status: bit 0 = left button down (BX & 1) == 1\n bit 1 = right button down (BX & 2) == 2\n bit 2 = center button down (BX & 4) == 4\n BX Count of times that button was pressed since last call\n CX X coordinate (horizontal pixel) at last press\n DX Y coordinate (vertical pixel) last press\n ──────────────────────────────────────────────────────────────────\n Info: This obtains:\n • The current button status.\n • The number of times the specified button (in BX) has been\n pressed since the last call to this function.\n • The X,Y coordinates of the pointer at the time of the most\n recent press of that button.\n\n You might use this to check for double-clicks, or periodically to\n check for the press of a particular button (e.g., if the right-\n button means to cancel).\n\n Notes: All X,Y coordinates are virtual coordinates and when working with\n text mode, you must divide each value by 8 to get a character\n clm,row.\n\nSee Also: INT 33H: Mouse Support\n Interrupts and BIOS Services\n -♦-"
  },
  {
    "id": "839-int_33h_0006h__query_button_released_counter.html",
    "t": "INT 33H 0006H: Query Button-Released Counter",
    "b": "Expects: AX 0006H\n BX Button to query (0=left, 1=right, 2=center)\n ──────────────────────────────────────────────────────────────────\n Returns: AX Button status: bit 0 = left button down (BX & 1) == 1\n bit 1 = right button down (BX & 2) == 2\n bit 2 = center button down (BX & 4) == 4\n BX Count of times that button was released since last call\n CX X coordinate (horizontal pixel) at last release\n DX Y coordinate (vertical pixel) last release\n ──────────────────────────────────────────────────────────────────\n Info: This obtains:\n • The current button status.\n • The number of times the specified button (in BX) has been\n released since the last call to this function.\n • The X,Y coordinates of the pointer at the time of the most\n recent release of that button.\n\n Notes: All X,Y coordinates are virtual coordinates and when working with\n text mode, you must divide each value by 8 to get a character\n clm,row.\n\nSee Also: INT 33H: Mouse Support\n Interrupts and BIOS Services\n -♦-"
  },
  {
    "id": "840-int_33h_0007h__set_horizontal_range.html",
    "t": "INT 33H 0007H: Set Horizontal Range",
    "b": "Expects: AX 0007H\n CX minimum X coordinate (horizontal pixel position)\n DX maximum X coordinate (horizontal pixel position)\n ──────────────────────────────────────────────────────────────────\n Returns: none\n ──────────────────────────────────────────────────────────────────\n Info: This sets a horizontal range out of which the mouse pointer will\n not be able to move. Attempts by the user (or the program via\n INT 33H 0004H) to move to the left of CX or the right of DX will\n cause the pointer to remain at the minimum or maximum value in\n the range.\n\n Use INT 33H 0008H to limit motion on the vertical axis.\n\n Notes: All X,Y coordinates are virtual coordinates and when working with\n text mode, you must divide each value by 8 to get a character\n clm,row.\n\nSee Also: INT 33H: Mouse Support\n Interrupts and BIOS Services\n -♦-"
  },
  {
    "id": "841-int_33h_0008h__set_vertical_range.html",
    "t": "INT 33H 0008H: Set Vertical Range",
    "b": "Expects: AX 0008H\n CX minimum Y coordinate (vertical pixel position)\n DX maximum Y coordinate (vertical pixel position)\n ──────────────────────────────────────────────────────────────────\n Returns: none\n ──────────────────────────────────────────────────────────────────\n Info: This sets a vertical range out of which the mouse pointer will\n not be able to move. Attempts by the user (or the program via\n INT 33H 0004H) to move above CX or below DX will cause the\n pointer to remain at the minimum or maximum value in the range.\n\n Use INT 33H 0007H to limit motion on the horizontal axis.\n\n Notes: All X,Y coordinates are virtual coordinates and when working with\n text mode, you must divide each value by 8 to get a character\n clm,row.\n\nSee Also: INT 33H: Mouse Support\n Interrupts and BIOS Services\n -♦-"
  },
  {
    "id": "842-int_33h_0009h__set_graphics_pointer_shape.html",
    "t": "INT 33H 0009H: Set Graphics Pointer Shape",
    "b": "Expects: AX 0009H\n BX pointer hot spot (horizontal)\n CX pointer hot spot (vertical)\n ES:DX address of pointer shape bit field (64 byte data area)\n ──────────────────────────────────────────────────────────────────\n Returns: none\n ──────────────────────────────────────────────────────────────────\n Info: This defines the appearance of the mouse pointer when functioning\n on a graphics-mode screen and it selects which part of that\n pointer will identify the specific pixel at which the mouse is\n pointed. The default graphics cursor is a left-leaning, upward-\n pointing arrow with the hot spot at 0,0 (in the top left corner).\n\n To modify the pointer for text-mode screens, see INT 33H 000aH.\n\n The data at ES:BX is 64 bytes long; two sets of 32. Each set of\n 32 bytes is organized as 16x16 bits; i.e., 16 rows of 2-byte\n values.\n\n The first set of 32 bytes defines the \"AND mask\"; that is, the\n background will show through wherever there is a 1-bit in that\n data.\n\n The second set defines the \"XOR mask\"; that is, after the \"AND\n mask\" has cleared out some of the background, the pixels matching\n the 1-bits in this data set are toggled.\n\n The BX and CX values specify the \"hot spot\" for instance, if BX=0\n and CX=0, then a button click it taken to mean a selection of the\n pixel in the top left corner of the pointer rectangle. If BX=15\n and CX=15, a click will select the pixel at the bottom/right\n corner of the pointer.\n\nSee Also: INT 33H: Mouse Support\n Interrupts and BIOS Services\n -♦-"
  },
  {
    "id": "843-int_33h_000ah__set_text_pointer_mask.html",
    "t": "INT 33H 000aH: Set Text Pointer Mask",
    "b": "Expects: AX 000aH\n BX pointer type: 0=software ptr; 1=hardware ptr\n CX AND mask (if BX=0) or cursor start line (if BX=1)\n DX XOR mask (if BX=0) or cursor end line (if BX=1)\n ──────────────────────────────────────────────────────────────────\n Returns: none\n ──────────────────────────────────────────────────────────────────\n Info: This lets you modify the appearance of the mouse pointer on the\n text-mode display. It also lets you use the standard blinking\n \"hardware cursor\" as the mouse pointer. By default, the pointer\n is a \"software cursor\" displayed as the pointed-to character,\n with an \"inverted\" color attribute.\n\n To modify the pointer for graphics screens, see INT 33H 0009H.\n\n BX 0000H = Software Pointer\n Use this to specify the desired colors for the pointer or to set\n the pointer to be displayed as a specific character (e.g., a\n checkmark, (√), or other character). This latter option is handy\n for signaling when a button has been pressed over selectable\n field, such as a menu item or hyperlink.\n\n The mouse support works by ANDing the value of the char/attr at\n the pointer with your AND mask (i.e., it removes bits from the\n screen char/attr which are 0s in your AND mask). It then applies\n the XOR mask to the result (i.e., it toggles bits of the result\n which are 1s in the XOR mask). It then stores the result of the\n two operations into the char/attr on the screen.\n\n CX and DX: The low byte of each mask affects the character code\n and the high byte affects the color-and-blink attribute. See\n Video Attributes for information on the bit-encoding of text-mode\n attribute bytes.\n\n The default values are: CX=ffffH and DX=7700H. The effect is\n that no information is masked by the AND mask, and that the\n foreground color is inverted (all three bits toggled) and the\n background color is inverted.\n\n This example makes the pointer into a red-on-blue check mark:\n\n mov BX,0 ;software pointer\n mov CX,0000H ;mask all current information\n mov DX,14fbH ;1xxx=blue bkgd, x4xx=red frgd, xxfb='√'\n mov AX,000aH\n int 33H\n\n To set the pointer to an arbitrary color without changing the\n character, use CX=00ffH to mask (clear) the attribute and BX=xx00\n to set the color to xx (see Screen Attributes).\n\n BX 0001H = Hardware Pointer\n This selects to ignore all of the above options and rely on the\n familiar blinking text cursor. In this case, the values for CX\n and DX identify the shape of the mouse cursor, as used in of\n INT 10H 10H.\n\n CX is the starting scan line (0 means the topmost line of the\n character cell) and DX is the ending scan line. The maximum\n valid value for DX depends upon the current screen mode and video\n adapter type:\n\n CGA scan line range is 0 to 7\n MDPA scan line range is 0 to 13\n EGA scan line range is 0 to 13\n VGA scan line range is 0 to 15\n\n Note that EGA and VGA may be in a mode which has fewer (or even\n more) scan lines per character cell (e.g., in 43-line mode,\n characters have 8 scan lines).\n\n Also note that it is valid to set DX to a larger value than CX.\n In that case, the cursor may be shown in two parts with a gap in\n the middle. The cursor blinks, regardless of what your do.\n\nSee Also: INT 33H: Mouse Support\n Interrupts and BIOS Services\n -♦-"
  },
  {
    "id": "844-int_33h_000bh__query_motion_distance.html",
    "t": "INT 33H 000bH: Query Motion Distance",
    "b": "Expects: AX 000bH\n ──────────────────────────────────────────────────────────────────\n Returns: CX Horizontal motion since last call (>0=right; <0=left)\n DX Vertical motion since last call (>0=down; <0=upward)\n ──────────────────────────────────────────────────────────────────\n Info: This obtains the distance the mouse has been moved since the most\n recent call to this function. The returned values are in units\n called mickeys. To convert to pixels, use INT 33H 001bH to query\n the current mickeys-to-pixel ratios).\n\n Note that CX and DX return as signed values, with negative\n numbers being a distance upward and to the left and positive\n values being motion downward and to the right.\n\nSee Also: INT 33H: Mouse Support\n Interrupts and BIOS Services\n -♦-"
  },
  {
    "id": "845-int_33h_000ch__set_mouse_event_handler.html",
    "t": "INT 33H 000cH: Set Mouse Event Handler",
    "b": "Expects: AX 000cH\n CX event mask (events which you want sent to your handler)\n bit 0 = mouse movement (CX | 01H)\n bit 1 = left button pressed (CX | 02H)\n bit 2 = left button released (CX | 04H)\n bit 3 = right button pressed (CX | 08H)\n bit 4 = right button released (CX | 10H)\n bit 5 = center button pressed (CX | 20H)\n bit 6 = center button released (CX | 40H)\n All events: CX = 007fH\n Disable handler: CX = 0000H\n ES:DX address of your event handler code\n ──────────────────────────────────────────────────────────────────\n Returns: none\n ──────────────────────────────────────────────────────────────────\n Info: This installs a custom mouse event handler. Specify which events\n you want to monitor via bit-codes in CX, and pass the address of\n your handler in ES:DX. When any of the specified events occur,\n the code at ES:DX will get control via a far CALL.\n\n On entry to your handler:\n AX contains a bit mask identifying which event has occurred (it is\n encoded in the same format as described for CX, above).\n\n BX contains the mouse button status:\n bit 0 = left button (BX & 1) == 1\n bit 1 = right button (BX & 2) == 2\n bit 2 = center button (BX & 4) == 4\n\n CX horizontal position (in text mode, divide by 8 for character clm)\n DX vertical position (in text mode, divide by 8 for character line)\n\n SI distance of last horizontal motion (mickeys: <0=left; >0=right)\n DI distance of last vertical motion (mickeys: <0=upward, >0=down)\n\n DS mouse driver data segment\n You will need to set up DS to access your own variables. You\n need not save/restore CPU registers, since the driver does this\n for you.\n\n Exit your custom handler via a FAR RETurn (not an IRET).\n\n To enable or disable selected events for your handler, use this\n function again, passing a modified mask in CX. To disable all\n events for the handler, call this function again passing a value\n of 0000H in CX.\n\n Warning: You must disable your custom event handler (call with CX=0)\n before exiting to DOS. For TSRs, you must enable each time you\n pop up and disable each time you pop down.\n\n Notes: You may prefer to use the more-flexible INT 33H 0014H (exchange\n handlers) or INT 33H 0018H (install mouse+key handler).\n\nSee Also: INT 33H: Mouse Support\n Interrupts and BIOS Services\n -♦-"
  },
  {
    "id": "846-int_33h_000dh__enable_lightpen_emulation.html",
    "t": "INT 33H 000dH: Enable Lightpen Emulation",
    "b": "Expects: AX 000dH\n ──────────────────────────────────────────────────────────────────\n Returns: none\n ──────────────────────────────────────────────────────────────────\n Info: This causes the mouse support to work with programs which are\n written to support a light pen (e.g., using the PEN function on\n BASIC). The mouse support apparently intercepts INT 10H 04H when\n this feature is enabled.\n\n When enabled, a click of either button is taken as a press of the\n pen button at current mouse position.\n\n Disable this support via INT 33H 000eH.\n\nSee Also: INT 33H: Mouse Support\n Interrupts and BIOS Services\n -♦-"
  },
  {
    "id": "847-int_33h_000eh__disable_lightpen_emulation.html",
    "t": "INT 33H 000eH: Disable Lightpen Emulation",
    "b": "Expects: AX 000eH\n ──────────────────────────────────────────────────────────────────\n Returns: none\n ──────────────────────────────────────────────────────────────────\n Info: This tells the mouse support to stop emulating a light pen. You\n would use this to keep the mouse movement from interfering with\n the operation of an attached light pen.\n\n When enabled via INT 33H 000dH, the mouse support apparently\n intercepts INT 10H 04H.\n\nSee Also: INT 33H: Mouse Support\n Interrupts and BIOS Services\n -♦-"
  },
  {
    "id": "848-int_33h_000fh__set_pointer_speed.html",
    "t": "INT 33H 000fH: Set Pointer Speed",
    "b": "Expects: AX 000fH\n CX desired horizontal mickeys per 8 pixels\n DX desired vertical mickeys per 8 pixels\n ──────────────────────────────────────────────────────────────────\n Returns: none\n ──────────────────────────────────────────────────────────────────\n Info: This sets the base speed at which the pointer moves around the\n screen, compared to the distance actually moved by the mouse.\n\n The mickey-to-pixel ratio is used to convert distance values,\n such as INT 33H 000bH and values obtained in SI and DI by custom\n event handlers (see INT 33H 000cH), to pixels or character cells.\n\n The pointer may actually move much farther/faster than the\n base speed specified in this call. When the mouse is moved\n quickly, the mouse support automatically doubles the ratio\n (moving the pointer exponentially more quickly). See\n INT 33H 0013H.\n\n 1 mickey = 1/200th of an inch = 0.005 inch.\n\n Note that the values for CX and DX are in character cells\n (8-pixel units). The default settings are CX=8 and DX=16. This\n means that the pointer moves twice as fast horizontally as it\n does vertically. It also means that a slow, steady 1-inch mouse\n motion moves the pointer by 25 characters horizontally or 12\n vertical lines. The calculation goes as follows:\n\n desiredCharsPerInch = 200 / CX\n ...so...\n CX = 200 / desiredCharsPerInch (thus, CX=8 moves 25 chars)\n\n For graphics mode (i.e., pixel measurements) use:\n\n CX = 25 / desiredPixelsPerInch (thus, CX=8 moves 200 pixels)\n\n Notes: INT 33H 001aH is an updated version of this call and\n INT 33H 001bH provides a way to query the current settings.\n\nSee Also: INT 33H: Mouse Support\n Interrupts and BIOS Services\n -♦-"
  },
  {
    "id": "849-int_33h_0010h__set_exclusion_area.html",
    "t": "INT 33H 0010H: Set Exclusion Area",
    "b": "Expects: AX 0010H\n CX (X1) leftmost coordinate of exclusion rectangle (pixel)\n DX (Y1) top coordinate of exclusion rectangle (pixel)\n SI (X2) rightmost coordinate of exclusion rectangle (pixel)\n DI (Y2) bottom coordinate of exclusion rectangle (pixel)\n ──────────────────────────────────────────────────────────────────\n Returns: none\n ──────────────────────────────────────────────────────────────────\n Info: This sets a rectangle in which the mouse pointer will be hidden.\n\n Unlike the limit range set by INT 33H 0007H and INT 33H 0008H,\n the mouse may be moved into and out of the exclusion area, but it\n will be hidden whenever there.\n\n Avoid using this unless you immediately present some other sort\n of screen-position indicator (such as a text cursor). You don't\n want the user saying \"Where did my mouse go?\"\n\n Note that all X,Y coordinates are virtual coordinates and when\n working with text mode, you must divide each value by 8 to get a\n character clm,row.\n\n Notes: ■ The exclusion area gets reset on each call to INT 33H 0001H\n (show pointer) and to INT 33H 0000H (reset).\n\n ■ All X,Y coordinates are virtual coordinates and when working\n with text mode, you must divide each value by 8 to get a\n character clm,row.\n\nSee Also: INT 33H: Mouse Support\n Interrupts and BIOS Services\n -♦-"
  },
  {
    "id": "850-int_33h_0013h__set_speed_doubling_threshold.html",
    "t": "INT 33H 0013H: Set Speed-Doubling Threshold",
    "b": "Expects: AX 0013H\n DX doubling limit, in mickeys-per-second\n ──────────────────────────────────────────────────────────────────\n Returns: none\n ──────────────────────────────────────────────────────────────────\n Info: When the mouse is moved quickly, the mouse support doubles the\n distance of the motion of the pointer. This makes it possible to\n use slow, fine motions for detail work without sacrificing speedy\n motion to move quickly across the screen.\n\n By default, if the mouse moves 64 mickeys per second (about 1/3rd\n inch per second), the mouse support doubles the pointer motion.\n If you prefer more acceleration, use values smaller than 64 in\n DX. For less acceleration, use larger values. To effectively\n eliminate this speed-doubling, use a large values, such as 10,000\n in DX.\n\n You can also set this threshold via INT 33H 001aH and query its\n current value via INT 33H 001bH.\n\nSee Also: INT 33H: Mouse Support\n Interrupts and BIOS Services\n -♦-"
  },
  {
    "id": "851-int_33h_0014h__exchange_mouse_event_handler.html",
    "t": "INT 33H 0014H: Exchange Mouse Event Handler",
    "b": "Expects: AX 0014H\n CX event mask (events which you want sent to your handler)\n bit 0 = mouse movement (CX | 01H)\n bit 1 = left button pressed (CX | 02H)\n bit 2 = left button released (CX | 04H)\n bit 3 = right button pressed (CX | 08H)\n bit 4 = right button released (CX | 10H)\n bit 5 = center button pressed (CX | 20H)\n bit 6 = center button released (CX | 40H)\n All events: CX = 007fH\n ES:DX address of your event handler code\n ──────────────────────────────────────────────────────────────────\n Returns: CX event mask of previous event handler\n ES:DX address of the previously-installed event handler code\n ──────────────────────────────────────────────────────────────────\n Info: This function works like INT 33H 000cH (which see for details).\n The only difference is that upon return, you obtain the address\n and event mask of the previously-installed event handler.\n\n This provides a way to install an event handler temporarily; that\n is, you can install one while performing a certain subroutine,\n then restore the previous one when you exit that subroutine.\n\n This also provides a way to chain event handlers. Install a\n handler for all events, and if you get an event which you don't\n really care about, pass it on to the previously-installed handler\n (assuming its event mask shows that it expects the event).\n\n Notes: INT 33H 0018H provides a flexible means for installing up to\n three specialized-event handlers.\n\nSee Also: INT 33H: Mouse Support\n Interrupts and BIOS Services\n -♦-"
  },
  {
    "id": "852-int_33h_0015h__query_size_of_mouse_status_buffer.html",
    "t": "INT 33H 0015H: Query Size of Mouse Status Buffer",
    "b": "Expects: AX 0015H\n ──────────────────────────────────────────────────────────────────\n Returns: BX size of buffer needed in INT 33H 0016H (save mouse status)\n ──────────────────────────────────────────────────────────────────\n Info: Use this function before calling INT 33H 0016H. It returns the\n size of the status-saving buffer you will need in that call.\n\nSee Also: INT 33H: Mouse Support\n Interrupts and BIOS Services\n -♦-"
  },
  {
    "id": "853-int_33h_0016h__save_mouse_status.html",
    "t": "INT 33H 0016H: Save Mouse Status",
    "b": "Expects: AX 0016H\n ES:DX address of mouse buffer to hold mouse status info\n ──────────────────────────────────────────────────────────────────\n Returns: ES:DX buffer contains data\n ──────────────────────────────────────────────────────────────────\n Info: This function loads the current set of mouse-support variables\n into a caller-supplied data area. Use this call to save the\n state of the mouse in case you might need to restore it at a\n later time (e.g., upon popping up as a TSR or upon return of\n control after using DOS Fn 4b00H EXEC).\n\n Warning: Use INT 33H 0015H to obtain the size of the buffer to be passed\n in this call. You must provide enough storage or the mouse\n support may overwrite important program variables or code.\n\n Notes: ■ The mouse-state buffer layout is not documented.\n\n ■ This fn is not supported by some non-Microsoft drivers,\n including some which claim full Microsoft compatibility.\n\nSee Also: INT 33H: Mouse Support\n Interrupts and BIOS Services\n -♦-"
  },
  {
    "id": "854-int_33h_0017h__restore_mouse_status.html",
    "t": "INT 33H 0017H: Restore Mouse Status",
    "b": "Expects: AX 0017H\n ES:DX address of buffer containing saved mouse status\n ──────────────────────────────────────────────────────────────────\n Returns: none\n ──────────────────────────────────────────────────────────────────\n Info: Use this function to restore mouse-driver status information\n which you obtained via a previous call to INT 33H 0016H (e.g.,\n when your TSR program is about to return control to an\n interrupted program or you get control back from a child process\n after using DOS Fn 4b00H EXEC).\n\n The buffer at ES:DX should contain data obtained via\n INT 33H 0016H (the buffer layout is not documented) and it\n should be the size returned by INT 33H 0015H.\n\nSee Also: INT 33H: Mouse Support\n Interrupts and BIOS Services\n -♦-"
  },
  {
    "id": "855-int_33h_0018h__set_alternate_event_handler.html",
    "t": "INT 33H 0018H: Set Alternate Event Handler",
    "b": "Expects: AX 0018H\n CX event mask (events which you want sent to your handler)\n bit 0 = mouse movement (CX | 01H)\n bit 1 = left button pressed (CX | 02H)\n bit 2 = left button released (CX | 04H)\n bit 3 = right button pressed (CX | 08H)\n bit 4 = right button released (CX | 10H)\n bit 5 = Shift down when button pressed (CX | 20H)\n bit 6 = Ctrl down when button pressed (CX | 40H)\n bit 7 = Alt down when button pressed (CX | 80H)\n CX = 00ffH = handle all events\n CX = 0000H = disable handler\n ES:DX address of your event handler code\n ──────────────────────────────────────────────────────────────────\n Returns: AX installation status: 0018H = installed\n ffffH = Error: can't install\n ──────────────────────────────────────────────────────────────────\n Info: This function is the more elegant version of INT 33H 000cH (which\n see for specs on the custom handler code).\n\n This function will inform your handler when a Shift-, Ctrl-, or\n Alt- key was down when a mouse button was pressed. It also\n allows you to install up to three separate event handlers,\n provided that each has a different event mask in CX.\n\n Bits 5, 6, and 7 specify the shift keys of interest. If you\n don't require this information, you may use INT 33H 000cH or\n INT 33H 0014H instead.\n\n If an event handler for the specified event mask (in CX) already\n exists, an error is returned (AX=ffffH upon return). In that\n case, you may use INT 33H 0019H to obtain the address of the\n previous handler. You may de-install that handler, install your\n own, then re-install the old one later.\n\n To de-install an alternate event handler, call this function with\n the address of the handler and 0's in relevant bits of the event\n mask. You should de-install event handlers before exiting your\n program.\n\nSee Also: INT 33H: Mouse Support\n Interrupts and BIOS Services\n -♦-"
  },
  {
    "id": "856-int_33h_0019h__query_user_alternate_event_handler.html",
    "t": "INT 33H 0019H: Query User Alternate Event Handler",
    "b": "Expects: AX 0019H\n CX event mask of desired handler (as used in INT 33H 0018H)\n ──────────────────────────────────────────────────────────────────\n Returns: CX event mask of handler or...\n 0000H = no handler matches\n ES:DX address of matching event handler\n ──────────────────────────────────────────────────────────────────\n Info: Use this function to obtain the address and mask of an alternate\n event handler installed via INT 33H 0018H (which see for the bit\n values for CX).\n\nSee Also: INT 33H: Mouse Support\n Interrupts and BIOS Services\n -♦-"
  },
  {
    "id": "857-int_33h_001ah__set_mouse_sensitivity.html",
    "t": "INT 33H 001aH: Set Mouse Sensitivity",
    "b": "Expects: AX 001aH\n BX horizontal speed, in mickeys-per-pixel\n CX vertical speed, in mickeys-per-pixel\n DX speed-doubling threshold, in mickeys-per-second\n ──────────────────────────────────────────────────────────────────\n Returns: none\n ──────────────────────────────────────────────────────────────────\n Info: This combines the functionality of INT 33H 000fH (set speed) and\n INT 33H 0013H (set doubling threshold).\n\n Use INT 33H 001bH to obtain the current values of these\n variables.\n\nSee Also: INT 33H: Mouse Support\n Interrupts and BIOS Services\n -♦-"
  },
  {
    "id": "858-int_33h_001bh__query_mouse_sensitivity.html",
    "t": "INT 33H 001bH: Query Mouse Sensitivity",
    "b": "Expects: AX 001bH\n ──────────────────────────────────────────────────────────────────\n Returns: BX horizontal speed, in mickeys-per-pixel\n CX vertical speed, in mickeys-per-pixel\n DX speed-doubling threshold, in mickeys-per-second\n ──────────────────────────────────────────────────────────────────\n Info: This obtains the current mouse motion-to-pointer motion\n variables. See INT 33H 000fH and INT 33H 0013H for details.\n\n You may use this function, tweak one or more variables, then call\n INT 33H 001aH to install the modifications.\n\nSee Also: INT 33H: Mouse Support\n Interrupts and BIOS Services\n -♦-"
  },
  {
    "id": "859-int_33h_001ch__set_inport_mouse_interrupt_rate.html",
    "t": "INT 33H 001cH: Set Inport Mouse Interrupt Rate",
    "b": "Expects: AX 001cH\n BX interrupt rate code: 1=none; 2=30 per sec, 4=50 per sec\n 8=100 per sec; 16=200 per second\n ──────────────────────────────────────────────────────────────────\n Returns: none\n ──────────────────────────────────────────────────────────────────\n Info: This sets the rate at which the mouse hardware will interrupt\n with updated mouse positions and status.\n\n This call is only meaningful for the Inport mouse. Use\n INT 33H 0024H to see if an Inport mouse is installed.\n\n Increasing the number of interrupts per second provides more\n accuracy for the mouse, but makes the foreground application slow\n down.\n\nSee Also: INT 33H: Mouse Support\n Interrupts and BIOS Services\n -♦-"
  },
  {
    "id": "860-int_33h_001dh__set_mouse_display_page.html",
    "t": "INT 33H 001dH: Set Mouse Display Page",
    "b": "Expects: AX 001dH\n BX video page number to use for displaying the mouse pointer\n ──────────────────────────────────────────────────────────────────\n Returns: none\n ──────────────────────────────────────────────────────────────────\n Info: This tells the mouse support which video page to display the\n mouse pointer. By default, the pointer is displayed on page 0.\n\n INT 33H 001eH returns the current video page used by the mouse\n support.\n\n This fn does not activate the specified video page. Use\n INT 10H 05H to do that. Use INT 10H 0fH to see which video page\n is currently active.\n\nSee Also: INT 33H: Mouse Support\n Interrupts and BIOS Services\n -♦-"
  },
  {
    "id": "861-int_33h_001eh__query_mouse_display_page.html",
    "t": "INT 33H 001eH: Query Mouse Display Page",
    "b": "Expects: AX 001eH\n ──────────────────────────────────────────────────────────────────\n Returns: BX video page upon which the mouse is displayed\n ──────────────────────────────────────────────────────────────────\n Info: This returns the video page number upon which the mouse support\n is currently displaying the mouse pointer.\n\n This does not tell you which video page is currently active. Use\n INT 10H 0fH to learn that. Use INT 10H 05H to activate a\n particular video page.\n\nSee Also: INT 33H: Mouse Support\n Interrupts and BIOS Services\n -♦-"
  },
  {
    "id": "862-int_33h_001fh__deactivate_mouse_driver.html",
    "t": "INT 33H 001fH: Deactivate Mouse Driver",
    "b": "Expects: AX 001fH\n ──────────────────────────────────────────────────────────────────\n Returns: AX status: 001fH=deactivated OK\n ffffH=can't deactivate\n ES:DX address of previous INT 33H handler\n ──────────────────────────────────────────────────────────────────\n Info: This deactivates the mouse driver. All interrupts used by the\n mouse support are disabled, effectively eliminating all mouse\n support.\n\n Use INT 33H 0021H to re-enable all interrupts used by the mouse\n support.\n\n Note that the INT 33H vector remains in place, but the only\n function it can perform is INT 33H 0021H (to re-enable).\n\n You might call this just before replacing the mouse support with\n your own system of interrupts and kludges. Then use the return\n value in ES:DX to reinstall the previous INT 33H code at some\n later time (i.e., when you exit to DOS).\n\nSee Also: INT 33H: Mouse Support\n Interrupts and BIOS Services\n -♦-"
  },
  {
    "id": "863-int_33h_0020h__reenable_mouse_driver.html",
    "t": "INT 33H 0020H: Reenable Mouse Driver",
    "b": "Expects: AX 0020H\n ──────────────────────────────────────────────────────────────────\n Returns: none\n ──────────────────────────────────────────────────────────────────\n Info: This reestablishes the connection between the mouse hardware and\n the mouse support. It re-installs all interrupts that were\n removed via a previous call to INT 33H 001fH.\n\nSee Also: INT 33H: Mouse Support\n Interrupts and BIOS Services\n -♦-"
  },
  {
    "id": "864-int_33h_0021h__reset_mouse_driver.html",
    "t": "INT 33H 0021H: Reset Mouse Driver",
    "b": "Expects: AX 0021H\n ──────────────────────────────────────────────────────────────────\n Returns: AX status: 0021H=success\n ffffH=can't reset (no driver)\n BX number of mouse buttons\n ──────────────────────────────────────────────────────────────────\n Info: This performs a \"software reset\" of the mouse support. It sets\n all internal variables to their standard defaults, as described\n under INT 33H 0000H.\n\n This works like INT 33H 0000H except that it does not perform a\n reset of the mouse hardware or of any hardware-related variables\n (some older mouse hardware takes several seconds to reset).\n\nSee Also: INT 33H: Mouse Support\n Interrupts and BIOS Services\n -♦-"
  },
  {
    "id": "865-int_33h_0024h__query_mouse_type_driver_version_irq_.html",
    "t": "INT 33H 0024H: Query Mouse Type/Driver Version/IRQ#",
    "b": "Expects: AX 0024H\n ──────────────────────────────────────────────────────────────────\n Returns: BH major version number\n BL minor version number (i.e., left of decimal)\n CH mouse type: 1 = bus mouse\n 2 = serial mouse\n 3 = Inport mouse\n 4 = PS/2 mouse\n 5 = HP mouse\n CL IRQ number:\n 0 = PS/2\n 2,3,4,5, or 7 = PC IRQ number\n ──────────────────────────────────────────────────────────────────\n Info: If you need to use new functions of a recent version of the mouse\n support, use this function and inspect the return values in BH\n and BL.\n\n The value in CH can be used to see if calls to INT 33H 001cH are\n meaningful.\n\nSee Also: INT 33H: Mouse Support\n Interrupts and BIOS Services\n -♦-"
  },
  {
    "id": "866-8088_286_386_486_pentium_instruction_set.html",
    "t": "8088/286/386/486/Pentium Instruction Set",
    "b": "Instruction Set Matrix\n Secondary Opcode Space\n\n Alphabetical List of Opcodes (except floating point)\n\n Functional Groups: Arithmetic / Logic\n\n Data Transfer\n\n Execution Control\n\n Processor Control\n\n Protection Control (80286)\n\n String Operation\n\n 386/486/Pentium-specific Opcodes (80386/486/Pentium)\n\n 80x87 Floating Point Opcodes (8087,287,387,486+)"
  },
  {
    "id": "867-instruction_set_matrix.html",
    "t": "Instruction Set Matrix",
    "b": "* indicates 286+ only (not available in 8088/8086).\n Φ indicates 386 and/or 486 and/or Pentium\n ╔════════╤════════╤════════╤════════╤════════╤════════╤════════╤════════╕\n ║ x0 │ x1 │ x2 │ x3 │ x4 │ x5 │ x6 │ x7 │\n ══╬════════╪════════╪════════╪════════╪════════╪════════╪════════╪════════╡\n 0x║ ADD │ ADD │ ADD │ ADD │ ADD │ ADD │ PUSH │ POP │\n ║ r/m,r8 │r/m,r16 │ r8,r/m │r16,r/m │ AL,im8 │AX,im16 │ ES │ ES │\n ──╫────────┼────────┼────────┼────────┼────────┼────────┼────────┼────────┤\n 1x║ ADC │ ADC │ ADC │ ADC │ ADC │ ADC │ PUSH │ POP │\n ║ r/m,r8 │r/m,r16 │ r8,r/m │r16,r/m │ AL,im8 │AX,im16 │ SS │ SS │\n ──╫────────┼────────┼────────┼────────┼────────┼────────┼────────┼────────┤\n 2x║ AND │ AND │ AND │ AND │ AND │ AND │ SEG │ DAA │\n ║ r/m,r8 │r/m,r16 │ r8,r/m │r16,r/m │ AL,im8 │AX,im16 │ ES │ │\n ──╫────────┼────────┼────────┼────────┼────────┼────────┼────────┼────────┤\n 3x║ XOR │ XOR │ XOR │ XOR │ XOR │ XOR │ SEG │ AAA │\n ║ r/m,r8 │r/m,r16 │ r8,r/m │r16,r/m │ AL,im8 │AX,im16 │ SS │ │\n ──╫────────┼────────┼────────┼────────┼────────┼────────┼────────┼────────┤\n 4x║ INC │ INC │ INC │ INC │ INC │ INC │ INC │ INC │\n ║ AX │ CX │ DX │ BX │ SP │ BP │ SI │ DI │\n ──╫────────┼────────┼────────┼────────┼────────┼────────┼────────┼────────┤\n 5x║ PUSH │ PUSH │ PUSH │ PUSH │ PUSH │PUSH │ PUSH │ PUSH │\n ║ AX │ CX │ DX │ BX │ SP │BP │ SI │ DI │\n ──╫────────┼────────┼────────┼────────┼────────┼────────┼────────┼────────┤\n 6x║ * PUSHA│ * POPA │ * BOUND│ ARPL │Φ SEG FS│Φ SEG GS│ΦopSize │ΦaddrSiz│\n ║ │ │ │ │ │ │ prefix │ prefix │\n ──╫────────┼────────┼────────┼────────┼────────┼────────┼────────┼────────┤\n 7x║ JO │ JNO │ JB/ │ JNB/ │ JE/ │ JNE/ │ JBE/ │ JNBE/ │\n ║ │ │ JNAE │ JAE │ JZ │ JNZ │ JNA │ JA │\n ──╫────────┼────────┼────────┼────────┼────────┼────────┼────────┼────────┤\n 8x║ ArOp1 │ ArOp1 │ ArOp2 │ ArOp2 │ TEST │ TEST │ XCHG │ XCHG │\n ║r/m,im8 │r/m,im16│r/m8,im8│rm16,im8│r/m,r8 │r/m,r16 │r8,r/m │r16,r/m │\n ──╫────────┼────────┼────────┼────────┼────────┼────────┼────────┼────────┤\n 9x║ NOP │ XCHG │ XCHG │ XCHG │ XCHG │ XCHG │ XCHG │ XCHG │\n ║ │ AX,CX │ AX,DX │ AX,BX │ AX,SP │ AX,BP │ AX,SI │ AX,DI │\n ──╫────────┼────────┼────────┼────────┼────────┼────────┼────────┼────────┤\n Ax║ MOV │ MOV │ MOV │ MOV │ MOVSB │ MOVSW │ CMPSB │ CMPSW │\n ║AL,mem8 │AX,mem16│mem8,AL │mem16,AX│ │ │ │ │\n ──╫────────┼────────┼────────┼────────┼────────┼────────┼────────┼────────┤\n Bx║ MOV │ MOV │ MOV │ MOV │ MOV │ MOV │ MOV │ MOV │\n ║ AL,im8 │ CL,im8 │ DL,im8 │ BL,im8 │ AH,im8 │ CH,im8 │ DH,im8 │ BH,im8 │\n ──╫────────┼────────┼────────┼────────┼────────┼────────┼────────┼────────┤\n Cx║* ShfOp │* ShfOp │RET near│RET near│ LES │ LDS │ MOV │ MOV │\n ║r/m8,imm│r/m16,im│ ±im16 │ │r16,mem │r16,mem │mem,im8 │mem,im16│\n ──╫────────┼────────┼────────┼────────┼────────┼────────┼────────┼────────┤\n Dx║ ShfOp │ ShfOp │ ShfOp │ ShfOp │ AAM │ AAD │ │ XLAT │\n ║r/m8,1 │r/m16,1 │r/m8,CL │r/m16,CL│ │ │ │ │\n ──╫────────┼────────┼────────┼────────┼────────┼────────┼────────┼────────┤\n Ex║ LOOPNE/│ LOOPE/ │ LOOP │ JCXZ │ IN │ IN │ OUT │ OUT │\n ║ LOOPNZ │ LOOPZ │ │ΦJECXZ │AL,port8│AX,port8│AL,port8│AX,port8│\n ──╫────────┼────────┼────────┼────────┼────────┼────────┼────────┼────────┤\n Fx║ LOCK │ │ REP/ │ REPZ/ │ HALT │ CMC │ Grp1 │ Grp1 │\n ║ │ │ REPNE │ REPE │ │ │r/m8 │r/m16 │\n ══╬════════╪════════╪════════╪════════╪════════╪════════╪════════╪════════╡\n ║ x0 │ x1 │ x2 │ x3 │ x4 │ x5 │ x6 │ x7 │\n ╚════════╧════════╧════════╧════════╧════════╧════════╧════════╧════════╛\n ╔════════╤════════╤════════╤════════╤════════╤════════╤════════╤════════╕\n ║ x8 │ x9 │ xA │ xB │ xC │ xD │ xE │ xF │\n ══╬════════╪════════╪════════╪════════╪════════╪════════╪════════╪════════╡\n 0x║ OR │ OR │ OR │ OR │ OR │ OR │ PUSH │Φ*Extnsn│\n ║ r/m,r8 │r/m,r16 │ r8,r/m │r16,r/m │ AL,im8 │AX,im16 │ CS │ OpCode │\n ──╫────────┼────────┼────────┼────────┼────────┼────────┼────────┼────────┤\n 1x║ SBB │ SBB │ SBB │ SBB │ SBB │ SBB │ PUSH │ POP │\n ║ r/m,r8 │r/m,r16 │ r8,r/m │r16,r/m │ AL,im8 │AX,im16 │ DS │ DS │\n ──╫────────┼────────┼────────┼────────┼────────┼────────┼────────┼────────┤\n 2x║ SUB │ SUB │ SUB │ SUB │ SUB │ SUB │ SEG │ DAS │\n ║ r/m,r8 │r/m,r16 │ r8,r/m │r16,r/m │ AL,im8 │AX,im16 │ CS │ │\n ──╫────────┼────────┼────────┼────────┼────────┼────────┼────────┼────────┤\n 3x║ CMP │ CMP │ CMP │ CMP │ CMP │ CMP │ SEG │ AAS │\n ║ r/m,r8 │r/m,r16 │ r8,r/m │r16,r/m │ AL,im8 │AX,im16 │ DS │ │\n ──╫────────┼────────┼────────┼────────┼────────┼────────┼────────┼────────┤\n 4x║ DEC │ DEC │ DEC │ DEC │ DEC │ DEC │ DEC │ DEC │\n ║ AX │ CX │ DX │ BX │ SP │ BP │ SI │ DI │\n ──╫────────┼────────┼────────┼────────┼────────┼────────┼────────┼────────┤\n 5x║ POP │ POP │ POP │ POP │ POP │POP │ POP │ POP │\n ║ AX │ CX │ DX │ BX │ SP │BP │ SI │ DI │\n ──╫────────┼────────┼────────┼────────┼────────┼────────┼────────┼────────┤\n 6x║ * PUSH │ * IMUL │ * PUSH │ * IMUL │ * INSB │ * INSW │* OUTSB │* OUTSW │\n ║ imm16 │r/m,im16│ imm8 │r/m,im8 │ │ │ │ │\n ──╫────────┼────────┼────────┼────────┼────────┼────────┼────────┼────────┤\n 7x║ JS │ JNS │ JP/ │ JNP/ │ JL/ │ JNL/ │ JLE/ │ JNLE/ │\n ║ │ │ JPE │ JPO │ JNG │ JGE │ JNG │ JG │\n ──╫────────┼────────┼────────┼────────┼────────┼────────┼────────┼────────┤\n 8x║ MOV │ MOV │ MOV │ MOV │ MOV │ LEA │ MOV │ POP │\n ║r/m,r8 │r/m,r16 │r8,r/m │r16,r/m │r/m,seg │r16,mem │seg,r/m │ r/m │\n ──╫────────┼────────┼────────┼────────┼────────┼────────┼────────┼────────┤\n 9x║ CBW │ CWD │ CALL │ WAIT │ PUSHF │ POPF │ SAHF │ LAHF │\n ║ │ │ far │ │ │ │ │ │\n ──╫────────┼────────┼────────┼────────┼────────┼────────┼────────┼────────┤\n Ax║ TEST │ TEST │ STOSB │ STOSW │ LODSB │ LODSW │ SCASB │ SCASW │\n ║AL,mem8 │AX,mem16│ │ │ │ │ │ │\n ──╫────────┼────────┼────────┼────────┼────────┼────────┼────────┼────────┤\n Bx║ MOV │ MOV │ MOV │ MOV │ MOV │ MOV │ MOV │ MOV │\n ║AX,im16 │CX,im16 │DX,im16 │BX,im16 │SP,im16 │BP,im16 │SI,im16 │DI,im16 │\n ──╫────────┼────────┼────────┼────────┼────────┼────────┼────────┼────────┤\n Cx║* ENTER │* LEAVE │RET far │RET far │ INT 3 │ INT │ INTO │ IRET │\n ║im16,im8│ │ ±im16 │ │ │ im8 │ │ │\n ──╫────────┼────────┼────────┼────────┼────────┼────────┼────────┼────────┤\n Dx║ ESC 0 │ ESC 1 │ ESC 2 │ ESC 3 │ ESC 4 │ ESC 5 │ ESC 6 │ ESC 7 │\n ║ 387/486│ 387/486│ 387/486│ 387/486│ 387/486│ 387/486│ 387/486│ 387/486│\n ──╫────────┼────────┼────────┼────────┼────────┼────────┼────────┼────────┤\n Ex║ CALL │ JMP │ JMP │ JMP │ IN │ IN │ OUT │ OUT │\n ║ near │ near │ far │ short │ AL,DX │ AX,DX │ AL,DX │ AX,DX │\n ──╫────────┼────────┼────────┼────────┼────────┼────────┼────────┼────────┤\n Fx║ CLC │ STC │ CLI │ STI │ CLD │ STD │ Grp2 │ Grp3 │\n ║ │ │ │ │ │ │ r/m8 │ r/m16 │\n ══╬════════╪════════╪════════╪════════╪════════╪════════╪════════╪════════╡\n ║ x8 │ x9 │ xA │ xB │ xC │ xD │ xE │ xF │\n ╚════════╧════════╧════════╧════════╧════════╧════════╧════════╧════════╛\n Instruction Set"
  },
  {
    "id": "868-secondary_opcode_space.html",
    "t": "Secondary Opcode Space",
    "b": "This table identifies operations for the instruction groups which contain\n the opcode in bits 3-5 of the second byte (normally the addressing mode\n byte).\n ╔═══════╤═══════╤═══════╤═══════╤═══════╤═══════╤═══════╤═══════╕\n ║md000rm│md001rm│md010rm│md011rm│md100rm│md101rm│md110rm│md111rm│\n ═══════╬═══════╪═══════╪═══════╪═══════╪═══════╪═══════╪═══════╪═══════╡\n ArOp1 ║ ADD │ OR │ ADC │ SBB │ AND │ SUB │ XOR │ CMP │\n ───────╫───────┼───────┼───────┼───────┼───────┼───────┼───────┼───────┤\n ArOp2 ║ ADD │ │ ADC │ SBB │ │ SUB │ │ CMP │\n ───────╫───────┼───────┼───────┼───────┼───────┼───────┼───────┼───────┤\n ShftOp ║ ROL │ ROR │ RCL │ RCR │SHL/SAL│ SHR │ │ RAR │\n ───────╫───────┼───────┼───────┼───────┼───────┼───────┼───────┼───────┤\n Grp1 ║ TEST │ │ NOT │ NEG │ MUL │ IMUL │ DIV │ IDIV │\n ───────╫───────┼───────┼───────┼───────┼───────┼───────┼───────┼───────┤\n Grp2 ║ INC │ DEC │CALL nr│CALL fr│JMP nr │JMP far│ PUSH │ │\n ───────╫───────┼───────┼───────┼───────┼───────┼───────┼───────┼───────┤\n Grp3 ║ INC │ DEC │ │ │ │ │ │ │\n ═══════╩═══════╧═══════╧═══════╧═══════╧═══════╧═══════╧═══════╧═══════╛\n Instruction Set Matrix Instruction Set"
  },
  {
    "id": "869-arithmetic_and_binary_logic_instructions.html",
    "t": "Arithmetic and Binary Logic Instructions",
    "b": "█▌Integer Math▐█\nADD dest,src add two operands, placing result in dest\n dest←(src + dest)\nADC dest,src add two operands, using carry from previous ADD\n dest←(src + dest + CF)\nINC dest add 1 to dest (reg or r/m)\n dest←(dest+1)\n\nSUB dest,src subtract src from dest, leaving result in dest\n dest←(dest - src)\nSBB dest,src subtract using borrow (carry flag) from previous SUB\n dest←((dest - src) - CF)\nDEC dest subtract 1 from dest (reg or r/m)\n dest←(dest - 1)\n\nCMP dest,src compare (non-destructive subtract)\n flags are set to indicate carry, overflow, etc.\n\nNEG dest change sign of an operand\n dest←(0 - dest);\n\nAAA adjust after ASCII addition\n AL←(AL corrected for ASCII addition)\nAAS adjust for ASCII subtraction\n AL←(AL corrected for ASCII subtraction)\nAAM adjust after ASCII multiply\n AH:AL←(AH:AL corrected for ASCII multiplication)\nAAD adjust before ASCII division\n AH:AL←(AH:AL prepared for division of ASCII codes)\n\nDAA adjust after BCD addition\n AL←(AL corrected for BCD addition)\nDAS adjust for BCD subtraction\n AL←(AL corrected for BCD subtraction)\n\nMUL src multiply AL(AX) by unsigned value src (reg/mem)\n AX←(AL * src8)\n DX:AX←(AX * src16)\nIMUL src multiply AL(AX) by signed integer src (reg/mem)\n AX←(AL * immed8)\n DX:AX←(AX * immed16)\nIMUL reg16,r/m,im16 multiply reg/mem by 16-bit immediate signed value 286+\n reg16←(r/m8 * im16)\n reg16←(r/m16 * im16)\n\nDIV src divide accumulator by unsigned value src (reg/mem)\n Division by 0 or result too large causes INT 0.\n AL←(AX ÷ src8); AH←(AX MOD src8)\n AX←(DX:AX ÷ src16); DX←(DX:AX MOD src16)\nIDIV src divide accumulator by unsigned value src (reg/mem)\n\nCBW convert byte to word (sign-extend AL into AH)\n AH←(filled with bit-7 of AL)\nCWD convert word to dword (sign-extend AX into DX)\n DX←(filled with bit-15 of AX)\n\n █▌Bitwise Logic▐█\nAND dest,src logical AND (mask; reset dest bits which are 0 in src)\n dest←(dest & src)\nTEST dest,src non-destructive AND (bit test; JZ jumps if no match)\n flags←(set as for dest & src)\n\nOR dest,src inclusive OR (set dest bits which are 1s in src)\n dest←(dest | src)\n\nXOR dest,src exclusive OR (toggle dest bits which are 1s in src)\n dest←(dest ^ src)\n\nNOT dest form 1's complement (toggle every bit in dest)\n dest←(~dest)\n\n █▌Shifts and Rotates▐█\nRCL dest Rotate dest left through Carry by 1 bit position\n dest,CL ...by CL bit positions\n dest,cnt ...by immediate count bit positions (mod 32) 386+\n\nRCR dest Rotate dest right through Carry by 1 bit position\n dest,CL ...by CL bit positions\n dest,cnt ...by immediate count bit positions (mod 32) 386+\n\nROL dest Rotate dest left by 1 bit position\n dest,CL ...by CL bit positions\n dest,cnt ...by immediate count bit positions (mod 32) 386+\n\nROR dest Rotate dest right by 1 bit position\n dest,CL ...by CL bit positions\n dest,cnt ...by immediate count bit positions (mod 32) 386+\n\nSHL/\n SAL dest Shift left by 1 bit position (multiply by 2)\n dest,CL ...by CL bit positions\n dest,cnt ...by immediate count bit positions (mod 32) 386+\n\nSHR dest Shift right by 1 position (divide by 2)\n dest,CL ...by CL bit positions\n dest,cnt ...by immediate count bit positions (mod 32) 386+\n\nSAR dest Shift arithmetic right (retain high bit) by 1 position\n dest,CL ...by CL bit positions\n dest,cnt ...by immediate count bit positions (mod 32) 386+\n────────────────────────────────────────────────────────────────────────────\n Instruction Set"
  },
  {
    "id": "870-data_transfer_instructions.html",
    "t": "Data Transfer Instructions",
    "b": "MOV dest,src transfer (copy) data to/from register, to/from memory\n dest←src\n\nXCHG dest,src exchange values of two registers or register and r/m\n dest ↔ src\n\nIN port8 (or DX) input to AL(or AX) from I/O port\n byte: AL←port\n word: AL←[port]; AH←[port+1]\n\nOUT port8 (or DX) output from AL(or AX) to I/O port\n byte: [port]←AL\n word: [port]←AL [port+1]←AH\n\nXLAT translate AL into a value in a translation table at BX\n AL←ES:[BX+(AL)]\n\nLEA reg16,addr load address into a register\n reg16←(result of EA calculation of addr offset)\n\nLDS reg16,mem load DS and reg16 from memory variable\n reg16←[mem16]; DS←[mem16+2]\nLES reg16,mem load ES and reg16 from memory variable\n reg16←[mem16]; ES←[mem16+2]\n\nLAHF load/convert flags into AH\nSAHF store/convert AH into flags\nPUSH src transfer reg16 or r/m16 to stack\n SP-=2; SS:[SP]←src\nPUSH immed transfer immed16 (or sign-extended immed8) to stack.\n SP-=2; SS:[SP]←immed16 286+\n\nPUSHA PUSH ALL: copy general registers to stack 286+\n SP-=10H; AX,BX,CX,DX,SI,DI,BP,SP saved on stack\n\nPUSHF PUSH Flags: transfer flags register to stack\n SP-=2; SS:[SP]←flags\n\nPOP dest transfer from stack to dest (reg16, r/m16, or segreg)\n dest←SS:[SP]; SP+=2\n\nPOPA POP All: copy general registers from stack 286+\n SP+=10H; AX,BX,CX,DX,SI,DI,BP restored from stack\n\nPOPF POP Flags: transfer from stack to flags register\n flags←SS:[SP]; SP+=2\n────────────────────────────────────────────────────────────────────────────\n String Operation Instructions Instruction Set"
  },
  {
    "id": "871-execution_control_instructions.html",
    "t": "Execution Control Instructions",
    "b": "JMP target unconditionally transfer control to target\n short: IP←(IP+(target displacement sign-extended))\n near: IP←(IP+(target displacement))\n indirect: IP←(register or value in memory)\n far: SS←target_seg; IP←target_offset\n\nJCXZ shortLbl jump if CX==0\n\nLOOP shortLbl CX←(CX-1) jump if CX!=0\nLOOPE/ shortLbl CX←(CX-1) jump if CX!=0 && ZF==ZR==1\n LOOPZ\nLOOPNE/ shortLbl CX←(CX-1) jump if CX!=0 && ZF==NZ==0\n LOOPNZ\n\nJccc shortLbl jump when condition ccc is met\n IP←(IP+(8-bit displacement sign-extended to 16 bits))\n\nJA/JNBE shortLbl jump if Above ((CF & ZF)==0 after unsigned math)\nJAE/JNB shortLbl jump if Above or Equal (CF==NC==0 after unsigned math)\nJB/JC shortLbl jump if Below/Jump if Carry set (CF==CY==1)\nJE/JZ shortLbl jump if Equal (ZF==ZR==1)\nJG/JNGE shortLbl jump if Greater (SF==(OF & ZF) after signed math)\nJGE/JNL shortLbl jump if Greater or Equal (SF==OF after signed math)\nJL/JNGE shortLbl jump if Less (ZF != OF after signed math)\nJLE/JNG shortLbl jump if Less or Equal (SF!=OF || ZF==0 after signed math)\nJNC shortLbl jump if carry not set (CF==NC==0) (same as JAE/JNB)\nJNE/JNZ shortLbl jump if Not Equal (ZF==NZ==0)\nJNO shortLbl jump if Not Overflow (OF==NO==0)\nJNP/JPO shortLbl jump if Parity Odd (PF==PO==0: count of 1-bits is ODD)\nJNS shortLbl jump if Not Sign (SF==PL==0: same as high-bit of dest)\nJO shortLbl jump if Overflow (OF==OV==1)\nJP/JPE shortLbl jump if Parity Even (PF==PE==1 count of 1-bits is EVEN)\nJS shortLbl jump if Sign (SF==NG==1: same as high-bit of dest)\n\nBOUND reg16,lmts perform limit-check on reg16. lmts is the address of\n a 2-word table with desired min/max limits 286+\n if (reg16<DS:[lmts]) or (reg16>DS:[lmts+2]) then INT 5\n\nENTER frmsiz,frms set high-level language stack frame. Use as the first\n operation in a CALLed procedure. Same as: 286+\n PUSH BP; (repeated frms times)\n MOV BP,SP;\n PUSH SP;\n SUB SP,frmsiz; (allocate dynamic space on stack)\n\nLEAVE undo the effect of ENTER. Use just before RET.\n Restores SP and BP to values at time of ENTER.\n\nINT type perform a software interrupt (call a system function)\n PUSHF; IF←0; TF←0;\n PUSH CS; PUSH IP\n IP← 0000:[type * 4]; CS ← 0000:[(type * 4) + 2]\n\nINTO type if OF==OV==1, then perform INT type\n\nIRET return from interrupt. Effectively the same as:\n POP IP; POP CS; POPF\n\nNOP do nothing (actually performs XCHG AX,AX)\n────────────────────────────────────────────────────────────────────────────\n Instruction Set"
  },
  {
    "id": "872-processor_control_instructions.html",
    "t": "Processor Control Instructions",
    "b": "CLC clear the carry flag to NC (CF←0)\nCMC complement (reverse the value of) the carry flag (CF←~CF)\nSTC set the carry flag to CY (CF←1)\nCLD clear direction flag to UP (string ops auto-increment) (DF←0)\nSTD set direction flag to DN (string ops auto-decrement) (DF←1)\nCLI disable maskable hardware interrupts (IF←0)\nSTI enable maskable hardware interrupts (IF←1)\n\nCTS/CLTS clear task switch flag. (TF←1) 286+\n\nHLT halt processing (perform NOPs until an interrupt occurs)\n\nWAIT/FWAIT wait for TEST line active (synchronize with coprocessor)\nLOCK (prefix) prevent coprocessor bus access for the next instruction\n prevents access only to mem affected by next opcode 386+\n\nSEG segreg (prefix) override default segreg for next EA calculation\n\n────────────────────────────────────────────────────────────────────────────\n Instruction Set"
  },
  {
    "id": "873-protection_control_instructions.html",
    "t": "Protection Control Instructions",
    "b": "All instructions on this page require 286 or higher CPU.\n\nLGDT src load Global Descriptor Table from 6-byte table at src\nSGDT dest store 6-byte Global Descriptor Table to memory at dest\n\nLIDT src load Interrupt Descriptor Table from 6-byte table at src\nSIDT dest store 6-byte Interrupt Descriptor Table to memory at dest\n\nLLDT src load Local Descriptor Table (GDT selector) from reg/mem16\nSLDT dest store Local Descriptor Table register into dest (r/m16)\n\nLMSW src load Machine Status Word (use to enter protected mode)\nSMSW src store Machine Status Word to reg/mem16\n\nLTR src load Task Register (GDT selector) from reg/mem16\nSTR dest store Task Register to reg/mem16\n\nLAR dest,src load high-byte of dest with Access Rights of src descriptor\n\nLSL dest,src load dest with Segment Limit of descriptor named by src\n\nARPL lvl Adjust Requested Privilege Level to higher of current or lvl\n\nVERR seg Sets ZF to ZR if task has read privileges for segment seg\n\nVERW seg Sets ZF to ZR if task has write privileges for segment seg\n────────────────────────────────────────────────────────────────────────────\n Instruction Set"
  },
  {
    "id": "874-386_486_pentium_specific_opcodes.html",
    "t": "386/486/Pentium-specific Opcodes",
    "b": "Opcodes on this page are supported by 386+. Opcodes for 486+ and Pentium are\nflagged.\n\n Note: On 386+ computers, the \"word size\" can be 32 bits instead of 16\n bits. This affects many opcopdes includng String Operations. In\n real mode, 16-bit registers and address operands are the default.\n In protected mode, the descriptor for CS indicates the default.\n At any time you can use a SIZ or ADDRSIZ prefix to toggle from\n the default to the other mode for the next operation.\n\nSIZ (prefix; 66H) next data reference is non-default size\nADDRSIZ (prefix; 67H) next address reference is non-default size\n\nBSF reg,src Bit Scan Forward. Put index of next 1-bit of src into reg\nBSR reg,src Bit Scan Reverse. Put index of prev 1-bit of src into reg\n (both: ZF is set and reg←0 if src contains all 0s)\n\nBSWAP reg32 Swap low-to-high ordering of 4-byte reg32 to high-to-low\n ordering. 486+\n\nBT r/m,im8 Test bit. Put bit im8 (or reg) of reg/mem into CF.\n r/m,reg (im8 or reg is used modulo 16 or modulo 32)\n\nBTC r/m,im8 Test bit im8 (or reg) of r/m & complement that bit.\n r/m,reg\n\nBTR r/m,im8 Test bit im8 (or reg) of reg/mem and reset that bit.\n r/m,reg\n\nBTS r/m,im8 Test bit im8 (or reg) of reg/mem and set that bit.\n r/m,reg\n\nCMPXCHG r/m,reg Compare and Exchange. 486+\n\nCMPXCHG8B Compare and Exchange 8 bytes Pentium\n\nCPUID Get info into EBX,ECX,EBX (mode is 0 or 1 in EAX) Pentium\n\nINVD Invalidate Data Cache. 486+\n\nINVLPG mem Invalidate Translation Lookaside Buffer (TLB) entry 486+\n\nJECXZ target Jump to target if ECX is 0.\n\nLFS reg,mem Load FS and reg from memory.\nLGS reg,mem Load GS and reg from memory.\nLSS reg,mem Load SS and reg from memory.\n\nMOV CRn,src32 Load src32 data into Control Register n (0,2,or 3)\nMOV dest,CRn Load Control Register n into dest (reg/mem32)\n\nMOV DRn,src32 Load src32 data into Debug Register n (0-3,6,or 7)\nMOV dest,DRn Load Debug Register n into dest (reg/mem32)\n\nMOV TRn,src32 Load src32 data into Test Register n (3-7)\nMOV dest,TRn Load Test Register n into dest (reg/mem32)\n\nSETccc dest If condition ccc is true, set the byte at dest to 1;\n else, set it to 0. (ccc is the same as conditional\n jump ops; see Execution Control Instructions)\n\nRDMSR reg/mem Read from model-specific register in ECX Pentium\n\nRDTSC Read timestamp counter (calculate clock cycles) Pentium\n\nROL/ROR/RCL/RCR/\nSHL/SAL/SHR/\nSAR r/m,im8 Shift/rotate by immediate count\n im8 is forced mod 16 or mod 32 internally\n\nSHLD r/m,reg,im8 Shift left r/m (16- or 32-bit) by im8 (or CL) bits,\nSHLD r/m,reg,CL inserting data from reg into the vacated positions\n\nSHRD r/m,reg,im8 Shift right r/m (16- or 32-bit) by im8 (or CL) bits,\nSHRD r/m,reg,CL inserting data from reg into the vacated positions\n\nWBINVD Write-Back and Invalidate Data Cache 486+\n\nWRMSR reg/mem Write to model-specific register in ECX Pentium\n\nXADD r/m,reg Exchange and Add 486+\n────────────────────────────────────────────────────────────────────────────\n Instruction Set"
  },
  {
    "id": "875-string_operation_instructions.html",
    "t": "String Operation Instructions",
    "b": "CLD clear direction flag to UP (DF←UP←0)\n sets ▲ (Delta) to positive; string ops auto-increment\nSTD set direction flag to DN (DF←DN←1)\n sets ▲ (Delta) to negative; string ops auto-decrement\n\nREP/REPE/REPZ (prefix) repeat: perform string operation repeatedly\n CX←(CX-1); string op repeats until CX==0\nREPNE/REPNZ (prefix) repeat: useful for string ops CMPS and SCAS\n ZF←0; CX←(CX-1); StrOp repeats while (CX!=0 and ZF==0)\n\nMOVSB copy byte(word) string (byte:▲=1, word:▲=2)\nMOVSW ES:[DI]←DS:[SI]; DI+=▲; SI+=▲\nMOVSXB copy byte(word) with SF (sign) extension 386+\nMOVSXW copy byte(word) with ZF (zero) extension 386+\n\nLODSB copy string byte(word) into AL(AX)\n AL ← DS:[SI]; SI+=1;\nLODSW AX ← DS:[SI]; SI+=2;\n\nSTOSB store bytes(words) into string\n ES:[DI]←AL; DI+=1;\nSTOSW ES:[DI]←AX; DI+=2;\n\nCMPSB compare byte(word) strings (byte:▲=1, word:▲=2)\nCMPSW flags←(result of CMP DS:[SI],ES:[DI]); DI+=▲; SI+=▲\n\nSCASB find byte(word) in string\n flags←(result of CMP DS:[DI],AL); DI+=1\nSCASW flags←(result of CMP DS:[DI],AX); DI+=2\n\nINSB port input byte(word) into string (byte:▲=1, word:▲=2)\nINSW 286+\n ES:[DI]←(byte/word at port DX); DI+=▲;\n\nOUTSB port output byte(word) from string (byte:▲=1, word:▲=2)\nOUTSW 286+\n [port DX]←DS:[SI]; SI+=▲;\n────────────────────────────────────────────────────────────────────────────\n Instruction Set"
  },
  {
    "id": "876-80x87_floating_point_opcodes.html",
    "t": "80x87 Floating Point Opcodes",
    "b": "These instructions can be executed when a 8087/80287/80387 numeric\n coprocessor is available or when using a (real) 486+ CPU.\n\n █▌Data Transfer and Constants▐█\nFLD src Load real: st(0) ← src (mem32/mem64/mem80)\nFILD src Load integer: st(0) ← src (mem16/mem32/mem64)\nFBLD src Load BCD: st(0) ← src (mem80)\n\nFLDZ Load zero: st(0) ← 0.0\nFLD1 Load 1: st(0) ← 1.0\nFLDPI Load pi: st(0) ← π (i.e., pi)\nFLDL2T Load log2(10): st(0) ← log2(10)\nFLDL2E Load log2(e): st(0) ← log2(e)\nFLDLG2 Load log10(2): st(0) ← log10(2)\nFLDLN2 Load loge(2): st(0) ← loge(2)\n\nFST dest Store real: dest ← st(0) (mem32/64)\nFSTP dest dest ← st(0) (mem32/64/80); pop stack\nFIST dest Store integer: dest ← st(0) (mem32/64)\nFISTP dest dest ← st(0) (mem16/32/64); pop stack\nFBST dest Store BCD: dest ← st(0) (mem80)\nFBSTP dest dest ← st(0) (mem80); pop stack\n\n █▌Compare▐█\nFCOM Compare real: Set flags as for st(0) - st(1)\nFCOM op Set flags as for st(0) - op (mem32/mem64)\nFCOMP op Compare st(0) to op (reg/mem); pop stack\nFCOMPP Compare st(0) to st(1); pop stack twice\n\nFICOM op Compare integer: Set flags as for st(0) - op (mem16/mem32)\nFICOMP op Compare st(0) to op (mem16/32); pop stack\n\nFTST Test for zero: Compare st(0) to 0.0\n\nFUCOM st(i) Unordered Compare: st(0) to st(i) 486+\nFUCOMP st(i) Compare st(0) to st(i) and pop stack\nFUCOMPP st(i) Compare st(0) to st(i); pop stack twice\n\nFXAM Examine: Eyeball st(0) (set condition codes)\n\n █▌Arithmetic▐█\nFADD Add real: st(0) ← st(0) + st(1)\nFADD src st(0) ← st(0) + src (mem32/mem64)\nFADD st(i),st st(i) ← st(i) + st(0)\nFADDP st(i),st st(i) ← st(i) + st(0); pop stack\nFIADD src Add integer: st(0) ← st(0) + src (mem16/mem32)\n\nFSUB Subtract real: st(0) ← st(0) - st(1)\nFSUB src st(0) ← st(0) - src (reg/mem)\nFSUB st(i),st st(i) ← st(i) - st(0)\nFSUBP st(i),st st(i) ← st(i) - st(0); pop stack\nFSUBR st(i),st Subtract Reversed: st(0) ← st(i) - st(0)\nFSUBRP st(i),st st(0) ← st(i) - st(0); pop stack\nFISUB src Subtract integer: st(0) ← st(0) - src (mem16/mem32)\nFISUBR src Subtract Rvrsd int: st(0) ← src - st(0) (mem16/mem32)\n\nFMUL Multiply real: st(0) ← st(0) * st(1)\nFMUL st(i) st(0) ← st(0) * st(i)\nFMUL st(i),st st(i) ← st(0) * st(i)\nFMULP st(i),st st(i) ← st(0) * st(i); pop stack\nFIMUL src Multiply integer: st(0) ← st(0) * src (mem16/mem32)\n\nFDIV Divide real: st(0) ← st(0) ÷ st(1)\nFDIV st(i) st(0) ← st(0) ÷ t(i)\nFDIV st(i),st st(i) ← st(0) ÷ st(i)\nFDIVP st(i),st st(i) ← st(0) ÷ st(i); pop stack\nFIDIV src Divide integer: st(0) ← st(0) ÷ src (mem16/mem32)\nFDIVR st(i),st Divide Rvrsd real: st(0) ← st(i) ÷ st(0)\nFDIVRP st(i),st st(0) ← st(i) ÷ st(0); pop stack\nFIDIVR src Divide Rvrsd int: st(0) ← src ÷ st(0) (mem16/mem32)\n\nFSQRT Square Root: st(0) ← √ st(0)\n\nFSCALE Scale by power of 2: st(0) ← 2 ↑ st(0)\n\nFXTRACT Extract exponent: st(0) ← exponent of st(0); gets pushed\n st(0) ← significand of st(0)\n\nFPREM Partial remainder: st(0) ← st(0) MOD st(1)\nFPREM1 Partial Remainder (IEEE): same as FPREM, but in IEEE standard 486+\n\nFRNDINT Round to nearest int: st(0) ← INT( st(0) ); depends on RC flag\n\nFABS Get absolute value: st(0) ← ABS( st(0) ); removes sign\nFCHS Change sign: st(0) ← -st(0)\n\n █▌Transcendental▐█\nFCOS Cosine: st(0) ← COS( st(0) )\nFPTAN Partial tangent: st(0) ← TAN( st(0) )\nFPATAN Partial Arctangent: st(0) ← ATAN( st(0) )\nFSIN Sine: st(0) ← SIN( st(0) )\nFSINCOS Sine and Cosine: st(0) ← SIN( st(0) ) and pushed to st(1)\n st(0) ← COS( st(0)\nF2XM1 Calculate (2 ↑ x)-1: st(0) ← (2 ↑ st(0)) - 1\nFYL2X Calculate Y * log2(X): st(0) is Y; st(1) is X; replaces st(0)\n and st(1) with: st(0) * log2( st(1) )\nFYL2XP1 Calculate Y * log2(X+1): st(0) is Y; st(1) is X; replaces st(0)\n and st(1) with: st(0) * log2( st(1)+1 )\n\n █▌Processor Control▐█\nFINIT Initilaize FPU\nFSTSW AX Store Status Word: AX ← MSW\nFSTSW dest dest ← MSW (mem16)\n\nFLDCW src Load control word: FPU CW ← src (mem16)\nFSTCW dest Store control word: dest ← FPU CW\n\nFCLEX Clear exceptions\n\nFSTENV dest Store environment: store status, control and tag words and\n exception pointers into memory at dest\nFLDENV src Load environment: load environment from memory at src\n\nFSAVE dest Store FPU state: store FPU state into 94-bytes at dest\nFRSTOR src Load FPU state: restore FPU state as saved by FSAVE\n\nFINCSTP Increment FPU stack ptr: st(6)←st(5); st(5)←st(4),...,st(0)←?\nFDECSTP Decrement FPU stack ptr: st(0)←st(1); st(1)←st(2),...,st(7)←?\n\nFFREE st(i) Mark reg st(i) as unused\n\nFNOP No operation: st(0) ← st(0)\n\nWAIT/FWAIT Synchronize FPU & CPU: Halt CPU until FPU finishes\n current opcode\n────────────────────────────────────────────────────────────────────────────\n Instruction Set"
  },
  {
    "id": "877-alphabetical_list_of_opcodes.html",
    "t": "Alphabetical List of Opcodes",
    "b": "This table lists all 80x86 opcodes except 80x87 Floating Point Opcodes.\n Additional descriptions are available in the the Opcode Functional Groups.\n\nAAA adjust after ASCII addition\nAAD adjust before ASCII division\nAAM adjust after ASCII multiply\nAAS adjust for ASCII subtraction\nADC dest,src add two operands, using carry from previous ADD\nADD dest,src add two operands, placing result in dest\nADDRSIZ (prefix; 67H) next address ref is non-default size 386+\nAND dest,src logical AND (mask; reset dest bits which are 0 in src)\nARPL lvl Adjust Requested Priv. Level to higher of cur or lvl 286+\nBOUND reg16,lmts perform limit-check on reg16\nBSF reg,src Bit Scan Forward; reg←(index of next 1-bit of src) 386+\nBSF reg,src Bit Scan Reverse; reg←(index of prev 1-bit of src) 386+\nBSWAP reg32 Swap low-to-high order of reg32 to high-to-low 486+\nBT r/m,im8/reg Test bit; put bit im8 (or reg) of reg/mem into CF 386+\nBTC r/m,im8/reg Test bit im8 (or reg) of r/m & complement that bit 386+\nBTR r/m,im8/reg Test bit im8 (or reg) of reg/mem and reset that bit 386+\nBTS r/m,im8/reg Test bit im8 (or reg) of reg/mem and set that bit 386+\nCBW convert byte to word (sign-extend AL into AH)\nCLC clear the carry flag to NC (CF←0)\nCLD clear direction flag to UP (DF←UP←0) set to auto-increment\nCLI disable maskable hardware interrupts (IF←0)\nCMC complement (reverse the value of) the carry flag (CF←~CF)\nCMP dest,src compare (non-destructive subtract)\nCMPSB compare byte strings; flags←(rslt of CMP DS:[SI],ES:[DI]);\n DI+=1; SI+=1\nCMPSW like CMPSB but for words (opSize is 2 or 4 bytes)\nCMPXCHG r/m,reg Compare and Exchange 486+\nCMPXCHG8B Compare and Exchange 8 bytes Pentium\nCPUID Get info into EBX,ECX,EBX (mode is 0 or 1 in EAX) Pentium\nCTS/CLTS clear task switch flag (TF←1) 286+\nCWD convert word to dword (sign-extend AX into DX)\nDAA adjust after BCD▲ addition\nDAS adjust for BCD▲ subtraction\nDEC dest subtract 1 from dest (reg or r/m)\nDIV src divide accumulator by unsigned value src (reg/mem)\nENTER frmsiz,cnt set high-level language stack frame\nFWAIT wait for TEST line active (synchronize with coprocessor)\nFxxxxxx See 80x87 Floating Point Opcodes\nHLT halt processing (perform NOPs until an interrupt occurs)\nIDIV src divide accumulator by unsigned value src (reg/mem)\nIMUL r16,r/m,im16 multiply reg/mem by 16-bit immediate signed value 286+\nIMUL src multiply AL(AX) by signed integer src (reg/mem)\nIN AL/AX,DX input to AL(or AX) from I/O port DX\nIN AL/AX,port8 input to AL(or AX) from I/O port\nINC dest add 1 to dest (reg or r/m)\nINSB port input byte into string; ←byte at port DX) DI+=1 286+\nINSW like INSB but fetches 16-bit words; DI+=2 286+\nINT type perform a software interrupt (call a system function)\nINTO type if OF==OV==1, then perform INT type\nINVD Invalidate Data Cache 486+\nINVLPG mem Invalidate Translation Lookaside Buffer (TLB) entry 486+\nIRET return from interrupt\nJA shortLbl jump if Above ((CF & ZF)==0 after unsigned math)\nJAE shortLbl jump if Above or Equal (CF==NC==0 after unsigned math)\nJB shortLbl jump if Below/Jump if Carry set (CF==CY==1)\nJC shortLbl jump if Below/Jump if Carry set (CF==CY==1)\nJCXZ shortLbl jump if CX==0\nJE shortLbl jump if Equal (ZF==ZR==1)\nJECXZ target Jump to target if ECX is 0 386+\nJG shortLbl jump if Greater (SF==(OF & ZF) after signed math)\nJGE shortLbl jump if Greater or Equal (SF==OF after signed math)\nJL shortLbl jump if Less (ZF != OF after signed math)\nJLE shortLbl jump if Less or Equal (SF!=OF || ZF==0 after signed math)\nJMP target unconditionally transfer control to target\nJNB shortLbl jump if Above or Equal (CF==NC==0 after unsigned math)\nJNBE shortLbl jump if Above ((CF & ZF)==0 after unsigned math)\nJNC shortLbl jump if carry not set (CF==NC==0) (same as JAE/JNB)\nJNE shortLbl jump if Not Equal (ZF==NZ==0)\nJNG shortLbl jump if Less or Equal (SF!=OF || ZF==0 after signed math)\nJNGE shortLbl jump if Greater (SF==(OF & ZF) after signed math)\nJNGE shortLbl jump if Less (ZF != OF after signed math)\nJNL shortLbl jump if Greater or Equal (SF==OF after signed math)\nJNO shortLbl jump if Not Overflow (OF==NO==0)\nJNP shortLbl jump if Parity Odd (PF==PO==0: cnt of 1-bits is ODD)\nJNS shortLbl jump if Not Sign (SF==PL==0: same as high-bit of dest)\nJNZ shortLbl jump if Not Equal (ZF==NZ==0)\nJO shortLbl jump if Overflow (OF==OV==1)\nJP shortLbl jump if Parity Even (PF==PE==1 cnt of 1-bits is even)\nJPE shortLbl jump if Parity Even (PF==PE==1 cnt of 1-bits is even)\nJPO shortLbl jump if Parity Odd (PF==PO==0: cnt of 1-bits is ODD)\nJS shortLbl jump if Sign (SF==NG==1: same as high-bit of dest)\nJZ shortLbl jump if Equal (ZF==ZR==1)\nLAHF load/convert flags into AH\nLAR dest,src load high-byte of dest with Access Rights of src dsc 286+\nLDS r16,mem load DS and reg16 from memory variable\nLEA r16,addr load address into a register\nLEAVE undo the effect of ENTER. Use just before RET.\nLES r16,mem load ES and reg16 from memory variable\nLFS reg,mem Load FS and reg from memory 386+\nLGDT src load Global Descr. Table from 6-byte table at src 286+\nLGS reg,mem Load GS and reg from memory 386+\nLIDT src load Int. Descriptor Table from 6-byte table at src 286+\nLLDT src load Local Descr. Tbl (GDT selector) from reg/mem16 286+\nLMSW src load Machine Status Word (use to enter prot. mode) 286+\nLOCK (prefix) prevent coproc. bus access on next opcode 386+\nLODSB copy string byte into AL; AL ← DS:[SI]; SI+=1\nLODSW copy string word into (E)AX; (E)AX←DS:[SI]; SI+=(2 or 4)\nLOOP shortLbl CX←(CX-1) jump if CX!=0\nLOOPE shortLbl CX←(CX-1) jump if CX!=0 && ZF==ZR==1\nLOOPNE shortLbl CX←(CX-1) jump if CX!=0 && ZF==NZ==0\nLOOPNZ shortLbl CX←(CX-1) jump if CX!=0 && ZF==NZ==0\nLOOPZ shortLbl CX←(CX-1) jump if CX!=0 && ZF==ZR==1\nLSL dest,src load dest with Segment Limit of descr. named by src 286+\nLSS reg,mem Load SS and reg from memory 386+\nLTR src load Task Register (GDT selector) from reg/mem16 286+\nMOV dest,src transfer (copy) data to/from register, to/from memory\nMOV CRn,src32 Load src32 data into Control Register n (0,2,or 3) 386+\nMOV dest,CRn Load Control Register n into dest (reg/mem32) 386+\nMOV dest,DRn Load Debug Register n into dest (reg/mem32) 386+\nMOV dest,TRn Load Test Register n into dest (reg/mem32) 386+\nMOV DRn,src32 Load src32 data into Debug Register n (0-3,6,or 7) 386+\nMOV TRn,src32 Load src32 data into Test Register n (3-7) 386+\nMOVSB copy byte string; ES:[DI]←DS:[SI]; DI+=1; SI+=1\nMOVSW copy word string; ES:[DI]←DS:[SI]; DI+=▲; SI+=▲ (▲=2 or 4)\nMOVSXB MOVSB with SF (sign) extension 386+\nMOVSXW MOVSW with ZF (zero) extension 386+\nMUL src multiply AL(AX) by unsigned value src (reg/mem)\nNEG dest change sign of an operand\nNOT dest form 1's complement (toggle every bit in dest)\nOR dest,src inclusive OR (set dest bits which are 1s in src)\nOUT DX,AL/AX output from AL (or AX) to I/O port DX\nOUT port8,AL/AX output from AL (or AX) to I/O port\nOUTS like OUTSB but outputs 16-bit words; SI+=2 286+\nOUTSB port output byte from string; [prtDX]←DS:[SI]; SI+=1 286+\nPOP dest transfer from stack to dest (reg16, r/m16, or segreg)\nPOPA POP All: copy general registers from stack. 286+\nPOPF POP Flags: transfer from stack to flags register\nPUSH immed transfer immed16 (or sign-extended immed8) to stack.\nPUSH src transfer reg16 or r/m16 to stack\nPUSHA PUSH ALL: copy general registers to stack. 286+\nPUSHF PUSH Flags: transfer flags register to stack\nRCL dest[,cnt] rotate dest left through Carry by 1, CL, or cnt\nRCR dest[,cnt] rotate dest right through Carry by 1, CL, or cnt\nRDMSR reg/mem Read from model-specific register in ECX Pentium\nRDTSC Read timestamp counter Pentium\nREP/REPE/REPZ (prefix) repeat: perform string operation repeatedly\n CX←(CX-1); string op repeats until CX==0\nREPNE/REPNZ (prefix) repeat: useful for string ops CMPS and SCAS\n ZF←0; CX←(CX-1); StrOp repeats while (CX!=0 and ZF==0)\nROL dest[,cnt] rotate dest left by 1, CL, or cnt\nROR dest[,cnt] rotate dest right by 1, CL, or cnt\nSAHF store/convert AH into flags\nSAL dest shift left (multiply by 2) by 1, CL, or cnt\nSAR dest shift arithmetic right (retain high bit) by 1, CL, or cnt\nSBB dest,src subtract using borrow (carry flag) from previous SUB\nSCASB find byte in string; flags←(rslt of CMP DS:[DI],AL); DI+=1\nSCASW like SCASB but for words (opSize is mem16 or mem32; DI+=▲)\nSEG segreg (prefix) override default segreg for next EA calc\nSETccc dest If condition ccc is true, set the byte at dest to 1 386+\nSGDT dest store 6-byte Global Desc. Table to memory at dest 286+\nSHL dest[,cnt] shift left (multiply by 2) by 1, CL, or cnt\nSHLD r/m,reg,im8 shift left r/m (16- or 32-bit) by im8 (or CL) bits,\n r/m,reg,CL inserting data from reg into the vacated positions 386+\nSHR dest[,cnt] shift right (divide by 2) by 1, CL, or cnt\nSHRD r/m,reg,im8 shift right r/m (16- or 32-bit) by im8 (or CL) bits,\n r/m,reg,CL inserting data from reg into the vacated positions 386+\nSIDT dest store 6-byte Int. Descriptor Table to memory at dest 286+\nSIZ (prefix; 66H) next data ref is non-default size 386+\nSLDT dest store Local Descr. Table register into dest (r/m16) 286+\nSMSW src store Machine Status Word to reg/mem16 286+\nSTC set the carry flag to CY (CF←1)\nSTD set direction flag to DN (DF←DN←1) set to auto-decrement\nSTD set direction flag to DN (string ops decrement) (DF←1)\nSTI enable maskable hardware interrupts (IF←1)\nSTOSB store byte into string; ES:[DI]←AL; DI+=1\nSTOSW store word into string; ES:[DI]←(E)AX; DI+=▲ (▲=2 or 4)\nSTR dest store Task Register to reg/mem16 286+\nSUB dest,src subtract src from dest, leaving result in dest\nTEST dest,src non-destructive AND (bit test; JZ jumps if no match)\nVERR seg Sets ZF to ZR if task has read privileges for seg 286+\nVERW seg Sets ZF to ZR if task has write privileges for seg 286+\nWAIT wait for TEST line active (synchronize with coprocessor)\nWBINVD Write-Back and Invalidate Data Cache 486+\nWRMSR reg/mem Write to model-specific register in ECX Pentium\nXADD r/m,reg Exchange and Add 486+\nXCHG dest,src exchange values of two registers or register and r/m\nXLAT translate AL into a value in a translation table at BX\nXOR dest,src exclusive OR (toggle dest bits which are 1s in src)\n────────────────────────────────────────────────────────────────────────────\n Instruction Set"
  },
  {
    "id": "878-cables_and_pin_outs.html",
    "t": "Cables and Pin Outs",
    "b": "TECH Help! provides diagrams of the following standard connectors:\n\n Parallel Port Connector\n\n Serial Port Connector - 25-pin\n Serial Port Connector - 9-pin\n\n InterLink Cables\n\n Keyboard Connectors: PC/XT AT PS/2\n\n Video Connectors: CGA EGA MDA VGA\n\n Hard Disk Connectors and Cables\n\n Diskette Drive Connectors and Cables\n\nSee Also: I/O Port Map\n TECH Topics\n -♦-"
  },
  {
    "id": "879-parallel_port_connector.html",
    "t": "Parallel Port Connector",
    "b": "1 1 1 1\n 3 2 1 0 9 8 7 6 5 4 3 2 1\n ┌───────────────────────────────┐\n \\ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ /\n \\ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ /\n └───────────────────────┘\n 2 2 2 2 2 2 1 1 1 1 1 1\n 5 4 3 2 1 0 9 8 7 6 5 4\n\n Pin In/Out Signal Name Pin In/Out Signal Name\n ─── ────── ──────────── ─── ────── ─────────────\n 1 I/O -STROBE 14 O -AUTO FEED XT\n 2 I/O Data Bit 0 15 I -ERROR\n 3 I/O Data Bit 1 16 O -INIT\n 4 I/O Data Bit 2 17 O -SLCT IN\n 5 I/O Data Bit 3 18 na Ground\n 6 I/O Data Bit 4 19 na Ground\n 7 I/O Data Bit 5 20 na Ground\n 8 I/O Data Bit 6 21 na Ground\n 9 I/O Data Bit 7 22 na Ground\n 10 I -ACK 23 na Ground\n 11 I BUSY 24 na Ground\n 12 I PE 25 na Ground\n 13 I SLCT\n\n Notes: ■ The signals on pins 10, 11, 12, 13, and 15 are represented at\n port n+1 (where n is the printer base port; e.g., at port 379H\n on LPT1). See Printer Ports.\n\n ■ Original PC/XT/AT Pins 1-9 can carry information in only one\n direction -- from the PC to the printer.\n\n ■ Bidirectional PS/2 On PS/2s and most printer adaptors built\n after 1987, the circuits are designed to handle bidirectional\n I/O.\n\n A bidirectional parallel cable is used with the DOS InterLink\n utility. See InterLink Cables.\n\nSee Also: Cables and Pin Outs\n Parallel Ports\n -♦-"
  },
  {
    "id": "880-serial_port_connector___25_pin.html",
    "t": "Serial Port Connector - 25-pin",
    "b": "1 1 1 1\n 3 2 1 0 9 8 7 6 5 4 3 2 1\n ┌───────────────────────────────┐\n \\ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ /\n \\ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ ■ /\n └───────────────────────┘\n 2 2 2 2 2 2 1 1 1 1 1 1\n 5 4 3 2 1 0 9 8 7 6 5 4\n\n Pin In/Out Signal Name Pin In/Out Signal Name\n ─── ────── ───────────── ─── ────── ─────────────\n 1 na not connected 14 na not connected\n 2 O Transmit Data 15 na not connected\n 3 I Receive Data 16 na not connected\n 4 O Request to Send 17 na not connected\n 5 I Clear to Send 18 na not connected\n 6 I Data Set Ready 19 na not connected\n 7 na Signal Ground 20 O Data Terminal Ready\n 8 I Data Carrier Detect 21 na not connected\n 9 na not connected 22 I Ring Indicate\n 10 na not connected 23 na not connected\n 11 na not connected 24 na not connected\n 12 na not connected 25 na not connected\n 13 na not connected\n\n Notes: ■ The signals on pins 5, 6, 8, and 22 are represented at port\n n+6 (where n is the base port; e.g., at port 3feH on COM1).\n See Serial Ports.\n\n ■ A serial port cable for normal data transfer with the DOS\n InterLink utility uses only three wires. For remote copy\n operations, you need a 7-wire null-modem cable. See\n InterLink Cables.\n\nSee Also: Cables and Pin Outs\n Serial Port Connector - 9-pin\n Serial Ports\n -♦-"
  },
  {
    "id": "881-serial_port_connector___9_pin.html",
    "t": "Serial Port Connector - 9-pin",
    "b": "5 4 3 2 1\n ┌───────────────┐\n \\ ■ ■ ■ ■ ■ /\n \\ ■ ■ ■ ■ /\n └───────┘\n 9 8 7 6\n\n Pin In/Out Signal Name\n ─── ────── ─────────────\n 1 I Data Carrier Detect\n 2 I Receive Data\n 3 O Transmit Data\n 4 O Data Terminal Ready\n 5 na Signal Ground\n 6 I Data Set Ready\n 7 O Request to Send\n 8 I Clear to Send\n 9 I Ring Indicate\n\n Notes: ■ The signals on pins 1, 6, 8, and 9 are represented at port\n n+6 (where n is the base port; e.g., at port 3feH on COM1).\n See Serial Ports.\n\n ■ A serial port cable for normal data transfer with the DOS\n InterLink utility uses only three wires. For remote copy\n operations, you need a 7-wire null-modem cable. See\n InterLink Cables.\n\nSee Also: Cables and Pin Outs\n Serial Port Connector - 25-pin\n Serial Ports\n -♦-"
  },
  {
    "id": "882-interlink_cables.html",
    "t": "InterLink Cables",
    "b": "█▌Overview▐█\n The DOS 6.0+ InterLink utility provides a means to share files and data\n between two computers without using a network. It is typically used to\n attach a laptop computer to a desktop model. This topic describes the\n cables used to connect the two computers.\n\n█▌Serial Cables▐█\n When connecting via COMn serial ports, you can use a standard 25-pin or\n 9-pin (or 25-to-9 pin) serial cable . The cable will need to have female\n connectors on both ends. If you have such a cable laying around, try\n it--it will probably work.\n\n Here are the pin connections, in case you need to create a cable or, if\n you need to buy one, you can specify your needs exactly:\n\n For normal data-transmission connections, just three wires are used:\n\n 9-pin (25-pin) 9-pin (25-pin)\n connector connector\n ───────────── ──────────────\n pin 5 (7) ◄═══ (ground-to-ground) ════► pin 5 (7)\n pin 3 (2) ◄══ (transmit-to-receive) ══► pin 2 (3)\n pin 2 (3) ◄══ (receive-to-transmit) ══► pin 3 (2)\n\n A 7-wire null-modem cable is needed for remote copy operations\n (i.e., Intersvr /RCOPY):\n\n 9-pin (25-pin) 9-pin (25-pin)\n connector connector\n ───────────── ──────────────\n pin 5 (7) ◄═══ (ground-to-ground) ════► pin 5 (7)\n pin 3 (2) ◄══ (transmit-to-receive) ══► pin 2 (3)\n\n pin 7 (4) ◄══════ (RTS-to-CTS) ═══════► pin 8 (5)\n pin 6 (6) ◄══════ (DSR-to-DTR) ═══════► pin 4 (20)\n\n pin 2 (3) ◄══ (receive-to-transmit) ══► pin 3 (2)\n pin 8 (5) ◄══════ (CTS-to-RTS) ═══════► pin 7 (4)\n pin 4 (20) ◄══════ (DTR-to-DSR) ═══════► pin 6 (6)\n\n Notes: ■ This cable also works for normal InterLink transmissions.\n ■ You can use a standard cable if you attach a \"null modem\n adapter\" to one end of it.\n\n█▌Parallel Cables▐█\n When connecting via LPTn parallel ports, you need male DB-25 connectors on\n both ends of the cable (many parallel cables have a Centronics connector\n on one end--these won't work). Eleven wires are connected:\n\n 25-pin 25-pin\n connector connector\n ───────── ─────────\n pin 2 ◄════► pin 15\n pin 3 ◄════► pin 13\n pin 4 ◄════► pin 12\n pin 5 ◄════► pin 10\n pin 6 ◄════► pin 11\n pin 15 ◄════► pin 2\n pin 13 ◄════► pin 3\n pin 12 ◄════► pin 4\n pin 10 ◄════► pin 5\n pin 11 ◄════► pin 6\n pin 25 ◄════► pin 25 (Ground-Ground)\n\nSee Also: Cables and Pin Outs\n Parallel Ports\n Serial Ports\n -♦-"
  },
  {
    "id": "883-cga_video_adaptor_pin_outs.html",
    "t": "CGA Video Adaptor Pin Outs",
    "b": "5 4 3 2 1\n ┌───────────────┐\n \\ ■ ■ ■ ■ ■ /\n \\ ■ ■ ■ ■ /\n └───────┘\n 9 8 7 6\n\n Pin In/Out Signal Name\n ─── ────── ─────────────\n 1 na Ground\n 2 na Ground\n 3 O Red\n 4 O Green\n 5 O Blue\n 6 O Intensity\n 7 na reserved\n 8 O Horizontal Sync\n 9 I Vertical Sync\n\nSee Also: CGA I/O Ports\n Cables and Pin Outs\n -♦-"
  },
  {
    "id": "884-ega_video_adaptor_pin_outs.html",
    "t": "EGA Video Adaptor Pin Outs",
    "b": "5 4 3 2 1\n ┌───────────────┐\n \\ ■ ■ ■ ■ ■ /\n \\ ■ ■ ■ ■ /\n └───────┘\n 9 8 7 6\n Pin Signal Name │ Signal Name\n ─── ───────────── │ ─────────────\n 1 Ground │ Shield Ground\n 2 r (secondary Red) │ Signal Ground\n 3 R (primary Red) │ Red\n 4 G (primary Green) │ Green\n 5 B (primary Blue) │ Blue\n 6 g (secondary Green)│ Intensity\n 7 b (secondary Blue) │ Mono Video\n 8 Horizontal Sync │ Horizontal Sync\n 9 Vertical Sync │ Vertical Sync\n ─────────────────────────┼──────────────────────\n 64-color modes │ 16- and 2-color modes\n\nSee Also: EGA I/O Ports\n Cables and Pin Outs\n -♦-"
  },
  {
    "id": "885-mda_video_adaptor_pin_outs.html",
    "t": "MDA Video Adaptor Pin Outs",
    "b": "5 4 3 2 1\n ┌───────────────┐\n \\ ■ ■ ■ ■ ■ /\n \\ ■ ■ ■ ■ /\n └───────┘\n 9 8 7 6\n\n Pin Signal Name\n ─── ─────────────\n 1 Ground\n 2 Ground\n 3 (not used)\n 4 (not used)\n 5 (not used)\n 6 +Intensity\n 7 +Video\n 8 +Horizontal Sync\n 9 -Vertical Sync\n\nSee Also: Cables and Pin Outs\n -♦-"
  },
  {
    "id": "886-vga_video_adaptor_pin_outs.html",
    "t": "VGA Video Adaptor Pin Outs",
    "b": "5 4 3 2 1\n ┌─────────────┐\n │ ■ ■ ■ ■ ■ │\n 10 \\ ■ x ■ ■ / 6\n \\ ■ ■ ■ ■ ■ /\n └─────────┘\n 1 1 1 1 1\n 5 4 3 2 1\n\n Pin Signal Name\n ─── ─────────────\n 1 Red\n 2 Green\n 3 Blue\n 4 (reserved)\n 5 (digital ground)\n 6 Red Rtn (analog ground)\n 7 Green Rtn (analog ground)\n 8 Blue Rtn (analog ground)\n 9 (plug; keyed connector)\n 10 (digital ground)\n 11 (reserved)\n 12 (reserved)\n 13 Horizontal Sync\n 14 Vertical Sync\n 15 (reserved)\n\nSee Also: VGA I/O Ports\n Cables and Pin Outs\n -♦-"
  },
  {
    "id": "887-keyboard_connector___pc_xt.html",
    "t": "Keyboard Connector - PC/XT",
    "b": "┌─\\./─┐\n ┌┘ └┐\n │3■ ■1│\n │5■ 2 ■4│\n └┐ ■ ┌┘\n └─────┘\n\n Pin In/Out Signal Name\n ─── ────── ───────────────\n 1 I +Keyboard Clock\n 2 I +Keyboard Data\n 3 O -Keyboard reset\n 4 power Ground\n 5 power +5 Volts\n\nSee Also: Keyboard Connector - AT\n Cables and Pin Outs\n -♦-"
  },
  {
    "id": "888-keyboard_connector___at.html",
    "t": "Keyboard Connector - AT",
    "b": "┌─\\./─┐\n ┌┘ └┐ ┌──────────┐\n 5-pin DIN │1■ ■3│ │ ││││││ │ 6-position SDL\n on system unit │4■ 2 ■5│ │ ABCDEF │ on keyboard\n └┐ ■ ┌┘ └─ └┴┴┴┴┘ ─┘\n └─────┘\n Pin In/Out Signal Name to SDL Pin\n ─── ────── ─────────────── ──────────\n 1 I/O +Keyboard Clock D\n 2 I/O +Keyboard Data B\n 3 na (reserved) F\n 4 power Ground C\n 5 power +5 Volts E\n not used A\n\nSee Also: Keyboard Connector - PC/XT\n Keyboard Connector - PS/2\n Cables and Pin Outs\n -♦-"
  },
  {
    "id": "889-keyboard_connector___ps_2.html",
    "t": "Keyboard Connector - PS/2",
    "b": "┌─\\./─┐\n ┌┘6■ ■5└┐\n │4■ ■3│\n └┐2■ ■1┌┘\n └─────┘\n Pin In/Out Signal Name\n ─── ────── ───────────────\n 1 I/O +Keyboard Data\n 2 na (reserved)\n 3 power Ground\n 4 power +5 Volts\n 5 I/O +Keyboard Clock\n 6 na (reserved)\n\nSee Also: Keyboard Connector - PC/XT\n Keyboard Connector - AT\n Cables and Pin Outs\n -♦-"
  },
  {
    "id": "890-hard_disk_connectors_and_cables.html",
    "t": "Hard Disk Connectors and Cables",
    "b": "┌───O───────────────────────────────────────────┐\n │ Hard Disk Drive │\n \\ \\\n \\ \\\n │ Drive Select Data │\n │ power Command Cable Pins Cable │\n └┬────┬─┬┬┬┬┬┬┬┬┬┬┬┬┬─┬┬────┬┬┬┬┬┬┬┬───┬┬┬┬┬┬─┬┬┘\n │oooo│ │││││││││││││ ││ X ││││││ ││\n \\────┘ └┴┴┴┴┴┴┴┴┴┴┴┘▲└┘ └┴┴┴┴┘▲└┘\n └───────────────────────┴─── Key Slots\n Key\n Slots Cables are keyed with a plug at the position of the key slot, but\n I've seen cables in which the plug has fallen out.\n\n Attach the cable with pin 1 (which has a colored wire) toward the\n slot.\n\n power A separate power cable is needed for each drive. The connector\n is keyed to avoid improper orientation.\n\n Command This is the wider of the two cables. It carries control\n Cable information to the drive. Most systems have two connectors on\n the Command Cable:\n ┌─────────────────┐\n │ Connected to the│\n │ controller │ (see below)\n └╥─┬─┬─┬─┬─┬─┬─┬─┬┘\ncolored ║ │ │ │ │ │ │ │ │ ┌─\n wire═╦═►║ │ │ │ │ │ │ │ │ │On the second hard disk, the Drive Select\n (key ║ ║ │ │ │ │ │ │ │ │ │jumper should be set to the second\n slot ║ ┌╨─┴─┴─┴─┴─┴─┴─┴─┴┐ │position and the terminating resistor\n side)║ │ Connected to the│◄═╡should be removed from the drive.\n ║ │ second hard disk│ └\n ║ └╥─┬─┬─┬─┬─┬─┬─┬─┬┘ ┌\n ║ ║ │ │ │ │ │\\t/│ │ │If your cable does not have this twist,\n ╚═►║ │ │ │ │ │ w │ │◄═╡then the first drive must have the\n ║ │ │ │ │ │ i │ │ │Drive Select jumper in the first position.\n ║ │ │ │ │ │ s │ │ └\n ║ │ │ │ │ │/t\\│ │ ┌\n ┌╨─┴─┴─┴─┴─┴─┴─┴─┴┐ │If your cable does have the twist, then\n │ Connected to the│◄═╡the Drive Select jumper on the first drive\n │ first hard disk │ │must be in the second position and the\n └─────────────────┘ │terminating resistor should be in place.\n └\n\n Drive Hard drives have a double row of pins (usually four or eight\n Select sets) with a jumper across one set. In most cases, the jumper\n should be across the second set (jumper the first set on the\n first hard disk only if your cable does not have a twist).\n\n If you can see any printing on the circuit board, you can usually\n figure out which is the side with the first position (DS 0 or\n pin 1, etc.). Or you can tell the end with pin 1 by looking at\n the back of the controller. It is the side that has a square\n solder mark.\n\n Data This is the narrow ribbon cable. There is one data cable for\n Cable each hard disk. Attach it with the colored wire toward the\n Key Slot.\n\n█▌Hard Disk Controller Card▐█\n\n ╔═══ Data Cable for first drive ╔═ Command Cable ┌─\n ║ ┌────────────────────────────▼───────────────┐│\n ╚══►│ :.:::::: :::::::::::::: ┌────┐ ││\n │1 1 └────┘ ││\n ╔══►│ :.:::::: ┌───────┐ ││\n ║ │1 ┌────┐ │ │ ┌──────┐ ┌────┐││\n ║ │ ┌────┐ └────┘ └───────┘ │ │ └────┘││\n ║ │ └────┘ └──────┘ ││\n ║ └──────────────────┬┬┬┬┬┬┬┬─┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┘│\n ║ └┴┴┴┴┴┴┘ └┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┘ │\n ╚═ Data Cable for second drive\n\n Controller cards vary in layout, but the connectors are similar.\n Just take care to connect the Data Cable for each drive to the\n correct connector and make sure that the connector is oriented\n correctly.\n\n Hard Disk Number: The board usually has HD0 or HD1 printed on it\n to guide you in this momentous decision.\n\n Connector Orientation: Cables often have a plug to match a\n missing pin, to ensure the proper orientation.\n\n The side of the cable that has a colored wire is the one to\n connect to pin 1. To locate pin 1 on the controller, try:\n\n ■ Look for a 1 printed on the circuit board. Or...\n ■ If there is a square solder mark on the back side of the\n controller where the pins are connected, this is pin 1. Or...\n ■ Refer to your controller documentation.\n\nSee Also: Diskette Drive Cables\n Cables and Pin Outs\n -♦-"
  },
  {
    "id": "891-diskette_drive_connectors_and_cables.html",
    "t": "Diskette Drive Connectors and Cables",
    "b": "┌─────────────────────────────────┐\n │ Diskette Drive │\n \\ \\\n │ │\n \\ └┘ DskChng jumper \\\n │ Drive │\n │ power Cable Select │\n └┬────┬─┬┬┬┬┬┬┬┬┬┬┬┬┬─┬┬─────┬┬┬┬─┘\n │oooo│ │││││││││││││ ││ X\n \\────┘ └┴┴┴┴┴┴┴┴┴┴┴┘▲└┘\n └────────────── Key Slot\n Key\n Slot The cable is keyed with a plug at the position of the key slot,\n but I've seen cables in which the plug has fallen out.\n\n Attach the cable with pin 1 (which has a colored wire) toward the\n slot.\n\n power A separate power cable is needed for each drive. The connector\n is keyed to avoid improper orientation.\n\n Cable Diskette drives are connected by only one cable. Most systems\n have two connectors on the Cable:\n ┌─────────────────┐ ┌\n │ Connected to the│◄═╡ Connect with the colored wire to pin 1 on\n │ controller │ │ the controller card. See below.\n └╥─┬─┬─┬─┬─┬─┬─┬─┬┘ └\ncolored ║ │ │ │ │ │ │ │ │\n wire═╦═►║ │ │ │ │ │ │ │ │\n (key ║ ║ │ │ │ │ │ │ │ │\n slot ║ ┌╨─┴─┴─┴─┴─┴─┴─┴─┴┐\n side)║ │ Connected to the│\n ║ │ second drive (B)│\n ║ └╥─┬─┬─┬─┬─┬─┬─┬─┬┘\n ║ ║ │ │ │ │ │\\t/│ │ ┌\n ╚═►║ │ │ │ │ │ w │ │ │If your cable does not have this twist,\n ║ │ │ │ │ │ i │ │◄═╡then drive A must have the Drive Select\n ║ │ │ │ │ │ s │ │ │jumper in the first position.\n ║ │ │ │ │ │/t\\│ │ └\n ┌╨─┴─┴─┴─┴─┴─┴─┴─┴┐\n │ Connected to the│\n │ first drive (A) │\n └─────────────────┘\n\n Drive Some, but not all diskette drives have a double row of pins\n Select (usually four sets) with a jumper across one set. The jumper\n should be across the second set for both diskette drives.\n\n If you can see any printing on the circuit board, you can usually\n figure out which is the side with the first position (D0 or\n pin 1, etc.). Or you can tell the end with pin 1 by looking at\n the back of the controller. It is the side that has a square\n solder mark.\n\n DiskChng A few drives let you choose whether the drive should\n Jumper detect when the drive door has been opened (indicating the\n likelihood that a disk has been swapped).\n\n DOS device drivers have supported Disk Change or \"change line\"\n for many years, and you should enable this feature (usually by\n placing the jumper).\n\n If DOS thinks that the drive does detect Disk Change, but it\n actually does not, then DOS may not be able to tell when a new\n diskette is inserted in the drive (for instance, the Dir command\n will show the directory of the previous diskette). This is\n dangerous.\n\n█▌Controller Card Connection▐█\n Many controller cards support both hard disk and diskettes. Be sure to\n connect the disketted drive cable to the pin-set marked FDD or floppy\n disk.\n\n Cables often have a plug to match a missing pin, to ensure the proper\n orientation.\n\n The side of the cable that has a colored wire is the one to connect to\n pin 1. To locate pin 1 on the controller, try:\n\n ■ Look for a 1 printed on the circuit board. Or...\n ■ If there is a square solder mark on the back side of the controller\n where the pins are connected, this is pin 1. Or...\n ■ Refer to your controller documentation.\n\nSee Also: Hard Disk Cables\n Cables and Pin Outs\n -♦-"
  },
  {
    "id": "892-i_o_port_map.html",
    "t": "I/O Port Map",
    "b": "• Ports 000H-0ffH are reserved for and used by the system board\n • Ports 100H-3ffH are decoded on the I/O bus for use by adapter cards\n • Ports 400H and up are not available on the system bus\n\n The following table summarizes I/O port usage for the PC/XT and AT.\n Individual ports covered in greater detail are marked with a hyperlink.\n Additional info is covered in I/O Port Detail. See Cables and Pin Outs\n for info on hardware connectors.\n\n AT PC/XT Description More Information\n▀▀▀▀▀▀▀ ▀▀▀▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n000-01f 000-00f DMA controller #1, 8237A-5. DMA Ports\n020-03f 020-021 Interrupt controller, 8259A. Int Controller\n040-05f 040-043 Timer 8253-5 (AT: 8254.2). Timer Ports\n 060-063 PPI (Programmable Peripheral Interface) PPI Ports\n keyboard, equipment switches, timer\n060-06f Keyboard controller 8042 AT Keyboard\n070-07f Real-time clock, CMOS Memory, NMI mask CMOS Memory\n080 manufacture's diagnostic checkpoint\n080-09f 080-083 DMA page register 74LS612 DMA Ports\n 0a0 NMI (Non-maskable Interrupt) mask\n0a0-0bf Interrupt Controller #2, 8259A\n0c0-0df DMA controller #2, 8237A-5 DMA Ports\n0f0-0ff Math Coprocessor\n\n102 PS/2 Programmable Option Select\n\n170-177 Hard disk (secondary) AT Hard Disk Ports\n1f0-1f7 Hard disk AT Hard Disk Ports\n200-207 200-20f Game I/O (joystick A/D port) Joystick Port\n 210-217 Expansion Box\n278-27f 278-27f Parallel Printer #2 (#3 with MDA) Printer Ports\n2c0-2df 2c0-2df EGA #2 EGA I/O Ports\n2e8-2ef Asynchronous Adapter Port #4 Serial Ports\n2f8-2ff 2f8-2ff Asynchronous Adapter Port #2 Serial Ports\n300-31f Prototype card\n 320-32f Hard disk XT Hard Disk Ports\n370-377 Diskette Controller (secondary) FDC Ports\n378-37f 378-37f Parallel Printer #1 (#2 with MDA) Printer Ports\n380-38f 380-38f Synchronous Data Link Control (SDLC)\n3a0-3af 3a0-3a9 Bisynchronous port #1\n\n3b0-3df 3b0-3df Video Graphics Array (VGA) VGA I/O Ports\n3b0-3bf 3b0-3bf Monochrome Display Adapter/Printer #1 Printer Ports\n3c0-3cf 3c0-3cf Enhanced Graphics Adapter (EGA) #1 EGA I/O Ports\n3d0-3df 3d0-3df Color/Graphics Adapter (CGA) and EGA CGA I/O Ports\n\n3f0-3f7 3f0-3f7 Diskette controller FDC Ports\n3ef-3ff Asynchronous Adapter Port #3 Serial Ports\n3f8-3ff 3f8-3ff Asynchronous Adapter Port #1 Serial Ports\n\nSee Also: I/O Port Detail\n BIOS Data Area\n Interrupts and BIOS Services\n Cables and Pin Outs\n -♦-"
  },
  {
    "id": "893-i_o_port_detail.html",
    "t": "I/O Port Detail",
    "b": "This detailed information covers some I/O ports that are not detailed\n elsewhere.\n\n Note: All IN and OUT examples are for 8-bit I/O\n (e.g., OUT 70H,0 really means MOV al,0; OUT 70H,al)\n\nPort Description\n▀▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n000H-\n01fH DMA (Direct Memory Access) controller See DMA Ports\n──── ──────────────────────────────────────────────────────────────────────\n020H-\n03fH Interrupt Controller. See Interrupt Controller Ports\n──── ──────────────────────────────────────────────────────────────────────\n040H-\n043H 8253 Timer chip. See Timer Ports\n──── ──────────────────────────────────────────────────────────────────────\n060H PC/XT (Programmable Peripheral Interface) port A. Read keyboard:\n IN al,60H ;fetches most recent scan code. See INT 09H\n See Scan Code\n AT keyboard data register. See AT Keyboard\n\n061H-\n063H PC/XT PPI Command/Mode Register. See PPI Ports.\n──── ──────────────────────────────────────────────────────────────────────\n064H AT keyboard command register. This port communicates with the 8042\n which runs an on-chip control program for the keyboard. It accepts\n command codes and data bytes.\n For commands and programming details, See AT Keyboard\n──── ──────────────────────────────────────────────────────────────────────\n070H AT register address (write-only) for Real-Time Clock and CMOS RAM.\n\n070H AT NMI mask. Use this port to mask the Non-maskable Interrupt.\n An OUT with bit 7=0 enables the NMI; with bit 7=1 disables NMI:\n OUT 70H,2dH ;enable NMI--2dH is a reserved addr in the CMOS Memory\n OUT 70H,0adH ;disable NMI\n──── ──────────────────────────────────────────────────────────────────────\n080H AT page register used during POST to accumulate errors\n──── ──────────────────────────────────────────────────────────────────────\n081H-\n08fH DMA page registers See DMA Ports\n──── ──────────────────────────────────────────────────────────────────────\n0a0H PC/XT NMI mask. Enable/disable Non-maskable Int (RAM parity err)\n OUT 0a0H,80H ;enable NMI\n OUT 0a0H,0 ;disable NMI\n──── ──────────────────────────────────────────────────────────────────────\n0c0H-\n0dfH AT DMA controller access to 16-bit DMA See DMA Ports\n──── ──────────────────────────────────────────────────────────────────────\n0f0H AT 80287 latch clear. 'Busy' gets latched upon an unmasked 287 error.\n OUT 0f0H,0 ;clears the latch\n\n0f1H AT 80287 Reset. Coprocessor is reset from protected mode to real mode\n OUT 0f1H,0 ;resets the 80287 to real mode\n\n0f8H-\n0fcH AT 80287 data. 286 sends opcodes & operands and receives results.\n──── ──────────────────────────────────────────────────────────────────────\n170H-\n177H AT hard disk controller #2 See AT Hard Disk Ports\n──── ──────────────────────────────────────────────────────────────────────\n1f0H-\n1f7H AT hard disk controller #1 See AT Hard Disk Ports\n──── ──────────────────────────────────────────────────────────────────────\n210H XT Expansion chassis control port\n213H XT Expansion chassis enable\n215H XT Expansion chassis data bus register\n215H XT Expansion chassis address register (high byte)\n216H XT (low byte)\n──── ──────────────────────────────────────────────────────────────────────\n278H-\n27fH Parallel Printer Adapter #2 See Printer Ports\n──── ──────────────────────────────────────────────────────────────────────\n2e8H-\n2efH Asynchronous Communications Adapter COM4. See Serial Ports\n──── ──────────────────────────────────────────────────────────────────────\n2f8H-\n2ffH Asynchronous Communications Adapter COM2. See Serial Ports\n──── ──────────────────────────────────────────────────────────────────────\n320H-\n32fH XT hard disk controller. See XT Hard Disk Ports\n──── ──────────────────────────────────────────────────────────────────────\n2c0H-\n2cfH Enhanced Graphics Adapter (EGA) #2. See EGA I/O Ports\n──── ──────────────────────────────────────────────────────────────────────\n378H-\n37fH Parallel Printer Adapter #1 See Printer Ports\n──── ──────────────────────────────────────────────────────────────────────\n3b4H- Monochrome Display Adapter (MDA) display control ports.\n3baH See CGA I/O Ports for a summary of usage of the 6854 CRT controller.\n The MDA has few capabilities beyond it's single standard display mode.\n──── ──────────────────────────────────────────────────────────────────────\n3bcH-\n3bdH Parallel Printer on MDA See Printer Ports\n──── ──────────────────────────────────────────────────────────────────────\n3b0H-\n3dfH Video Graphics Array (VGA) See VGA I/O Ports\n3c0H-\n3dfH Enhanced Graphics Adapter (EGA) See EGA I/O Ports\n3d2H-\n3dcH Color/Graphics Adapter (CGA) See CGA I/O Ports\n──── ──────────────────────────────────────────────────────────────────────\n3e8H- asynchronous communications adapter COM3.\n3efH See Serial Ports\n──── ──────────────────────────────────────────────────────────────────────\n3f0H-\n3f7H diskette drive controller (aka FDC) See FDC Ports\n──── ──────────────────────────────────────────────────────────────────────\n3f8H- asynchronous communications adapter COM1.\n3ffH See Serial Ports\n──── ──────────────────────────────────────────────────────────────────────\nSee Also: I/O Port Map\n BIOS Data Area\n Interrupts and BIOS Services\n Cables and Pin Outs\n -♦-"
  },
  {
    "id": "894-at_keyboard_functions.html",
    "t": "AT Keyboard Functions",
    "b": "The keyboard of the AT (and its Intel 8042 microcomputer interface) is\n programmable. You can set the key-repeat rate and delay and control the\n \"lock\" key LED display.\n\n The keyboard controller generates interrupt level 1 (IRQ 1) on each press\n and release of a key. IRQ 1 is vectored to INT 09H and handled by BIOS.\n\n Port 60H is for writing data and is maintained for compatibility with\n earlier models. If the examples using port 64H don't work, try using 60H.\n\n Port 64H is for writing commands and data and for reading keyboard status.\n Before sending a command to the keyboard, the BIOS tests its status\n (IN AL,64H) and makes sure a key isn't being pressed or the internal\n buffer isn't full, etc. There's a small risk if you just go ahead and\n send the command:\n\n mov al,cmd_code\n out 64H,al\n\n For a two-part command such as setting the typeamatic rate, it's wise to\n delay a little while between OUTs:\n\n mov al,cmd_code\n out 64H,al\n mov cx,2000H ;arbitrary\ndelay: loop delay\n mov al,data_value\n out 64H,al\n\nCmd Description\n▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n0ffH Reset the keyboard and start internal diagnostics\n0feH Resend the last transmission\n0fdH-0f7H (NOP)\n0f6H Set keyboard to defaults and continue scanning\n0f5H Set keyboard to defaults and disable keyboard scanning\n0f4H Enable keyboard. Kybd sends 'ACK', clears buffer, and starts scanning\n──── ───────────────────────────────────────────────────────────────────────\n0f3H Set typeamatic rate and delay. First send 0f3H, then send data byte:\n ╓7┬6┬5┬4┬3┬2┬1┬0╖\n ║0│dly│ reptRate║\n ╙╥┴─┴─┴─┴─┴─┴─┴─╜\n ║ ╚╦╝ ╚═══════╩═► bits 0-4 set the repeat rate (see below)\n ║ ╚════════════► bits 5-6 set initial delay before first repeat:\n ║ 00=250ms; 01=500ms; 10=750ms; 11=1000ms\n ╚═══════════════► bit 7 is always 0\n Value Rate Value Rate\n This chart is a partial guide for the repeat 0 = 30.0 0aH = 10.0\n rate (bits 0-4). You can interpolate for 1 = 26.7 0dH = 9.2\n values not shown, but let's face it, you're 2 = 24.0 10H = 7.5\n only interested in the fastest rates. 4 = 20.0 14H = 5.0\n 8 = 15.0 1fH = 2.0\n\n The keyboard is initially set to begin repeating after 1/2-second and\n repeat at 10 repeats per second. This is much too slow. A data byte\n of 01H sets the delay to 1/4-second with 26 repeats per second.\n See INT 16H 03H (set keyboard rate and delay)\n──── ───────────────────────────────────────────────────────────────────────\n0f2H-0efH (NOP)\n0eeH Echo. Diagnostics aid. Simply sends 0eeH right back.\n──── ───────────────────────────────────────────────────────────────────────\n0edH Turn LED 'lock key' lights on or off. First send 0edH, then send byte:\n ╓7┬6┬5┬4┬3┬2┬1┬0╖\n ║ not used│c│n│s║\n ╙─┴─┴─┴─┴─┴╥┴╥┴╥╜\n ║ ║ ╚═► ScrollLock light 01H=turn on\n ║ ╚═══► NumLock light 02H=turn on\n ╚═════► CapsLock light 04H=turn on\n\n The bit positions 0-3 correspond to bits 4-6 of the keyboard flags\n variable in the BIOS Data Area. You should make an effort to keep the\n flags in sync with the lights. For instance, if you do a big favor for\n the user and set his ten-key pad into NumLock mode (by setting bit 5 of\n 0:0417) then be sure to turn on the corresponding LED (e.g., bit 1).\n──── ───────────────────────────────────────────────────────────────────────\nSee Also: INT 16H (BIOS keyboard services)\n Keyboard Flags\n Keyboard Scan Codes\n Cables and Pin Outs\n BIOS Data Area\n I/O Port Map\n -♦-"
  },
  {
    "id": "895-asynchronous_adapter_ports.html",
    "t": "Asynchronous Adapter Ports",
    "b": "The BIOS Data Area contains a list of up to four COM port base addresses.\n During POST the older BIOSes tests for and initialize COM1 and COM2; newer\n ones also handle COM 3 and COM 4.\n\n ■ The COM1 adapter decodes ports 3f8H through 3ffH\n ■ The COM2 adapter decodes ports 2f8H through 2ffH\n ■ The COM3 adapter decodes ports 3e8H through 3efH\n ■ The COM4 adapter decodes ports 2e8H through 2efH\n\n The ROM BIOS INT 14H will work with any of the four ports, as long as you\n store the port's base address into the COMn port table starting at\n 0040:0000. It is critical that no two adapters share the same physical\n port addresses or neither will work.\n\n BIOS supports a simple polling-style serial I/O. The adapter is able to\n force a hardware interrupt on a variety of conditions, depending upon the\n values in the Interrupt Enable Register (3f9H or 2f9H).\n\n ■ COM1 forces interrupt level 4 (IRQ 4 is handled by INT 0cH vector)\n ■ COM2 forces interrupt level 3 (IRQ 3 is handled by INT 0bH vector)\n ■ COM3 shares IRQ4. BIOS checks the Int ID regs to see who rang\n ■ COM4 shares IRQ3. BIOS checks the Int ID regs to see who rang\n\n In the following chart, pb+n is one of 3f8H+n, 2f8H+n, 3e8H+n, 2e8H+n,\n depending upon the port. For instance, for COM1, pb+3=3fbH.\n\nPort Description\n▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\npb+0 Write: transmitter holding register. 8 bits of character to be sent.\n Read: receiver buffer register. 8 bits of character received.\n\n Write: (if DLAB=1) divisor latch low byte Baud Divisor▐▌Baud Divisor\n After OUT pb+3,80H this port holds ▀▀▀▀ ▀▀▀▀▀▀▀▐▌▀▀▀▀ ▀▀▀▀▀▀▀\n the low byte of the clock divisor 110 1040▐▌1200 96\n which, together with the high byte 150 768 ▐▌2400 48\n (port pb+1) constitute 16-bit value 300 384 ▐▌4800 24\n that sets the baud rate as shown: 600 192 ▐▌9600 12\n──── ───────────────────────────────────────────────────────────────────────\npb+1 Write: divisor latch high byte (when DLAB=1; i.e., after OUT pb+3,80H)\n Write: interrupt enable register\n ╓7┬6┬5┬4┬3┬2┬1┬0╖\n ║0 0 0 0│ │ │ │ ║\n ╙─┴─┴─┴─┴╥┴╥┴╥┴╥╜ bit\n ║ ║ ║ ╚═► 0: 1=enable interrupt when rec'd data is available\n ║ ║ ╚═══► 1: 1=enable interrupt when transmit buffer is empty\n ║ ╚═════► 2: 1=enable int on rec'r line status (err or break)\n ╚═══════► 3: 1=enable int on modem status (CTS,DSR,RI,RLSD)\n──── ───────────────────────────────────────────────────────────────────────\npb+2 Read: interrupt identification reg. When an interrupt occurs, read\n this register to find what caused it.\n ╓7┬6┬5┬4┬3┬2┬1┬0╖\n ║ │0 0│ │ │ ║\n ╙─┴─┴─┴─┴╥┴─┴─┴╥╜ bit\n ╚╦╝ ║ ╚╦╝ ╚═► 0: 1=no interrupt pending; can be used in polling\n ║ ║ ╚════►1-2: 00=receiver line status interrupt. Occurs on:\n ║ ║ overrun, parity, or framing error, or break\n ║ ║ Reset by reading line status (port pb+5)\n ║ ║ 01=received data available\n ║ ║ Reset by reading receiver buffer (port pb+0)\n ║ ║ 10=transmitter buffer empty\n ║ ║ Reset by writing transmitter buffer (pb+0)\n ║ ║ 11=modem status. Occurs upon:\n ║ ║ Clear To Send, Data Set Ready, Ring Ind, or\n ║ ║ Rec'd Line Signal Detect.\n ║ ║ Reset by reading modem status (port pb+6).\n ║ ╚═══════► 3: (16550 UARTs) 1=Receiver FIFO time-out\n ╚══════════════►6-7: (16550 UARTs) 00=FIFOs disabled (or old 8250)\n 11=FIFOs enabled\n 01=FIFOs enabled and DMA mode\n\n Write: (16550 UARTs) FIFO control register (write only)\n ╓7┬6┬5┬4┬3┬2┬1┬0╖\n ║ │0 0│ │ │ │ ║\n ╙─┴─┴─┴─┴╥┴╥┴╥┴╥╜ bit\n ╚╦╝ ║ ║ ║ ╚═► 0: 1=enable FIFO mode\n ║ ║ ║ ╚═══► 1: 1=clear receiver FIFO\n ║ ║ ╚═════► 2: 1=clear transmit FIFO\n ║ ╚═══════► 3: DMA mode select\n ╚══════════════►6-7: FIFO interrupt triggger level: 00=1 byte;\n 01=four bytes; 10=8 bytes; 11=16 bytes\n──── ───────────────────────────────────────────────────────────────────────\npb+3 Read/Write: line control register\n ╓7┬6┬5┬4┬3┬2┬1┬0╖\n ║ │ │ │par│s│len║\n ╙╥┴╥┴╥┴─┴─┴╥┴─┴─╜ bit\n ║ ║ ║ ╚╦╝ ║ ╚═╩═► 0-1: word length: 00=5, 01=6, 10=7, 11=8\n ║ ║ ║ ║ ╚═════► 2: stop bits: 0=1,1=2 (some oddball exceptions)\n ║ ║ ║ ╚══════► 3-4: parity: x0=None, 01=Odd, 11=Even\n ║ ║ ╚═══════════► 5: stuck parity (not used by BIOS)\n ║ ╚═════════════► 6: enable break control. 1=start sending 0s (spcs)\n ╚═══════════════► 7: DLAB (Divisor Latch Access Bit) Determines mode\n of ports pb+1 and pb+2. 1=set baud, 0=normal\n──── ───────────────────────────────────────────────────────────────────────\npb+4 Write: modem control register\n ╓7┬6┬5┬4┬3┬2┬1┬0╖\n ║0 0 0│ │ │ │ │ ║\n ╙─┴─┴─┴╥┴╥┴╥┴╥┴╥╜ bit\n ║ ║ ║ ║ ╚═► 0: 1=activate -DTR (-data trmnl rdy), 0=deactivate\n ║ ║ ║ ╚═══► 1: 1=activate -RTS (-request to send), 0=deactivate\n ║ ║ ╚═════► 2: 1=activate -OUT1 (spare, user-designated output)\n ║ ╚═══════► 3: 1=activate -OUT2\n ╚═════════► 4: 1=activate loopback for diagnostic testing\n──── ───────────────────────────────────────────────────────────────────────\npb+5 Read: line status register\n ╓7┬6┬5┬4┬3┬2┬1┬0╖\n ║ │ │ │ │ │ │ │ ║ Note: bits 1-4 cause interrupt if enabled (pb+1)\n ╙╥┴╥┴╥┴╥┴╥┴╥┴╥┴╥╜ bit\n ║ ║ ║ ║ ║ ║ ║ ╚► 0: 1=data ready (DR). Reset by reading recv'r buffer\n ║ ║ ║ ║ ║ ║ ╚══► 1: 1=overrun error (OE). Previous character is lost\n ║ ║ ║ ║ ║ ╚════► 2: 1=parity error (PE). Reset by reading line status\n ║ ║ ║ ║ ╚══════► 3: 1=framing error (FE). Bad stop bit in character\n ║ ║ ║ ╚════════► 4: 1=break indicated (BI). Sustained space received\n ║ ║ ╚══════════► 5: 1=transmitter holding register empty. OK to send\n ║ ╚════════════► 6: 1=transmitter empty. No data being processed.\n ╚══════════════► 7: (16450 UARTs) 1=Receiver FIFO error\n──── ───────────────────────────────────────────────────────────────────────\npb+6 Read: modem status register\n ╓7┬6┬5┬4┬3┬2┬1┬0╖\n ║ │ │ │ │ │ │ │ ║ Note: bits 0-3 cause an interrupt if enabled (pb+1)\n ╙╥┴╥┴╥┴╥┴╥┴╥┴╥┴╥╜ bit\n ║ ║ ║ ║ ║ ║ ║ ╚═► 0: 1=Delta Clear To Send (DCTS) has changed state\n ║ ║ ║ ║ ║ ║ ╚═══► 1: 1=Delta Data Set Ready (DDSR) has changed state\n ║ ║ ║ ║ ║ ╚═════► 2: 1=Trailing Edge Ring Indicator (TERI) is active\n ║ ║ ║ ║ ╚═══════► 3: 1=Delta Data Carrier Detect (DDCD) has changed\n ║ ║ ║ ╚═════════► 4: 1=Clear To Send (CTS) is active\n ║ ║ ╚═══════════► 5: 1=Data Set Ready (DSR) is active\n ║ ╚═════════════► 6: 1=Ring Indicator (RI) is active\n ╚═══════════════► 7: 1=Data Carrier Detect (DCD) is active\n──── ───────────────────────────────────────────────────────────────────────\npb+7 Read/Write scratch pad\n──── ───────────────────────────────────────────────────────────────────────\nSee Also: INT 14H (serial port I/O)\n BIOS Data Area\n Cables and Pin Outs\n I/O Port Map\n -♦-"
  },
  {
    "id": "896-diskette_controller_ports.html",
    "t": "Diskette Controller Ports",
    "b": "This describes I/O for the Floppy Disk Controller (FDC). The main\n component is the NEC µPD765 (or compatible FDC chip).\n\n The AT FDC is incorporated on the same card as its hard disk controller,\n but is compatible with the standard PC/XT FDC (except as noted below).\n The main differences are that the AT FDC is capable of multiple data rates\n but handles only two drives.\n\n ■ Diskette controller 1 decodes ports 3f0H through 3f7H\n ■ Diskette controller 2 decodes ports 370H through 377H (on AT only)\n\n The FDC generates interrupt level 6 (IRQ 6) after each operation (read,\n write, seek, recalibrate, etc.). IRQ 6 is vectored to INT 0eH and handled\n by BIOS.\n\nPort Description\n▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n3f2H Write: digital output register\n ╓7┬6┬5┬4┬3┬2┬1┬0╖\n ║D C B A│ │ │ ║\n ╙─┴─┴─┴─┴╥┴╥┴─┴─╜ bit\n ╚══╦══╝ ║ ║ ╚═╩═► 0-1: Drive to select 0-3 (AT: bit 1 not used)\n ║ ║ ╚═════► 2: 0=reset diskette controller; 1=enable controller\n ║ ╚═══════► 3: 1=enable diskette DMA and interrupts\n ╚══════════► 4-7: drive motor enable. Set bits to turn drive ON.\n (AT: bits 6-7 not used)\n──── ───────────────────────────────────────────────────────────────────────\n3f4H Read-only: main status register\n ╓7┬6┬5┬4┬3┬2┬1┬0╖\n ║ │ │ │ │D C B A║\n ╙╥┴╥┴╥┴╥┴─┴─┴─┴─╜ bit\n ║ ║ ║ ║ ╚═════╩═► 0: diskette drive busy (AT: bits 2-3 not used)\n ║ ║ ║ ╚═════════► 4: 1=controller busy (read or write in progress)\n ║ ║ ╚═══════════► 5: 1=non-DMA mode; 0=DMA mode active\n ║ ╚═════════════► 6: Data direction: 1=ctrlr to CPU; 0 = CPU═►FDC\n ╚═══════════════► 7: Req. for Master. 1=OK to send/recv cmd or data\n──── ───────────────────────────────────────────────────────────────────────\n3f5H Read/Write: FDC command/data register\n This port is used for all controller command operations. First, a\n command byte is output, then one or more data parameters are output.\n The operation is performed, then 0 or more inputs return the results.\n All of this I/O goes through this port and must take place in the\n correct sequence.\n\n This lists the commands used by BIOS for its standard functions, but\n it does not show the parameters that follow or values of the results.\n Sorry, but you'll need the Tech Ref if you want more information.\n\n Cmd Description\n ▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n e6H Read data (expects 8 parms to follow; 7 results when done)\n c5H Write data (expects 8 parms to follow; 7 results when done)\n 4dH Format track (expects 5 parms to follow; 7 results when done)\n 07H Recalibrate (expects 1 parm to follow; no results when done)\n 0fH Seek Track (expects 2 parms to follow; no results when done)\n──── ───────────────────────────────────────────────────────────────────────\n3f6H AT Write: fixed disk register (no information available)\n──── ───────────────────────────────────────────────────────────────────────\n3f7H AT Write: diskette control register\n ╓7┬6┬5┬4┬3┬2┬1┬0╖\n ║ │ ║\n ╙─┴─┴─┴─┴─┴─┴─┴─╜ bit\n ╚════╦════╝ ╚═╩═► 0-1: data transfer rate\n ║ 00=500 KBS, 01=300 KBS, 10=250 KBS, 11=res.\n ╚══════════► 2-7: I can't find anything about these\n\n Read: digital input register. Used for diagnostics (except bit 7)\n ╓7┬6┬5┬4┬3┬2┬1┬0╖\n ║c│ │ head │ │ ║\n ╙╥┴╥┴─┴─┴─┴─┴╥┴╥╜ bit\n ║ ║ ╚══╦══╝ ║ ╚═► 0: 1=select drive 0\n ║ ║ ║ ╚═══► 1: 1=select drive 1\n ║ ║ ╚══════► 2-5: Head select 0-3 (bit 2=hd 0, bit 3=hd 1, etc)\n ║ ╚═════════════► 6: Write Gate\n ╚═══════════════► 7: Change Line (1=diskette change line is ON)\n──── ───────────────────────────────────────────────────────────────────────\nSee Also: INT 13H (disk I/O)\n Device Drivers\n BIOS Data Area\n AT Hard Disk Ports\n XT Hard Disk Ports\n Cables and Pin Outs\n I/O Port Map\n -♦-"
  },
  {
    "id": "897-at_hard_disk_ports.html",
    "t": "AT Hard Disk Ports",
    "b": "The AT hard disk controller is incorporated onto the same adapter card as\n its diskette controller. Its I/O ports, commands, and status signals are\n different from those of the XT controller. See XT Hard Disk Ports for\n details.\n\n ■ AT Hard disk controller #1 decodes ports 1f0H through 1f7H\n ■ AT Hard disk controller #2 decodes ports 170H through 177H\n\n The controller generates interrupt level 14 (IRQ 14) after every operation\n (read, write, seek, etc.). IRQ 14 is vectored to INT 76H where an action\n flag bit is set at address 0:048e.\n\nPort Description\n▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n1f0H Data register. Read/write data from/to controller sector buffer\n──── ───────────────────────────────────────────────────────────────────────\n1f1H Write: Write Precompensation register. Turn on write precompensation.\n Read: Error register. Contains bits for last error.\n ╓7┬6┬5┬4┬3┬2┬1┬0╖\n ║ │ │0│ │0│ │ │ ║\n ╙╥┴╥┴─┴╥┴─┴╥┴╥┴╥╜ bit\n ║ ║ ║ ║ ║ ╚═► 0: Data Address Mark not found\n ║ ║ ║ ║ ╚═══► 1: Track 0 Error\n ║ ║ ║ ╚═════► 2: Command was aborted\n ║ ║ ╚═════════► 4: Sector ID not found\n ║ ╚═════════════► 6: ECC Error: Uncorrectable data error\n ╚═══════════════► 7: Bad block\n──── ───────────────────────────────────────────────────────────────────────\n1f2H Sector count. Read/Write count of sectors for operation\n──── ───────────────────────────────────────────────────────────────────────\n1f3H Sector number. Read/Write current/starting logical sector number\n──── ───────────────────────────────────────────────────────────────────────\n1f4H Cylinder high (bits 0-1 are bits 8-9 of 10-bit cylinder number)\n1f5H Cylinder low (bits 0-7 of 10-bit cylinder number)\n──── ───────────────────────────────────────────────────────────────────────\n1f6H Drive & Head. Read/Write: bits indicate head, drive for operation\n──── ───────────────────────────────────────────────────────────────────────\n1f7H Write: command register (Summary: see Tech Ref for full details)\n 1xH = Restore to cylinder 0 (low nibble is step rate)\n 7xH = Seek to cylinder (low nibble is step rate)\n 2xH = Read sector (low nibble indicates retry and ECC-read)\n 3xH = Write sector (low nibble indicates retry and ECC-read)\n 50H = Format track\n 4xH = verify read (low nibble indicates retry)\n 90H = diagnose\n 91H = set parameters (max heads,sectors) for selected drive\n\n1f7H Read: status register\n ╓7┬6┬5┬4┬3┬2┬1┬0╖\n ║ │ │ │ │ │ │ │ ║\n ╙╥┴╥┴╥┴╥┴╥┴╥┴╥┴╥╜ bit\n ║ ║ ║ ║ ║ ║ ║ ╚═► 0: 1=previous command ended in an error.\n ║ ║ ║ ║ ║ ║ ╚═══► 1: Index: set to 1 while index hole is detected\n ║ ║ ║ ║ ║ ╚═════► 2: Corrected data. Error found, but ECC fixed it.\n ║ ║ ║ ║ ╚═══════► 3: Data Request. Buffer is waiting for data (busy)\n ║ ║ ║ ╚═════════► 4: Seek completed\n ║ ║ ╚═══════════► 5: Write fault\n ║ ╚═════════════► 6: Drive ready for read/write/seek (unless bit 4=0)\n ╚═══════════════► 7: Busy. 1=executing cmd (other bits are invalid)\n──── ───────────────────────────────────────────────────────────────────────\nSee Also: INT 13H (disk I/O)\n Hard Disk Parameter Table\n Device Drivers\n BIOS Data Area\n Diskette Controller Ports\n XT Hard Disk Ports\n Cables and Pin Outs\n I/O Port Map\n -♦-"
  },
  {
    "id": "898-xt_hard_disk_ports.html",
    "t": "XT Hard Disk Ports",
    "b": "This describes the XT hard disk controller. It is similar to most of the\n non-IBM hard disk controllers which are used in PCs. However, there is no\n guarantee, especially considering that the AT uses a different setup all\n together. It is safest to let the system firmware mask the differences.\n\n ■ The XT hard disk controller decodes ports 320H through 327H\n\n The controller generates interrupt level 5 (IRQ 5) after every operation\n (read, write, seek, etc.). IRQ 5 is vectored to INT 0dH (which is also\n assigned as the seldom-used IRQ for LPT2). INT 0dH disables the Hard Disk\n DMA and returns.\n\nPort Description\n▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n320H Data register. Write commands, read status.\n Write: Always a series of bytes, written sequentially to this port.\n The first byte is a controller command and the following bytes\n (up to 5) describe head, cylinder, sector, and a control byte\n which has a variety of definitions, too numerous for this\n discussion.\n Read: When an error is sensed (port 321H, bit 1), you can write a\n Sense_Cmd sequence to this register, then read it four times to\n obtain everything the controller has to say. The first byte\n indicates the error. Better check the Tech Ref for this stuff.\n──── ───────────────────────────────────────────────────────────────────────\n321H Write: controller reset\n Output a byte of 00H to this port to reset the controller.\n Read: controller status register\n ╓7┬6┬5┬4┬3┬2┬1┬0╖\n ║ │d│ │e│ ║\n ╙─┴─┴╥┴─┴─┴─┴╥┴─╜ bit\n ║ ╚═══► 1: 1=error has occurred\n ╚═══════════► 5: logical unit number (drive 0 or drive 1)\n──── ───────────────────────────────────────────────────────────────────────\n322H Write: generate controller select pulse\n Any OUT to this port enables the controller. Use before a cmd.\n──── ───────────────────────────────────────────────────────────────────────\n323H Write: DMA and interrupt mask register\n ╓7┬6┬5┬4┬3┬2┬1┬0╖\n ║ not used │i│d║\n ╙─┴─┴─┴─┴─┴─┴╥┴╥╜ bit\n ║ ╚═► 0: 1=enable DMA, 0=don't use DMA\n ╚═══► 1: 1=enable interrupt after ctrlr command (IRQ 5)\n──── ───────────────────────────────────────────────────────────────────────\nSee Also: INT 13H (disk I/O)\n AT Hard Disk Ports\n Hard Disk Parameter Table\n Diskette Controller Ports\n Device Drivers\n BIOS Data Area\n Cables and Pin Outs\n I/O Port Map\n -♦-"
  },
  {
    "id": "899-enhanced_graphics_adapter_i_o_ports.html",
    "t": "Enhanced Graphics Adapter I/O Ports",
    "b": "The Enhanced Graphics Adapter is upwardly-compatible with the CGA when\n accessed through the BIOS. The EGA is far more complex at the hardware\n level, but it does include emulation of many CGA registers/operations\n (see CGA I/O Ports). This topic covers the EGA changes and extensions to\n CGA I/O usage.\n\n Perhaps the most significant change for an applications programmer is that\n you don't need to check for retrace when writing to the screen. The EGA\n will not allow \"video snow\" in any case.\n\n ■ EGA #1 decodes ports 3c0H through 3dfH\n ■ EGA #2 decodes ports 2c0H through 2dfH\n\n The EGA can generate interrupt level 2 (IRQ 2) during the overscan at the\n start of the vertical retrace. IRQ 2 is vectored to INT 0aH. If you use\n this interrupt, be aware that the AT uses IRQ 2 as a cascade request for a\n whole class of IRQs (IRQ 8-15) so the interrupt is handled at the INT 71H\n vector.\n\n Note: BIOS stores mirrors of the current CRTC port values and other EGA\n information in EGA Data Areas. To change values, you should read\n the appropriate variable, set the bit, perform the OUT, and store\n the new value in the variable.\n\nPort Description\n▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n3c0H Write: Attribute Controller (ATC) address and data port\n Perform IN al,3daH ;(or IN 3baH) to force address mode\n OUT 3c0H,reg_no ;select ATC register (go to data mode)\n OUT 3c0H,value ;store a value in an ATC register\n Note: bits 0-4: select an ATC register\n bit 5: 1=enable display; 0=set register\n\n After selecting a reg, perform another OUT 3c0H,data as below:\n\n ATC Reg Data description\n ▀▀▀▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n 00-0fH palette registers: select colors for this attribute\n ╓7┬6┬5┬4┬3┬2┬1┬0╖\n ║ │r│g│b│R│G│B║ Note: R,G,B are 2/3-intensity\n ╙─┴─┴╥┴╥┴╥┴╥┴╥┴╥╜ bit r,g,b are 1/3-intensity\n ║ ║ ║ ║ ║ ╚═► 0: Red\n ║ ║ ║ ║ ╚═══► 1: Green\n ║ ║ ║ ╚═════► 2: Blue\n ║ ║ ╚═══════► 3: blue' (also MDA-emulation undrln)\n ║ ╚═════════► 4: green' (also CGA-emul. intensity)\n ╚═══════════► 5: red'\n 10H mode control\n ╓7┬6┬5┬4┬3┬2┬1┬0╖\n ║ │ │ │ │ ║\n ╙─┴─┴─┴─┴╥┴╥┴╥┴╥╜ bit\n ║ ║ ║ ╚═► 0: 1=graphics modes, 0=text\n ║ ║ ╚═══► 1: 1=MDA attributes, 0=color attribs\n ║ ╚═════► 2: 1=9th dot=8th dot for line/box chrs\n ║ 0=use bkgd color as 9th dot of char\n ╚═══════► 3: 1=enable blink, 0=allow 4-bit bkgd\n 11H select overscan (border) clr. Same rgbRGB as palette regs\n 12H enable color planes\n ╓7┬6┬5┬4┬3┬2┬1┬0╖\n ║ │ │ ║\n ╙─┴─┴─┴─┴─┴─┴─┴─╜ bit\n ╚╦╝ ╚═════╩═► 0-3: bits enable color planes 0-3\n ╚══════════► 4-5: video status to multiplex\n 00=R&B, 01=b&G, 10=r&g, 11=unused\n 13H horizontal pixel panning\n Number of dots to shift data left. Bits 0-3 valid (0-0fH)\n──── ───────────────────────────────────────────────────────────────────────\n3c2H Write: miscellaneous control functions\n ╓7┬6┬5┬4┬3┬2┬1┬0╖\n ║ │ │ │ │ │ │ ║\n ╙╥┴╥┴╥┴╥┴─┴─┴╥┴╥╜ bit\n ║ ║ ║ ║ ╚╦╝ ║ ╚═► 0: 1=select 3BxH (emulate MDA); 0=select 3DxH (CGA)\n ║ ║ ║ ║ ║ ╚═══► 1: 1=enable RAM; 0=disable RAM\n ║ ║ ║ ║ ╚══════► 2-3: Dot clock: 00=14mHz; 01=16mHz; 10=external\n ║ ║ ║ ╚═════════► 4: 1=select feature output; 0=select internal\n ║ ║ ╚═══════════► 5: Page bit for odd/even mode\n ║ ╚═════════════► 6: Horizontal retrace polarity: 1=negative, 0=pos\n ╚═══════════════► 7: Vertical retrace polarity: 1=neg, 0=positive\n──── ───────────────────────────────────────────────────────────────────────\n3c4H Write: sequencer address register\n3c5H Write: sequencer data register\n Perform OUT 3c4H,reg_no; then OUT 3c5H,data\n\n Seq Reg Data description\n ▀▀▀▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n 00 sequencer reset.\n Bits 0-1 indicate asynchronous/synchronous reset.\n 01 clocking mode\n ╓7┬6┬5┬4┬3┬2┬1┬0╖\n ║ │ │ │ │ ║\n ╙─┴─┴─┴─┴╥┴╥┴╥┴╥╜ bit\n ║ ║ ║ ╚═► 0: 1=8 dots per char; 0=9 dots/char\n ║ ║ ╚═══► 1: CRT bandwidth: 1=low; 0=high\n ║ ╚═════► 2: 1=shift every char; 0=every 2nd chr\n ╚═══════► 3: dot clock: 1=halved; 0=normal\n 02 map mask: bits 0-3 enable writes to bit planes 0-3\n 03 character map select:\n bits 0-1 select Map B (for when attribute bit 3=0)\n bits 2-3 select Map A (for when attribute bit 3=1)\n 04 memory mode\n ╓7┬6┬5┬4┬3┬2┬1┬0╖\n ║ │ │ │ ║\n ╙─┴─┴─┴─┴─┴╥┴╥┴╥╜ bit\n ║ ║ ╚═► 0: 1=text char generator; 0=graphics\n ║ ╚═══► 1: 1=EGA ram > 64K; 0=64K\n ╚═════► 2: 1=sequential; 0=odd/even (like CGA)\n──── ───────────────────────────────────────────────────────────────────────\n3caH Write: graphics 2 position (must be 0 for EGA)\n──── ───────────────────────────────────────────────────────────────────────\n3ccH Write: graphics 1 position (must be 1 for EGA)\n──── ───────────────────────────────────────────────────────────────────────\n3ceH Write: graphics 1 and 2 address register\n3cfH Write: graphics controller data register\n Perform OUT 3ceH,reg_no; then OUT 3cfH,data\n\n GDC Reg Data description\n ▀▀▀▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n 00 set/reset. bits 0-3 select planes for write mode 00\n 01 enable set/reset\n 02 color compare. Bits 0-3 select color for read mode 01\n 03 data rotate and function select for write mode 00\n bits 0-2: set rotate count for write mode 00\n 3-4: fn select for write modes 00 and 02\n 00=no change; 01=AND; 10=OR; 11=XOR\n 04 read map select. Bits 0-2 select map # for read mode 00.\n 05 mode register\n ╓7┬6┬5┬4┬3┬2┬1┬0╖\n ║ │ │ │ │ │ ║\n ╙─┴─┴╥┴╥┴╥┴╥┴─┴─╜ bit\n ║ ║ ║ ║ ╚═╩═► 0-1: Write mode 0-2\n ║ ║ ║ ╚═════► 2: test condition\n ║ ║ ╚═══════► 3: read mode: 1=color cmpare, 0=direct\n ║ ╚═════════► 4: 1=use odd/even RAM addressing\n ╚═══════════► 5: 1=use CGA mid-res map (2-bits/pix)\n 06 miscellaneous graphics control\n ╓7┬6┬5┬4┬3┬2┬1┬0╖\n ║ │ │ │ ║\n ╙─┴─┴─┴─┴─┴─┴╥┴╥╜ bit\n ╚╦╝ ║ ╚═► 0: 1=graphics; 0=enable char gen (txt)\n ║ ╚═══► 1: 1=chain odd maps after even maps\n ╚══════► 2: memory mapping for CPU\n 00=a000H(128K)\n 01=a000H (64K)\n 10=b000H(32K MDA)\n 11=b800H (32K CGA)\n 07 color masking disable\n bits 0-3 disable planes from compare in read mode 01\n 08 bit mask. Bits 0-7 select bits to mask in all planes\n──── ───────────────────────────────────────────────────────────────────────\n3d4H or 3b4H CRT controller address\n──── ───────────────────────────────────────────────────────────────────────\n3d5H or 3b5H CRT controller internal registers\n Note: Port 3c0H bit 0 selects which port address-pair to use.\n (3bxH is normal for MDA; 3dxH is normal for CGA).\n Perform OUT 3x4H,reg_no; then OUT 3x5H,data\n\n CRTC Rg Data description\n ▀▀▀▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n 00-11H See Video Initialization Table\n and CGA I/O Ports. Exceptions:\n 02H start horizontal blanking (character count)\n 03H end horizontal blanking\n bits 0-4 are blank width; bits 5-6 are skew enable\n 04H start horizontal retrace (character position)\n 05H end horizontal retrace\n ╓7┬6┬5┬4┬3┬2┬1┬0╖\n ║ │ │ ║\n ╙╥┴─┴─┴─┴─┴─┴─┴─╜ bit\n ║ ╚╦╝ ╚═══════╩═► 0-4: horizontal retrace width\n ║ ╚════════════► 5-6: retrace delay 0-3 char-clocks\n ╚═══════════════► 7: 1=start panning on odd addr; 0=even\n 06H vertical total (scan lines)\n 07H bit 8 for certain CRTC registers\n ╓7┬6┬5┬4┬3┬2┬1┬0╖\n ║ │ │ │ │ │ │ ║\n ╙─┴─┴╥┴╥┴╥┴╥┴╥┴╥╜ bit\n ║ ║ ║ ║ ║ ╚═► 0: vertical total (CRTC Reg 06)\n ║ ║ ║ ║ ╚═══► 1: vert disp'd enable end (CRTC 12H)\n ║ ║ ║ ╚═════► 2: vertical retrace start (CRTC 10H)\n ║ ║ ╚═══════► 3: start vert blanking (CRTC Reg 15H)\n ║ ╚═════════► 4: line compare (CRTC Reg 18H)\n ╚═══════════► 5: cursor location (CRTC Reg 0aH)\n 08H preset row scan first scan line after vertical retrace\n 10H Write: vertical retrace start\n 11H Write: vertical retrace end\n ╓7┬6┬5┬4┬3┬2┬1┬0╖\n ║ │ │ │ ║\n ╙─┴─┴╥┴╥┴─┴─┴─┴─╜ bit\n ║ ║ ╚═════╩═► 0-3: retrace width in scan lines\n ║ ╚═════════► 4: 0=clear vertical interrupt\n ╚═══════════► 5: 0=enable vertical interrupt IRQ2\n 12H vertical displayed end (scan line)\n 13H vertical displayed adjustment\n 14H underline location. Bits 0-5 are scan line number.\n 15H start vertical blanking (scan line)\n 16H end vertical blanking\n 17H mode control\n ╓7┬6┬5┬4┬3┬2┬1┬0╖\n ║ │ │ │ │ │ │ │ ║\n ╙╥┴╥┴╥┴╥┴╥┴╥┴╥┴╥╜ bit\n ║ ║ ║ ║ ║ ║ ║ ╚═► 0: 0=CGA graphics addr compatible mode\n ║ ║ ║ ║ ║ ║ ╚═══► 1: select row scan counter\n ║ ║ ║ ║ ║ ╚═════► 2: horiz retrace: 1=double vert. res.\n ║ ║ ║ ║ ╚═══════► 3: 1=use char clock/2 for word refresh\n ║ ║ ║ ╚═════════► 4: 1=force high impedance on output\n ║ ║ ╚═══════════► 5: address wrapping mode\n ║ ╚═════════════► 6: 1=byte addressing mode; 0=word mode\n ╚═══════════════► 7: 0=hardware reset; 1=normal ops\n 18H line compare (scan line) Used in split screen operations\n──── ───────────────────────────────────────────────────────────────────────\n3daH or 3baH Write: bits 0-1 control Feature Control outputs FC0 and FC1\n Note: Port 3c0H bit 0 selects which port address to use.\n\n Read: status bits are same as MDA (port 3baH) or CGA (port 3daH)\n ╓7┬6┬5┬4┬3┬2┬1┬0╖\n ║ │ │ │ │ ║\n ╙─┴─┴─┴─┴╥┴╥┴╥┴╥╜ bit\n ║ ║ ║ ╚═► 0: retrace. 1=display is in vert or horiz retrace.\n ║ ║ ╚═══► 1: 1=light pen is triggered; 0=armed\n ║ ╚═════► 2: 1=light pen switch is open; 0=closed\n ╚═══════► 3: 1=vertical sync pulse is occurring.\n Note: With EGA, you don't need to synchronize with retrace\n when writing to video RAM.\n──── ───────────────────────────────────────────────────────────────────────\n3ddH or 3bbH Write: light pen latch reset. Any OUT clears the latch.\n──── ───────────────────────────────────────────────────────────────────────\n3dcH or 3bcH Write: light pen latch set. Any OUT arms the latch.\n──── ───────────────────────────────────────────────────────────────────────\nSee Also: VGA I/O Ports\n CGA I/O Ports\n EGA/VGA Data Areas\n INT 10H (BIOS video services)\n I/O Port Map\n Cables and Pin Outs\n -♦-"
  },
  {
    "id": "900-video_graphics_array_i_o_ports.html",
    "t": "Video Graphics Array I/O Ports",
    "b": "The VGA is upwardly-compatible with the CGA, MDA, and EGA in that all\n commonly-used I/O activities are emulated at the expected port addresses.\n\n Video programming at the hardware port level has become increasingly\n difficult and risky while the BIOS programming interface has become\n flexible and comprehensive. It is recommended that you use the BIOS\n functions when possible. See INT 10H (video services).\n\n The following table lists ports and indexes for the VGA without providing\n full details. Since the VGA uses the same port range as the EGA, you may\n refer to EGA I/O Ports and CGA I/O Ports for related information.\n\nPort Description\n▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n3c0H Attribute Address Register (read/write)\n──── ───────────────────────────────────────────────────────────────────────\n3c0H Palette Registers / Other Attribute Registers (write)\n Index: 00H∙∙∙0fH Palette registers\n 10H mode control\n 11H overscan (border) color\n 12H enable color planes\n 13H horizontal pixel panning\n 14H color select register\n──── ───────────────────────────────────────────────────────────────────────\n3c1H Palette Registers (read)\n──── ───────────────────────────────────────────────────────────────────────\n3c2H Miscellaneous Output Register (write)\n──── ───────────────────────────────────────────────────────────────────────\n3c2H Input Status Register 0 (read)\n──── ───────────────────────────────────────────────────────────────────────\n3c3H VGA Enable Register (read/write)\n──── ───────────────────────────────────────────────────────────────────────\n3c4H Sequencer Address Register (read/write)\n──── ───────────────────────────────────────────────────────────────────────\n3c5H Other Sequencer Registers (read/write)\n Index: 00H reset\n 01H Clocking Mode\n 02H Map Mask\n 03H Character Map Select\n 04H Memory Mode\n──── ───────────────────────────────────────────────────────────────────────\n3c6H PEL Mask Register\n──── ───────────────────────────────────────────────────────────────────────\n3c7H PEL Address Register for Read Mode (write)\n──── ───────────────────────────────────────────────────────────────────────\n3c7H DAC State Register (read)\n──── ───────────────────────────────────────────────────────────────────────\n3c8H PEL Address Register for Write Mode (read)\n──── ───────────────────────────────────────────────────────────────────────\n3c9H PEL Data Register\n──── ───────────────────────────────────────────────────────────────────────\n3caH Feature Control Register (read)\n──── ───────────────────────────────────────────────────────────────────────\n3ccH Miscellaneous Output Register (read)\n──── ───────────────────────────────────────────────────────────────────────\n3ceH Graphics Address Register\n──── ───────────────────────────────────────────────────────────────────────\n3cfH Other Graphics Registers\n Index: 00H set/reset\n 01H enable set/reset\n 02H color compare\n 03H data rotate\n 04H read map select\n 05H graphics mode register\n 06H miscellaneous graphics control\n 07H color don't care\n 08H plane bit mask\n──── ───────────────────────────────────────────────────────────────────────\n3?4H CRT controller address (3b4H=MDA emulation, 3d4H=CGA emulation)\n3?5H CRT controller internal registers\n Index: 00H horizontal total\n 02H start horizontal blanking (character count)\n 03H end horizontal blanking\n 04H start horizontal retrace (character position)\n 05H end horizontal retrace\n 06H vertical total (scan lines)\n 07H overflow (bit 8 for certain CRTC registers)\n 08H preset row scan; first scan line after vertical retrace\n 09H maximum scan line\n 0aH cursor start\n 0bH cursor end\n 0cH regen start address (high)\n 0dH regen start address (low)\n 0eH Cursor location (high)\n 0fH Cursor location (low)\n 10H vertical retrace start\n 11H vertical retrace end\n 12H vertical displayed end (scan line)\n 13H vertical displayed adjustment\n 14H underline location. Bits 0-5 are scan line number.\n 15H start vertical blanking (scan line)\n 16H end vertical blanking\n 17H mode control\n 18H line compare (scan line) Used for split screen\n──── ───────────────────────────────────────────────────────────────────────\n3?aH Feature Control Register (write) (3baH=mono emulation, 3daH=CGA emul.)\n──── ───────────────────────────────────────────────────────────────────────\n3?aH Input Status Register 1 (read)\n──── ───────────────────────────────────────────────────────────────────────\nSee Also: EGA I/O Ports\n CGA I/O Ports\n EGA/VGA Data Areas\n INT 10H (BIOS video services)\n I/O Port Map\n Cables and Pin Outs\n -♦-"
  },
  {
    "id": "901-color_graphics_adapter_i_o_ports.html",
    "t": "Color/Graphics Adapter I/O Ports",
    "b": "This describes the I/O control ports for the Color/Graphics Adapter. The\n CGA is built around the Motorolla 6845 CRT controller chip.\n\n ■ The CGA decodes ports 3d0H through 3dfH (actually using 3d2H-3dcH)\n\n Note: These ports overlap the EGA I/O Ports for upward compatibility.\n With some exceptions, the CGA information applies to the EGA.\n\n An early Tech Ref indicated that the CGA could force hardware interrupt\n level 2 (IRQ 2) upon vertical retrace. However, the CGA has never had\n this ability (but EGA/VGA supports this feature).\n\n Note: BIOS stores \"mirrors\" of the current CRTC port values in the\n BIOS Data Area. To change a single bit, you should read the\n appropriate variable, set the bit, perform the OUT, and store the\n new value in the variable.\n\nPort Description\n▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n3d4H Write: CRT Controller register select. Use this port to select any of\n the 18 CRTC registers. Do an OUT 3d4H,reg_no followed by a read from\n or write to port 3d5H.\n──── ───────────────────────────────────────────────────────────────────────\n3d5H CRT Controller registers. After selecting via port 3d4H, output or\n input here to access the CRTC internal registers.\n\n Write: See Video Initialization Table for a summary of the CRTC\n registers and a way to look up standard BIOS settings for the\n display modes.\n\n Read: Registers R12 through R17 can be read to determine the current\n video page address, cursor address, and light pen information.\n──── ───────────────────────────────────────────────────────────────────────\n3d8H Write: Mode Select Register (BIOS keeps current value at 40:0065)\n ╓7┬6┬5┬4┬3┬2┬1┬0╖\n ║ │b│r│v│c│g│w║\n ╙─┴─┴╥┴╥┴╥┴╥┴╥┴╥╜ bit\n ║ ║ ║ ║ ║ ╚═► 0: width (text modes): 0=40 clms; 1=80 clms\n ║ ║ ║ ║ ╚═══► 1: 1=enable graphics modes; 0=text modes\n ║ ║ ║ ╚═════► 2: 1=disable color burst on composite monitor\n ║ ║ ╚═══════► 3: 1=enable video signal; 0=disable (all black)\n ║ ╚═════════► 4: dot resolutn: 0=320 2-bit dots; 1=640 1-bit dots\n ╚═══════════► 5: enable blink: 1=text attribute bit 7 blinks fgnd\n 0=attr bit 7 is bkgd intensity\n──── ───────────────────────────────────────────────────────────────────────\n3d8H Write: Color Select Register\n ╓7┬6┬5┬4┬3┬2┬1┬0╖\n ║ │b│i│I│R│G│B║\n ╙─┴─┴╥┴╥┴─┴─┴─┴─╜ bit\n ║ ║ ╚═════╩═► 0-3: color. Text modes: IRGB of border\n ║ ║ Graphics modes: IRGB of background\n ║ ╚═════════► 4: intensity. Text: bkgd intensity\n ║ Mid-res graphics: pixel intensity\n ╚═══════════► 5: blue. Select grafx palette 0 or 1 (1 adds blue)\n──── ───────────────────────────────────────────────────────────────────────\n3daH Read: Status Register\n ╓7┬6┬5┬4┬3┬2┬1┬0╖\n ║ │ │ │ │ ║\n ╙─┴─┴─┴─┴╥┴╥┴╥┴╥╜ bit\n ║ ║ ║ ╚═► 0: retrace. 1=display in vert or horiz retrace.\n ║ ║ ╚═══► 1: 1=light pen trigger is triggered; 0=armed\n ║ ╚═════► 2: 1=light pen switch is open; 0=closed\n ╚═══════► 3: 1=vertical sync pulse is occurring. Display is\n in vertical retrace--access won't cause \"snow\"\n──── ───────────────────────────────────────────────────────────────────────\n3dbH Read/Write: Light Pen Latch Reset. Any OUT clears light pen latch.\n3dcH Read/Write: Light Pen Latch Set. Any OUT sets the light pen latch.\n──── ───────────────────────────────────────────────────────────────────────\nSee Also: EGA I/O Ports\n VGA I/O Ports\n BIOS Data Area\n Video Initialization Table\n INT 10H (BIOS video services)\n I/O Port Map\n Cables and Pin Outs\n -♦-"
  },
  {
    "id": "902-game_i_o_adapter_port.html",
    "t": "Game I/O Adapter Port",
    "b": "Port 201H is designated as the Game Adapter Port or Joystick Port. It is\n not supported by the PC/XT BIOS, but AT BIOS service INT 15H 84H provides\n an easy-to-use interface for the adapter.\n\n It is an analog-to-digital converter which can be used by scientific\n measuring tools and other devices which present an analog (resistive)\n input to the interface. It accepts up to four digital inputs (on/off data\n such as the press of a button) and up to four resistive inputs (such as an\n X-ordinate of a joystick or a temperature value from an electronic\n thermometer).\n\n The value obtained by an IN from 201H is as diagrammed:\n\n ╓─7┬─6┬─5┬─4╥─3┬─2┬─1┬─0╖\n ║B2│B1│A2│A1║By│Bx│Ay│Ax║\n ╙──┴──┴──┴──╨──┴──┴──┴──╜\n ╚════╦════╝ ╚═════════╩═► Coordinates (resistive, time-dependent inputs)\n ╚══════════════════► Buttons/Triggers (digital inputs)\n\n You can read the buttons (digital inputs) with:\n\n mov dx,201H\n out dx,al ;initiate transaction; AL=anything\n in al,dx ;read bits 4-7 for buttons: 0=pressed, 1=open\n\n The joysticks, paddles, measuring devices (resistive inputs) are read by\n tracking the time that an X or Y bit stays high (1) after an OUT 201,xxx.\n To read an individual resistive input (e.g., joystick A, X ordinate):\n\n mov dx,201H\n out dx,al ;initiate transaction AL=anything\n mov cx,-1 ;set resistance counter for first loop\n again: in al,dx ;read the settings\n inc cx ;bump counter\n test al,1 ;has X-ordinate for joystick A gone low?\n jnz again ;loop until it does (when bit=0, we're done)\n\n The delay value accumulated in CX will indicate the X-ordinate position of\n joystick A. The resulting value is CPU-dependent. To ensure accuracy, it\n would be better to use a hardware timer, rather than a loop counter.\n\nSee Also: INT 15H 84H (joystick support)\n I/O Port Map\n -♦-"
  },
  {
    "id": "903-pc_sounds___speaker_support.html",
    "t": "PC Sounds / Speaker Support",
    "b": "PC compatibles have a built-in capability to make sounds and music via the\n small speaker attached to the system board. This feature is very limited,\n but creative programmers have performed miracles in the past, producing\n beeps and squawks for games and even producing recognizable speech.\n\n█▌BIOS Support▐█\n The only BIOS-supported sound can be produced via INT 10H 0eH (Write\n Character as TTY), passing AL=07H, to output a standard beep.\n\n█▌Hardware Control▐█\n The speaker is connected to PPI port B, port 61H (see PPI Ports). Set\n bit 1 to pulse the speaker out and clear bit 1 it to bring the speaker\n back to normal. For instance,\n\n in al,61H ;get current value\n\n again: or al,02H ;set bit 2 to pulse it out\n out 61H, al\n\n mov cx,1000H\n delay: loop delay ;wait a little while\n\n and al,0fdH ;clear bit 2 to pulse it back in\n out 61H, al\n jmp again\n\n By pulsing it in and out at a given frequency, a specific tone is\n produced. The above example produces various tones, depending upon\n the speed of the CPU.\n\n For better control, you can use the PC internal timer to pulse it of and\n on at a given frequency. Timer channel 2 can be gated directly to the\n speaker. To make a specific tone:\n\n 1) Program timer channel 2 to output a square-wave pulse at the desired\n frequency by writing b6H to port 43H. Then output a divisor word to\n port 42H (do that by writing first the low then the high byte -- see\n Timer Ports).\n\n The divisor word is a 16-bit value which, when divided into the\n timer's frequency (1.19318 MHz), selects the desired output\n frequency. For instance, middle C has a frequency of about 261 Hz.\n To obtain that output, use a divisor of 4560 (1,193,180/261 = 4560).\n\n 2) Enable the speaker by setting bit 1 of I/O port 61H.\n\n 3) Gate the channel-2 timer output into the speaker by setting bit 0 of\n I/O port 61H.\n\n 4) After a while (say, half of a second), disable the speaker by\n clearing bits 0-1 of I/O port 61H.\n\n Step 4, above, determines the duration of the tone. The standard way to\n set the duration is by watching the tick count at 0040:006c in the\n BIOS Data Area and counting the number of 55ms-interval that occur. The\n timer-tick interrupt occurs 18.2 times per second, so (for instance) 9\n timer ticks occur in about 1/2 of a second.\n\n On ATs, a more accurate duration can be obtained by using the BIOS timer\n support. See INT 15H 86H and INT 15H 8300H. Another way to improve\n accuracy has been used in the past by the orginal PC's BASIC: It sped up\n the standard timer tick by a factor of four whenever music was being\n played.\n\n█▌Example▐█\n For instance...\n\n mov al, 0b6H\n out 43H, al\n mov al, 0d0H ;low-byte of divisor (11d0H = 4560 = middle C)\n out 42H, al\n mov al, 11H ;high-byte of divisor word\n out 42H, al\n\n in al, 61H ;get current value of PPI\n or al, 03H ;send timer output to speaker and enable speaker\n out 61H, al\n\n mov cx, 0007H ;high-word for AT INT 15H (wait) service\n mov dx, 0a120H ;low-word (0007a120H = 500,000ms = 1/2-second)\n mov ah, 86H\n int 15H ;see INT 15H 86H (wait)\n\n in al, 61H ;get current value of PPI\n and al, 0fcH ;clear bits 0 and 1\n out 61H, al ;turn off the speaker\n\n ...plays middle C for one half of a second.\n\nSee Also: Timer Ports\n I/O Port Map\n -♦-"
  },
  {
    "id": "904-timer_ports.html",
    "t": "Timer Ports",
    "b": "Ports 40H-43H control the PC timer circuits. There are three timer\n channels:\n\n 0) Channel 0 is used as a general system timer. It handles the periodic\n \"timer-tick\". It is initialized by the BIOS to invoke INT 08H\n (IRQ 0) 18.206 times per second (once every 54.936 milliseconds).\n\n 1) Channel 1 is used in a dedicated manner to support the memory refresh\n function. The output is used to generate a direct-memory access\n (DMA) cycle request on DMA channel 0. This DMA channel is used to\n refresh the systems RAM by performing a dummy memory-read every so\n often (once every 15 microseconds on the original PC).\n\n This is critical to system operation, so we are usually advised to\n keep \"hands off\". However, I have seen experiments in which this\n timer was slowed down a bit in order to increase overall system\n performance by a few percent. Too slow of a value eventually causes\n fatal memory errors.\n\n 2) Channel 2 is used to drive the audio speaker on the system board (it\n originally handled cassette-tape I/O, but that is surely moot). The\n output of channel 2 can be directed to control the speaker via I/O\n port 61H (see PPI Ports and Speaker Control).\n\n Channel 2 is available for application-controlled timing tasks;\n however, it is a global resource. Rather than using direct port I/O\n you are advised to use fns such as INT 1aH and INT 15H 86H for timed\n operations.\n\nPort Description\n▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n 40H Read/Write: Count value for counter 0\n Port 43H bits 4-5 control the way the counter is set.\n 41H Read/Write: Count value for counter 1\n 41H Read/Write: Count value for counter 2\n──── ───────────────────────────────────────────────────────────────────────\n 43H Write: set channel's mode of operation\n ╓7┬6┬5┬4┬3┬2┬1┬0╖\n ║ch#│r/l│mode │ ║\n ╙─┴─┴─┴─┴─┴─┴─┴╥╜ bits mask\n └╥┘ └╥┘ └─╥─┘ ╚═► 0: 01H 0=process count as binary\n ║ ║ ║ 1=process counts as BCD▲\n ║ ║ ╚═════►1-3: 0eH select timer mode:\n ║ ║ 000 = mode 0: interrupt on terminal count\n ║ ║ 001 = mode 1: programmable one-shot\n ║ ║ x10 = mode 2: rate generator\n ║ ║ x11 = mode 3: square-wave rate generator\n ║ ║ 100 = mode 4: software-triggered strobe\n ║ ║ 101 = mode 5: hardware-triggered strobe\n ║ ╚══════════►4-5: 30H select read/load sequence:\n ║ 00 = latch counter for stable read\n ║ 01 = read/load most significant byte only\n ║ 10 = read/load least significant byte only\n ║ 11 = read/load LSB then MSB\n ╚══════════════►6-7: c0H specify counter to affect:\n 00 = counter 0, 01= counter 1\n 10 = counter 2, 11= counter 3\n\nSee Also: Speaker Control\n PPI Ports\n I/O Port Map\n -♦-"
  },
  {
    "id": "905-interrupt_controller_ports.html",
    "t": "Interrupt Controller Ports",
    "b": "Ports 20H-21H are decoded by the PC's 8259A Interrupt Controller chip.\n This controller is initialized by the BIOS and there is rarely any need to\n perform I/O to these ports in application programs.\n\n The only common exception is seen when a program intercepts an IRQ\n interrupt (INT 08H-0fH) and does not pass control on to the normal INT\n handler. For instance, when a TSR traps a keystroke via INT 09H, you may\n need to send an \"End-of-Interrupt\" to the 8259. In most cases, it is wise\n to simply pass control down the line to the original interrupt handler and\n let it handle such housekeeping chores.\n\n In the following, the ICWs are Initialization Control Words. These are\n output in a particular order during system startup by the BIOS. The OCWs\n are Operation Control Words which may be output by IRQ handlers.\n\nPort Description\n▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n 20H ICW1 First control word initialization sequence\n ╓7┬6┬5┬4┬3┬2┬1┬0╖\n ║0 0 0│1│ │ │ │ ║\n ╙─┴─┴─┴╥┴╥┴╥┴╥┴╥╜ bits mask\n ║ ║ ║ ║ ╚═► 0: 01H (IC4) 1=init sequences will include ICW4\n ║ ║ ║ ╚═══► 1: 02H (SNGL) 0=cascaded ctrlrs; 1=single ctrlr\n ║ ║ ╚═════► 2: 04H (ADI) not used; set to 0 on PC\n ║ ╚═══════► 3: 08H (LTIM) 0=edge-triggered; 1=level-triggered\n ╚═════════► 4: 10H must be 1 (indicates this is ICW1)\n\n 21H ICW2 Second control word in initialization sequence\n ╓7┬6┬5┬4┬3┬2┬1┬0╖\n ║ │0 0 0║\n ╙─┴─┴─┴─┴─┴─┴─┴─╜ bits mask\n └───╥───┘\n ╚══════════► 3-7: f8H high-order bits of interrupt table addr\n\n 21H ICW3 Third control word in initialization sequence; not actually\n used since bit 4 is set in ICW1.\n\n 21H ICW4 Fourth control word initialization sequence (actually 3rd in PC)\n ╓7┬6┬5┬4┬3┬2┬1┬0╖\n ║0 0 0│1│ │ │ │ ║\n ╙─┴─┴─┴╥┴╥┴╥┴╥┴╥╜ bits mask\n ║ ║ ║ ║ ╚═► 0: 01H (uPM) 1=PC/8088 mode\n ║ ║ ║ ╚═══► 1: 02H (AEIO) 1=automatic EOI\n ║ ║ ║ 0=must send EOI at end of int\n ║ ║ ╚═════► 2: 04H (M/S) 0=master mode; 1=slave/cascade mode\n ║ ╚═══════► 3: 08H (BUF) 1=this is a buffered bus\n ╚═════════► 4: 10H (SFNM) 1=ctrlrs are nested in this system\n──── ───────────────────────────────────────────────────────────────────────\n 21H OCW1 Read/Write: Get/Set Interrupt Mask\n Each bit corresponds to an IRQ; a 1-enables that IRQ and a\n 0 masks it.\n\n 20H OCW2 Write: Change IRQ priority; set EOI mode\n ╓7┬6┬5┬4┬3┬2┬1┬0╖\n ║ cmd │0 0│level║\n ╙─┴─┴─┴─┴─┴─┴─┴─╜ bits mask\n └─╥─┘ ╚═══╩═► 0: 07H specifies level (0-7) to be acted upon\n ║ by command in bits 5-7\n ╚═════════════► 4: e0H one of the commands:\n 000 = rotate in automatic EOI (clear)\n 001 = non-specific End Of Interrupt\n 010 = no operation\n 011 = specific End Of Interrupt\n 100 = rotate in automatic EOI (set)\n 101 = rotate on non-specific EOI\n 110 = set priority\n 111 = rotate on specific EOI command\n Note: The command most commonly sent is 20H to port 20H (that is, the\n non-specific End of Interrupt command). You would use this\n after assuming control of an IRQ such as INT 09H (kybd int).\n\n 20H OCW3 Write: Select Status Read Mode\n ╓7┬6┬5┬4┬3┬2┬1┬0╖\n ║0│ │0 1│ │rmd║\n ╙─┴─┴─┴─┴─┴╥┴─┴─╜ bits mask\n └╥┘ ║ ╚═╩═►0-1: 03H selects register read mode:\n ║ ║ 00=nop; 01=nop\n ║ ║ 10=read IR register on next read cmd\n ║ ║ 11=read IS register on next read cmd\n ║ ╚══════► 2: 04H 1=poll command; 0=no poll command\n ╚═════════════►5-6: 60H special mask mode:\n 00=nop; 01=nop\n 10=reset special mask\n 11=set special mask\n\n 20H or\n 21H Read: A read of either of these ports returns the status of the\n controller.\n\nSee Also: I/O Port Map\n -♦-"
  },
  {
    "id": "906-programmable_peripheral_interface__ppi__ports.html",
    "t": "Programmable Peripheral Interface (PPI) Ports",
    "b": "Ports 60H-63H are decoded by the PC's 8255A Programmable Peripheral\n Interface chip. These ports control the keyboard and timers and contain\n configuration information collected during the POST.\n\nPort Description\n▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n060H Read keyboard:\n IN al,60H ;fetches most recent scan code. See INT 09H\n See Scan Code\n AT keyboard data register. See AT Keyboard\n (Note: AT Keyboard register duplicated at port 64H)\n\n061H PPI port B.\n ╓7┬6┬5┬4┬3┬2┬1┬0╖\n ║ │ │ │ │ │0│ │ ║\n ╙╥┴╥┴╥┴╥┴╥┴─┴╥┴╥╜ bit mask\n ║ ║ ║ ║ ║ ║ ╚═► 0: 01H gate timer channel 2 to speaker\n ║ ║ ║ ║ ║ ╚═══► 1: 02H pulse speaker 1=out, 0=in\n ║ ║ ║ ║ ║ (see Speaker Control for examples)\n ║ ║ ║ ║ ╚═══════► 3: 04H 1=read high switches;\n ║ ║ ║ ║ 0=read low ones (see 62H)\n ║ ║ ║ ╚═════════► 4: 10H 0=enable RAM parity checking; 1=disable\n ║ ║ ╚═══════════► 5: 20H 0=enable I/O channel check\n ║ ╚═════════════► 6: 40H 0=hold keyboard clock low\n ╚═══════════════► 7: 80H 0=enable keyboard; 1=disable keyboard\n\n062H PPI port C.\n ╓7┬6┬5┬4┬3┬2┬1┬0╖\n ║ │ │ │0│equipmt║\n ╙╥┴╥┴╥┴─┴─┴─┴─┴─╜ bit\n ║ ║ ║ ╚═════╩═► 0-3: DIP switch values. See Equipment List\n ║ ║ ╚═══════════► 5: 1=Timer 2 channel out\n ║ ╚═════════════► 6: 1=I/O channel check\n ╚═══════════════► 7: 1=RAM parity check error occurred.\n\nSee Also: Speaker Control\n I/O Port Map\n -♦-"
  },
  {
    "id": "907-parallel_printer_adapter_ports.html",
    "t": "Parallel Printer Adapter Ports",
    "b": "The ROM-BIOS supports up to three parallel printer ports which are\n assigned as LPT1-LPT3. During POST the BIOS tests these ports in this\n order:\n\n 1) 3bcH Port found on Monochrome Display / Printer Adapter\n 2) 378H printer port adapter #1\n 3) 278H printer port adapter #2\n\n It assigns the ports as LPT1-LPT3, as they are discovered and stores the\n port addresses that respond starting at 0040:08. See BIOS Data Area.\n\n BIOS service INT 17H provides full printer support for up to 4 parallel\n printers. To add a forth printer, you would need to place its base\n address into the BIOS data word at 0040:0010.\n\n You can trick the system into thinking that one printer is another. It is\n a simple matter of swapping base port addresses in low memory:\n\n ;─────── this example swaps LPT1 for LPT2\n mov ax,0\n mov ds,ax\n mov si,0408H ;point to start of printer table at 0:0408\n mov ax,[si] ;get base port for LPT1\n xchg ax,[si+2] ;swap with port for LPT2\n mov [si],ax ;and put old LPT2 into LPT1 spot\n\n█▌Bidirectional I/O▐█\n PS/2s and many later parallel-port adapters support high-speed\n bidirectional I/O. In this \"extended mode\", you can set bit 5 of p+2\n (e.g., 37aH) and then read data via IN p+0 (e.g., 378H).\n\n The BIOS does not provide support for bidirectional I/O.\n\nPort Description\n▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n378H-\n37fH Parallel Printer Adapter #1\n 3bcH is base of MDPA\n 278H is base of printer adapter #2\n──── ───────────────────────────────────────────────────────────────────────\n378H Data Latch\n Write: send byte to printer\n Read: (PC/XT/old: Fetch last byte sent\n Bidirectional: Read byte from connected device (when bit 5 of\n port p+2 (37aH) has been set to 1).\n──── ───────────────────────────────────────────────────────────────────────\n379H Read-only: Printer Status\n ╓7┬6┬5┬4┬3┬2┬1┬0╖\n ║ │ │ │ │ │0 0 0║\n ╙╥┴╥┴╥┴╥┴╥┴─┴─┴─╜ bit\n ║ ║ ║ ║ ╚═══════► 3: -ERROR (pin 15) 0=printer signals an error\n ║ ║ ║ ╚═════════► 4: +SLCT (pin 13) 1=printer is selected\n ║ ║ ╚═══════════► 5: +PE (pin 12) 1=out of paper\n ║ ╚═════════════► 6: -ACK (pin 10) 0=ready for next character\n ╚═══════════════► 7: -BUSY (pin 11) 0=busy or off-line or error\n──── ───────────────────────────────────────────────────────────────────────\n37aH Read/Write: Printer Controls\n ╓7┬6┬5┬4┬3┬2┬1┬0╖\n ║0 0│ │ │ │ │ │ ║\n ╙─┴─┴╥┴╥┴╥┴╥┴╥┴╥╜ bit\n ║ ║ ║ ║ ║ ╚═► 0: +Strobe (pin 1) 1 when sending byte\n ║ ║ ║ ║ ╚═══► 1: +AUTO LineFeed (pin 14) 1 causes LF after CR\n ║ ║ ║ ╚═════► 2: -INIT (pin 16) 0 resets the printer\n ║ ║ ╚═══════► 3: +SLCT IN (pin 17) 1 selects the printer\n ║ ╚═════════► 4: +IRQ Enable (hdwr INT when -ACK goes false)\n ║ LPT1═►IRQ 7 (INT 0fH)\n ║ LPT2═►IRQ 5 (INT 0dH)\n ╚═══════════► 5: direction (PS/2 and later ATs)\n 0=write data to printer or device\n 1=read data from device\n──── ───────────────────────────────────────────────────────────────────────\nSee Also: INT 17H (printer support)\n Parallel Port Connector\n I/O Port Map\n Cables and Pin Outs\n -♦-"
  },
  {
    "id": "908-dma_ports.html",
    "t": "DMA Ports",
    "b": "DMA (Direct Memory Access) is used for high-speed data transfers between\n I/O devices and memory without intervention of the CPU. It is typically\n employed by diskette and hard disk drivers, but it could be used for\n streaming tape or any other device as long as it does not interfere with\n the operation of other standard devices.\n\n The original PC supports four 8-bit DMA channels, across a 20-bit address\n space, using an Intel 8237A DMA controller chip. The AT supports seven\n DMA channels by cascading a second 8237A DMA controller. The differences\n between PC and AT DMA are covered at the end of this section.\n\n Channel Usage in PC and XT\n ▀▀▀▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n 0 memory refresh (highest priority)\n 1 not used\n 2 diskette adapter\n 3 hard disk adapter (lowest priority)\n\n Note: All PC-compatibles use DMA channel 0 for memory refresh. If\n memory is not refreshed as set by the BIOS, data in RAM will\n degrade within a few hundredths of a second. It is wise to avoid\n monkeying with DMA port settings.\n\nPort Description\n▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n000H-007H DMA base address an offset registers\n All are 16-bit registers: read/write the low byte, then the high byte\n at the same I/O port. Base addresses are offsets from a DMA Page\n (see below).\n\n000H Write: DMA channel 0 base address (also sets current address)\n Read: DMA channel 0 current address\n001H Write: DMA channel 0 base address and word count\n Read: DMA channel 0 current word count\n002H Write: DMA channel 1 base address\n Read: DMA channel 1 current address\n003H Write: DMA channel 1 base address and word count\n Read: DMA channel 1 current word count\n004H Write: DMA channel 2 base address (diskette adapter)\n Read: DMA channel 2 current address \"\n005H Write: DMA channel 2 base address and word count \"\n Read: DMA channel 2 current word count \"\n006H Write: DMA channel 3 base address (hard disk adapter)\n Read: DMA channel 3 current address \"\n007H Write: DMA channel 3 base address and word count \"\n Read: DMA channel 3 current word count \"\n──── ───────────────────────────────────────────────────────────────────────\n008H-00fH DMA control/status registers\n008H Write: DMA command register\n ╓7┬6┬5┬4┬3┬2┬1┬0╖\n ║ │ │ │ │ │ │ │ ║\n ╙╥┴╥┴╥┴╥┴╥┴╥┴╥┴╥╜ bit\n ║ ║ ║ ║ ║ ║ ║ ╚═► 0: 1=enable memory-to-memory DMA (ch0◄═►ch1)\n ║ ║ ║ ║ ║ ║ ╚═══► 1: 1=enable Ch0 address hold\n ║ ║ ║ ║ ║ ╚═════► 2: 1=disable controller\n ║ ║ ║ ║ ╚═══════► 3: 1=select compressed timing mode\n ║ ║ ║ ╚═════════► 4: 1=enable rotating priority\n ║ ║ ╚═══════════► 5: 1=select extended write mode; 0=late write\n ║ ╚═════════════► 6: 1=select DRQ sensing as active high; 0=low\n ╚═══════════════► 7: 1=select DACK sensing as active high; 0=low\n Read: DMA status register\n ╓7┬6┬5┬4┬3┬2┬1┬0╖\n ║ │ │ │ │ │ │ │ ║\n ╙─┴─┴─┴─┴─┴─┴─┴─╜ bit\n ╚══╦══╝ ╚═════╩═► 0-3: channel 0-3 has reached terminal count\n ╚════════════► 4-7: channel 0-3 has a request pending\n\n009H Write: request register\n ╓7┬6┬5┬4┬3┬2┬1┬0╖\n ║ unused │ │ ║\n ╙─┴─┴─┴─┴─┴╥┴─┴─╜ bit\n ║ ╚═╩═► 0-1: select channel (00=0; 01=1; 10=2; 11=3)\n ╚═════► 2: 1=set request bit for channel; 0=reset request\n\n00aH Write: single mask bit register\n ╓7┬6┬5┬4┬3┬2┬1┬0╖\n ║ unused │ │ ║\n ╙─┴─┴─┴─┴─┴╥┴─┴─╜ bit\n ║ ╚═╩═► 0-1: select channel (00=0; 01=1; 10=2; 11=3)\n ╚═════► 2: 1=set mask for channel; 0=clear mask (enable)\n\n00bH Write: mode register\n ╓7┬6┬5┬4┬3┬2┬1┬0╖\n ║ │ │ │ │ │ │ │ ║\n ╙─┴─┴╥┴╥┴─┴─┴─┴─╜ bit\n ╚╦╝ ║ ║ ╚╦╝ ╚═╩═► 0-1: select channel (00=0; 01=1; 10=2; 11=3)\n ║ ║ ║ ╚══════► 2-3: xfer type: 00=verify (nop); 01=write; 10=read\n ║ ║ ╚═════════► 4: 1=enable auto-initialization\n ║ ╚═══════════► 5: 1=select addr increment; 0=address decrement\n ╚══════════════► 6-7: 00=demand mode; 01=single\n 10=block; 11=cascade\n\n00cH Write: clear byte pointer flip-flop. Any write clears the flip-flop\n so that the next write to any of the 16-bit registers is\n decoded as the low byte. The next is the high byte, then next\n is low, etc.\n\n00dH Write: master clear. Any OUT clears the ctrlr (must be re-init'd)\n Read: temporary reg. Last byte in memory-to-memory xfer (not used)\n\n00eH Write: Clear mask registers. Any OUT enables all 4 channels.\n\n00fH Write: master clear. Clear or mask any or all of the channels.\n ╓7┬6┬5┬4┬3┬2┬1┬0╖\n ║ │ │ │ │ ║\n ╙─┴─┴─┴─┴╥┴╥┴╥┴╥╜ bit\n ║ ║ ║ ╚═► 0: 1=mask channel 0; 0=enable\n ║ ║ ╚═══► 1: 1=mask channel 1;\n ║ ╚═════► 2: 1=mask channel 2;\n ╚═══════► 3: 1=mask channel 3;\n Read: temporary reg. Last byte in memory-to-memory xfer (not used)\n\n081H-08fH DMA page registers.\n To select a starting address for a DMA operation, do an OUT to the\n page register (ports 81H-83H) for the selected channel then set the\n base address (ports 00H-07H) for the channel. A page register is set\n with a 4-bit value that represents bits 16-19 of the 20-bit DMA\n address. Since the current address is a 16-bit value, it is not\n possible to cross a 64K boundary (e.g., address 1000:0, 2000:0, etc.)\n with a DMA operation.\n\n081H Channel 2 page register (diskette DMA)\n\n082H Channel 3 page register (hard disk DMA)\n\n083H Channel 1 page register\n\n▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n█▌AT DMA▐█\n The DMA system on the AT is basically upwardly-compatible with PC and XT\n DMA. In addition to the four 8-bit channels of the PC, the AT adds a\n second 8237A-5 DMA controller which supports channels 4-7.\n\nChannel Usage in AT\n▀▀▀▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n 0 spare ─┐\n 1 SDLC (Synchronous Data Link Control) ╞═► 8-bit DMA channels\n 2 diskette adapter │\n 3 hard disk adapter ─┘\n 4 (controller 2) cascade for controller 1 ─┐\n 5 spare ╞═► 16-bit DMA channels\n 6 spare │\n 7 spare ─┘\n\n──── ───────────────────────────────────────────────────────────────────────\n081H-08fH DMA page registers. On the AT, all 8 bits of the Page registers\n are used. They become the high 8-bits of a 24-bit address space\n (with the low 16-bits being set in a channel's base/current address\n register). The page size is 128K (64K words) so DMA transfers must not\n cross a 128K boundary (e.g., address 2000:0, 4000:0, 6000:0, etc.)\n\n081H Channel 2 page register (diskette DMA) (address bits 16-23)\n082H Channel 3 page register (hard disk DMA) (address bits 16-23)\n083H Channel 1 page register (address bits 16-23)\n087H Channel 0 page register (address bits 16-23)\n089H Channel 6 page register (address bits 17-23)\n08bH Channel 5 page register (address bits 17-23)\n08aH Channel 7 page register (address bits 17-23)\n08fH refresh\n──── ───────────────────────────────────────────────────────────────────────\n0c0H-0dfH AT DMA controller registers for 16-bit DMA I/O. Channels 0-3 work\n with 8-bit I/O as in the PC. Additional channels 4-7 support 16-bit\n device-to-memory and memory-to-device transfers. Transfers for these\n channels always start on a word boundary and all addresses and counts\n are for 16-bit words (e.g., a base address of 123H actually refers to\n offset 246H from the page for that channel).\n\n0c0H Channel 4 base and current address (bits 1-16; bit 0 assumed 0)\n0c2H Channel 4 current word count\n0c4H Channel 5 base and current address (bits 1-16)\n0c6H Channel 5 current word count\n0c8H Channel 6 base and current address (bits 1-16)\n0caH Channel 6 current word count\n0ccH Channel 7 base and current address (bits 1-16)\n0ceH Channel 7 current word count\n──── ───────────────────────────────────────────────────────────────────────\n0d0H-0dfH AT DMA control/status registers\n0d0H Write: command register\n Read: status register\n0d2H Write request register\n0d4H Write single mask register bit\n0d6H Write Mode register\n0d8H Clear byte pointer flip-flop\n0daH Write: master clear\n Read: temporary register\n0dcH Clear mask register\n0deH Write all mask register bits\n──── ───────────────────────────────────────────────────────────────────────\nSee Also: I/O Port Map\n -♦-"
  },
  {
    "id": "909-_obsolete_.html",
    "t": "◄Obsolete►",
    "b": "◄Obsolete►\n──────────────────────────────────────────\nThis API service or structure is a remnant\nof bygone days of earlier versions of DOS.\n\nIt is no longer supported."
  },
  {
    "id": "910-_superseded_.html",
    "t": "◄Superseded►",
    "b": "◄Superseded►\n──────────────────────────────────────────\nThis API service or structure is a remnant\nof bygone days of earlier versions of DOS.\n\nLater versions of DOS continue to support\nit, but there are better ways to get the\nsame result.\n──────────────────────────────────────────\nFor an old-to-new cross-reference, see\nSuperseded Services in the Index."
  },
  {
    "id": "911-_wasundoc_.html",
    "t": "◄WasUndoc►",
    "b": "◄WasUndoc►\n───────────────────────────────────────────────────\nThis API service was first documented by Microsoft\nin DOS 5.0, but is supported by earlier versions.\n\nThe ◄WasUndoc► flag is irrelevant with regard to\nprogramming considerations; only the supported\nversion number is important.\n───────────────────────────────────────────────────\nTECH Help! flags these services only to bring them\nto your attention. They are often useful and might\notherwise be overlooked as a programming resource."
  },
  {
    "id": "912-_undocumented_.html",
    "t": "◄Undocumented►",
    "b": "◄Undocumented►\n───────────────────────────────────────────────────────────\nThis API service or structure is not documented by official\nMicrosoft sources. Something may be undocumented for any\nof several reasons:\n\n■ It is dangerous; you could lose data.\n■ It may change in future versions of DOS.\n■ It has no particular value; there are other ways...\n\nIn most cases, information contained in TECH Help! has been\ngleaned from official Microsoft sources, such as a\nMicrosoft Knowledge Base on Compuserve or in trusted\npublications such as Microsoft Systems Journal. Some\ninformation was obtained through trial-and-error testing.\n\nIn general, it's best to avoid using undocumented features."
  },
  {
    "id": "913-qasciiz.html",
    "t": "ASCIIZ",
    "b": "ASCIIZ String\n──────────────────────────────────────────\nA sequence of characters terminated by an\nASCII NUL byte (00H).\n\nASCIIZ strings are the standard text\nstring used in the C programming language:\n\n char szMyFile[]=\"c:myfile.txt\";\n\nIn assembly language:\n\n szMyFile db 'c:myfile.txt',0"
  },
  {
    "id": "914-qbcd.html",
    "t": "BCD",
    "b": "BCD\n Binary-Coded Decimal\n─────────────────────────────────────────────────────\nBCD is a way to represent decimal numbers in a more\ncompact way than ASCII text. One byte represents two\ndigits:\n\n 01H = 1 decimal\n 20H = 20 decimal (not 32)\n 99H = 99 decimal (not 153)\n─────────────────────────────────────────────────────\n■ BCD is used rarely on PCs and in PC programming.\n■ Note that hex digits A-F are never used, so numbers\n such as 0aH or b1H are invalid as BCD values."
  },
  {
    "id": "915-qcluster.html",
    "t": "Cluster",
    "b": "cluster\n─────────────────────────────────────────────────────\nA cluster, as used in the DOS file system, is a group\nof sequential sectors on disk.\n\nEach cluster represents a power-of-2 count of sectors.\nCommon cluster sizes are 2, 4, 8, and 16 sectors.\n─────────────────────────────────────────────────────\n■ DOS allocates disk data in clusters in the FAT.\n■ DOS fn 1cH returns cluster size for a disk.\n■ A disk Boot sector contains the cluster size."
  },
  {
    "id": "916-qstdtextfile.html",
    "t": "StdTextFile",
    "b": "Standard ASCII Text File\n─────────────────────────────────────────────────\nUnformatted text in a file that can be loaded and\nmodified by Edit (or any text editor).\n\nUnlike binary data files or word processor\ndocument files, text files contain no special\nformatting codes embedded in the text--only the\ntext of the lines, with each line ending with\nCR+LF (0dH, 0ah).\n─────────────────────────────────────────────────\n■ AUTOEXEC.BAT and CONFIG.SYS are text files.\n■ Most configuration files (.INI) are text files.\n■ I/O Redirection uses text files."
  },
  {
    "id": "917-qtsr.html",
    "t": "TSR",
    "b": "memory resident (TSR) programs\n───────────────────────────────────────────────\nTSR stands for Terminate and Stay Resident; it\nrefers to a program which leaves all or part of\nitself in memory after it exits to DOS.\n───────────────────────────────────────────────\n■ DOS fn 31H makes a program RAM-resident\n■ INT 27H is the old way to go TSR."
  },
  {
    "id": "918-qcrc.html",
    "t": "CRC",
    "b": "Checksum\n────────────────────────────────────────────────\nA simple sum of all bytes (or words) in a block\nof data, taken modulo 256 (or 65536). Used to\nverify data integrity.\n\n (CRC) Cyclic Redundancy Code\n────────────────────────────────────────────────\nLike a checksum, but using a complicated formula\nthat avoids offsetting errors.\n\n (ECC) Error Checking and Correction\n────────────────────────────────────────────────\nLike a CRC, but containing more information.\nWith an ECC, it is possible to detect all errors\nand to correct all single-bit and some multiple-\nbit errors."
  },
  {
    "id": "919-qcvf.html",
    "t": "CVF",
    "b": "CVF\n Compressed Volume File\n────────────────────────────────────────────────────────────\nA CVF is a file with a name such as DBLSPACE.000 or\nDBLSPACE.001; it contains all of the files and file-system\nbookkeeping information for a DoubleSpace compressed disk.\n────────────────────────────────────────────────────────────\nBefore a CVF can be accessed as a disk, it must be mounted;\nthat is, the DoubleSpace support must recognize it and assign\nit a drive letter.\n────────────────────────────────────────────────────────────\n■ TECH Help! describes the layout of CVFs in detail.\n See DoubleSpace and CVF Layout in the Index."
  },
  {
    "id": "920-qexitcode.html",
    "t": "ExitCode",
    "b": "exit code\n────────────────────────────────────────────────\nAn 8-bit value furnished by any program when it\nterminates via DOS fn 4fH (exit) or 31H\n(terminate and go resident).\n────────────────────────────────────────────────\n■ DOS fn 4dH obtains the most recent exit code.\n■ The IF ERRORLEVEL command tests the exit code."
  },
  {
    "id": "921-qlstring.html",
    "t": "Lstring",
    "b": "Lstring\n──────────────────────────────────────────────────────\nA sequence of characters usually defining a string of\ntext. The first byte identifies the length, in bytes,\nof the rest of the string.\n\nLstrings are often used in the Pascal programming\nlanguage but are seen in only a few DOS system\nservices (ASCIIZ strings are the standard).\n\nIn assembly language:\n\n sMyFile db 12,'c:myfile.txt'\n──────────────────────────────────────────────────────\n■ PSPs contain an Lstring of the command-line text.\n■ DOS fn 4b00H uses an Lstring in its parameter block."
  },
  {
    "id": "922-qfilespec.html",
    "t": "Filespec",
    "b": "filespec\n──────────────────────────────────────────────────\nIdentifies a file. It contains a 1-to-8-character\nfilename (with optional extension), optionally\npreceded by a drive ID and directory path.\n\n fully-qualified filespec\n ┌─────────────┴─────────────────┐\n Example: C:\\WORDPROC\\MYBOOK\\CHAPTER1.TXT\n └┬┘└───────┬───────┘└─────┬─────┘\n drive ID directory filename.ext\n──────────────────────────────────────────────────\n■ All DOS API services will apply the current\n default drive and directory, if omitted.\n■ DOS ignores character case in filespecs.\n■ The d:\\path string should not exceed 63 bytes."
  },
  {
    "id": "923-qhex.html",
    "t": "Hex",
    "b": "Hex\n Hexadecimal Notation\n─────────────────────────────────────────────────\nA base-16 numbering system, used by programmers.\nIt uses the 16 digits:\n\n 1 2 3 4 5 6 7 8 9 a b c d\n─────────────────────────────────────────────────\n■ TECH Help! shows hex numbers suffixed with \"H\".\n■ Assemblers and Debug require hex numbers\n beginning with \"a-f\" to start with a leading 0.\n TECH Help! does not follow this convention."
  },
  {
    "id": "924-qmemconv.html",
    "t": "MemConv",
    "b": "Conventional Memory\n─────────────────────────────────────────────\nThis is the \"standard\" or \"normal\" computer\nmemory that exists on all PC-compatibles.\n\nPCs support a maximum of 640K of conventional\nmemory. TSRs, device drivers, and DOS itself\noccupy some portion of that 640K.\n\nOther types of memory require additional\nsupport hardware (see EMS) or a 286-based or\nbetter CPU (see XMS and HMA), or a 386-based\nor better CPU (see UMB).\n─────────────────────────────────────────────\n■ DOS fns 48H, 49H, and 4aH work with\n conventional memory by default."
  },
  {
    "id": "925-qmemems.html",
    "t": "MemEMS",
    "b": "Expanded Memory\n EMS Memory\n Expanded Memory Specification\n────────────────────────────────────────────────────\nEMS (or expanded memory) is a type of memory\navailable on 8088- and 286-based computers that have\na special memory hardware and a supporting device\ndriver. It is also available on 386-based computers\nwhen EMM386.EXE (or other emulator) is installed.\n\nEMS works by taking a \"window\" of memory addresses\nbetween the 640K and 1MB marks, and \"paging\" blocks\nof memory into that window.\n─────────────────────────────────────────────────────\n■ TECH Help! covers programming aspects of EMS in\n detail. See EMS in the Index."
  },
  {
    "id": "926-qmemhma.html",
    "t": "MemHma",
    "b": "HMA\n High Memory Area\n────────────────────────────────────────────────────────\nA 65520-byte area of memory from ffff:0010 to ffff:ffff.\nIt is available on 286-based and 386+ computers in which\nthe HIMEM.SYS device driver has been installed.\n\nDOS can load itself into the HMA, freeing up nearly 64K\nof conventional memory for use by application programs.\n────────────────────────────────────────────────────────\n■ DOS=HIGH (in CONFIG.SYS) puts DOS in the HMA\n■ If the HMA has not been taken, it may by used by\n TSRs, etc. See XMS in the Index.\n■ Part of the HMA may be free; see HMA Suballocations"
  },
  {
    "id": "927-qmemumb.html",
    "t": "MemUMB",
    "b": "UMB\n Upper Memory Block\n─────────────────────────────────────────────────\nTraditionally, memory between 640K and 1 MB has\nbeen \"reserved\" for special purposes such as\nvideo memory and ROM.\n\nOn 386+ computers, it is possible to map extended\nmemory into the unused areas of reserved memory.\n\nThe resulting islands of memory are called\nUpper Memory Blocks, or UMBs.\n─────────────────────────────────────────────────\n■ DOS fn 5803H (along with fn 48H) provide\n access to UMBs. See UMB in the Index.\n■ DEVICE=HIMEM.SYS ─┐ use in CONFIG.SYS\n DEVICE=EMM386.EXE │ to enable access\n DOS=UMB ─┘ to UMBs\n■ DEVICEHIGH= load device drivers into UMBs"
  },
  {
    "id": "928-qmemxms.html",
    "t": "MemXMS",
    "b": "Extended Memory\n XMS Memory\n Extended Memory Specification\n───────────────────────────────────────────\nA type of memory available on 286-based and\nbetter computers which have memory above\nthe 1 MB mark. The HIMEM.SYS device driver\noversees the use of extended memory.\n\nXMS increases available memory for programs\nthat have been written to take advantage of\nit (such as Windows applications and the\nSMARTDrive disk cache).\n───────────────────────────────────────────\n■ TECH Help! covers programming aspects of\n using XMS in detail. See XMS and DPMI in\n the Index."
  },
  {
    "id": "929-qpid.html",
    "t": "PID",
    "b": "PID\n Process ID\n──────────────────────────────────────────────\nThis is a 16-bit value that uniquely\nidentifies a running program or installed TSR.\n\nThe PID or any program is the segment address\nof its PSP.\n──────────────────────────────────────────────\n■ DOS fns 52H and 50H are used by TSRs to make\n sure that DOS uses their PSP instead of the\n PSP of the program they interrupt."
  },
  {
    "id": "930-qslack.html",
    "t": "Slack",
    "b": "file slack space\n──────────────────────────────────────────────────────────────────────\nDOS allocates disk space in multiple-sector chunks called \"clusters\".\nClusters typically hold 2K, 4K, or 8K of data.\n\nWhen DOS creates a file, it must allocate at least one cluster for\nthat file. Since file sizes vary, some portion of the last cluster is\nwasted (it contains no file data).\n\n┌─½K┬─½K┬─½K┬─½K┬─½K┬─½K┬─½K┬─½K┐ In this figure, a 2-byte file\n│hi │ │ │ │ │ │ │ │ (just the word \"hi\") is stored in\n└┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┘ a 4096-byte cluster, so 4094 bytes\n└──────────────┬────────────────┘ of storage are \"wasted\" -- that's\n 4K cluster the \"file slack\".\n──────────────────────────────────────────────────────────────────────\n■ DoubleSpace's allocation scheme that minimizes slack space; a 1-byte\n file occupies only 512 bytes of physical storage."
  },
  {
    "id": "931-qvidcga.html",
    "t": "VidCga",
    "b": "CGA\n Color Graphics Adapter\n─────────────────────────────────────────────────────\nCGA is the oldest standard in color displays; it was\navailable on the original IBM-PC shipped circa 1981.\n\n Text: 16 colors; 80-columns by 25-lines\n 40-columns by 25-lines\nGraphics: 2 colors; 640x200\n 4 colors; 320x200\n\nLater adapters, including EGA and VGA, support the CGA\nstandard but provide additional screen colors and\nresolutions.\n──────────────────────────────────────────────────────\n■ TECH Help! covers programming aspects of the CGA in\n detail. See CGA in the Index."
  },
  {
    "id": "932-qvidega.html",
    "t": "VidEga",
    "b": "EGA\n Enhanced Graphics Adapter\n────────────────────────────────────────────────────────\nEGA is a video display standard introduced by IBM around\n1984. It became popular a couple of years later when\nlow-cost non-IBM versions became available.\n\nIt supports the CGA standard but improves upon it by\nadding higher resolution and additional colors in\ngraphics modes.\n\n Text: 16 colors; 40- and 80-columns/25-lines\n 40- and 80-columns/43-lines\nGraphics: 16 colors; 640x350 (max)\n\nLater standards, including VGA, support the CGA and EGA\nstandards but provide additional screen colors and\nresolutions.\n────────────────────────────────────────────────────────\n■ TECH Help! covers programming aspects of the EGA in\n detail. See EGA in the Index."
  },
  {
    "id": "933-qvidmda.html",
    "t": "VidMDA",
    "b": "MDA or MDPA\n Monochrome Display Adapter\n────────────────────────────────────────────────────────\nMDA is the oldest display standard; it was available on\nthe original IBM-PC shipped circa 1981 (sometimes called\nMDPA since the original adaptor also provided a parallel\nprinter port).\n\n Text: 2 colors+underline; 80-columns by 25-lines\n 40-columns by 25-lines\nGraphics: none\n\nA common variant is the \"Hercules\" or \"MonoGraphics\"\ndisplay adapter which supports black-and-white graphics."
  },
  {
    "id": "934-qvidvga.html",
    "t": "VidVGA",
    "b": "VGA\n Video Graphics Array\n────────────────────────────────────────────────────────\nVGA is a video display standard introduced by IBM around\n1987. It became popular a couple of years later when\nlow-cost non-IBM versions became available.\n\nIt supports the CGA and EGA standards but improves upon\nthem by adding higher resolution in graphics modes.\n\n Text: 16 colors; 40- and 80-columns by 25-lines\n 40- and 80-columns by 43-lines\n 40- and 80-columns by 50-lines\nGraphics: 16 colors; 640x480 (max)\nGraphics: 256 colors; 320x200\n────────────────────────────────────────────────────────\n■ TECH Help! covers programming aspects of the VGA in\n detail. See VGA in the Index.\n■ \"Super VGA\" provides additional screen resolutions.\n Look for SVGA and VESA in the Index."
  },
  {
    "id": "935-qwildcard.html",
    "t": "Wildcard",
    "b": "wildcards\n───────────────────────────────────────────────────────\nA wildcard character is either of the characters ? or *\nwhen used in a filename or an extension.\n\n ? stands for \"any single character in this position\"\n\n * stands for \"any sequence of characters\" in a\n filename or extension.\n\nA wildcard filespec is any file identifier containing\none or more wildcard characters in the filename and/or\nextension.\n───────────────────────────────────────────────────────\n■ DOS fns 4eH and 4fH (find files) accept wildcards."
  },
  {
    "id": "936-vesa_svga_bios_functions.html",
    "t": "VESA/SVGA BIOS Functions",
    "b": "The VESA/SuperVGA BIOS supports the following functions:\n\n INT 10H 4f00H Query SuperVGA Support\n\n INT 10H 4f01H Query SuperVGA Mode Information\n\n INT 10H 4f02H Set SuperVGA Video Mode\n\n INT 10H 4f03H Query Current SuperVGA Video Mode\n\n INT 10H 4f04H Save/Restore SuperVGA State\n\n INT 10H 4f05H Query/Set SuperVGA Video Memory Window\n\nSee Also: SVGA\n VESA/SVGA Video Modes\n -♦-"
  },
  {
    "id": "937-int_10h_4f00h___query_supervga_support.html",
    "t": "INT 10H 4f00H - Query SuperVGA Support",
    "b": "Expects: AX 4f00H\n ES:DI Addr of buffer to receive an SvgaInfoRec\n ──────────────────────────────────────────────────────────────────\n Returns: AX VESA status: AH = 0 means successful (else failed)\n AL = 4fH means function is supported\n ES:DI buffer contains returned data (if successful)\n ──────────────────────────────────────────────────────────────────\n Info: This function is used to see if VESA support is present and to\n learn which extended video modes it supports.\n\n The buffer at ES:DI must be at least 256 bytes long; see\n SvgaInfoRec for a layout of the returned information. This VESA\n BIOS may place the list of supported modes into your buffer,\n anywhere after offset 12H.\n\nSee Also: SVGA\n VESA/SVGA BIOS Services\n -♦-"
  },
  {
    "id": "938-int_10h_4f01h___query_supervga_mode_information.html",
    "t": "INT 10H 4f01H - Query SuperVGA Mode Information",
    "b": "Expects: AX 4f01H\n CX VESA/SVGA Video Mode number (may also be std modes 00-13H)\n ES:DI Addr of buffer to receive an SvgaModeInfoRec\n ──────────────────────────────────────────────────────────────────\n Returns: AX VESA status: AH=0 means successful (else failed)\n AL=4fH means function supported\n ES:DI buffer contains returned data (if successful)\n ──────────────────────────────────────────────────────────────────\n Info: Obtains information about the capabilities, resolution, memory\n access model, etc. for a particular SuperVGA video mode.\n\n The buffer at ES:DI must be 256 bytes long (though only the first\n 29 bytes are defined). See SvgaModeInfoRec for a layout of the\n returned information.\n\n Notes: ■ VESA implementations may not return the entire data structure.\n Be sure to check bit 1 of the byte at offset 0.\n\nSee Also: SVGA\n VESA/SVGA BIOS Services\n -♦-"
  },
  {
    "id": "939-int_10h_4f02h___set_supervga_video_mode.html",
    "t": "INT 10H 4f02H - Set SuperVGA Video Mode",
    "b": "Expects: AX 4f02H\n BX VESA/SVGA Video Mode number (may also be std modes 00-13H)\n (bit 15 set = don't clear video memory on mode set)\n ──────────────────────────────────────────────────────────────────\n Returns: AX VESA status: AH=0 means successful (else failed)\n AL=4fH means function supported\n ──────────────────────────────────────────────────────────────────\n Info: Initializes the display adaptor for a specified video mode.\n\n You can use this call to initialize for non-VESA mode numbers\n (e.g., VGA modes 10H-13H) just by setting the mode number in BL\n and clearing BH.\n\n By default, this call clears all video memory to spaces or black\n pixels. You can request to leave the video memory buffer as is\n by setting bit 15 of BX.\n\n Use INT 10H 4f00H to see what mode numbers are valid for BX.\n\nSee Also: SVGA\n VESA/SVGA BIOS Services\n -♦-"
  },
  {
    "id": "940-int_10h_4f03h___query_current_supervga_video_mode.html",
    "t": "INT 10H 4f03H - Query Current SuperVGA Video Mode",
    "b": "Expects: AX 4f03H\n ──────────────────────────────────────────────────────────────────\n Returns: AX VESA status: AH=0 means successful (else failed)\n AL=4fH means function supported\n BX VESA/SVGA Video Mode number currently active\n ──────────────────────────────────────────────────────────────────\n Info: Obtains the number of the current video mode.\n\n Notes: ■ Unlike INT 10H 0fH, this does NOT return the state of \"clear\n video memory bit\" that was used when the mode was initialized;\n that is, only the high bit of BX always comes back as 0.\n\nSee Also: SVGA\n VESA/SVGA BIOS Services\n -♦-"
  },
  {
    "id": "941-int_10h_4f04h___save_restore_supervga_state.html",
    "t": "INT 10H 4f04H - Save/Restore SuperVGA State",
    "b": "Expects: AX 4f04H\n CX bit flags indicate which states to save/restore\n DL SubFn number: 00H = Get save-state buffer size\n 01H = Save SuperVGA state\n 02H = Restore SuperVGA state\n ES:BX addr of buffer (subfns 01H and 02H only)\n ──────────────────────────────────────────────────────────────────\n Returns: AX VESA status: AH=0 means successful (else failed)\n AL=4fH means function supported\n BX size of save-state buffer in 64-byte blocks (subfn 00H only)\n ──────────────────────────────────────────────────────────────────\n Info: Use this function to save the current state of the SuperVGA\n system and to later restore that state.\n\n CX describes what you want to save or restore as bit flags:\n 1\n ┌5───4┬3┬2┬1┬0┐\n │0...0│s│c│b│h│\n └─────┴╥┴╥┴╥┴╥┘ bit mask\n ║ ║ ║ ╚══► 0: 01H save/restore video hardware state\n ║ ║ ╚════► 1: 02H save/restore video BIOS data state\n ║ ╚══════► 2: 04H save/restore DAC state; color regs\n ╚════════► 3: 08H save/restore entire SuperVGA state\n\n Notes: ■ To use this function: first decide what info you need to save\n and set the bits of CX and set DL to 00H to see how much memory\n you'll need. Then allocate a buffer of the needed size (it is\n BX * 64 bytes lone). Set ES:BX to point to the buffer and use\n DL=01H to save the info into the buffer.\n\n ■ The layout of the return information at ES:BX is not documented\n and will be OEM-dependent.\n\nSee Also: SVGA\n VESA/SVGA BIOS Services\n -♦-"
  },
  {
    "id": "942-int_10h_4f05h___query_set_supervga_video_memory_window.html",
    "t": "INT 10H 4f05H - Query/Set SuperVGA Video Memory Window",
    "b": "Expects: AX 4f05H\n BH SubFn number: 00H = Select memory window\n 01H = Query current memory window\n BL window ID 0 or 1\n DX (subfn 00H only) window position (see below)\n ──────────────────────────────────────────────────────────────────\n Returns: AX VESA status: AH=0 means successful (else failed)\n AL=4fH means function supported\n DX current or new window position (see below)\n ──────────────────────────────────────────────────────────────────\n Info: This function is used to map chunks of video memory into CPU\n address space, or to find out which part of video memory is\n currently available to the CPU.\n\n The CPU address space for most systems is the 64K starting at\n a000:0. Even in standard VGA modes, there are 256K of video\n memory to be accessed. SVGA modes can require 1.3 MB (1280K) of\n video memory or more.\n\n For instance, in order to access graphical scan line 1024, you\n need to page-in the 20th page of video memory. This function\n provides the interface to do that--and avoids needing to the port\n I/O or other obscure coding.\n\n Before using this function, you must use INT 10H 4f01H to obtain\n a SvgaModeInfoRec containing detailed information about the video\n mode. For instance, the rWinBAttrs bit 1 will be 0 if only one\n video window is supported for that mode. It also returns\n wWinGran, which is essential to determining what scan line gets\n pages in when you select a block with DX (see below).\n\n DX with subfn 00H, DX selects the chunk of memory that you want to\n make accessible.\n\n DX is a video memory address, expressed in \"window granularity\n units\". The size of such a unit is given in the wWinGran field\n of the SvgaModeInfoRec.\n\n For instance, if wWinGran is 4, then the units are 4K, so\n addressing a scan line that begins at video memory offset 8193\n will require that DX be set to 2 to map in the third page of\n video memory.\n\n This call maps the specified page to the start of the video\n memory segment for the specified window. The wWinASeg of\n SvgaModeInfoRec will provide the segment address in CPU terms\n (usually a000H).\n\n Notes: ■ This function can also be called via a FAR CALL, to avoid the\n INT-handler overhead. Use INT 10H 4f01H to obtain the address\n of the function handler.\n\n When called directly, the value in AX is ignored, but other\n parameters are the same. Upon return, AX and DX are destroyed.\n\n ■ Also note that the function address may change when you switch\n video modes, so be sure to obtain the right address, just\n before calling.\n\nSee Also: SVGA\n VESA/SVGA BIOS Services\n -♦-"
  },
  {
    "id": "943-extended_memory_specification__xms_.html",
    "t": "Extended Memory Specification (XMS)",
    "b": "This topic describes the Extended Memory Specification, which provides a\n way for applications and operating systems to access Extended▲ Memory on\n 286+ CPUs, without the complications of running in protected mode. XMS\n also describes how to access the HMA▲ (though it is nearly always best to\n let MS-DOS use the HMA).\n\n See XMS Functions for descriptions of services.\n\n XMS is an industry standard proposed jointly by Microsoft, Lotus, Intel,\n and AST. The version 2.0 spec has been in effect since 1992.\n\n Virtually every AT-class or better computer has some XMS memory and nearly\n all users install the device driver that enables access to XMS.\n\n Note: Extended Memory is not available on pre-AT (8088-based) PCs.\n However, some of these older machines are equipped with LIM-EMS\n boards. The Expanded Memory Specification (EMS) offers access to\n additional memory on such computers.\n\n█▌Determining if XMS is Installed▐█\n XMS memory is managed by an installable device driver. The one that\n comes with MS-DOS is named HIMEM.SYS, but other names may be used by\n other vendors.\n\n When the driver is installed, it hooks INT 2fH, and watches for calls in\n which AH=43H. Use INT 2fH 4300H (get installed state) to see if its\n support is available.\n\n█▌Accessing XMS Services▐█\n Use INT 2fH 4310H (get XMS entry address) to learn the address at which\n the XMS service dispatcher resides.\n\n Load AH with a service number (and other registers as needed), and use a\n FAR CALL to call the entry address. Check AX upon return. If AX=0, then\n the request succeeded; otherwise and XMS error code is returned in BL.\n See INT 2fH 4310H for an example.\n\n See XMS Functions for parameters required for each service.\n\n█▌DOS Support▐█\n Starting with version 5.0, DOS comes with an XMS support driver\n (HIMEM.SYS) for 286-based and better computers. A few DOS device\n drivers and TSRs will take advantage of XMS if it is present:\n\n ■ DOS 5.0+ loads most of COMMAND.COM into the HMA▲, and places disk I/O\n buffers there and otherwise makes good use of the area.\n\n ■ DOS 5.0+ RAMDISK.SYS can use XMS (DEVICE=RAMDISK.SYS nnn /E).\n\n ■ DOS 5.x SMARTDRV.EXE disk cache will use XMS automatically (unless /A\n is used to specify EMS▲). The DOS 6.0 cache can use XMS ONLY.\n\n ■ DOS 6.0 programs and TSRs: Defrag, Dosshell, Msbackup, Mscdex, and\n Vsafe use XMS memory when it is available.\n\n ■ DOS 6.2 DoubleSpace support will place part of itself into the HMA▲\n when BUFFERS= is small.\n\n█▌What about UMBs?▐█\n Although the XMS describes two fns for accessing UMBs▲, it does not supply\n the upper memory; that is, it appears to be able to track areas of memory\n that happen to exist between 640K and 1MB, but most computers don't have\n any available memory there.\n\n Support for the DEVICEHIGH= and Loadhigh commands is supplied only on 386+\n CPUs by the MS-DOS device driver Emm386.Exe (or other compatible system\n software such as 386Max, or NetRoom, etc.)\n\n The memory that is mapped into the upper memory blocks is subtracted from\n the pool above 1 MB, so an XMS provider (such as HIMEM.SYS) must be\n present for UMB support to be present.\n\n See Accessing Upper Memory for related info.\n\nSee Also: XMS Functions\n XMS Error Codes\n Expanded Memory Specification (EMS)\n DOS Interrupts\n Interrupts and BIOS Services\n -♦-"
  },
  {
    "id": "944-xms_functions.html",
    "t": "XMS Functions",
    "b": "TECH Help! describes all services of the Extended Memory Specification\n version 2.0. Version 2.0 has been standard since October, 1992 and is\n usually available on 286+ computers running DOS 4.0+.\n\n There are two parts to the XMS API. The first uses INT 2fH 43xxH as a way\n to test for installation and to obtain the entry address for the other\n services. After obtaining that address, you call it directly. See\n INT 2fH 4310H for an example.\n\n See: INT 2fH 4300H (is HIMEM.SYS installed?)\n INT 2fH 4310H (get XMM entry address)\n AH\n ▀▀▀ ────────────────────────────────────────────────── General Functions\n 00H Get XMS version number\n ────────────────────────────────────────────────────── Standard Functions\n 01H Request high memory area\n 02H Release high memory area\n 03H Global enable A20\n 04H Global disable A20\n 05H Local enable A20\n 06H Local disable A20\n 07H Query A20 state\n ──────────────────────────────────────────────────── XMS Memory Functions\n 08H Query free extended memory\n 09H Allocate extended memory block\n 0aH Free extended memory block\n 0bH Move extended memory block\n 0cH Lock extended memory block\n 0dH Unlock extended memory block\n 0eH Get handle information\n 0fH Resize extended memory block\n ─────────────────────────────────────────────────────────── UMB Functions\n 10H Request upper memory block\n 11H Release upper memory block\n\nSee Also: XMS\n XMS Error Codes\n Expanded Memory Specification (EMS)\n DOS Interrupts\n Interrupts and BIOS Services\n -♦-"
  },
  {
    "id": "945-xms_00h__get_xms_version_number.html",
    "t": "XMS 00H: Get XMS Version Number",
    "b": "Compatibility: XMS 2.0+\n Expects: AH 00H\n ──────────────────────────────────────────────────────────────────\n Returns: AX status: 0000H = successful\n 0001H = error and BL=XMS error code (if BL >= 80H)\n else = XMS version number in BCD; e.g., 0234H=2.34\n BX driver internal version number\n DX HMA flag: 0001H = HMA▲ exists; 0000H=HMA does not exist\n ──────────────────────────────────────────────────────────────────\n Info: This fn obtains the version number of the Extended Memory\n Specification that is supported by the installed driver.\n\n The return value in DX indicates the existence of the HMA (use\n XMS 01H to test its availability).\n\nSee Also: XMS Functions\n Extended Memory Specification (XMS)\n DOS Functions\n -♦-"
  },
  {
    "id": "946-xms_01h__request_high_memory_area.html",
    "t": "XMS 01H: Request High Memory Area",
    "b": "Compatibility: XMS 2.0+\n Expects: AH 01H\n DX Space needed, in bytes (TSRs and drivers)\n ffffH (application programs)\n ──────────────────────────────────────────────────────────────────\n Returns: AX status: 0000H = successful\n 0001H = error and BL=XMS error code (if BL >= 80H)\n ──────────────────────────────────────────────────────────────────\n Info: This fn attempts to reserve the 65520 bytes of the HMA▲ for the\n caller. The XMM will reject this request if the value in DX is\n less than a certain minimum (i.e., set via HIMEM.SYS /HMAMIN=).\n\n Notes: ■ With DOS 5.0, DOS itself will use the HMA if the line DOS=HIGH\n is in the CONFIG.SYS file.\n\n ■ Two undocumented services (INT 2fH 4axxH) can be used to\n request a suballocation of the HMA if DOS has not used all of\n it (there may be as much as 16K free). The DOS 6.2 version of\n DoubleSpace will use that space, when available.\n\n ■ It is important to be courteous about using the HMA. The HMA\n is allocated as a single large block. For instance, if your\n TSR will need only 10K of RAM, you should not use the HMA:\n leave it available for DOS or a TSR that can use all 64K.\n\n ■ Applications which will use the HMA temporarily can pass\n DX=ffffH so they can be assured of getting it if it is\n available. Be sure to XMS 02H before terminating.\n\nSee Also: XMS Functions\n INT 2fH 4AxxH\n Extended Memory Specification (XMS)\n DOS Functions\n -♦-"
  },
  {
    "id": "947-xms_02h__release_high_memory_area.html",
    "t": "XMS 02H: Release High Memory Area",
    "b": "Compatibility: XMS 2.0+\n Expects: AH 02H\n ──────────────────────────────────────────────────────────────────\n Returns: AX status: 0000H = successful\n 0001H = error and BL=XMS error code (if BL >= 80H)\n ──────────────────────────────────────────────────────────────────\n Info: Releases control of the HMA▲ after a previous call to XMS 01H\n (request HMA).\n\n Applications which use the HMA must release it before\n terminating. Once released, any code or data in it is lost.\n\nSee Also: XMS Functions\n Extended Memory Specification (XMS)\n DOS Functions\n -♦-"
  },
  {
    "id": "948-xms_03h__global_enable_a20.html",
    "t": "XMS 03H: Global Enable A20",
    "b": "Compatibility: XMS 2.0+\n Expects: AH 03H\n ──────────────────────────────────────────────────────────────────\n Returns: AX status: 0000H = successful\n 0001H = error and BL=XMS error code (if BL >= 80H)\n ──────────────────────────────────────────────────────────────────\n Info: This enables the A20 line, making the HMA▲ accessible, starting\n at FFFF:0000.\n\n Only the owner of the HMA should mess with this; see XMS 01H\n (request HMA).\n\n Notes: ■ Toggling A20 is relatively slow on some machines.\n\n ■ TSR owners of the HMA who toggle A20 on popup, should first get\n the current state via XMS 07H, and restore that setting before\n popping down.\n\n Setting A20 disables segment wrap-around--on which a few\n poorly-written programs depend.\n\nSee Also: XMS Functions\n Extended Memory Specification (XMS)\n DOS Functions\n -♦-"
  },
  {
    "id": "949-xms_04h__global_disable_a20.html",
    "t": "XMS 04H: Global Disable A20",
    "b": "Compatibility: XMS 2.0+\n Expects: AH 04H\n ──────────────────────────────────────────────────────────────────\n Returns: AX status: 0000H = successful\n 0001H = error and BL=XMS error code\n ──────────────────────────────────────────────────────────────────\n Info: This disables the A20 line, making the HMA▲ inaccessible\n (FFFF:0000 will point to someplace in low memory).\n\n Only the owner of the HMA should mess with this; see XMS 01H\n (request HMA).\n\n Notes: ■ Toggling A20 is relatively slow on some machines.\n\n ■ TSR owners of the HMA who toggle A20 on popup, should first get\n the current state via XMS 07H, and restore that setting before\n popping down.\n\nSee Also: XMS Functions\n Extended Memory Specification (XMS)\n DOS Functions\n -♦-"
  },
  {
    "id": "950-xms_05h__local_enable_a20.html",
    "t": "XMS 05H: Local Enable A20",
    "b": "Compatibility: XMS 2.0+\n Expects: AH 05H\n ──────────────────────────────────────────────────────────────────\n Returns: AX status: 0000H = successful\n 0001H = error and BL=XMS error code (if BL >= 80H)\n ──────────────────────────────────────────────────────────────────\n Info: This attempts to enable the A20 line. It should only be used by\n programs which need direct access to the HMA▲.\n\n If you have used INT 2fH 4a02H to get an HMA suballocation from\n DOS, you must be certain that the A20 line is enabled before\n accessing that memory. For performance reasons, use XMS 07H and\n then enable it onoly if it is not already enabled. Use XMS 06H\n to disable it later (if necessary) to put it back the way it was.\n\n Note: If the HMA is owned by DOS, then it is highly likely that A20 is\n enabled all of the time.\n\nSee Also: XMS Functions\n Extended Memory Specification (XMS)\n DOS Functions\n -♦-"
  },
  {
    "id": "951-xms_06h__local_disable_a20.html",
    "t": "XMS 06H: Local Disable A20",
    "b": "Compatibility: XMS 2.0+\n Expects: AH 06H\n ──────────────────────────────────────────────────────────────────\n Returns: AX status: 0000H = successful\n 0001H = error and BL=XMS error code (if BL >= 80H)\n ──────────────────────────────────────────────────────────────────\n Info: This cancels a previous call to XMS 05H (local enable A20).\n\n If you have used INT 2fH 4a02H to get an HMA suballocation from\n DOS, you must be certain that the A20 line is enabled before\n accessing that memory, and put back to to its former state before\n exiting. Use XMS 07H to learn the state of A20 before enabling\n it (XMS 05H) and use this function (XMS 06H), if necessary, to\n put it back the way it was.\n\nSee Also: XMS Functions\n Extended Memory Specification (XMS)\n DOS Functions\n -♦-"
  },
  {
    "id": "952-xms_07h__query_a20_state.html",
    "t": "XMS 07H: Query A20 State",
    "b": "Compatibility: XMS 2.0+\n Expects: AH 07H\n ──────────────────────────────────────────────────────────────────\n Returns: AX status: 0000H = A20 is physically enabled\n 0001H = error and BL=XMS error code (if BL >= 80H)\n ──────────────────────────────────────────────────────────────────\n Info: This checks the state of the a20 line by testing for segment-\n wrap. The A20 line must be enabled befor accessin the HMA. See\n INT 2fH 4axxH for a way to get access to a suballocation of the\n HMA.\n\n If your TSR toggles A20 on popup, you should first use this fn to\n get the current state, and remember to restore that setting\n before popping down.\n\nSee Also: XMS Functions\n Extended Memory Specification (XMS)\n DOS Functions\n -♦-"
  },
  {
    "id": "953-xms_08h__query_free_extended_memory.html",
    "t": "XMS 08H: Query Free Extended Memory",
    "b": "Compatibility: XMS 2.0+\n Expects: AH 08H\n ──────────────────────────────────────────────────────────────────\n Returns: AX size of largest free XMB, in kbytes\n BL XMS error code (if BL >= 80H)\n ──────────────────────────────────────────────────────────────────\n Info: This obtains the size, in K-bytes, of the largest free block of\n extended memory.\n\n Notes: The 64K-16 bytes of the HMA▲ are not included in this\n calculation.\n\nSee Also: XMS Functions\n Extended Memory Specification (XMS)\n DOS Functions\n -♦-"
  },
  {
    "id": "954-xms_09h__allocate_extended_memory_block.html",
    "t": "XMS 09H: Allocate Extended Memory Block",
    "b": "Compatibility: XMS 2.0+\n Expects: AH 09H\n DX desired size of block, in K-bytes\n ──────────────────────────────────────────────────────────────────\n Returns: AX status: 0000H = successful\n 0001H = error and BL=XMS error code (if BL >= 80H)\n DX XMS handle\n ──────────────────────────────────────────────────────────────────\n Info: This allocates a block of extended memory and returns a handle to\n use in future reference to that block.\n\n If no memory is allocated, DX returns with 0000H (null handle).\n\n By default, XMS supports 32 handles. Use HIMEM.SYS /NUMHANDLES=\n in the DEVICE= CONFIG.SYS command to increase this max.\n\nSee Also: XMS Functions\n Extended Memory Specification (XMS)\n DOS Functions\n -♦-"
  },
  {
    "id": "955-xms_0ah__free_extended_memory_block.html",
    "t": "XMS 0aH: Free Extended Memory Block",
    "b": "Compatibility: XMS 2.0+\n Expects: AH 0aH\n DX XMS handle (as obtained via XMS 09H)\n ──────────────────────────────────────────────────────────────────\n Returns: AX status: 0000H = successful\n 0001H = error and BL=XMS error code (if BL >= 80H)\n ──────────────────────────────────────────────────────────────────\n Info: This fn frees a block of extended memory that was previously\n allocated via XMS 09H (allocate XMB).\n\n When an XMB is freed, its handle and all data in it become\n invalid and should not be accessed.\n\nSee Also: XMS Functions\n Extended Memory Specification (XMS)\n DOS Functions\n -♦-"
  },
  {
    "id": "956-xms_0bh__move_extended_memory_block.html",
    "t": "XMS 0bH: Move Extended Memory Block",
    "b": "Compatibility: XMS 2.0+\n Expects: AH 0bH\n DS:SI address of a filled-in XmsMoveInfoRec (see below)\n ──────────────────────────────────────────────────────────────────\n Returns: AX status: 0000H = successful\n 0001H = error and BL=XMS error code (if BL >= 80H)\n ──────────────────────────────────────────────────────────────────\n Info: This fn copies a block of data from one location to another. Use\n it to transfer data into and out of extended memory. It can also\n copy data from place to place in conventional memory or between\n extended memory blocks.\n\n DS:SI points to a structure that describes the data to be moved. It is\n formatted as:\n\n XmsMoveInfoRec\n Offset Size Contents\n ▀▀▀▀▀▀ ▀▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n +0 4 lRgnLength DWORD size, in bytes to move\n (must be an even number)\n +4 2 wSrcHandle src XMB handle or 0=conventional mem\n +6 4 lSrcOffset DWORD offset in src XMB block\n or segment:offset in conventional mem\n +0aH 2 wDestHandle dest XMB handle or 0=conventional mem\n +0cH 4 lDestOffset DWORD offset in dest XMB block\n or segment:offset in conventional mem\n 16 size of an XmsMoveInfoRec\n\n When wSrcHandle or wDestHandle is 0000H, the source or\n destination is in conventional memory. In that case, the\n lSrcOffset (or lDestOffset) must be a 32-bit segment:offset in\n conventional memory.\n\n Notes: ■ If source and destination overlap, the source must be less than\n the destination.\n\n ■ The lRgnLength must be even.\n\n ■ The move is faster when both source and destination begin on\n WORD boundaries and faster still when aligned on DWORD\n boundaries (on 386+ CPUs).\n\nSee Also: XMS Functions\n Extended Memory Specification (XMS)\n DOS Functions\n -♦-"
  },
  {
    "id": "957-xms_0ch__lock_extended_memory_block.html",
    "t": "XMS 0cH: Lock Extended Memory Block",
    "b": "Compatibility: XMS 2.0+\n Expects: AH 0cH\n DX XMS handle (as obtained via XMS 09H)\n ──────────────────────────────────────────────────────────────────\n Returns: AX status: 0000H = successful\n 0001H = error and BL=XMS error code (if BL >= 80H)\n DX:BX 32-bit linear address of base of block\n ──────────────────────────────────────────────────────────────────\n Info: This locks an extended memory block into place (XMM will not move\n its data around while locked) and returns a 32-bit linear address\n of the start of the block.\n\n The block should be unlocked as soon as possible (see XMS 0dH).\n\n The XMM maintains a \"lock-count\" and only allows the block to\n move when the lock count is decremented to 0. XMS 0eH obtains\n the current lock count.\n\nSee Also: XMS Functions\n Extended Memory Specification (XMS)\n DOS Functions\n -♦-"
  },
  {
    "id": "958-xms_0dh__unlock_extended_memory_block.html",
    "t": "XMS 0dH: Unlock Extended Memory Block",
    "b": "Compatibility: XMS 2.0+\n Expects: AH 0dH\n DX XMS handle (as obtained via XMS 09H)\n ──────────────────────────────────────────────────────────────────\n Returns: AX status: 0000H = successful\n 0001H = error and BL=XMS error code (if BL >= 80H)\n DX:BX 32-bit linear address of base of block\n ──────────────────────────────────────────────────────────────────\n Info: This unlocks an extended memory block that has been locked via\n XMS 0cH. After unlocking, any 32-bit pointers to the data become\n invalid.\n\n XMBs should be unlocked as soon as possible to avoid memory\n fragmentation.\n\n The XMM maintains a \"lock-count\" and only allows the block to\n move when the lock count is decremented to 0. XMS 0eH obtains\n the current lock count.\n\nSee Also: XMS Functions\n Extended Memory Specification (XMS)\n DOS Functions\n -♦-"
  },
  {
    "id": "959-xms_0eh__get_handle_information.html",
    "t": "XMS 0eH: Get Handle Information",
    "b": "Compatibility: XMS 2.0+\n Expects: AH 0eH\n DX XMS handle (as obtained via XMS 09H)\n ──────────────────────────────────────────────────────────────────\n Returns: AX status: 0000H = successful\n 0001H = error\n BH current lock count\n BL current number of free XMS handles\n DX size of the block, in K-bytes\n ──────────────────────────────────────────────────────────────────\n Info: This fn obtains information about an extended memory block.\n\n To get the 32-bit address of the block, use XMS 0cH (lock XMB).\n\nSee Also: XMS Functions\n Extended Memory Specification (XMS)\n DOS Functions\n -♦-"
  },
  {
    "id": "960-xms_0fh__resize_extended_memory_block.html",
    "t": "XMS 0fH: Resize Extended Memory Block",
    "b": "Compatibility: XMS 2.0+\n Expects: AH 0fH\n BX desired new size, in K-bytes\n DX XMS handle (as obtained via XMS 09H) must be unlocked\n ──────────────────────────────────────────────────────────────────\n Returns: AX status: 0000H = successful\n 0001H = error and BL=XMS error code (if BL >= 80H)\n ──────────────────────────────────────────────────────────────────\n Info: This fn resizes an extended memory block previously allocated via\n XMS 09H (allocate XMB).\n\n The block must not be locked when this is called (XMS 0cH).\n\n When decreasing the size, any data beyond the end of the new\n block-length becomes invalid.\n\n A \"grow\" request may fail because of memory fragmentation caused\n by locked blocks. You can try unlocking all of your XMBs and\n retry the grow request.\n\nSee Also: XMS Functions\n Extended Memory Specification (XMS)\n DOS Functions\n -♦-"
  },
  {
    "id": "961-xms_10h__request_upper_memory_block.html",
    "t": "XMS 10H: Request Upper Memory Block",
    "b": "Compatibility: XMS 2.0+\n Expects: AH 10H\n DX desired size of UMB▲, in paragraphs (16-byte units)\n ──────────────────────────────────────────────────────────────────\n Returns: AX status: 0000H = successful\n 0001H = error and BL=XMS error code (if BL >= 80H)\n BX segment of the UMB\n DX (success) Actual size of the UMB\n (failure) Size of largest UMB available\n ──────────────────────────────────────────────────────────────────\n Info: This is a low-level way to gain ownership of a UMB▲ or to learn\n the size of the largest available UMB.\n\n See Accessing Upper Memory for the correct (DOS-blessed) way to\n get a UMB when running DOS 3.0+.\n\n Notes: ■ To learn the size of the largest available UMB, set DX=ffffH on\n entry.\n\n ■ UMBs are guaranteed not be affect the EMS frame.\n\n ■ UMBs are paragraph-aligned.\n\nSee Also: XMS Functions\n Extended Memory Specification (XMS)\n DOS Functions\n -♦-"
  },
  {
    "id": "962-xms_11h__release_upper_memory_block.html",
    "t": "XMS 11H: Release Upper Memory Block",
    "b": "Compatibility: XMS 2.0+\n Expects: AH 11H\n DX segment address of he UMB (as obtained via XMS 10H)\n ──────────────────────────────────────────────────────────────────\n Returns: AX status: 0000H = successful\n 0001H = error and BL=XMS error code (if BL >= 80H)\n ──────────────────────────────────────────────────────────────────\n Info: This frees ownership of a UMB obtained via XMS 10H (request UMB).\n\n See Accessing Upper Memory for the correct (DOS-blessed) way to\n get and release a UMB when running DOS 3.0+.\n\n Notes: When a UMB has been released, any code and data in it becomes\n invalid and should not be accessed.\n\nSee Also: XMS Functions\n Extended Memory Specification (XMS)\n DOS Functions\n -♦-"
  },
  {
    "id": "963-xms_error_codes.html",
    "t": "XMS Error Codes",
    "b": "Upon return from XMS Functions, the AX register indicates success or\n failure:\n\n AX=0000H = success\n AX=0001H = failure\n\n When a function fails, the BL register will contain an error code. All\n XMS error codes have bit 7 set; so BL will be >= 80H.\n\n BL Meaning\n ▀▀▀ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀\n 80H Function not implemented\n 81H A VDISK device is detected (screws up allocations...)\n 82H An A20 error occurred\n\n 8eH General XMM driver error\n 8fH Unrecoverable XMM driver error\n\n 90H HMA does not exist\n 91H HMA is already in use\n 92H DX is less than /HMAMIN= parm\n 93H HMA is not allocated\n 94H A20 line is still enabled\n\n a0H All extended memory is allocated\n a1H All XMS handles are in use\n a2H Invalid handle\n\n a3H WSrcHandle is bad\n a4H LSrcOffset is bad\n a5H WDestHandle is bad\n a6H LDestOffset is bad\n a7H Length is invalid\n a8H Invalid overlap in move\n\n a9H Parity error\n aaH Block is not locked\n abH Block is locked\n acH Lock count has overflowed\n adH Lock failed\n\n b0H A smaller UMB is available\n b1H No UMBs are available\n b2H UMB segment number is invalid\n 90H Attribute type undefined\n\nSee Also: XMS Functions\n Extended Memory Specification (XMS)\n DOS Functions\n -♦-"
  },
  {
    "id": "964-using_tech_help_.html",
    "t": "Using TECH Help!",
    "b": "Welcome to TECH Help!\n The Electronic Technical Reference Manual\n\n TECH Help! is a reference tool for programmers--a fully-indexed hypertext\n source of technical facts, topics, and data layouts, instantly available\n from your program editor or debugger.\n\n Its compressed data file contains over 500 printed pages of text; the\n boiled-down essence of the most often needed information found in the DOS\n Technical Reference and PC,AT,and PS/2 BIOS and Hardware References.\n\n Flambeaux Software, Inc. / 1147 East Broadway, Ste 56 / Glendale, CA 91205\n (818) 500-0044\n Written by Dan Rollins\n ╔═══════════════════════════════════════════════════════════════════════╗\n ║ Owners of TECH Help! are licensed to make backup copies in support of ║\n ║ individual use on a single computer. All other rights are reserved. ║\n ╚═══════════════════════════════════════════════════════════════════════╝\n Press ◄─┘ to see how to use TECH Help!\n Help! (continued)\n\n Dedication\n ┌─────────────────────────┐\n │ To │\n │ Robert Benjamin Rollins │\n │ and │\n │ Amanda Jasmine Rollins │\n ┌────────────────┘ └─────────────────┐\n │ May your lives be filled with joy as you have filled mine. │\n └────────────────────────────────────────────────────────────┘\n\n When faced with a problem you don't understand,\n first do any part of it that you DO understand\n and then look at it again.\n -- Robert Anson Heinlein\n (from The Moon is A Harsh Mistress)\n\n┌────────────┐ The author and publisher have made an intensive effort to\n│ Disclaimer │ make sure that all information contained in this text is\n└────────────┘ correct and effective. The author and publisher make no\n warranty of any kind, expressed or implied, with regard to programs, or\n theories, or advice, or any documentation contained herein. The author\n and publisher shall not be liable in any event for incidental or\n consequential damages in connection with, or arising out of, the\n furnishing, performance, or use of this program or the text it displays.\n\n┌────────────┐\n│ Trademarks │ Flambeaux Software, TECH Help!, and Electronic Manual are\n└────────────┘ trademarks of Flambeaux Software\n IBM and PC-DOS are trademarks of International Business Machines Corp.\n Microsoft, MS-DOS, GWBASIC, and Windows are trademarks of Microsoft Corp.\n All trademarks and trade names mentioned in this text are the property\n of their respective owners.\n Buford Whiffle-Bumpkin is not a trademark of anyone, as far as I know.\n\n This program and associated programs and data files are\n Copyright (c) 1985,1993 by Flambeaux Software, Inc."
  },
  {
    "id": "965-using_tech_help___continued_.html",
    "t": "Using TECH Help! (Continued)",
    "b": "TECH Help! uses xView, Flambeaux's standard hypertext Viewer, to display\n the text and interact with you. To use the Viewer, simply wander through\n the hypertext, reading whatever looks interesting.\n\n You can press F2 at any time to return to the \"Main Menu\" page. ┌────────\n ┌────────────────────────────────────────────────────────────────┘ mouse\n ╓─┴┐ Click or drag in the ◄scrollbar► to scroll.\n ║▐▐│ The Left Button selects a ◄hyperlink►.\n ║ │ The Right Button \"Goes Back\" to the previous topic.\n ╚══╛ Click in the ◄menubar► or ◄button bar► to choose options, etc.\n ┌───╖───────────────────────────────────────────────────── keyboard\n ╓──│Esc║ Use ↑↓←→ and PgUp and PgDn to point and scroll.\n╓────╜ ╘═╤═╝ Letter keys A-Z point to hyperlinks starting with that letter.\n║Enter ◄─┘│ Press Enter to view the topic associated with a hyperlink.\n╚═┌──╖─┬──┴╥─╖ Press Esc to backtrack to a previous topic.\n │A┌╨─╖Alt║ ║ Press F1 if you need more help. ┌───╖\n ╘═╡Z ║═══╩═╝ Press Alt+letter to drop-down a menu. │F1 ║ displays\n ╘══╝ ╘═══╝ more help.\n ────────────── Go ahead and select one of these hyperlinks ─────────────────\n\n Installing & Configuring Help! Help! Syntax Popup Help! Main Menu"
  },
  {
    "id": "966-scrollbar.html",
    "t": "scrollbar",
    "b": "▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n▒▒█▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀█▒▒▒\n▒▒█ ─┬─┐ █░▒▒\n▒▒█ Click for up one line ═► │↑│ █░▒▒\n▒▒█ │░│ █░▒▒\n▒▒█ Click for up one screen ═► │░│ █░▒▒\n▒▒█ │░│ █░▒▒\n▒▒█ Drag this up and down ═► ▐█▌ █░▒▒\n▒▒█ │░│ █░▒▒\n▒▒█ Click for down one screen ═► │░│ █░▒▒\n▒▒█ │░│ █░▒▒\n▒▒█ Click for down one line ═► │↓│ █░▒▒\n▒▒█ ─┴─┘ █░▒▒\n▒▒█▄▄ The scrollbar disappears on ▄▄█░▒▒\n▒▒▒░█ short (non-scrolling) pages. █░░░▒▒\n▒▒▒▒█▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄█░▒▒▒▒\n▒▒▒▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒▒▒▒\n▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒"
  },
  {
    "id": "967-button_bar.html",
    "t": "button bar",
    "b": "▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n▒▒█▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀█▒▒▒\n▒▒█ ─┬─┐ █░▒▒\n▒▒█ \"buttons\" │↑│ █░▒▒\n▒▒█ ║ ║ ║ ▐█▌ █░▒▒\n▒▒█ ╔═════╝ ║ ╚══════╗ │░│ █░▒▒\n▒▒█ ║ ║ ║ │░│ █░▒▒\n▒▒█ ║ ║ ║ │↓│ █░▒▒\n▒▒█ └────▼───────▼────────▼───┴─┘ █░▒▒\n▒▒█ █ F1:Help│F2:Home│Esc:GoBack█ █░▒▒\n▒▒█ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀ █░▒▒\n▒▒█ You may click the button bar █░▒▒\n▒▒█ or press the associated key. █░▒▒\n▒▒█▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄█░▒▒\n▒▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒▒\n▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒"
  },
  {
    "id": "968-menubar.html",
    "t": "menubar",
    "b": "▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n▒▒█▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀█▒▒▒\n▒▒█ ▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄ █░▒▒\n▒▒█ ══ Menubar ═══► █ File Goto Configure Help █ █░▒▒\n▒▒█ ┌─▲─────▲─────▲──────────▲───┬─┐ █░▒▒\n▒▒█ To open a menu, │ │↑│ █░▒▒\n▒▒█ ┌─┬───╥─╖ ┌───╖ ▐█▌ █░▒▒\n▒▒█ press │ │Alt║ ║+│ F ║ (or G, C, or H) and │░│ █░▒▒\n▒▒█ ╘═╧═══╩═╝ ╘═══╝ │░│ █░▒▒\n▒▒█ use ↓↑←→ to point and ◄─┘ Enter to choose. │░│ █░▒▒\n▒▒█ OR just point and click with the mouse. │░│ █░▒▒\n▒▒█▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄█░▒▒\n▒▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒▒\n▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒"
  },
  {
    "id": "969-hyperlink.html",
    "t": "hyperlink",
    "b": "A hyperlink is a word or phrase which is\nconnected to a destination page.\n\n┌──┤page├──┐╔═►┌──┤page├──┐╔═►┌──┤page├──┐\n│text text │║ │text text │║ │text text │\n│ link═══╪╝ │ text text│║ │ text text│\n│ text text│ │ link═══╪╝ │text text │\n│text text │ │ text text│ │ text text│\n└──────────┘ └──────────┘ └──────────┘\nIt may also be connected to a viewer\nfunction such as \"Exit\" or \"BackTrack\" or\nto a popup definition, such as this one."
  },
  {
    "id": "970-installing_tech_help_.html",
    "t": "Installing TECH Help!",
    "b": "TECH Help! is composed of a program and a data file. The hypertext\n viewer is named XVIEW.EXE. The accompanying \"hypertext database\" is\n named TECH60.H!.\n\n Installation is quite simple. Just run the INSTALL program on the\n distribution diskette. When distributed on high-capacity diskettes, you\n can install manually by simply copying the files XVIEW.EXE and TECH60.H!\n to your hard disk.\n\n The following sections describe some customization features and options.\n\n█▌Multiple Help! databases▐█\n If you have more than one compatible hypertext data file, it is possible\n that the XVIEW command will startup with the \"wrong\" file. If that\n happens, press F9 or select Open... from the File menu (Alt+F,O) and then\n choose the other file.\n\n The \"xview topic\" syntax causes the Help! viewer to look in all databases\n for topic, stopping at the first one it locates. You may wish to select\n one of the databases as your \"primary\" database so that this syntax will\n first look for topics in that database. There are two ways to do that:\n\n ■ Use F9 to bring up the file list.\n Choose the desired hypertext data file and press Enter.\n Select \"Startup with this file\" from the Configure/Options menu.\n Choose \"Save Setup\" from the Configure Menu.\n\n ...or...\n\n ■ Create two or more batch files like so...\n ┌───────────────────────────────────────────(THELP.BAT)\n │REM start up with TECH Help!\n │c:\\help\\XVIEW /m=c:\\help\\tech60.H! %1 %2\n └─────────────────────────────────────────────────────\n ┌───────────────────────────────────────────(DHELP.BAT)\n │REM start up with DOS 6.0 Help\n │c:\\help\\XVIEW /m=c:\\help\\dos60.H! %1 %2\n └─────────────────────────────────────────────────────\n\n The /M option selects the primary database. See XVIEW Syntax.\n\n█▌Configuring Colors & Options▐█\n The Configure menu provides a way to choose custom colors and other\n options. Just press Alt+C to drop-down the menu and use the arrow keys\n and Enter to select options.\n\n See Help! Menus for information on each menu option. Remember to choose\n Save Setup from the Configure menu (Alt+C,S) to make the Help! viewer\n remember your settings.\n\n█▌Controlling the Printer▐█\n TECH Help! is primarily an on-screen media, so the printer support is\n somewhat limited. Pressing F5 (or Alt+F,P) will send the text of the\n current topic to the PRN device. The following procedures provide some\n control over printing:\n\n ■ Printer Filtering: If your printer cannot print box-and-line\n characters, the printed output may contain a bunch of italic Ms or\n other characters where you expect to see the box-and-line characters.\n\n In that case, choose Printer Filter from the Configure/Options menu\n (Alt+C,O,P). And then Save Setup (Alt+C,S). That way XVIEW will use\n universally-printable characters, such as +---+ rather than ┌───┐.\n\n Alternatively, you may be able to set your printer to print the box-\n and-line characters. For instance, on HP LaserJets, use the front\n panel to select the PC-8 character set.\n\n ■ Printing to a different printer: By default, XVIEW prints to PRN\n (LPT1). To print to another printer, use Edit to modify the prnName\n line of the xView configuration file. See Modifying XVIEW.INI.\n\n ■ Printing a setup string: You can set a string of control codes to be\n sent to the printer before each topic. Use Edit to modify the prnSetup\n line. See Modifying XVIEW.INI.\n\n ■ Printing more or fewer lines per page: Use Edit to modify the prnLines\n line. You may also want to use a setup string to set your printer to\n use a smaller font. See Modifying XVIEW.INI.\n\n ■ Early page eject; and blank pages: By default, XVIEW prints 59 lines\n of text and then ejects the page. If your printer has been set to\n automatically eject at exactly 59 lines, xView will print a blank page\n between each printed page.\n\n To change this behavior, you may modify XVIEW.INI, as above, setting\n prnLines= to a smaller number (say, 55) OR send a prnSetup string to\n tell your printer to print more lines before ejecting the page, OR use\n your printer's front panel to set the default page length to 60 or more\n lines.\n\n█▌Installation Options▐█\n Here are several other installation options and tips:\n\n ■ Put XVIEW on your path. Add c:\\your_TechHelp_dir to your command\n search path so you can easily start XVIEW, regardless of your current\n default directory.\n\n ■ Make a batch file to start TECH Help!. Many users find it convenient\n to have a \\BATCH directory on the command search path to hold often-\n used batch files. A batch file such as...\n\n ┌────────────────────────────────────── (c:\\BATCH\\THELP.BAT)\n │c:\\help\\xview %1 /M=c:\\help\\tech60.h!\n\n ...will start TECH Help! and ensure that it locates its data file.\n See xView■Syntax for related details.\n\n ■ XVIEW will find the TECH60.H! file if it's in the same directory as\n XVIEW.EXE. It will also find it if it's anywhere on the command search\n path or if you have used /M=file in the XVIEW command line.\n\n Another way to ensure that it will find its data file is to store an\n XVIEWPATH variable in the DOS environment like so:\n\n Set XVIEWPATH=c:\\yourTechHelp_dir ◄─┘\n\n This is also handy if you have other hypertext data files created\n with Flambeaux Software's xText hypertext authoring system.\n\n ■ TECH Help! will look for its configuration file (XVIEW.INI) in the\n directory in which XVIEW.EXE is stored. Another way to ensure that\n it can find the file is to store an XVIEWINIT variable in the DOS\n environment like so:\n\n Set XVIEWINIT=c:\\yourTechHelp_dir ◄─┘\n\n This is important on networks, since it allows each user to have custom\n colors and options. Contact Flambeaux Software for information on\n network licensing of TECH Help!.\n\n█▌RAM-Resident Help!▐█\n You may wish to install TECH Help! as a TSR▲. You may do so by executing\n the command...\n\n xview /I\n or\n loadhigh xview /I (386+ PCs after using DOS=UMB in CONFIG.SYS)\n\n ...or by placing that command in your AUTOEXEC.BAT. You may then access\n TECH Help! by pressing Alt+H OR put the cursor on the text of an indexed\n topic (such as ASCII) and press Alt+L.\n\n There are several memory-saving options in which TECH Help! uses available\n expanded or extended memory. For instance, use...\n\n xview /IX\n\n ...to install TECH Help! so that it uses only about 5K of conventional\n memory and swaps its code and data to extended memory.\n\n It is possible to select different pop-up hot keys. See Popup Help! and\n xView■Syntax for related details.\n\n█▌Backups and Bootlegs▐█\n TECH Help! is not copy-protected. Registered owners are expressly granted\n the right to copy the TECH Help! files to a backup diskette and/or your\n hard disk for support of a single user on a single computer, as provided\n for in the License Agreement which accompanies this software.\n\n TECH Help! is a copyrighted, proprietary, commercial program and\n all rights, including distribution in any form, are reserved by\n Flambeaux Software, Inc.\n\n It is NOT NICE to give away copies of TECH Help!, since Dan Rollins and\n the hard-working people at Flambeaux Software would not receive any money\n for the effort that has gone into this product and Dan's two beautiful\n children will be forced to live in the street, begging for scraps of\n potatoes.\n\n If you happened to get a bootleg copy of any of the Help! series, please\n write or call:\n Flambeaux Software, Inc.\n 1147 East Broadway Street, Suite 56\n Glendale, CA 91205\n (818) 500-0044\n\n ...to obtain the full package at a SPECIAL DISCOUNT for BOOTLEG-BUSTERS.\n You will not be asked to tell us the source of your copy. And we accept\n Visa, MasterCard, and American Express.\n\n If you see TECH Help! on any BBS, we would appreciate it if you tell the\n SysOp that TECH Help! is a copyrighted commercial product, not \"Freeware\",\n not \"Shareware\", and not public domain.\n\n Finally, we appreciate your feedback on this product and we apologize for\n any errors and typos in this text. The skinny TECH Help! disk represents\n years of work researching, testing, cross-referencing, typing, and\n proofreading; it's the equivalent of several large books.\n To err is human; to forgive, divine.\n────────────────────────────────────────────────────────────────────────────\n Popup Help! Installing & Configuring Help! xView■Syntax Main Menu"
  },
  {
    "id": "971-popup_help_.html",
    "t": "Popup Help!",
    "b": "TECH Help! is very useful as a RAM-resident popup program, placing reams\n of technical information at your fingertips as you work. Once installed,\n it can be activated from within your program editor, debugger, programming\n environment, or at the DOS prompt.\n\n ■ To make TECH Help! resident, use XVIEW /I (or /IX,/IE,or /IDd)\n To remove TECH Help! from memory, use XVIEW /U.\n See xView■Syntax for details.\n\n ■ Use Alt+H or Alt+L to popup Help! (XVIEW /K= sets the hotkeys)\n • Alt-H pops up the most recently-viewed page of text\n • Alt-L searches the Index page for the word at your cursor; e.g.,\n\n C:>ASCII▬ (now press Alt+L to pop up the ASCII Table)\n\n█▌Features and Limitations▐█\n ■ TECH Help! is designed for use with a text-based program editor or\n debugger. It will not pop up when the screen is in graphics mode.\n\n ■ xView performs the usual shenanigans to avoid the DOS reentrancy\n problem. Once inside of a DOS function, the popup request (hot key)\n will be noticed but may not be acted upon immediately. xView passes\n control of all intercepted interrupt vectors to their original owners\n and works with all popular popup programs; however, it is possible\n that some programs will disable the ability to popup xView or that\n some other conflict will arise.\n\n ■ The /IX, /IE, and /ID TSR-installation options are more likely to cause\n conflicts than the /I (or /IC) option.\n\n ■ If the Alt+H or Alt+L hot keys interfere with a keystroke of another\n application, you may select a different scan code for either or both\n of them. For programs such as QBASIC, which react immediately at\n the press of the [Alt] key, it is possible to select a Ctrl-shifted\n key or a seldom-used function key, such as F12. See xView■Examples.\n\n ■ When XVIEW starts, it locates one or more hypertext databases and\n text files. The first such file it finds becomes the active manual\n (the /M option and the \"Startup with this file\" option from the\n Configure/Options menu can override this behavior.\n\n XVIEW reads information from the file header. Thereafter, it must hit\n the data file for each topic page as you select it. In popup mode, the\n file is closed upon exit from the popup and re-opened whenever XVIEW\n is activated. Thus, it is important that the data file remain in its\n original drive and directory.\n────────────────────────────────────────────────────────────────────────────\n Installing & Configuring Help! xView■Syntax Main Menu"
  },
  {
    "id": "972-xview_syntax.html",
    "t": "xView■Syntax",
    "b": "Examples │ Notes\n Purpose: Displays hypertext databases and text files. In conjunction with\n the TECH Help! database, provides in-depth technical reference\n information for programmers.\n\n See Using TECH Help! for a general introduction.\n\n Syntax: XVIEW [topic] [/B] [/H] [/M=file] [/Q] [/?] ◄═════ normal startup\n\n or: XVIEW /I[swap] [/M=file] [/K=key1,key2] [/B] [/Q] ◄═══ load TSR\n or: XVIEW /U [/Q] ◄═══ remove TSR\n\n█▌Parameters▐█\n\n (none) starts xView as an interactive, full screen program. After the\n initial logo screen, the Main Menu page is displayed.\n\n topic is any keyword found on the General Index page. You need only\n type enough of topic to make it unique (e.g., XVIEW ASCII would\n bring up the ASCII Table topic. You may surround topic with\n quotes to lookup two-word topics, such as \"file attributes\". If\n topic is present, /I and /K are ignored.\n\n /B starts xView with a black-and-white color set. After choosing a\n custom color set (Alt+C,C,C) and Save Setup (Alt+C,S) xView will\n startup with your custom color set.\n\n /H sets xView to display the maximum number of screen lines\n available on your video system (43 lines on EGA and 50 on VGA.\n\n /M=file specifies the name and location of the hypertext database file.\n xView will look in its program directory, the current default\n directory, in the XVIEWPATH directory, and down the command\n search path to locate hypertext databases and text files.\n See Notes.\n\n /Q starts \"quietly\"; bypasses the logo screen and displays the Main\n Menu. When used with /I, skips the logo screen when going TSR.\n\n /? displays a brief TTY-style syntax summary.\n\n ───────────────────────────────────────────────────── TSR Options\n /I[swap] Loads xView into memory as a TSR▲. swap is C, E, X, or D.\n /I and...\n /IC specify to load as a standard TSR, using about 140K of\n conventional memory.\n\n /IE, /IX, and /IE use only 5K or conventional memory by swapping\n data into and out of conventional memory when you pop it up.\n See Notes.\n\n /IE uses EMS (expanded memory) for swapping storage.\n /IX uses XMS (extended memory) for swapping storage.\n /IDd uses disk space on drive d (or the default drive) for storage.\n\n/K=key1,key2 selects hot key triggers to be used when in TSR mode.\n key1 identifies the key for popping up at the most recently-viewed\n page. Default: Alt+H.\n key2 identifies the \"lookup\" key. When used, xView will attempt to\n read the screen at the current cursor location and collect a\n topic to lookup. Default: Alt+L.\n\n Both key names are in the form Achar (for Alt+char) or Cchar\n (for Ctrl+char) or F1...F12 or NONE. For char, you may use\n any alphabetic character A...Z, or F1...F12.\n\n /U Unloads xView from memory (if it has been installed as a TSR).\n\nSee Also: Examples\n Notes\n Installing TECH Help!\n Popup Help!\n -♦-"
  },
  {
    "id": "973-xview_examples.html",
    "t": "xView■Examples",
    "b": "Notes │ Syntax\n xview\n starts TECH Help! for interactive browsing. It is not made RAM-resident.\n\n xview mouse /H\n starts TECH Help! and immediately turns to \"INT 33H: Mouse Support\" topic\n and sets the screen to 43-line mode on EGA and 50-line mode on VGAs (/H).\n xView is not made RAM-resident.\n\n xview \"file alloc\"\n starts TECH Help! and immediately turns to \"File Allocation Table\" topic.\n Quotes are used to keep the topic as a single lookup parameter.\n\n XVIEW /I /K=CH,CL\n installs TECH Help! as a RAM-resident TSR▲ using about 140K of\n conventional memory (/I). It displays the logo screen and then\n returns to DOS. The hot keys are set to Ctrl+H and Ctrl+L (/K=CH,CL).\n\n Loadhigh XVIEW /I\n installs TECH Help! as a TSR. On many systems, this will use about 90K\n of conventional memory and about 50K of upper memory. Your results can\n vary, depending upon UMB availability.\n\n xview /IX /Q\n installs TECH Help! as a RAM-resident TSR using about 5K of memory and\n will swap to and from extended memory (/IX). It will not make a big\n production about going resident (/Q). It will use the default keys (Alt+H\n and Alt+L) for popping up.\n\n ┌─────────────────────────────────────────────────(ED.BAT)\n │@Echo off\n │REM ------ make TECH Help! resident while editing\n │xview /M=c:\\help\\tech60.h! /I /Q /K=cF1,cF2\n │Edit %1\n │xview /U /Q\n └─────────────────────────────────────────────────────────\n This batch file loads TECH Help! as a TSR, setting its hot keys to\n Ctrl+F1 and Ctrl+F2 (/K=CF1,CF2) to avoid conflict with keys used by the\n MS-DOS Edit program. It then runs Edit, passing it a filename to edit.\n When you exit from Edit, the batch file then unloads TECH Help! from\n memory. Example...\n\n ed myprog.asm\n\n ...will edit MYPROG.ASM and let you use Ctrl+F1 to popup TECH Help!\n while editing.\n\nSee Also: Notes\n Syntax\n Installing TECH Help!\n Popup Help!\n -♦-"
  },
  {
    "id": "974-xview_notes.html",
    "t": "xView■Notes",
    "b": "Syntax │ Examples\nDoshelp, Help, and xView\n ■ XVIEW.EXE is the name of the Flambeaux Software hypertext viewer. In\n previous versions, the viewer was named HELP.EXE and the version that\n ships with Flambeaux's ◄DOS Help!► is named DOSHELP.EXE.\n\nTECH Help! files\n ■ The program file is named XVIEW.EXE. This is the generic name of\n Flambeaux's hypertext viewer (as shipped with ◄xText►, the hypertext\n development system.\n\n ■ The hypertext database is named TECH60.H!. xView will look for this\n file in the following locations:\n • The directory named in XVIEW /M=file (if used).\n • The directory named in an e-var XVIEWPATH=yourDir (if any).\n • The directory in which XVIEW.EXE is stored.\n • The current default directory.\n\nTECH Help! configuration file\n ■ When you set configuration options in the menu (and then save the\n setup) or whenever you place a bookmark, xView saves information into\n a standard text file, named XVIEW.INI.\n\n ■ xView will look for that file in the following places:\n • The directory named in an e-var XVIEWINIT=yourDir (if any).\n • The directory in which XVIEW.EXE is stored.\n\n ■ The XVIEWINIT variable is handy for network installations. It lets\n each individual user have a personal copy of configuration settings.\n Contact Flambeaux Software for information on network and site\n licensing.\n\n ■ XVIEW.INI contains some options that are not available through menu\n commands, including printer options. See Modifying XVIEW.INI.\n\nTSR Mode\n ■ The DOS 5.0+ Loadhigh command will usually allocate about 50K of upper\n memory and about 90K of conventional memory. On most systems, xView is\n too large to fit entirely in upper memory.\n\n ■ The /IE, /IX, and /IDd force the TSR-mode xView to minimize its use of\n conventional memory. However, there are several potential problems\n that can occur in these modes. If you find that popping up xView\n causes a lockup or other problems, switch to /IC.\n\n Note: It is easy to remove xView from RAM. If you expect to need it\n temporarily, say, while editing program files, use...\n ┌─────────────────────────────────────────────────(ED.BAT)\n │@Echo off\n │REM --------- make TECH Help! resident while editing\n │xview /M=c:\\help\\tech60.h! /I /Q /K=CF1,CF2\n │Edit %1\n │xview /U /Q\n └─────────────────────────────────────────────────────────\nSee Also: Syntax\n Examples\n Installing TECH Help!\n Popup Help!\n -♦-"
  },
  {
    "id": "975-xview_ini.html",
    "t": "XVIEW.INI",
    "b": "The TECH Help! Configuration File\n\n The TECH Help! viewer (XVIEW.EXE) obtains configuration information\n from a standard text file▲ named XVIEW.INI. Initially, the file does\n not exist, but it is created when you choose Save Setup from the\n Configure menu. It will be in one of:\n\n • The directory named in an XVIEWINIT= environment variable.\n • The directory in which the Viewer (XVIEW.EXE) is stored.\n\n The .INI file looks and works just like the .INI files used in Windows.\n It is a simple text file containing [sections], beneath which are options\n pertaining to that section.\n\n Each time you choose Save Setup from the Configure menu, the current\n colors and options are saved in a special section for the current file.\n This means you can save settings and bookmarks, etc. for text files, as\n well as for TECH Help! and other hypertext databases.\n\n█▌The [Viewer Global] Section▐█\n Configuration settings that apply to the viewer in general are saved in\n this section. Note that the [database_name] section (described below) can\n override some of these settings.\n\n manExtensions=ext [ext...]\n Tells the viewer what files to consider to be viewable. It will always\n look for files with extensions .XDB, .H!, and .TXT, but you can add\n extensions here, to make it look for other text files.\n\n To change: Edit XVIEW.INI.\n\n manPasteFile=d:\\path\\filename.ext\n Tells the viewer where to deposit text selected by Copy to Paste File\n command on the File menu. By default, the Viewer puts such text into a\n file named PASTE.TXT, in the current directory.\n\n To change: Edit XVIEW.INI.\n\n manStartupFile=d:\\path\\filename.ext\n Choose which file should be displayed first (unless overridden via the\n XVIEW /M= option).\n\n To change: Choose \"Startup with This File\" from Configure/Options.\n\n prnName=filename.ext or deviceName\n Select an output device other than PRN. For instance, set this to LPT2 or\n just give the name of a file if you want to send \"printed\" output to a\n text file.\n\n To change: Edit XVIEW.INI.\n\n prnLines=n\n When printing, this many lines are printed before the viewer sends a\n form-feed (ejecting the page). For instance, set n to 80 if your printer\n is set at 8-lpi. You may set n to 0 to keep the viewer from sending any\n form-feeds.\n\n To change: Edit XVIEW.INI.\n\n prnSetup=binaryCodes\n This sequence (up to 60 bytes) will be printed verbatim at the start of\n each topic. You can use it to set your printer to a specific typeface,\n or whatever. For instance...\n\n prnSetup=←(10U\n\n ...sets HP-compatible printers to use the PC-8 character set, so that\n box-and-line characters print as they appear on the screen.\n\n To change: Edit XVIEW.INI; to make the Esc character (←) in the MS-DOS\n Edit program, press Ctrl+P, then press Esc.\n\n prnFilterBoxChars=1 or 0\n 0 means to send box-and-line characters directly to the printer (when the\n user uses the Print command on the File menu). 1 means to convert them\n to universally-printable characters such as +---+.\n\n To change: Select \"Printer Filter\" from the Configure/Options menu.\n\n vidBlackAndWhite=1 or 0\n 1 overrides ALL color settings and makes the viewer display in black and\n white only. You get a similar (though non-permanent) effect by starting\n the viewer with the /B option.\n\n To change: Choose Force Black and White from the Configure/Colors menu.\n\n vidNoBlinkColors=1 or 0\n 1 masks bit 7 of all Screen Attributes (and then makes adjustments to\n avoid any unreadable foreground/background combinations). This may be\n needed on video systems in which a lot of text (or the menubar, etc.) is\n flashing.\n\n To change: Choose Disable Blink+Bold from the Configure/Colors menu.\n\n window=top,left,high,wide\n Sets the default size and position for the Viewer window (used when a\n database does not give a size via the .O window= command).\n\n To change: Edit XVIEW.INI.\n\n colors=xx,xx,xx,xx,xx,xx,xx,xx ... xx\n Sets the default colors (used when a database does not provide a color\n set). See the Colors= Line Layout for details.\n\n To change: Edit XVIEW.INI.\n\n█▌The [database_name] Section▐█\n Configuration options for a particular xText database or text file are\n saved in a separate section. Settings are remembered for text files as\n well as xText databases.\n\n bkmkn=pgNo,lineNo,menuText\n These describe the bookmarks for this file.\n\n To change: Choose from the Goto/Bookmarks/Place Bookmark menu.\n\n window=top,left,high,wide\n Sets the size for the Viewer window when this file is active.\n\n To change: Choose from the Window Size settings in the Configure menu.\n\n colors=xx,xx,xx,xx,xx,xx,xx,xx ... xx\n Sets the colors for the Viewer window when this file is active. See the\n Colors= Line Layout for details.\n\n To change: Choose Custom Colors from the Configure/Colors menu and\n choose Save Setup from the Configure menu.\n Or: Edit XVIEW.INI.\n -♦-"
  },
  {
    "id": "976-colors__line_layout.html",
    "t": "Colors= Line Layout",
    "b": "In XVIEW.INI, a line beginning with colors= may appear in each [section].\n It identifies the colors for the viewer to use on the various parts of the\n xView window when the specified database is active.\n\n Note: The normal way to change this line is to choose Custom Colors\n from the Configure/Colors menu and then choose Save Setup from\n the Configure menu.\n\n However, the \"Set colors\" dialog does not provide complete\n control over all parts of the screen. Some additional color\n variations are available if you choose to hack away in hex.\n Here's the byte-by-byte layout of the colors= line:\n\ncolors= (note: must be all on one line)\n xx,xx,xx,xx,xx,xx,xx,xx,xx,xx,xx,xx,xx,xx,xx,xx,xx,xx,xx,xx,xx,xx,,,\n ├┘ ├┘ ├┘ ├┘ ├┘ ├┘ ├┘ ├┘ ├┘ ├┘ ├┘ ├┘ ├┘ ├┘ ├┘ ├┘ ├┘ ├┘ ├┘ ├┘ ├┘ ├┘└┬┘\n1 normal │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │\n2 hyperlink │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │\n3 reverse/crsr │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │\n4 -- highlight #1 │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │\n5 ───── highlight #2 │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │\n6 ──────── highlight #3 │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │\n7 ─────────── highlight #4 │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │\n8 ────────────── highlight #5 │ │ │ │ │ │ │ │ │ │ │ │ │ │ │\n9 ───────────────── highlight #6 │ │ │ │ │ │ │ │ │ │ │ │ │ │\n10 ───────────────────── page title │ │ │ │ │ │ │ │ │ │ │ │ │\n11 ───────────────────────────── frame │ │ │ │ │ │ │ │ │ │ │ │\n12 ──────────────────────────── scrollbar │ │ │ │ │ │ │ │ │ │ │\n13 ───────────────────────── scrollbar thumb │ │ │ │ │ │ │ │ │ │\n14 ───────────────────────────────── button bar │ │ │ │ │ │ │ │ │\n15 ────────────────────────────── button separator │ │ │ │ │ │ │ │\n16 ───────────────────────────── button hot character │ │ │ │ │ │ │\n17 ─────────────────────────────── menubar/menu interior │ │ │ │ │ │\n18 ───────────────────────────────────── menu hot character │ │ │ │ │\n19 ──────────────────────────────────────────── menu separator │ │ │ │\n20 ─────────────────────────────────────────── disabled menu item │ │ │\n21 ───────────────────────────────────────────────────── menu cursor │ │\n22 ───────────────────────────────────────────────── window drop shadow │\n23-24 ───────────────────────────────────────────────── reserved; not used\n\nUse information from the Screen Attributes topic or the Color Table to\nformulate values for each xx that you wish to change.\n\nSee Also: Screen Attributes\n XVIEW.INI\n -♦-"
  },
  {
    "id": "977-tech_help__viewer_help.html",
    "t": "TECH Help! Viewer Help",
    "b": "▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n▒▒█▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀█▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒█▀▀▀▀▀▀▀▀█▒▒▒▒▒▒▒▒▒▒▒▒▒\n▒█▀ Function Keys ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀█▒▒█▀ Topics ▀▀▀▀▀▀▀▀▀█▒▒▒▒\n▒█ ┌───╖┌───╖ █░▒█ █░▒▒▒\n▒█ These instructions │F1 ║│F2 ║ ◄Main Menu► █░▒█ TECH Help! Menus █░▒▒▒\n▒█ ╘═══╝╘═══╝ █░▒█ █░▒▒▒\n▒█ ┌───╖┌───╖ █░▒█ Using TECH Help! █░▒▒▒\n▒█ ◄Index of topics► │F3 ║│F4 ║ ◄Find text► █░▒█ █░▒▒▒\n▒█ ╘═══╝╘═══╝ +Shift= Repeat █░▒█ Popup Help! █░▒▒▒\n▒█ ┌───╖┌───╖ █░▒█ █░▒▒▒\n▒█ ◄Print topic► │F5 ║│F6 ║ ◄Author credits► █░▒█ Installation █░▒▒▒\n▒█ ◄Copy text► +Shift ╘═══╝╘═══╝ █░▒█ ─────────────── █░▒▒▒\n▒█ ┌───╖┌───╖ █░▒█ xView■Syntax █░▒▒▒\n▒█ ◄Set Colors► │F7 ║│F8 ║ ◄List History► █░▒█ xView■Notes █░▒▒▒\n▒█ ╘═══╝╘═══╝ █░▒█ xView■Examples █░▒▒▒\n▒█ ┌───╖┌───╖ █░▒█▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄█░▒▒▒\n▒█ ◄View other files► │F9 ║│F10║ ◄Exit► █░▒▒░░░░░░░░░░░░░░░░░░░░▒▒▒\n▒█ ╘═══╝╘═══╝ +Shift= No Cls █░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n▒█▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄█░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒▒█▀▀▀▀▀▀▀█▒▒▒▒▒▒▒▒▒\n▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒█ ╓───┐ █░▒▒▒▒▒▒▒▒\n▒█▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀█▒▒▒▒█▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀ ║ ↑ │ ▀▀▀▀▀█░▒▒▒\n▒█ Cursor Motion █░▒▒▒█ Arrow keys move the cursor from ╓───┐╚═══╛╓───┐ █░▒▒▒\n▒█▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄█░▒▒▒█ hyperlink to hyperlink. On long ║ ← │ ║ → │ █░▒▒▒\n▒▒░░░░░░░░░░░░░░░░░▒▒▒█ topics, the screen scrolls. ╚═══╛╓───┐╚═══╛ █░▒▒▒\n▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒█▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄ ║ ↓ │ ▄▄▄▄▄█░▒▒▒\n▒▒█▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀█▒▒▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░█ ╚═══╛ █░░░░░░▒▒▒\n▒▒█ SPEED KEY █░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒█▄▄▄▄▄▄▄█░▒▒▒▒▒▒▒▒\n▒▒█ ╓───┐ ┌───╖ █░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░░░░░░░░▒▒▒▒▒▒▒▒\n▒▒█ ║ A │•••│ Z ║ █░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n▒▒█ ╚═══╛ ╘═══╝ ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀█▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n▒▒█ Press any alphabetic character key to █░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n▒▒█ move the cursor to the first (or next) █░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n▒▒█ hyperlink that begins with that letter. █░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n▒▒█▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄█░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n▒▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒▒█▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀█▒▒▒▒\n▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒█ ╓───┐ ╓───┐ ╓───┐ █░▒▒▒\n▒▒█▀▀▀▀▀▀▀▀▀▀▀▀▀█▒▒█▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀ ║Home ║ ↑ │ ║PgUp █░▒▒▒\n▒▒█ ╓────┐ █░▒█ Home and End go to top and bottom.╚═══╛ ╚═══╛ ╚═══╛ █░▒▒▒\n▒▒█ ╓────╜ │ █░▒█ PageUp and PageDown move through █░▒▒▒\n▒▒█ ║ Enter◄─┘│ █░▒█ the text screen-by-screen. ╓───┐ ╓───┐ ╓───┐ █░▒▒▒\n▒▒█ ╚═════════╛ █░▒█▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄ ║End│ ║ ↓ │ ║PgDn █░▒▒▒\n▒▒█ activates █░▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░█ ╚═══╛ ╚═══╛ ╚═══╛ █░▒▒▒\n▒▒█ the link at █░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒█▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄█░▒▒▒\n▒▒█ the cursor. ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀█▒▒▒▒▒▒▒▒▒▒▒▒▒░░░░░░░░░░░░░░░░░░░░░▒▒▒\n▒▒█ ┌───╖ █░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n▒▒█ To retrace your steps, press │Esc║ █░▒█▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀█▒▒▒▒▒\n▒▒█ ╘═══╝ █░▒█ File Configure Goto Help █░▒▒▒▒\n▒▒█▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄█░▒█ ┌───╖ █░▒▒▒▒\n▒▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒█ │Alt║+a highlighted letter █░▒▒▒▒\n▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒█ ╘═══╝ opens a menu. Use █░▒▒▒▒\n▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒█ the arrow keys to point █░▒▒▒▒\n▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒█ and [Enter] to choose. █░▒▒▒▒\n▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒█▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄█░▒▒▒▒\n▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒▒▒▒\n▒█▀▀▀▀▀▀▀█▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n▒█ Using █░▒▒▒█▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀█▒▒▒▒▒▒\n▒█ a █░▒▒▒█──────────────────────────╔═══╝─────────────────────────█░▒▒▒▒▒\n▒█ Mouse █░▒▒▒█ ┌─╩─┐ █░▒▒▒▒▒\n▒█▄▄▄▄▄▄▄█░▒▒▒█ LEFT button SELECTS ► │█ █│ ◄ RIGHT button BACKTRACKS █░▒▒▒▒▒\n▒▒░░░░░░░░░▒▒▒█ hyperlink or option. │ │ or CANCELS operation. █░▒▒▒▒▒\n▒▒▒▒▒▒▒▒▒▒▒▒▒▒█▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄ └───┘ ▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄█░▒▒▒▒▒\n▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░░░░░░░░░░░░░░░░░░░░░█▄▄▄▄▄▄▄█░░░░░░░░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒\n▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░░░░░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n▒▒█▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀█▒▒▒█▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀█▒▒▒▒▒\n▒▒█ ─┬─┐ █░▒▒█ └──────────────────────────┘ █░▒▒▒▒\n▒▒█ Click▲ for up one line ═► │↑│ █░▒▒█ F1:Help│F2:Home│Esc:GoBack █░▒▒▒▒\n▒▒█ │░│ █░▒▒█ └──┬──┘ └──┬──┘ └────┬───┘ █░▒▒▒▒\n▒▒█ Click for up one screen ═► │░│ █░▒▒█ Click▲ in the button bar █░▒▒▒▒\n▒▒█ │░│ █░▒▒█ or press the associated key. █░▒▒▒▒\n▒▒█ Drag▲ this up and down ═► ▐█▌ █░▒▒█▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄█░▒▒▒▒\n▒▒█ │░│ █░▒▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒▒▒▒\n▒▒█ Click for down one screen ═► │░│ █░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n▒▒█ │░│ █░▒▒█▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀█▒▒▒▒▒\n▒▒█ Click for down one line ═► │↓│ █░▒▒█ Note: Dragging▲ in the text █░▒▒▒▒\n▒▒█ ─┴─┘ █░▒▒█ area also scrolls the screen.█░▒▒▒▒\n▒▒█▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄█░▒▒█▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄█░▒▒▒▒\n▒▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒▒▒▒\n▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒█▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀█▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒█ End of Instructions █░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒█────────────────────────────────█░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒█ Press Esc to █░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒█ Return to the Previous Topic █░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒█▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄█░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒"
  },
  {
    "id": "978-qclick.html",
    "t": "Click",
    "b": "clicking a mouse button\n─────────────────────────────────────────\nPosition the mouse pointer over a screen\nelement and press and release the button."
  },
  {
    "id": "979-qdrag.html",
    "t": "Drag",
    "b": "dragging with the mouse\n────────────────────────────────────\n1. Position the mouse pointer over a\n screen element.\n\n2. Press the button.\n\n3. While keeping the button pressed,\n move the mouse.\n\n4. Release the button."
  },
  {
    "id": "980-_main_menu_.html",
    "t": "◄Main Menu►",
    "b": "┌──╖\n│F2║ immediately displays the \"Main Menu\"\n╘══╝ of this hypertext database."
  },
  {
    "id": "981-_index_of_topics_.html",
    "t": "◄Index of Topics►",
    "b": "┌──╖\n│F3║ displays the \"Index Page\" of this\n╘══╝ hypertext database."
  },
  {
    "id": "982-_find_text_.html",
    "t": "◄Find Text►",
    "b": "┌──╖\n│F4║ begins a search for any text in this file.\n╘══╝ Just input the text and press Enter.\n\nWhen the text is found, the topic containing\nit is displayed and the text is highlighted.\n ┌─────╖ ┌──╖\nTo continue the search, use │Shift║+│F4║\n ╘═════╝ ╘══╝"
  },
  {
    "id": "983-_print_topic_.html",
    "t": "◄Print Topic►",
    "b": "┌──╖\n│F5║ prints the text of the current topic.\n╘══╝ By default,text is sent 'raw' to the PRN device.\n\nPrinter options can be set by using a text editor to\nmodify XVIEW.INI (the Viewer configuration file).\nOptions include:\n\n prnName=PRN (device or FILENAME.EXT)\n prnLines=59 (lines per page)\n prnSetup=<any_text> (printed before each topic)\n prnFilterBoxChars=1 (e.g., print +--+, not ┌──┐)"
  },
  {
    "id": "984-_copy_text_.html",
    "t": "◄Copy Text►",
    "b": "┌─────╖ ┌──╖\n│Shift║+│F5║ copies lines of text from the current\n╘═════╝ ╘══╝ file into a file named PASTE.TXT.\n\n1) Press [Shift+F5] and use the arrow keys to move to the\n first line that you want to copy.\n2) Press [Enter] and use the arrows to mark the desired block.\n3) Press [Enter] again to write the marked text to the file.\n\n─╔═╝────────────────────────────────────── Using the Mouse ───\n┌╩─┐ Press [Shift+F5].\n│▌▐│ Move the mouse pointer to the desired first line.\n│ │ Press the [Left Button] and drag to mark the block.\n└──┘ Release the button and click [OK] to save."
  },
  {
    "id": "985-_credits___copyright_.html",
    "t": "◄Credits & Copyright►",
    "b": "┌──╖\n│F6║ Displays information about this\n╘══╝ hypertext database file and a few words\nabout the hypertext viewer program."
  },
  {
    "id": "986-_set_colors_.html",
    "t": "◄Set Colors►",
    "b": "┌──╖\n│F7║ changes the color settings for the\n╘══╝ current file.\n\nYour choices are saved in XVIEW.INI (the\nViewer configuration file) and used thereafter.\n\nYou may start this program with the /B option\nto override with Black & White colors only."
  },
  {
    "id": "987-_list_history_.html",
    "t": "◄List History►",
    "b": "┌──╖\n│F8║ Displays a list of the last 32 topics\n╘══╝ You have viewed. Just choose from the\nlist to get back to any of these topics.\n┌───╖\n│Esc║ is a quick way to backtrack to the\n╘═══╝ most recently-viewed pages."
  },
  {
    "id": "988-_view_other_files_.html",
    "t": "◄View Other Files►",
    "b": "┌──╖\n│F9║ displays a list of available hypertext\n╘══╝ databases and text files. Just choose\nfrom the list to open a file.\n\nIf some of your files are not listed, you\nmay wish to use the DOS command...\n\n SET XVIEWPATH=<path>[;...]\n\n ...before starting this program."
  },
  {
    "id": "989-_exit_.html",
    "t": "◄Exit►",
    "b": "┌───╖\n│F10║ exits from Help!, restoring the previous\n╘═══╝ contents of the screen.\n┌─────╖ ┌───╖\n│Shift║+│F10║ exits from Help!, but leaves the\n╘═════╝ ╘═══╝ current topic visible on your screen.\n\nNote: Shift+F10 just \"pops down\" when in TSR mode."
  },
  {
    "id": "990-help__menus_and_button_controls.html",
    "t": "Help! Menus and Button Controls",
    "b": "File Configure Goto Topics Help databaseName \n\n Pick a menu title from the example above for information about that menu.\n\n ────────────────────────────────────────────────────────\n\n Pick a button from the example below for information about that button.\n\n F1:Help│F2:Home│F3:Index│F4:Search│F9:Files│F10:Exit│<<-│+>>│Esc:GoBack \n\n -♦-"
  },
  {
    "id": "991-databasename.html",
    "t": "databaseName",
    "b": "This area is a mouse-clickable\nbutton that brings up the list of\navailable hypertext databases and\ntext files."
  },
  {
    "id": "992-f2_home.html",
    "t": "F2:Home",
    "b": "A press of [F2] or a mouse click on this\nbutton displays the Main Menu."
  },
  {
    "id": "993-f3_index.html",
    "t": "F3:Index",
    "b": "A press of [F3] or a mouse click on\nthis button displays the Index page."
  },
  {
    "id": "994-file_menu.html",
    "t": "File Menu",
    "b": "File Configure Goto Topics Help databaseName \n ┌──────────────────┐\n │ Open... │\n │ ──────────────── │\n │ Print topic │\n │ ──────────────── │\n │ Copy text │\n │ View paste file │\n │ ──────────────── │\n │ eXit from Viewer │\n └──────────────────┘\n\n Select Help! Menus or press Esc to Backtrack or choose a menu:\n\n File Configure Goto Topics Help databaseName"
  },
  {
    "id": "995-open___.html",
    "t": "Open...",
    "b": "Brings up the list of available\nhypertext databases and text files."
  },
  {
    "id": "996-print_topic.html",
    "t": "Print Topic",
    "b": "Prints the current topic.\n\nThe Configure/Options/Print Filter menu command affects\nthe output. Settings in XVIEW.INI set the output device\nor file, lines per page, and printer setup codes."
  },
  {
    "id": "997-copy_text.html",
    "t": "Copy Text",
    "b": "Lets you select lines of the current topic to\nbe copied, then appends that text to a file\nnamed PASTE.TXT in the current directory.\n\nThe destination file for Copy operations can\nbe set by editing XVIEW.INI"
  },
  {
    "id": "998-view_paste_file.html",
    "t": "View Paste File",
    "b": "Displays the contents of PASTE.TXT\n(a file in the current directory) or\nwhatever file has been set as the\nmanPasteFile= in XVIEW.INI.\n\nThis menu item is disabled if the\npaste file does not exist."
  },
  {
    "id": "999-exit_from_viewer.html",
    "t": "Exit from Viewer",
    "b": "Exits from the Help! Viewer.\n\nNote: Shift+F10 also exits, but\n it leaves the text of the\n current topic visible.\n\nWhen in TSR mode, both F10 and\nSH+F10 \"pop-down\" and return\ncontrol to the foreground program."
  },
  {
    "id": "1000-configure_menu.html",
    "t": "Configure Menu",
    "b": "File Configure Goto Topics Help databaseName \n ┌────────────────┐\n │ Colors ► │\n │ Window Size ► │\n │ Options ► │\n │ ────────────── │\n │ Save Setup │\n └────────────────┘\n\n Select Help! Menus or press Esc to Backtrack or choose a menu:\n\n File Configure Goto Topics Help databaseName"
  },
  {
    "id": "1001-save_setup.html",
    "t": "Save Setup",
    "b": "Saves the current colors, options,\nand bookmarks to the configuration\nfile."
  },
  {
    "id": "1002-window_size.html",
    "t": "Window Size",
    "b": "Lets you change the height of the\nviewer window.\n\nUse this to reveal whatever the viewer\nwindow is currently covering."
  },
  {
    "id": "1003-configure_colors_menu.html",
    "t": "Configure/Colors Menu",
    "b": "File Configure Goto Topics Help databaseName \n ┌────────────────┐┌─────────────────────────┐\n │ Colors ► ││ Custom Colors... │\n │ Window Size ► ││ Reset to file defaults │\n │ Options ► ││ force Black and white │\n │ ────────────── ││ disable blink+bold bkgd │\n │ Save Setup │└─────────────────────────┘\n └────────────────┘\n\n Select Help! Menus or press Esc to Backtrack or choose a menu:\n\n File Configure Goto Topics Help databaseName"
  },
  {
    "id": "1004-custom_colors___.html",
    "t": "Custom Colors...",
    "b": "Brings up the Custom Colors\ndialog box to let you choose\na custom color set for the\nactive hypertext database or\ntext file."
  },
  {
    "id": "1005-reset_to_file_defaults.html",
    "t": "Reset to File Defaults",
    "b": "Sets the colors of the active\ndatabase to the original\nsettings defined for the file."
  },
  {
    "id": "1006-force_black_and_white.html",
    "t": "Force Black and White",
    "b": "Activates the black & white-only color set\n-- not only for TECH Help!, but all\nhypertext databases and text files.\n\nThis selection is remembered only if you\nSave Setup."
  },
  {
    "id": "1007-disable_blink_bold_bkgd.html",
    "t": "disable blink+bold bkgd",
    "b": "If the text or menubar or hyperlink cursor\nis flashing like mad, this option stops\nthe flashing fast.\n\nYou may then want to Set Colors to make\nadditional custom adjustments.\n\nThis selection is remembered only if you\nSave Setup."
  },
  {
    "id": "1008-configure_options_menu.html",
    "t": "Configure/Options Menu",
    "b": "File Configure Goto Topics Help databaseName \n ┌────────────────┐\n │ Colors ► │\n │ Window Size ► │┌────────────────────────┐\n │ Options ► ││ Printer Filter │\n │ ────────────── ││ Zoom Effect │\n │ Save Setup ││ Control CGA Snow │\n └────────────────┘│ beep on Error │\n │ Startup with this file │\n └────────────────────────┘\n\n Select Help! Menus or press Esc to Backtrack or choose a menu:\n\n File Configure Goto Topics Help databaseName"
  },
  {
    "id": "1009-printer_filter.html",
    "t": "Printer Filter",
    "b": "When selected, all box-and-line\ncharacters are printed as dashes,\nasterisks, and other universally-\nprintable characters.\n ┌──┐ +--+\nExample: │hi│ is printed as |hi|\n └──┘ +--+"
  },
  {
    "id": "1010-zoom_effect.html",
    "t": "Zoom Effect",
    "b": "Turns on or off the Viewer's visual\nzoom-in and zoom-out effect (seen\nwhen you select hyperlinks)."
  },
  {
    "id": "1011-control_cga_snow.html",
    "t": "Control CGA Snow",
    "b": "Turn this on when running on a CGA system\nthat displays irritating \"video snow\".\n\nThis slows down the display somewhat."
  },
  {
    "id": "1012-beep_on_error.html",
    "t": "Beep On Error",
    "b": "The viewer normally beeps when it\ndetects an invalid keystroke. Turn\nthis off to quiet things down."
  },
  {
    "id": "1013-startup_with_this_file.html",
    "t": "Startup with this file",
    "b": "By default, the viewer activates the first database it\nfinds when it starts up.\n\nTo startup with a particular database, activate that\ndatabase, then select this option, then Save Setup.\n\nNote: Setting this ensures that the Viewer will also\n find all other files in the same directory.\n\nYou can also use the viewer's /M= command-line switch to\nstart with a particular database."
  },
  {
    "id": "1014-goto_menu.html",
    "t": "Goto Menu",
    "b": "File Configure Goto Topics Help databaseName \n ┌───────────────────┐\n │ Backtrack │\n │ History │\n │ ───────────────── │\n │ Bookmarks ► │\n │ Browse Next │\n │ Browse Previous │\n │ ───────────────── │\n │ Topic Search │\n │ Find Text │\n │ Find Again │\n └───────────────────┘\n\n Select Help! Menus or press Esc to Backtrack or choose a menu:\n\n File Configure Goto Topics Help databaseName"
  },
  {
    "id": "1015-backtrack.html",
    "t": "Backtrack",
    "b": "┌───╖\n│Esc║ Immediately redisplays the\n╘═══╝ most-recently viewed page.\n\nUse this to return to where you\nleft off after \"hyper-jumping\"\naround a database.\n\nWhen at the first page viewed in\nthis session, this exits from the\nHelp! viewer."
  },
  {
    "id": "1016-history.html",
    "t": "History",
    "b": "Displays a list of the last 32\npages that have been viewed. Just\nselect from the list to go to that\npage."
  },
  {
    "id": "1017-browse_next.html",
    "t": "Browse Next",
    "b": "┌───╖\n│ + ║ displays the page that is\n╘═══╝ sequentially one higher than\nthe current page."
  },
  {
    "id": "1018-browse_previous.html",
    "t": "Browse Previous",
    "b": "┌───╖\n│ - ║ displays the page that is\n╘═══╝ sequentially one lower than\nthe current page."
  },
  {
    "id": "1019-topicsearch.html",
    "t": "TopicSearch",
    "b": "Brings up the \"Search for Indexed Topic\" dialog box.\nInput a topic to locate and press [Enter].\n\nThe viewer attempts to match that text to hyperlinks\nin the Index of all available databases.\n\nIf no match is found, the viewer displays the\n\"Can't Find\" page."
  },
  {
    "id": "1020-find_text.html",
    "t": "Find Text",
    "b": "Brings up the \"Find Text\" dialog box. Input any text\nyou want to locate and press [Enter].\n\nThe viewer searches the current hypertext database or\ntext file for a match, and highlights the match if\none is found.\n\nUse [Shift+F4] or Find Again to continue a search."
  },
  {
    "id": "1021-find_again.html",
    "t": "Find Again",
    "b": "Continues a search that was started\nvia the Find Text command."
  },
  {
    "id": "1022-goto_bookmarks_menu.html",
    "t": "Goto/Bookmarks Menu",
    "b": "File Configure Goto Topics Help databaseName \n ┌───────────────────┐\n │ Backtrack │\n │ History │\n │ ───────────────── │┌───────────────────┐\n │ Bookmarks ► ││ Place bookmark ► │\n │ Browse Next ││ ───────────────── │\n │ Browse Previous ││ 1 pgTitle │\n │ ───────────────── ││ 2 pgTitle │\n │ Topic Search ││ 3 pgTitle │\n │ Find Text ││ 4 pgTitle │\n │ Find Again ││ 5 pgTitle │\n └───────────────────┘│ 6 pgTitle │\n │ 7 pgTitle │\n │ 8 pgTitle │\n │ 9 pgTitle │\n └───────────────────┘\n\n Select Help! Menus or press Esc to Backtrack."
  },
  {
    "id": "1023-1_pgtitle.html",
    "t": "1 pgTitle",
    "b": "Goes to the specified bookmark (if it has\nbeen set previously). You can also go to a\nbookmark by pressing [Alt]+[number].\n\nTo set a bookmark, activate the desired\npage and scroll to the desired position.\nThen press [Ctrl]+[F1...F9]."
  },
  {
    "id": "1024-goto_bookmarks_place_bookmark_menu.html",
    "t": "Goto/Bookmarks/Place bookmark Menu",
    "b": "File Configure Goto Topics Help databaseName \n ┌───────────────────┐\n │ Backtrack │\n │ History │\n │ ───────────────── │┌───────────────────┐┌───────┐\n │ Bookmarks ► ││ Place bookmark ► ││ 1 ^F1 │\n │ Browse Next ││ ───────────────── ││ 2 ^F2 │\n │ Browse Previous ││ 1 pgTitle ││ 3 ^F3 │\n │ ───────────────── ││ 2 pgTitle ││ 4 ^F4 │\n │ Topic Search ││ 3 pgTitle ││ 5 ^F5 │\n │ Find Text ││ 4 pgTitle ││ 6 ^F6 │\n │ Find Again ││ 5 pgTitle ││ 7 ^F7 │\n └───────────────────┘│ 6 pgTitle ││ 8 ^F8 │\n │ 7 pgTitle ││ 9 ^F9 │\n │ 8 pgTitle │└───────┘\n │ 9 pgTitle │\n └───────────────────┘\n\n Select Help! Menus or press Esc to Backtrack."
  },
  {
    "id": "1025-1__f1.html",
    "t": "1 ^F1",
    "b": "Places a bookmark at the current topic\nand position within that topic.\n\nAfter placing this bookmark, you may\nreturn to it by pressing [Alt]+[number].\n\nYou can quickly place a bookmark at the\ncurrent position by pressing [Ctrl]+[F1]\nthrough [Ctrl]+[F9]."
  },
  {
    "id": "1026-topics_menu.html",
    "t": "Topics Menu",
    "b": "This menu provides quick\naccess to some commonly-\nneeded topics."
  },
  {
    "id": "1027-help_menu.html",
    "t": "Help Menu",
    "b": "File Configure Goto Topics Help databaseName \n ┌───────────────────┐\n │ Using this Viewer │\n │ ───────────────── │\n │ About... │\n └───────────────────┘\n\n Select Help! Menus or press Esc to Backtrack or choose a menu:\n\n File Configure Goto Topics Help databaseName"
  },
  {
    "id": "1028-using_this_viewer.html",
    "t": "Using this Viewer",
    "b": "Displays \"F1 Help\" on the mechanics of using\nthis hypertext Viewer."
  },
  {
    "id": "1029-about___.html",
    "t": "About...",
    "b": "Displays a page that identifies the database, its\ncopyright, its author, etc.\n\nThis page also displays the viewer copyright."
  },
  {
    "id": "1030-flambeaux_software.html",
    "t": "Flambeaux Software",
    "b": "▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒█▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀█▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒█ Flambeaux Software. Inc. █░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒█ 1147 E. Broadway, Suite #56 █░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒█ Glendale, CA 91205 █░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒█▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄█░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒█▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀█▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒█ Business Offices: 818-500-0044 █░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒█ FAX line: 818-957-0194 █░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒█ Toll-free order line: 1-800-833-7355 █░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒█▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄█░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n\n Long before hypertext became an industry buzzword, Flambeaux was marketing\n DOS Help! with its unique system of embedded cross-references and had\n received awards for excellence from the Computer Press Association.\n\n──────────────────────────────── Chronology ─────────────────────────────────\n 1984 ■ Flambeaux Software is founded by Jack Crone and Dan Rollins\n The word \"flambeaux\" is French -- literally \"torches\".\n\n 1985 ■ ◄DOS Help!► (for DOS 2.0) is introduced\n\n 1986 ■ DOS Help! receives a Computer Press Association award for\n excellence as an on-line tutorial\n ■ ◄Tech Help!► is introduced\n\n 1987 ■ DOS Help! receives a second Computer Press Association award\n\n 1988 ■ DOS Help! is designated Editor's Choice by PC Magazine\n ■ Ziff-Davis Publishing commissions Flambeaux to develop \"The Best\n of Tech Help!\" as a subscription premium for PC Tech Journal\n\n 1989 ■ Ziff-Davis Publishing commissions Flambeaux to develop \"The Best\n of DOS Help!\" as a subscription premium for PC Computing\n ■ Phoenix Technologies Ltd. is licensed to distribute DOS Help! to\n the OEM market\n\n 1990 ■ ◄xText►, the world's first practical hypertext system, is\n introduced\n ■ Multilingual DOS Help! is introduced, as Flambeaux translates\n its popular database into French, German, and Spanish editions\n\n 1992 ■ xText Version 2.0 is released: major changes to user interface.\n\n 1993 ■ The xText viewer is licensed for use by Microsoft in DOS 6.0\n (as the help system for Microsoft Anti-Virus).\n\n 1994 ■ Flambeaux releases TECH Help! version 6.0\n ■ Flambeaux products are in use by millions of people worldwide"
  },
  {
    "id": "1031-dos_help_.html",
    "t": "DOS Help!",
    "b": "DOS Help!\n\nThis is Flambeaux Software's on-screen hypertext-\nbased replacement for the MS-DOS manual. It can\nreplace or supplement the existing on-line help.\n\nIt has been named Editor's Choice by PC Magazine.\nIt is installed on millions of PCs, worldwide."
  },
  {
    "id": "1032-_tech_help__.html",
    "t": "◄Tech Help!►",
    "b": "TECH Help!\n\nThis is a MASSIVE hypertext database of\nprogramming information. It is a pop-up\nreference for:\n\n • INT 21H functions\n • BIOS interrupts\n • Mouse, keyboard, EMS, XMS, VGA, EGA...\n • I/O ports, pin outs, opcodes...\n • System data areas/structure layouts\n • Way too much stuff to list!"
  },
  {
    "id": "1033-xtext.html",
    "t": "xText",
    "b": "xText\n\nThis is the hypertext authoring system used to create the\nTECH Help! database that you are viewing right now.\n\n ■ Create the text with your own favorite word processor\n or text editor. Insert simple \"dot commands\" to\n identify topics and connect hyperlinks.\n\n ■ Useful for any type of on-screen data, including\n context-sensitive help for application programs.\n\n ■ No fees or royalties for distributing the xText Viewer.\n It is available in eight international languages.\n Currently in use at over 30 million sites."
  },
  {
    "id": "1034-not_done_yet.html",
    "t": "Not Done Yet",
    "b": "▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n▒▒▒▒▒▒▒▒▒▒▒▒▒█▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀█▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n▒▒▒▒▒▒▒▒▒▒▒▒▒█ The requested topic has not been written yet. █░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n▒▒▒▒▒▒▒▒▒▒▒▒▒█▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄█░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒█▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀█▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒█ Press Esc to █░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒█ Return to the Previous Topic █░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒█▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄█░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒"
  },
  {
    "id": "1035-unable_to_locate_topic.html",
    "t": "Unable To Locate Topic",
    "b": "▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n▒▒▒▒▒▒▒█▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀█▒▒▒▒▒▒▒▒▒▒\n▒▒▒▒▒▒▒█ The requested topic (or the file it's in) can't be found. █░▒▒▒▒▒▒▒▒▒\n▒▒▒▒▒▒▒█▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄█░▒▒▒▒▒▒▒▒▒\n▒▒▒▒▒▒▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒▒▒▒\n▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒█▀▀▀▀▀█▒▒▒▒▒▒▒▒▒▒▒▒▒\n▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒█ Tip █░▒▒▒▒▒▒▒▒▒▒▒▒\n▒▒█▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀█▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒█▀▀▀▀▀▀▀▀█▄▄▄▄▄█▀▀▀▀▀▀▀▀█▒▒▒▒\n▒▒█ Pick an Option █░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒█ To ensure that all █░▒▒▒\n▒▒█▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄█▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀█▒▒▒▒█ hypertext files █░▒▒▒\n▒▒▒░░█ █░▒▒▒█ are searched, put: █░▒▒▒\n▒▒▒▒▒█ ■ Try again: Search all hypertext █░▒▒▒█ SET XVIEWPATH=d:\\path █░▒▒▒\n▒▒▒▒▒█ files for a different topic. █░▒▒▒█ in your AUTOEXEC.BAT █░▒▒▒\n▒▒▒▒▒█ ■ Search this file for any text. █░▒▒▒█▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄█░▒▒▒\n▒▒▒▒▒█ █░▒▒▒▒░░░░░░░░░░░░░░░░░░░░░░░░░▒▒▒\n▒▒▒▒▒█ ■ View the Index of this file. █░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n▒▒▒▒▒█ ■ View the Home page of this file. █░▒▒▒▒▒█▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀█▒▒▒▒▒\n▒▒▒▒▒█ ■ See the list of hypertext files. █░▒▒▒▒▒█ Esc to Backtrack █░▒▒▒▒\n▒▒▒▒▒█▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄█░▒▒▒▒▒█▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄█░▒▒▒▒\n▒▒▒▒▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒░░░░░░░░░░░░░░░░░░░░░░▒▒▒▒\n▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒"
  },
  {
    "id": "1036-unable_to_display.html",
    "t": "Unable to Display",
    "b": "▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n▒▒▒▒▒▒▒▒▒▒▒▒▒█▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀█▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n▒▒▒▒▒▒▒▒▒▒▒▒▒█ Sorry, but that topic cannot be displayed. █░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n▒▒▒▒▒▒▒▒▒▒▒▒▒█▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄█░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n▒▒▒▒▒▒▒▒▒█▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀█▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n▒▒▒▒▒▒▒▒▒█ This hypertext viewer is not capable of displaying █░▒▒▒▒▒▒▒▒▒▒▒▒▒\n▒▒▒▒▒▒▒▒▒█ graphics images on your video system. █░▒▒▒▒▒▒▒▒▒▒▒▒▒\n▒▒▒▒▒▒▒▒▒█ -OR- █░▒▒▒▒▒▒▒▒▒▒▒▒▒\n▒▒▒▒▒▒▒▒▒█ That link can't be accessed while in TSR mode. █░▒▒▒▒▒▒▒▒▒▒▒▒▒\n▒▒▒▒▒▒▒▒▒█▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄█░▒▒▒▒▒▒▒▒▒▒▒▒▒\n▒▒▒▒▒▒▒▒▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒\n▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒█▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀█▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒█ Press Esc to █░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒█ Return to the Previous Topic █░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒█▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄█░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒"
  }
]
